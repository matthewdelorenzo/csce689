Area,Delay,Score,Current Run,Episode,Verilog,Time,Tokens
N/A,N/A,-0.1,2.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
);
   reg [31:0] q_reg;
   
   always @(posedge clk) begin
       if (reset) begin
           q_reg <= 32'h1;
       end else begin
           q_reg <= {q_reg[30:0], q_reg[31] ^ q_reg[21] ^ q_reg[1] ^ q_reg[0]};
       end
   end

   assign q = q_reg;

endmodule",0.011363147000000406,88
N/A,N/A,-0.1,3.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
);
reg [31:0] lfsr;

always @(posedge clk) begin
    if (reset) begin
        lfsr <= 32'h1;
    end else begin
        lfsr <= {lfsr[30:0], lfsr[31] ^ lfsr[21] ^ lfsr[1] ^ lfsr[0]};
    end
end

assign q = lfsr;

endmodule",0.010978403000000192,92
N/A,N/A,-0.1,4.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
);
   reg [31:0] lfsr;

    always @(posedge clk) begin
        if (reset) begin
            lfsr <= 32'h1;
        end else begin
            lfsr <= {lfsr[30:0], lfsr[31] ^ lfsr[21] ^ lfsr[1] ^ lfsr[0]};
        end
    end

    assign q = lfsr;
endmodule",0.010941411999999762,95
N/A,N/A,-0.1,5.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
);
reg [31:0] r;

always @(posedge clk) begin
    if (reset) begin
        r <= 32'h1;
    end else begin
        r <= {r[30:0], r[31] ^ r[21] ^ r[1] ^ r[0]};
    end
end

assign q = r;

endmodule",0.011837600999999864,73
N/A,N/A,-0.1,6.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
);
   reg [31:0] r;

    always @(posedge clk) begin
        if (reset) begin
            r <= 32'h1;
        end else begin
            r <= {r[30:0], r[31] ^ r[21] ^ r[1] ^ r[0]};
        end
    end

    assign q = r;
endmodule",0.011052395000000104,82
N/A,N/A,-0.1,7.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
);
reg [31:0] r;

always @(posedge clk) begin
    if (reset) begin
        r <= 32'h1;
    end else begin
        r <= {r[30:0], r[31] ^ r[21] ^ r[1] ^ r[0]};
    end
end

assign q = r;

endmodule",0.010972012999999947,72
N/A,N/A,-0.1,8.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
);
   reg [31:0] r;

    always @(posedge clk) begin
        if (reset) begin
            r <= 32'h1;
        end else begin
            r <= {r[30:0], r[31] ^ r[21] ^ r[1] ^ r[0]};
        end
    end

    assign q = r;
endmodule",0.010990125999999822,75
N/A,N/A,-0.1,9.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
);
   reg [31:1] r;

    always @(posedge clk) begin
        if (reset) begin
            r <= 32'h1;
        end else begin
            r <= {r[30:1], r[31] ^ r[21] ^ r[1] ^ r[0]};
        end
    end

    assign q = r;
endmodule",0.011382580000000253,80
N/A,N/A,-0.1,10.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
);
reg[31:0] r;

always @(posedge clk) begin
    if (reset) begin
        r <= 32'h1;
    end else begin
        r <= {r[30:0], r[31] ^ r[21] ^ r[1] ^ r[0]};
    end
end

assign q = r;

endmodule",0.010935735999999974,73
N/A,N/A,-0.1,11.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
);
   reg [31:1] lfsr;

    always @(posedge clk) begin
        if (reset) begin
            lfsr <= 32'h1;
        end else begin
            lfsr <= {lfsr[30:1], lfsr[31] ^ lfsr[21] ^ lfsr[1] ^ lfsr[0]};
        end
    end

    assign q = lfsr;

endmodule",0.011149249999999888,91
N/A,N/A,-1,12.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
);
reg [31:0 q_reg;

always @(posedge clk) begin
    if (reset) begin
        q_reg <= 32'h1;
    end else begin
        q_reg <= {q_reg[30:0], q_reg[31] ^ q_reg[21] ^ q_reg[1] ^ q_reg[0]};
    end
end

assign q = q_reg;

endmodule",0.010732323000000044,79
N/A,N/A,-0.1,13.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
);
   reg[31:0] r;

    always @(posedge clk) begin
        if (reset) begin
            r <= 32'h1;
        end else begin
            r <= {r[30:0], r[31] ^ r[21] ^ r[1] ^ r[0]};
        end
    end

    assign q = r;

endmodule",0.010591076999999949,82
N/A,N/A,-0.1,14.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
);
 reg [31:0] r;

 always @(posedge clk) begin
    if (reset) begin
        r <= 32'h1;
    end else begin
        r <= {r[30:0], r[31] ^ r[21] ^ r[1] ^ r[0]};
    end
 end

 assign q = r;

endmodule",0.010358443999999967,74
N/A,N/A,-1,15.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
);
reg [31:0 q;
always @(posedge clk) begin
    if (reset) begin
        q <= 32'h1;
    end else begin
        q <= {q[30:0], q[31] ^ q[21] ^ q[1] ^ q[0]};
    end
end

endmodule",0.010542467000000055,64
N/A,N/A,-1,16.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
);
   reg [31:0 q];
    
    always @(posedge clk) begin
        if (reset) begin
            q <= 32'h1;
        end else begin
            q <= {q[30:0], q[31] ^ q[21] ^ q[1] ^ q[0]};
        end
    end

endmodule",0.010524404999999959,67
N/A,N/A,-1,17.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
);
   //assignreg [31:0] lfsr;

    always @(posedge clk) begin
        if (reset) begin
            lfsr <= 32'h1;
        end else begin
            lfsr <= {lfsr[30:0], lfsr[31] ^ lfsr[21] ^ lfsr[1] ^ lfsr[0]};
        end
    end

    assign q = lfsr;
endmodule",0.010006428000000067,104
N/A,N/A,-1,18.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
);
reg [31:0 q;always @(posedge clk) begin
    if (reset) begin
        q <= 32'h1;
    end else begin
        q <= {q[30:0], q[31] ^ q[21] ^ q[1] ^ q[0]};
    end
end

endmodule",0.010545919000000126,69
N/A,N/A,-1,19.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
);
   reg [31:1] q;
   
   always @(posedge clk) begin
       if (reset) begin
           q <= 32'h1;
       end else begin
           q <= {q[30:1], q[31] ^ q[21] ^ q[1] ^ q[0]};
       end
   end

   assign q[0] = q[31];

endmodule",0.010701654000000005,78
N/A,N/A,-0.1,20.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
);
reg[31:0] q_reg;

always @(posedge clk) begin
    if (reset) begin
        q_reg <= 32'h1;
    end else begin
        q_reg <= {q_reg[30:0], q_reg[31] ^ q_reg[21] ^ q_reg[1] ^ q_reg[0]};
    end
end

assign q = q_reg;

endmodule",0.010544522,81
N/A,N/A,-1,21.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
);
   reg [31:0 q;always @(posedge clk) begin
        if (reset) begin
            q <= 32'h1;
        end else begin
            q <= {q[30:0], q[31] ^ q[21] ^ q[1] ^ q[0]};
        end
    end
endmodule",0.010826335000000409,71
N/A,N/A,-1,22.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
);
reg [31:0 q;]
reg [31:0] q;

always @(posedge clk) begin
    if (reset) begin
        q <= 32'h1;
    end else begin
        q <= {q[30:0], q[31] ^ q[21] ^ q[1] ^ q[0]};
    end
end

endmodule",0.010835650999999835,77
N/A,N/A,-1,23.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
);
   reg [31:1] q;
    always @(posedge clk) begin
        if (reset) begin
            q <= 32'h1;
        end else begin
            q <= {q[30:1], q[31] ^ q[21] ^ q[1] ^ q[0]};
        end
    end
endmodule",0.010643878999999856,66
N/A,N/A,-1,24.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
);
reg [31:0 q;]
 qreg [31:0] q;

always @(posedge clk) begin
    if (reset) begin
        q <= 32'h1;
    end else begin
        q <= {q[30:0], q[31] ^ q[21] ^ q[1] ^ q[0]};
    end
end

endmodule",0.010567247000000002,77
N/A,N/A,-0.1,25.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
);
   reg[31:0] q_reg;

    always @(posedge clk) begin
        if (reset) begin
            q_reg <= 32'h1;
        end else begin
            q_reg <= {q_reg[30:0], q_reg[31] ^ q_reg[21] ^ q_reg[1] ^ q_reg[0]};
        end
    end

    assign q = q_reg;

endmodule",0.010383577000000255,84
N/A,N/A,-1,26.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
);
   reg [31:)0reg [31:0] q_reg;

   always @(posedge clk) begin
       if (reset) begin
           q_reg <= 32'h1;
       end else begin
           q_reg <= {q_reg[30:0], q_reg[31] ^ q_reg[21] ^ q_reg[1] ^ q_reg[0]};
       end
   end

   assign q = q_reg;

endmodule",0.010800990999999982,95
N/A,N/A,-1,27.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
);
reg [31:0 q;]
 q;always @(posedge clk) begin
    if (reset) begin
        q <= 32'h1;
    end else begin
        q <= {q[30:0], q[31] ^ q[21] ^ q[1] ^ q[0]};
    end
end

endmodule",0.010711632000000026,69
N/A,N/A,-0.1,28.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
);
 reg [31:0] r;

 always @(posedge clk) begin
    if (reset) begin
        r <= 32'h1;
    end else begin
        r <= {r[30:0], r[31] ^ r[21] ^ r[1] ^ r[0]};
    end
 end

 assign q = r;

endmodule",0.010146727999999605,79
N/A,N/A,-1,29.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
);
   reg [31:q][0] lfsr;

    always @(posedge clk) begin
        if (reset) begin
            lfsr <= 32'h1;
        end else begin
            lfsr <= {lfsr[30:0], lfsr[31] ^ lfsr[21] ^ lfsr[1] ^ lfsr[0]};
        end
    end

    assign q = lfsr;
endmodule",0.010369823,94
N/A,N/A,-0.1,30.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
);
 reg [31:0] r;

 always @(posedge clk) begin
    if (reset) begin
        r <= 32'h1;
    end else begin
        r <= {r[30:0], r[31] ^ r[21] ^ r[1] ^ r[0]};
    end
 end

 assign q = r;

endmodule",0.010433350999999647,75
N/A,N/A,-0.1,31.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
);
  reg [31:0] q_reg;
    wire feedback;

    assign feedback = q_reg[31] ^ q_reg[21] ^ q_reg[1] ^ q_reg[0];

    always @(posedge clk) begin
        if (reset) begin
            q_reg <= 32'h1;
        end else begin
            q_reg <= {q_reg[30:0], feedback};
        end
    end

    assign q = q_reg;
endmodule",0.010386865999999717,97
N/A,N/A,-1,32.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
);
reg[31:0 q_reg;

always @(posedge clk) begin
    if (reset) begin
        q_reg <= 32'h1;
    end else begin
        q_reg <= {q_reg[30:0], q_reg[31] ^ q_reg[21] ^ q_reg[1] ^ q_reg[0]};
    end
end

assign q = q_reg;

endmodule",0.010215953999999972,79
N/A,N/A,-1,33.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
);
   reg [31:0 q;`reg [31:0] q;

   always @(posedge clk) begin
       if (reset) begin
           q <= 32'h1;
       end else begin
           q <= {q[30:0], q[31] ^ q[21] ^ q[1] ^ q[0]};
       end
   end

endmodule",0.010519579999999973,80
N/A,N/A,-1,34.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
);
reg [31:0 q;];
 qreg [31:0] q;

always @(posedge clk) begin
    if (reset) begin
        q <= 32'h1;
    end else begin
        q <= {q[30:0], q[31] ^ q[21] ^ q[1] ^ q[0]};
    end
end

endmodule",0.010595482999999906,77
N/A,N/A,-1,35.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
);
   //assign qreg [31:0] r;

   always @(posedge clk) begin
       if (reset) begin
           r <= 32'h1;
       end else begin
           r <= {r[30:0], r[31] ^ r[21] ^ r[1] ^ r[0]};
       end
   end

   assign q = r;
endmodule",0.010109485999999723,86
N/A,N/A,-1,36.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
);
   reg [31:1] q;;
   always @(posedge clk) begin
       if (reset) begin
           q <= 32'h1;
       end else begin
           q <= {q[30:1], q[31] ^ q[21] ^ q[1] ^ q[0]};
       end
   end
endmodule",0.010529958999999867,66
N/A,N/A,-1,37.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
);
reg [31:0 q;``
always @(posedge clk) begin
    if (reset) begin
        q <= 32'h1;
    end else begin
        q <= {q[30:0], q[31] ^ q[21] ^ q[1] ^ q[0]};
    end
end

endmodule",0.010711203000000058,64
N/A,N/A,-1,38.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
);
   reg [31:1] lfsr_reg;
    wire feedback;

    always @(posedge clk) begin
        if (reset) begin
            lfsr_reg <= 32'h1;
        end else begin
            feedback = lfsr_reg[32] ^ lfsr_reg[22] ^ lfsr_reg[2] ^ lfsr_reg[1];
            lfsr_reg <= {lfsr_reg[31:1], feedback};
        end
    end

    assign q = lfsr_reg;
endmodule",0.01077468299999973,113
N/A,N/A,-1,39.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
);
reg[31:0 q;
always @(posedge clk) begin
    if (reset) begin
        q <= 32'h1;
    end else begin
        q <= {q[30:0], q[31] ^ q[21] ^ q[1] ^ q[0]};
    end
end

endmodule",0.010371673999999942,64
N/A,N/A,-1,40.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
);
   reg[31:0 q_reg;

    always @(posedge clk) begin
        if (reset) begin
            q_reg <= 32'h1;
        end else begin
            q_reg <= {q_reg[30:0], q_reg[31] ^ q_reg[21] ^ q_reg[1] ^ q_reg[0]};
        end
    end

    assign q = q_reg;

endmodule",0.010334465000000126,82
N/A,N/A,-1,41.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
);
reg [31:q] q_reg;

always @(posedge clk) begin
    if (reset) begin
        q_reg <= 32'h1;
    end else begin
        q_reg <= {q_reg[30:0], q_reg[31] ^ q_reg[21] ^ q_reg[1] ^ q_reg[0]};
    end
end

assign q = q_reg;

endmodule",0.009888462999999792,79
N/A,N/A,-1,42.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
);
   reg [31:0 q;`]reg [31:0] q;

    always @(posedge clk) begin
        if (reset) begin
            q <= 32'h1;
        end else begin
            q <= {q[30:0], q[31] ^ q[21] ^ q[1] ^ q[0]};
        end
    end
endmodule",0.01051905299999989,80
N/A,N/A,-0.1,43.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
);
 reg [31:0] r;

 always @(posedge clk) begin
    if (reset) begin
        r <= 32'h1;
    end else begin
        r <= {r[30:0], r[31] ^ r[21] ^ r[1] ^ r[0]};
    end
 end

 assign q = r;

endmodule",0.010015407000000032,72
N/A,N/A,-1,44.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
);
reg [31:0 q;]
 q; always @(posedge clk) begin
    if (reset) begin
        q <= 32'h1;
    end else begin
        q <= {q[30:0], q[31] ^ q[21] ^ q[1] ^ q[0]};
    end
end

endmodule",0.011260538000000153,69
N/A,N/A,-1,45.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
);
   reg [31:]0 q_reg;

    always @(posedge clk) begin
        if (reset) begin
            q_reg <= 32'h1;
        end else begin
            q_reg <= {q_reg[30:0], feedback};
        end
    end

    wire feedback = q_reg[31] ^ q_reg[21] ^ q_reg[1] ^ q_reg[0];

    assign q = q_reg;

endmodule",0.010914061000000252,88
N/A,N/A,-1,46.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
);
   reg [31:1] q;;0always @(posedge clk) begin
        if (reset) begin
            q <= 32'h1;
        end else begin
            q <= {q[30:0], q[31] ^ q[21] ^ q[1] ^ q[0]};
        end
    end
endmodule",0.011399332999999956,71
N/A,N/A,-1,47.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
);
reg [31:0 q;`
`
reg [31:0] q;

always @(posedge clk) begin
    if (reset) begin
        q <= 32'h1;
    end else begin
        q <= {q[30:0], q[31] ^ q[21] ^ q[1] ^ q[0]};
    end
end

endmodule",0.010870978999999892,77
N/A,N/A,-1,48.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
);
   reg [31:0 q;`] qreg [31:0] q;

    always @(posedge clk) begin
        if (reset) begin
            q <= 32'h1;
        end else begin
            q <= {q[30:0], q[31] ^ q[21] ^ q[1] ^ q[0]};
        end
    end

endmodule",0.011326040999999787,80
N/A,N/A,-1,49.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
);
reg[31:0 q;reg [31:0] q;

always @(posedge clk) begin
    if (reset) begin
        q <= 32'h1;
    end else begin
        q <= {q[30:0], q[31] ^ q[21] ^ q[1] ^ q[0]};
    end
end

endmodule",0.010545318999999775,77
N/A,N/A,-1,50.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
);
   reg[31:0 q];
    
    always @(posedge clk) begin
        if (reset) begin
            q <= 32'h1;
        end else begin
            q <= {q[30:0], q[31] ^ q[21] ^ q[1] ^ q[0]};
        end
    end

endmodule",0.010743084000000014,67
N/A,N/A,-1,51.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
);
reg [31:0 q;]
 q; ;always @(posedge clk) begin
    if (reset) begin
        q <= 32'h1;
    end else begin
        q <= {q[30:0], q[31] ^ q[21] ^ q[1] ^ q[0]};
    end
end

endmodule",0.011114037000000021,69
N/A,N/A,-1,52.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
);
   //reg [31:0] r;

    always @(posedge clk) begin
        if (reset) begin
            r <= 32'h1;
        end else begin
            r <= {r[30:0], r[31] ^ r[21] ^ r[1] ^ r[0]};
        end
    end

    assign q = r;
endmodule",0.010565997999999688,77
N/A,N/A,-1,53.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
);
   reg [31:)0] q_reg;

    always @(posedge clk) begin
        if (reset) begin
            q_reg <= 32'h1;
        end else begin
            q_reg <= {q_reg[30:0], q_reg[31] ^ q_reg[21] ^ q_reg[1] ^ q_reg[0]};
        end
    end

    assign q = q_reg;
endmodule",0.01122719899999991,82
N/A,N/A,-1,54.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
);
reg [31:0 q;];
 q;reg [31:0] q;

always @(posedge clk) begin
    if (reset) begin
        q <= 32'h1;
    end else begin
        q <= {q[30:0], q[31] ^ q[21] ^ q[1] ^ q[0]};
    end
end

endmodule",0.011392494000000308,77
N/A,N/A,-1,55.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
);
   reg [31:q]31reg [31:0] q_reg;

   always @(posedge clk) begin
       if (reset) begin
           q_reg <= 32'h1;
       end else begin
           q_reg <= {q_reg[30:0], q_reg[31] ^ q_reg[21] ^ q_reg[1] ^ q_reg[0]};
       end
   end

   assign q = q_reg;

endmodule",0.010666408000000072,95
N/A,N/A,-1,56.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
);
 reg [31:]0] r;

always @(posedge clk) begin
    if (reset) begin
        r <= 32'h1;
    end else begin
        r <= {r[30:0], r[31] ^ r[21] ^ r[1] ^ r[0]};
    end
end

assign q = r;

endmodule",0.010618114000000123,72
N/A,N/A,-1,57.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
);
reg [31:0 q;]
 q; ;always @(posedge clk) begin
    if (reset) begin
        q <= 32'h1;
    end else begin
        q <= {q[30:0], q[31] ^ q[21] ^ q[1] ^ q[0]};
    end
end

endmodule",0.011428056999999825,69
N/A,N/A,-1,58.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
);
   reg [31:1] q;;
1wire feedback;

    assign feedback = q[32] ^ q[22] ^ q[2] ^ q[1];

    always @(posedge clk) begin
        if (reset) begin
            q <= 32'h1;
        end else begin
            q <= {q[30:1], feedback};
        end
    end

    assign q[31:0] = {q[31:1], feedback};

endmodule",0.012323893999999669,99
N/A,N/A,-0.1,59.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
);
 reg [31:0] r;

 always @(posedge clk) begin
    if (reset) begin
        r <= 32'h1;
    end else begin
        r <= {r[30:0], r[31] ^ r[21] ^ r[1] ^ r[0]};
    end
 end

 assign q = r;

endmodule",0.010891703999999613,74
N/A,N/A,-0.1,60.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
);
  reg [31:0] r;

  always @(posedge clk) begin
    if (reset) begin
      r <= 32'h1;
    end else begin
      r <= {r[30:0], r[31] ^ r[21] ^ r[1] ^ r[0]};
    end
  end

  assign q = r;
endmodule",0.010665637000000672,77
N/A,N/A,-1,61.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
);
reg[31:0 q;`always @(posedge clk) begin
    if (reset) begin
        q <= 32'h1;
    end else begin
        q <= {q[30:0], q[31] ^ q[21] ^ q[1] ^ q[0]};
    end
end

endmodule",0.011448924999999832,67
N/A,N/A,-1,62.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
);
   reg [31:0 q;`] q;
always @(posedge clk) begin
        if (reset) begin
            q <= 32'h1;
        end else begin
            q <= {q[30:0], q[31] ^ q[21] ^ q[1] ^ q[0]};
        end
    end
endmodule",0.011791435000000128,71
N/A,N/A,-0.1,63.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
);
   reg [31:1] lfsr;
    
    always @(posedge clk) begin
        if (reset) begin
            lfsr <= 32'h1;
        end else begin
            lfsr <= {lfsr[30:1], lfsr[31] ^ lfsr[21] ^ lfsr[1] ^ lfsr[0]};
        end
    end

    assign q = lfsr;
    
endmodule",0.011648167999999792,90
N/A,N/A,-1,64.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
);
reg [31:0 q;``]always @(posedge clk) begin
    if (reset) begin
        q <= 32'h1;
    end else begin
        q <= {q[30:0], q[31] ^ q[21] ^ q[1] ^ q[0]};
    end
end

endmodule",0.01130178000000015,69
N/A,N/A,-0.1,65.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
);
   reg[31:1] q_reg;
   
   always @(posedge clk) begin
       if (reset) begin
           q_reg <= 32'h1;
       end else begin
           q_reg <= {q_reg[30:1], q_reg[31] ^ q_reg[21] ^ q_reg[1] ^ q_reg[0]};
       end
   end

   assign q = {q_reg[31:1], q_reg[0]};

endmodule",0.011094631999999827,94
N/A,N/A,-1,66.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
);
reg [31:0 q;];
always @(posedge clk) begin
    if (reset) begin
        q <= 32'h1;
    end else begin
        q <= {q[30:0], q[31] ^ q[21] ^ q[1] ^ q[0]};
    end
end

endmodule",0.011585354999999353,69
N/A,N/A,-1,67.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
);
   reg [31:1] q;;0;always @(posedge clk) begin
        if (reset) begin
            q <= 32'h1;
        end else begin
            q <= {q[30:0], q[31] ^ q[21] ^ q[1] ^ q[0]};
        end
    end
endmodule",0.011659944999999894,71
N/A,N/A,-1,68.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
);
reg[31:0 q;`]reg [31:0] q;

always @(posedge clk) begin
    if (reset) begin
        q <= 32'h1;
    end else begin
        q <= {q[30:0], q[31] ^ q[21] ^ q[1] ^ q[0]};
    end
end

endmodule",0.011825093999999758,75
N/A,N/A,-1,69.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
);
   //assign q =reg [31:0] lfsr;

   always @(posedge clk) begin
       if (reset) begin
           lfsr <= 32'h1;
       end else begin
           lfsr <= {lfsr[30:0], lfsr[31] ^ lfsr[21] ^ lfsr[1] ^ lfsr[0]};
       end
   end

   assign q = lfsr;
endmodule",0.010787727000000302,102
N/A,N/A,-1,70.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
);
   reg [31:0 q;`]``always @(posedge clk) begin
        if (reset) begin
            q <= 32'h1;
        end else begin
            q <= {q[30:0], q[31] ^ q[21] ^ q[1] ^ q[0]};
        end
    end
endmodule",0.011681435999999934,71
N/A,N/A,-1,71.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
);
reg [31:q];always @(posedge clk) begin
    if (reset) begin
        q <= 32'h1;
    end else begin
        q <= {q[30:0], q[31] ^ q[21] ^ q[1] ^ q[0]};
    end
end

endmodule",0.010991608000000319,69
N/A,N/A,-0.1,72.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
);
 reg[31:0] r;

always @(posedge clk) begin
    if (reset) begin
        r <= 32'h1;
    end else begin
        r <= {r[30:0], r[31] ^ r[21] ^ r[1] ^ r[0]};
    end
end

assign q = r;

endmodule",0.010697229999999891,79
N/A,N/A,-1,73.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
);
   reg [31:1] q;;   
<=
   always @(posedge clk) begin
       if (reset) begin
           q <= 32'h1;
       end else begin
           q <= {q[30:1], q[31] ^ q[21] ^ q[1] ^ q[0]};
       end
   end
endmodule",0.011719885999999846,66
N/A,N/A,-1,74.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
);
reg [31:0 q;]
 q; ;always @(posedge clk) begin
    if (reset) begin
        q <= 32'h1;
    end else begin
        q <= {q[30:0], q[31] ^ q[21] ^ q[1] ^ q[0]};
    end
end

endmodule",0.01162348400000024,69
N/A,N/A,-1,75.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
);
   reg [31:0 q;];
always @(posedge clk) begin
        if (reset) begin
            q <= 32'h1;
        end else begin
            q <= {q[30:0], q[31] ^ q[21] ^ q[1] ^ q[0]};
        end
    end
endmodule",0.011506953000000486,71
N/A,N/A,-0.1,76.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
);
reg [31:1] lfsr;

always @(posedge clk) begin
    if (reset) begin
        lfsr <= 32'h1;
    end else begin
        lfsr <= {lfsr[30:1], lfsr[31] ^ lfsr[21] ^ lfsr[1] ^ lfsr[0]};
    end
end

assign q = {lfsr[31:1], lfsr[0]};

endmodule",0.011270679999999977,100
N/A,N/A,-1,77.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
);
   reg[31:0 q;always @(posedge clk) begin
        if (reset) begin
            q <= 32'h1;
        end else begin
            q <= {q[30:0], q[31] ^ q[21] ^ q[1] ^ q[0]};
        end
    end
endmodule",0.010888843000000037,71
N/A,N/A,-0.1,78.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
);
reg[31:1] q_reg;
wire feedback;

// Calculate feedback based on the tap positions
assign feedback = q_reg[31] ^ q_reg[22] ^ q_reg[2] ^ q_reg[1];

always @(posedge clk) begin
    if (reset) begin
        q_reg <= 32'h1; // Reset to 32'h1
    end else begin
        q_reg <= {q_reg[30:1], feedback}; // Shift and insert feedback
    end
end

assign q = {q_reg[31:1], feedback}; // Output the current state

endmodule",0.011091010000000345,122
N/A,N/A,-1,79.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
);
   reg [31:)0] qreg [31:0] q_next;

   always @(posedge clk) begin
       if (reset) begin
           q <= 32'h1;
       end else begin
           q_next = {q[30:0], feedback};
           q <= q_next;
       end
   end

   wire feedback = q[31] ^ q[21] ^ q[1] ^ q[0];

endmodule",0.011700765999999696,94
N/A,N/A,-1,80.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
);
   reg [31:q0];always @(posedge clk) begin
        if (reset) begin
            q <= 32'h1;
        end else begin
            q <= {q[30:0], q[31] ^ q[21] ^ q[1] ^ q[0]};
        end
    end
endmodule",0.011441259999999787,71
N/A,N/A,-1,81.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
);
reg [31:0 q;];
 q; reg [31:0] q;

always @(posedge clk) begin
    if (reset) begin
        q <= 32'h1;
    end else begin
        q <= {q[30:0], q[31] ^ q[21] ^ q[1] ^ q[0]};
    end
end

endmodule",0.011384183999999742,77
N/A,N/A,-0.1,82.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
);
   reg [31:1] lfsr;   
   always @(posedge clk) begin
       if (reset) begin
           lfsr <= 32'h1;
       end else begin
           lfsr <= {lfsr[30:1], lfsr[31] ^ lfsr[21] ^ lfsr[1] ^ lfsr[0]};
       end
   end

   assign q = lfsr;

endmodule",0.011784050999999351,88
N/A,N/A,-1,83.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
);
reg [31:0 q;`
`
`
reg [31:0] q;

always @(posedge clk) begin
    if (reset) begin
        q <= 32'h1;
    end else begin
        q <= {q[30:0], q[31] ^ q[21] ^ q[1] ^ q[0]};
    end
end

endmodule",0.011536619000000137,77
N/A,N/A,-1,84.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
);
   reg [31:]0 q   reg [31:0] q_next;

   always @(posedge clk) begin
       if (reset) begin
           q <= 32'h1;
       end else begin
           q_next = {q[30:0], feedback};
           q <= q_next;
       end
   end

   wire feedback;
   assign feedback = q[31] ^ q[21] ^ q[1] ^ q[0];

endmodule",0.011386587999999698,92
N/A,N/A,-1,85.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
);
 reg [31:]0reg [31:0] q_reg;
 wire feedback;

 assign feedback = q_reg[31] ^ q_reg[21] ^ q_reg[1] ^ q_reg[0];

 always @(posedge clk) begin
    if (reset) begin
        q_reg <= 32'h1;
    end else begin
        q_reg <= {q_reg[30:0], feedback};
    end
 end

 assign q = q_reg;

endmodule",0.01098265300000012,99
N/A,N/A,-1,86.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
);
reg [31:0 q;]
 q; ;always @(posedge clk) begin
    if (reset) begin
        q <= 32'h1;
    end else begin
        q <= {q[30:0], q[31] ^ q[21] ^ q[1] ^ q[0]};
    end
end

endmodule",0.011413722999999543,69
N/A,N/A,-1,87.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
);
   //assign q =32reg [31:0] q_reg;
   wire feedback;

   assign feedback = q_reg[31] ^ q_reg[21] ^ q_reg[1] ^ q_reg[0];

   always @(posedge clk) begin
       if (reset) begin
           q_reg <= 32'h1;
       end else begin
           q_reg <= {q_reg[30:0], feedback};
       end
   end

   assign q = q_reg;

endmodule",0.010709509999999867,105
N/A,N/A,-0.1,88.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
);
 reg [31:0] r;

 always @(posedge clk) begin
    if (reset) begin
        r <= 32'h1;
    end else begin
        r <= {r[30:0], r[31] ^ r[21] ^ r[1] ^ r[0]};
    end
 end

 assign q = r;

endmodule",0.010804626999999734,73
N/A,N/A,-1,89.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
);
reg[31:0 q;``]reg [31:0] q;

always @(posedge clk) begin
    if (reset) begin
        q <= 32'h1;
    end else begin
        q <= {q[30:0], q[31] ^ q[21] ^ q[1] ^ q[0]};
    end
end

endmodule",0.011202495000000035,77
N/A,N/A,-1,90.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
);
   reg[31:0 q;];
always @(posedge clk) begin
        if (reset) begin
            q <= 32'h1;
        end else begin
            q <= {q[30:0], q[31] ^ q[21] ^ q[1] ^ q[0]};
        end
    end
endmodule",0.011193467000000012,71
N/A,N/A,-0.1,91.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
);
  reg [31:0] r;

  always @(posedge clk) begin
    if (reset) begin
      r <= 32'h1;
    end else begin
      r <= {r[30:0], r[31] ^ r[21] ^ r[1] ^ r[0]};
    end
  end

  assign q = r;

endmodule",0.010905345000000288,82
N/A,N/A,-1,92.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
);
   reg [31:0 q;`] q;
 qreg [31:0] q;

    always @(posedge clk) begin
        if (reset) begin
            q <= 32'h1;
        end else begin
            q <= {q[30:0], q[31] ^ q[21] ^ q[1] ^ q[0]};
        end
    end
endmodule",0.011970352999999712,80
N/A,N/A,-1,93.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
);
reg [31:0 q;]
 q; ;always @(posedge clk) begin
    if (reset) begin
        q <= 32'h1;
    end else begin
        q <= {q[30:0], q[31] ^ q[21] ^ q[1] ^ q[0]};
    end
end

endmodule",0.011347666999999895,69
N/A,N/A,-1,94.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
);
   reg [31:1] q;;
1;wire feedback;

    assign feedback = q[31] ^ q[21] ^ q[1] ^ q[0];

    always @(posedge clk) begin
        if (reset) begin
            q <= 32'h1;
        end else begin
            q <= {q[30:0], feedback};
        end
    end
endmodule",0.011162608999999435,81
N/A,N/A,-1,95.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
);
reg [31::0] lfsr;

always @(posedge clk) begin
    if (reset) begin
        lfsr <= 32'h1;
    end else begin
        lfsr <= {lfsr[30:0], lfsr[31] ^ lfsr[21] ^ lfsr[1] ^ lfsr[0]};
    end
end

assign q = lfsr;

endmodule",0.011108377000000225,89
N/A,N/A,-1,96.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
);
   reg [31:0 q;`](
``always @(posedge clk) begin
        if (reset) begin
            q <= 32'h1;
        end else begin
            q <= {q[30:0], q[31] ^ q[21] ^ q[1] ^ q[0]};
        end
    end
endmodule",0.01137532500000038,71
N/A,N/A,-1,97.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
);
reg[31:0 q;`]`reg [31:0] q;

always @(posedge clk) begin
    if (reset) begin
        q <= 32'h1;
    end else begin
        q <= {q[30:0], q[31] ^ q[21] ^ q[1] ^ q[0]};
    end
end

endmodule",0.01109877100000034,77
N/A,N/A,-1,98.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
);
   reg [31]:0] r;

    always @(posedge clk) begin
        if (reset) begin
            r <= 32'h1;
        end else begin
            r <= {r[30:0], r[31] ^ r[21] ^ r[1] ^ r[0]};
        end
    end

    assign q = r;
endmodule",0.010796843999999695,75
N/A,N/A,-1,99.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
);
   reg [31];:reg [31:0] q_reg;

   always @(posedge clk) begin
       if (reset) begin
           q_reg <= 32'h1;
       end else begin
           q_reg <= {q_reg[30:0], q_reg[31] ^ q_reg[21] ^ q_reg[1] ^ q_reg[0]};
       end
   end

   assign q = q_reg;

endmodule",0.010538802000000125,95
N/A,N/A,-1,100.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
);
reg [31:0 q;``]
reg [31:0] q;

always @(posedge clk) begin
    if (reset) begin
        q <= 32'h1;
    end else begin
        q <= {q[30:0], q[31] ^ q[21] ^ q[1] ^ q[0]};
    end
end

endmodule",0.011175203000000522,77
N/A,N/A,-0.1,101.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
);
 reg [31:1] q_reg;
 
 always @(posedge clk) begin
    if (reset) begin
        q_reg <= 32'h1;
    end else begin
        q_reg <= {q_reg[30:1], q_reg[31] ^ q_reg[21] ^ q_reg[1] ^ q_reg[0]};
    end
 end
 
 assign q = {q_reg, q_reg[0]};
 
endmodule",0.010847479999999798,261
