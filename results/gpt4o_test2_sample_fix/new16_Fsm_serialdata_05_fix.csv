Area,Delay,Score,Current Run,Episode,Verilog
N/A,N/A,-1,0,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP,
        DONE
    } state_t;
    
    state_t state, next_state;
    reg [7:0] data_shift_reg;
    reg [2:0] bit_counter;
    
    // FSM state transition
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
        end else begin
            state <= next_state;
        end
    end
    
    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 0)
                    next_state = START;
                else
                    next_state = IDLE;
            end
            
            START: begin
                next_state = DATA;
            end

            DATA: begin
                if (bit_counter == 3'd7)
                    next_state = STOP;
                else
                    next_state = DATA;
            end
            
            STOP: begin
                if (in == 1)
                    next_state = DONE;
                else
                    next_state = START;
            end
            
            DONE: begin
                next_state = IDLE;
            end
            
            default: begin
                next_state = IDLE;
            end
        endcase
    end

    // Data shifting logic
    always @(posedge clk) begin
        if (reset) begin
            data_shift_reg <= 8'd0;
            bit_counter <= 3'd0;
        end else if (state == DATA) begin
            data_shift_reg <= {in, data_shift_reg[7:1]};
            bit_counter <= bit_counter + 3'd1;
        end else if (state != DATA) begin
            bit_counter <= 3'd0;
        end
    end

    // Output logic
    assign out_byte = (state == DONE) ? data_shift_reg : 8'bx;
    assign done = (state == DONE);

endmodule"
N/A,N/A,-1,1,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    // State and next-state logic
    state_t state, next_state;

    // Bit counter for data bits
    logic [2:0] bit_counter;

    // Shift register for assembling the data byte
    logic [7:0] shift_reg;

    // Combinational logic to determine next state
    always_comb begin
        case (state)
            IDLE: next_state = in ? IDLE : START; // Wait for start bit (0)
            START: next_state = DATA;             // Start bit detected, shift to DATA state
            DATA: next_state = (bit_counter == 3'd7) ? STOP : DATA; // Shift until 8 bits received
            STOP: next_state = in ? IDLE : DATA;  // Check stop bit, if correct move to IDLE
            default: next_state = IDLE;           // Default state
        endcase
    end

    // State transition and output logic
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_counter <= 3'd0;
            shift_reg <= 8'd0;
            done <= 1'b0;
        end else begin
            state <= next_state;

            case (state)
                IDLE: begin
                    bit_counter <= 3'd0;
                    shift_reg <= 8'd0;
                    done <= 1'b0;
                end
                START: begin
                    shift_reg <= 8'd0;
                    done <= 1'b0;
                end
                DATA: begin
                    shift_reg <= {in, shift_reg[7:1]}; // Shift in the LSB first
                    bit_counter <= bit_counter + 3'd1;
                    done <= 1'b0;
                end
                STOP: begin
                    if (in) begin // Stop bit correct
                        out_byte <= shift_reg; // Output the received byte
                        done <= 1'b1;
                    end
                end
            endcase
        end
    end

endmodule"
N/A,N/A,-1,2,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    // State and next-state logic
    state_t state, next_state;

    // Bit counter for data bits
    logic [2:0] bit_counter;

    // Shift register for assembling the data byte
    logic [7:0] shift_reg;

    // Combinational logic to update next state
    always_comb begin
        case (state)
            IDLE: next_state = in ? IDLE : START; // Wait for start bit (0)
            START: next_state = DATA;             // Start bit detected, shift to DATA
            DATA: next_state = (bit_counter == 3'b111) ? STOP : DATA; // Receive 8 data bits
            STOP: next_state = in ? IDLE : STOP;  // Verify stop bit (1)
            default: next_state = IDLE;
        endcase
    end

    // Sequential logic for state transitions
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_counter <= 3'b0;
            shift_reg <= 8'b0;
        end else begin
            state <= next_state;

            // State-specific behavior
            if (state == DATA) begin
                shift_reg <= {in, shift_reg[7:1]}; // Shift in LSB first
                bit_counter <= bit_counter + 1;
            end

            if (state == STOP && next_state == IDLE) begin
                shift_reg <= 8'b0;
                bit_counter <= 3'b0;
            end
        end
    end

    // Output assignments
    assign out_byte = shift_reg;
    assign done = (state == STOP) && (next_state == IDLE) && in;
endmodule"
N/A,N/A,-1,3,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    // State and next-state logic
    state_t state, next_state;

    // Bit counter for data bits
    logic [2:0] bit_count;

    // Shift register for assembling the data byte
    logic [7:0] shift_reg;

    // Combinational logic to update next state
    always_comb begin
        case (state)
            IDLE: next_state = in ? IDLE : START; // Wait for start bit (0)
            START: next_state = DATA;             // Start bit detected, shift to DATA state
            DATA: next_state = (bit_count == 3'd7) ? STOP : DATA; // Shift until 8 bits received
            STOP: next_state = in ? IDLE : DATA;  // Check stop bit, if correct move to IDLE
            default: next_state = IDLE;           // Default state
        endcase
    end

    // State transition and output logic
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 3'd0;
            shift_reg <= 8'd0;
            done <= 1'b0;
        end else begin
            state <= next_state;

            case (state)
                IDLE: begin
                    bit_count <= 3'd0;
                    shift_reg <= 8'd0;
                    done <= 1'b0;
                end
                START: begin
                    shift_reg <= 8'd0;
                    done <= 1'b0;
                end
                DATA: begin
                    shift_reg <= {in, shift_reg[7:1]}; // Shift in data bits
                    bit_count <= bit_count + 1;
                end
                STOP: begin
                    done <= (in == 1'b1); // Done only if stop bit is 1
                end
            endcase
        end
    end

    // Assign output byte
    assign out_byte = shift_reg;
endmodule"
N/A,N/A,-1,4,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    // State and next-state logic
    state_t state, next_state;

    // Bit counter for data bits
    logic [2:0] bit_counter;

    // Shift register for assembling the data byte
    logic [7:0] shift_reg;

    // Combinational logic to determine next state
    always_comb begin
        case (state)
            IDLE: next_state = in ? IDLE : START; // Wait for start bit (0)
            START: next_state = DATA;             // Start bit detected, shift to DATA state
            DATA: next_state = (bit_counter == 3'd7) ? STOP : DATA; // Shift until 8 bits received
            STOP: next_state = in ? IDLE : DATA;  // Check stop bit, if correct move to IDLE
            default: next_state = IDLE;           // Default state
        endcase
    end

    // State transition and output logic
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_counter <= 3'd0;
            shift_reg <= 8'd0;
            done <= 1'b0;
        end else begin
            state <= next_state;

            case (state)
                IDLE: begin
                    bit_counter <= 3'd0;
                    done <= 1'b0;
                end
                START: begin
                    done <= 1'b0;
                end
                DATA: begin
                    shift_reg <= {in, shift_reg[7:1]}; // Shift in the incoming bit
                    bit_counter <= bit_counter + 1;
                end
                STOP: begin
                    if (in) begin
                        done <= 1'b1; // Stop bit correct, done with byte reception
                        out_byte <= shift_reg; // Parallel load of the data byte
                    end else begin
                        done <= 1'b0; // Incorrect stop bit, output is don't-care
                    end
                end
            endcase
        end
    end
endmodule"
N/A,N/A,-1,5,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    // State and next-state logic
    state_t state, next_state;

    // Bit counter for data bits
    logic [2:0] bit_counter;

    // Shift register for assembling the data byte
    logic [7:0] shift_reg;

    // Combinational logic to determine next state
    always_comb begin
        case (state)
            IDLE: next_state = in ? IDLE : START; // Wait for start bit (0)
            START: next_state = DATA;             // Start bit detected, shift to DATA state
            DATA: next_state = (bit_counter == 3'd7) ? STOP : DATA; // Shift until 8 bits received
            STOP: next_state = in ? IDLE : START; // If stop bit (1), return to IDLE; else START
            default: next_state = IDLE;
        endcase
    end

    // Sequential logic to update state and perform actions
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_counter <= 3'd0;
            shift_reg <= 8'd0;
            done <= 1'b0;
        end else begin
            state <= next_state;

            case (state)
                IDLE: begin
                    done <= 1'b0;
                end
                DATA: begin
                    bit_counter <= bit_counter + 1'b1;
                    shift_reg <= {in, shift_reg[7:1]}; // Shift in the least significant bit first
                end
                STOP: begin
                    done <= 1'b1;  // Indicate a valid output byte
                    bit_counter <= 3'd0;
                end
            endcase

            if (state == STOP && next_state == IDLE) begin
                // Capture the output byte when done is asserted
                out_byte <= shift_reg;
            end
        end
    end
endmodule"
N/A,N/A,-1,6,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    // State and next-state logic
    state_t state, next_state;

    // Bit counter for data bits
    logic [2:0] bit_counter;

    // Shift register for assembling the data byte
    logic [7:0] shift_reg;

    // Combinational logic to determine next state
    always_comb begin
        case (state)
            IDLE: next_state = in ? IDLE : START; // Wait for start bit (0)
            START: next_state = DATA;             // Start bit detected, shift to DATA state
            DATA: next_state = (bit_counter == 3'd7) ? STOP : DATA; // Shift until 8 bits received
            STOP: next_state = in ? IDLE : START; // If stop bit (1), return to IDLE; else START
            default: next_state = IDLE;
        endcase
    end

    // Sequential logic to update state and perform actions
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_counter <= 3'd0;
            shift_reg <= 8'd0;
            done <= 1'b0;
        end else begin
            state <= next_state;

            case (state)
                IDLE: begin
                    done <= 1'b0;
                end

                DATA: begin
                    bit_counter <= bit_counter + 1'b1;
                    shift_reg <= {in, shift_reg[7:1]}; // Shift in the least significant bit first
                end

                STOP: begin
                    done <= 1'b1;  // Indicate that we have received a full valid byte
                end

                default: begin
                    // Reset default actions if needed
                end
            endcase

            if (state == STOP) begin
                bit_counter <= 3'd0;   // Reset bit counter after STOP state
            end
        end
    end

    assign out_byte = shift_reg; // Output the latched byte"
N/A,N/A,-1,7,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    // State and next-state logic
    state_t state, next_state;

    // Bit counter for data bits
    logic [2:0] bit_counter;

    // Shift register for assembling the data byte
    logic [7:0] shift_reg;

    // Combinational logic to determine next state
    always_comb begin
        case (state)
            IDLE: next_state = in ? IDLE : START; // Wait for start bit (0)
            START: next_state = DATA;             // Start bit detected, shift to DATA state
            DATA: next_state = (bit_counter == 3'd7) ? STOP : DATA; // Shift until 8 bits received
            STOP: next_state = in ? IDLE : START; // If stop bit (1), return to IDLE; else START
            default: next_state = IDLE;
        endcase
    end

    // Sequential logic to update state and perform actions
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_counter <= 3'd0;
            shift_reg <= 8'd0;
            done <= 1'b0;
        end else begin
            state <= next_state;

            case (state)
                IDLE: begin
                    done <= 1'b0;
                end

                START: begin
                    bit_counter <= 3'd0;
                    shift_reg <= 8'd0;
                end

                DATA: begin
                    shift_reg <= {in, shift_reg[7:1]}; // Shift in the serial data
                    bit_counter <= bit_counter + 3'd1;
                end

                STOP: begin
                    if (in) begin // Verify stop bit
                        out_byte <= shift_reg; // Output the assembled data byte
                        done <= 1'b1;         // Indicate done for one cycle
                    end else begin
                        done <= 1'b0;
                    end
                end
            endcase
        end
    end
endmodule"
N/A,N/A,-1,8,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum reg [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    // State and next-state logic
    state_t state, next_state;

    // Bit counter for data bits
    reg [2:0] bit_counter;

    // Shift register for assembling the data byte
    reg [7:0] shift_reg;

    // Combinational logic to determine next state
    always @(*) begin
        case (state)
            IDLE: next_state = (in == 1'b0) ? START : IDLE;
            START: next_state = DATA;
            DATA: next_state = (bit_counter == 3'd7) ? STOP : DATA;
            STOP: next_state = (in == 1'b1) ? IDLE : STOP;
            default: next_state = IDLE;
        endcase
    end

    // Sequential logic for state transition and output logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            shift_reg <= 8'b0;
            bit_counter <= 3'b0;
            done <= 1'b0;
        end else begin
            state <= next_state;  // updates the current state to next state
            
            // Output logic
            case (state)
                START: begin
                    bit_counter <= 3'b0;         // Reset bit counter
                    done <= 1'b0;                // Clear done signal
                end
                DATA: begin
                    shift_reg <= {in, shift_reg[7:1]}; // Shift in the bits to shift register
                    bit_counter <= bit_counter + 1;    // Count the bits
                end
                STOP: begin
                    if (in == 1'b1) begin
                        done <= 1'b1;                // Set done when stop bit is correct
                    end else begin
                        done <= 1'b0;
                    end
                end
            endcase
        end
    end

    // Output the assembled byte when done is asserted
    assign out_byte = done ? shift_reg : 8'b0;

endmodule"
N/A,N/A,-1,9,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP,
        DONE
    } state_t;

    state_t state, next_state;
    logic [7:0] shift_reg;
    logic [2:0] bit_counter;

    // State transition logic
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
        end else begin
            state <= next_state;
        end
    end

    // Next state logic
    always_comb begin
        done = 0;
        next_state = state;
        case (state)
            IDLE: begin
                if (in == 0) begin  // start bit detected
                    next_state = START;
                end
            end
            START: next_state = DATA;
            DATA: begin
                if (bit_counter == 7) begin
                    next_state = STOP;
                end
            end
            STOP: begin
                if (in == 1) begin  // correct stop bit
                    next_state = DONE;
                    done = 1;
                end else begin  // incorrect stop bit, wait for next start
                    next_state = IDLE;
                end
            end
            DONE: begin
                next_state = IDLE;  // return to IDLE to receive next byte
            end
        endcase
    end

    // Datapath: shifting in the bits
    always_ff @(posedge clk) begin
        if (reset) begin
            shift_reg <= 0;
            bit_counter <= 0;
        end else begin
            case (state)
                START: begin
                    bit_counter <= 0;
                end
                DATA: begin
                    shift_reg <= {in, shift_reg[7:1]};  // shift in the bit
                    bit_counter <= bit_counter + 1;
                end
                default: begin
                    // maintain current values
                end
            endcase
        end
    end

    // Output logic
    assign out_byte = shift_reg;

endmodule"
N/A,N/A,-1,10,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    // State and next-state logic
    state_t state, next_state;

    // Bit counter for data bits
    logic [2:0] bit_counter;

    // Shift register for assembling the data byte
    logic [7:0] shift_reg;

    // Combinational logic to update next state
    always_comb begin
        case (state)
            IDLE: next_state = in ? IDLE : START; // Wait for start bit (0)
            START: next_state = DATA;             // Start bit detected, shift to DATA state
            DATA: next_state = (bit_counter == 3'd7) ? STOP : DATA; // Shift until 8 bits received
            STOP: next_state = in ? IDLE : START; // If stop bit (1), return to IDLE; else START
            default: next_state = IDLE;
        endcase
    end

    // Sequential logic to update state and perform actions
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_counter <= 3'd0;
            shift_reg <= 8'd0;
            done <= 1'b0;
        end else begin
            state <= next_state;

            case (state)
                IDLE: begin
                    done <= 1'b0;
                end

                START: begin
                    bit_counter <= 3'd0;
                    shift_reg <= 8'd0;
                end

                DATA: begin
                    shift_reg <= {in, shift_reg[7:1]}; // Shift in the serial data
                    bit_counter <= bit_counter + 3'd1;
                end

                STOP: begin
                    if (in) begin // Verify stop bit (1)
                        out_byte <= shift_reg; // Output the received byte
                        done <= 1'b1;          // Indicate byte is ready
                    end else begin
                        done <= 1'b0;
                    end
                end
            endcase
        end
    end
endmodule"
N/A,N/A,-1,11,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    // State and next-state logic
    state_t state, next_state;

    // Bit counter for data bits
    logic [2:0] bit_counter;

    // Shift register for assembling the data byte
    logic [7:0] shift_reg;

    // Combinational logic to update next state
    always_comb begin
        case (state)
            IDLE: next_state = in ? IDLE : START; // Wait for start bit (0)
            START: next_state = DATA;             // Start bit detected, shift to DATA state
            DATA: next_state = (bit_counter == 3'd7) ? STOP : DATA; // Shift until 8 bits received
            STOP: next_state = in ? IDLE : DATA;  // Check stop bit, if correct move to IDLE
            default: next_state = IDLE;           // Default state
        endcase
    end

    // State transition and output logic
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_counter <= 3'd0;
            shift_reg <= 8'd0;
            done <= 1'b0;
        end else begin
            state <= next_state;

            case (state)
                IDLE: begin
                    bit_counter <= 3'd0;
                    shift_reg <= 8'd0;
                    done <= 1'b0;
                end
                START: begin
                    shift_reg <= 8'd0;
                    done <= 1'b0;
                end
                DATA: begin
                    shift_reg <= {in, shift_reg[7:1]}; // Shift in data bits
                    bit_counter <= bit_counter + 1;
                end
                STOP: begin
                    done <= (in == 1'b1); // Done only if stop bit is 1
                end
            endcase
        end
    end

    // Assign output byte when done
    assign out_byte = done ? shift_reg : 8'bx;

endmodule"
N/A,N/A,-1,12,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    // State and next-state logic
    state_t state, next_state;

    // Bit counter for data bits
    logic [2:0] bit_counter;

    // Shift register for assembling the data byte
    logic [7:0] shift_reg;

    // Combinational logic to update next state
    always_comb begin
        case (state)
            IDLE: next_state = in ? IDLE : START; // Wait for start bit (0)
            START: next_state = DATA;             // Start bit detected, shift to DATA state
            DATA: next_state = (bit_counter == 3'd7) ? STOP : DATA; // Shift until 8 bits received
            STOP: next_state = in ? IDLE : START; // If stop bit (1), return to IDLE; else START
            default: next_state = IDLE;
        endcase
    end

    // Sequential logic to update state and perform actions
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_counter <= 3'd0;
            shift_reg <= 8'd0;
            done <= 1'b0;
        end else begin
            state <= next_state;

            case (state)
                IDLE: begin
                    done <= 1'b0;
                end

                DATA: begin
                    bit_counter <= bit_counter + 1'b1;
                    shift_reg <= {in, shift_reg[7:1]}; // Shift in the least significant bit first
                end

                STOP: begin
                    done <= 1'b1;  // Indicate a valid output byte
                    bit_counter <= 3'd0;
                end
            endcase

            if (state == STOP && next_state == IDLE) begin
                // Capture the output byte when done is asserted
                out_byte <= shift_reg;
            end
        end
    end
endmodule"
N/A,N/A,-1,13,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    // State and next-state logic
    state_t state, next_state;

    // Bit counter for data bits
    logic [2:0] bit_counter;

    // Shift register for assembling the data byte
    logic [7:0] shift_reg;

    // Combinational logic to determine next state
    always_comb begin
        case (state)
            IDLE: next_state = in ? IDLE : START; // Wait for start bit (0)
            START: next_state = DATA;             // Start bit detected, shift to DATA state
            DATA: next_state = (bit_counter == 3'd7) ? STOP : DATA; // Shift until 8 bits received
            STOP: next_state = in ? IDLE : START; // If stop bit (1), return to IDLE; else START
            default: next_state = IDLE;
        endcase
    end

    // Sequential logic to update state and perform actions
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_counter <= 3'd0;
            shift_reg <= 8'd0;
            done <= 1'b0;
        end else begin
            state <= next_state;

            case (state)
                IDLE: begin
                    done <= 1'b0;
                end

                START: begin
                    bit_counter <= 3'd0;
                    shift_reg <= 8'd0;
                end

                DATA: begin
                    shift_reg <= {in, shift_reg[7:1]}; // Shift in the serial data
                    bit_counter <= bit_counter + 3'd1;
                end

                STOP: begin
                    if (in) begin // Verify stop bit
                        out_byte <= shift_reg; // Output the assembled data byte
                        done <= 1'b1;         // Indicate done for one cycle
                    end else begin
                        done <= 1'b0;
                    end
                end
            endcase
        end
    end
endmodule"
N/A,N/A,-1,14,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum reg [2:0] {
        IDLE,
        START,
        DATA,
        STOP,
        WAIT_FOR_STOP
    } state_t;
    
    state_t state, next_state;
    reg [7:0] shift_reg;
    reg [3:0] bit_count;

    // FSM state transition
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
        end else begin
            state <= next_state;
        end
    end
    
    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 0)
                    next_state = START;
                else
                    next_state = IDLE;
            end
            START: begin
                next_state = DATA;
            end
            DATA: begin
                if (bit_count == 8)
                    next_state = STOP;
                else
                    next_state = DATA;
            end
            STOP: begin
                if (in == 1)
                    next_state = IDLE;
                else
                    next_state = WAIT_FOR_STOP;
            end
            WAIT_FOR_STOP: begin
                if (in == 1)
                    next_state = IDLE;
                else
                    next_state = WAIT_FOR_STOP;
            end
        endcase
    end
    
    // Datapath
    always @(posedge clk) begin
        if (reset) begin
            bit_count <= 0;
            shift_reg <= 8'd0;
        end else begin
            case (state)
                IDLE: begin
                    bit_count <= 0;
                end
                START: begin
                    // Do nothing, just transition
                end
                DATA: begin
                    shift_reg <= {in, shift_reg[7:1]};
                    bit_count <= bit_count + 1;
                end
                STOP: begin
                    // Do nothing, checking stop bit
                end
                WAIT_FOR_STOP: begin
                    // Do nothing, waiting for stop bit
                end
            endcase
        end
    end

    // Output logic
    assign done = (state == STOP) && (in == 1);
    assign out_byte = (done) ? shift_reg : 8'd0;

endmodule"
N/A,N/A,-1,15,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    // State and next-state logic
    state_t state, next_state;

    // Bit counter for data bits
    logic [2:0] bit_counter;

    // Shift register for assembling the data byte
    logic [7:0] shift_reg;

    // Combinational logic to determine next state
    always_comb begin
        case (state)
            IDLE: next_state = in ? IDLE : START; // Wait for start bit (0)
            START: next_state = DATA;             // Start bit detected, shift to DATA state
            DATA: next_state = (bit_counter == 3'd7) ? STOP : DATA; // Shift until 8 bits received
            STOP: next_state = in ? IDLE : DATA;  // Check stop bit, if correct move to IDLE
            default: next_state = IDLE;           // Default state
        endcase
    end

    // State transition and output logic
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_counter <= 3'd0;
            shift_reg <= 8'd0;
            done <= 1'b0;
        end else begin
            state <= next_state;

            case (state)
                IDLE: begin
                    done <= 1'b0;
                end

                START: begin
                    bit_counter <= 3'd0;
                    shift_reg <= 8'd0;
                end

                DATA: begin
                    shift_reg <= {in, shift_reg[7:1]}; // Shift in the serial data
                    bit_counter <= bit_counter + 3'd1;
                end

                STOP: begin
                    if (in) begin // Verify stop bit (1)
                        done <= 1'b1;
                        out_byte <= shift_reg; // Output the received byte
                    end else begin
                        done <= 1'b0;
                    end
                end
            endcase
        end
    end
endmodule"
N/A,N/A,-1,16,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    // State and next-state logic
    state_t state, next_state;

    // Bit counter for data bits
    logic [2:0] bit_counter;

    // Shift register for assembling the data byte
    logic [7:0] shift_reg;

    // Combinational logic to update next state
    always_comb begin
        case (state)
            IDLE: next_state = in ? IDLE : START; // Wait for start bit (0)
            START: next_state = DATA;             // Start bit detected, shift to DATA state
            DATA: next_state = (bit_counter == 3'd7) ? STOP : DATA; // Shift until 8 bits received
            STOP: next_state = in ? IDLE : START; // Validate stop bit (1), return to IDLE if valid
            default: next_state = IDLE;           // Explicit default state
        endcase
    end

    // Sequential logic to update state and output signals
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_counter <= 3'd0;
            shift_reg <= 8'h00;
        end else begin
            state <= next_state;

            case (state)
                DATA: begin
                    shift_reg <= {in, shift_reg[7:1]}; // Shift in the LSB first
                    bit_counter <= bit_counter + 1'b1;
                end
                STOP: begin
                    if (in) begin
                        done <= 1'b1; // Set done, valid stop bit
                    end
                end
                default: begin
                    done <= 1'b0; // Ensure done is low otherwise
                    bit_counter <= 3'd0; // Reset bit counter
                end
            endcase
        end
    end

    // Output assignment
    assign out_byte = (done) ? shift_reg : 8'hXX; // Only output when done is 1

endmodule"
N/A,N/A,-1,17,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    // State and next-state logic
    state_t state, next_state;

    // Bit counter for data bits
    logic [2:0] bit_counter;

    // Shift register for assembling the data byte
    logic [7:0] shift_reg;

    // Combinational logic to update next state
    always_comb begin
        case (state)
            IDLE: next_state = in ? IDLE : START; // Wait for start bit (0)
            START: next_state = DATA;             // Start bit detected, shift to DATA state
            DATA: next_state = (bit_counter == 3'd7) ? STOP : DATA; // Shift until 8 bits received
            STOP: next_state = in ? IDLE : START; // If stop bit (1), return to IDLE; else START
            default: next_state = IDLE;
        endcase
    end

    // Sequential logic to update state and perform actions
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_counter <= 3'd0;
            shift_reg <= 8'd0;
            done <= 1'b0;
        end else begin
            state <= next_state;

            case (state)
                IDLE: begin
                    done <= 1'b0;
                end

                DATA: begin
                    bit_counter <= bit_counter + 1'b1;
                    shift_reg <= {in, shift_reg[7:1]}; // Shift in the least significant bit first
                end

                STOP: begin
                    done <= 1'b1;  // Indicate a valid output byte
                    bit_counter <= 3'd0;
                end

                default: begin
                    done <= 1'b0;
                end
            endcase
        end
    end

    // Output assignment
    assign out_byte = (done) ? shift_reg : 8'd0; // Only output when done is 1

endmodule"
N/A,N/A,-1,18,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    // State and next-state logic
    state_t state, next_state;

    // Bit counter for data bits
    logic [2:0] bit_counter;

    // Shift register for assembling the data byte
    logic [7:0] shift_reg;

    // Combinational logic to update next state
    always_comb begin
        case (state)
            IDLE: next_state = in ? IDLE : START; // Wait for start bit (0)
            START: next_state = DATA;             // Start bit detected, shift to DATA state
            DATA: next_state = (bit_counter == 3'd7) ? STOP : DATA; // Shift until 8 bits received
            STOP: next_state = in ? IDLE : DATA;  // Check stop bit, if correct move to IDLE
            default: next_state = IDLE;           // Default state
        endcase
    end

    // State transition and output logic
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_counter <= 3'd0;
            shift_reg <= 8'd0;
            done <= 1'b0;
        end else begin
            state <= next_state;

            case (state)
                IDLE: begin
                    bit_counter <= 3'd0;
                    shift_reg <= 8'd0;
                    done <= 1'b0;
                end
                START: begin
                    shift_reg <= 8'd0;
                    done <= 1'b0;
                end
                DATA: begin
                    shift_reg <= {in, shift_reg[7:1]}; // Shift in the LSB first
                    bit_counter <= bit_counter + 3'd1;
                    done <= 1'b0;
                end
                STOP: begin
                    if (in) begin // Stop bit correct
                        out_byte <= shift_reg; // Output the received byte
                        done <= 1'b1;
                    end
                end
            endcase
        end
    end

endmodule"
N/A,N/A,-1,19,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    // State and next-state logic
    state_t state, next_state;

    // Bit counter for data bits
    logic [2:0] bit_count;

    // Shift register for assembling the data byte
    logic [7:0] shift_reg;

    // Combinational logic to update next state
    always_comb begin
        case (state)
            IDLE: next_state = in ? IDLE : START; // Wait for start bit (0)
            START: next_state = DATA;             // Start bit detected, shift to DATA state
            DATA: next_state = (bit_count == 3'd7) ? STOP : DATA; // Shift until 8 bits received
            STOP: next_state = in ? IDLE : START; // If stop bit (1), return to IDLE; else START
            default: next_state = IDLE;
        endcase
    end

    // Sequential logic to update state and perform actions
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 3'd0;
            shift_reg <= 8'd0;
            done <= 1'b0;
        end else begin
            state <= next_state;

            case (state)
                IDLE: begin
                    bit_count <= 3'd0;
                    done <= 1'b0;
                end
                START: begin
                    // Prepare for data collection
                end
                DATA: begin
                    // Shift data in
                    shift_reg <= {in, shift_reg[7:1]};
                    bit_count <= bit_count + 1;
                end
                STOP: begin
                    done <= in;  // Done if stop bit is correct
                end
            endcase

        end
    end

    // Output the received byte when done
    assign out_byte = shift_reg;

endmodule"
N/A,N/A,-1,20,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum reg [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    // State and next-state logic
    state_t state, next_state;

    // Bit counter for data bits
    reg [2:0] bit_count;

    // Shift register for assembling the data byte
    reg [7:0] shift_reg;

    // Combinational logic to determine next state
    always @(*) begin
        case (state)
            IDLE: next_state = (in == 1'b0) ? START : IDLE;
            START: next_state = DATA;
            DATA: next_state = (bit_count == 3'd7) ? STOP : DATA;
            STOP: next_state = (in == 1'b1) ? IDLE : STOP;
            default: next_state = IDLE;
        endcase
    end

    // Sequential logic for state transition and output logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            shift_reg <= 8'b0;
            bit_count <= 3'b0;
            done <= 1'b0;
        end else begin
            state <= next_state;  // updates the current state to next state
            
            // Output logic
            case (state)
                IDLE: begin
                    done <= 1'b0;
                end
                START: begin
                    bit_count <= 3'b0;
                end
                DATA: begin
                    shift_reg[bit_count] <= in; // shift the incoming bit
                    bit_count <= bit_count + 1;
                end
                STOP: begin
                    if (in == 1'b1) begin
                        out_byte <= shift_reg;
                        done <= 1'b1;
                    end else begin
                        done <= 1'b0;
                    end
                end
            endcase
        end
    end
endmodule"
N/A,N/A,-1,21,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    // State and next-state logic
    state_t state, next_state;

    // Bit counter for data bits
    logic [2:0] bit_counter;

    // Shift register for assembling the data byte
    logic [7:0] shift_reg;

    // Combinational logic to update next state
    always_comb begin
        case (state)
            IDLE: next_state = in ? IDLE : START; // Wait for start bit (0)
            START: next_state = DATA;             // Start bit detected, shift to DATA state
            DATA: next_state = (bit_counter == 3'd7) ? STOP : DATA; // Shift until 8 bits received
            STOP: next_state = in ? IDLE : START; // If stop bit (1), return to IDLE; else START
            default: next_state = IDLE;
        endcase
    end

    // Sequential logic to update state and perform actions
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_counter <= 3'd0;
            shift_reg <= 8'd0;
            done <= 1'b0;
        end else begin
            state <= next_state;

            case (state)
                IDLE: begin
                    done <= 1'b0;
                end
                DATA: begin
                    bit_counter <= bit_counter + 1'b1;
                    shift_reg <= {in, shift_reg[7:1]}; // Shift in the least significant bit first
                end
                STOP: begin
                    done <= 1'b1;  // Indicate a valid output byte
                    bit_counter <= 3'd0;
                end
            endcase

            if (state == STOP && next_state == IDLE) begin
                // Capture the output byte when done is asserted
                out_byte <= shift_reg;
            end
        end
    end
endmodule"
N/A,N/A,-1,22,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    // State and next-state logic
    state_t state, next_state;

    // Bit counter for data bits
    logic [2:0] bit_count;

    // Shift register for assembling the data byte
    logic [7:0] shift_reg;

    // Combinational logic to update next state
    always_comb begin
        case (state)
            IDLE: next_state = in ? IDLE : START; // Wait for start bit (0)
            START: next_state = DATA;             // Start bit detected, shift to DATA state
            DATA: next_state = (bit_count == 3'd7) ? STOP : DATA; // Shift until 8 bits received
            STOP: next_state = in ? IDLE : START; // If stop bit (1), return to IDLE; else START
            default: next_state = IDLE;
        endcase
    end

    // Sequential logic to update state and perform actions
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 3'd0;
            shift_reg <= 8'd0;
            done <= 1'b0;
        end else begin
            state <= next_state;

            case (state)
                IDLE: begin
                    bit_count <= 3'd0;
                    done <= 1'b0;
                end
                START: begin
                    // Prepare for data collection
                end
                DATA: begin
                    // Shift data in
                    shift_reg <= {in, shift_reg[7:1]};
                    bit_count <= bit_count + 1;
                end
                STOP: begin
                    done <= in;  // Done if stop bit is correct
                end
            endcase

        end
    end

    // Output the received byte when done
    assign out_byte = shift_reg;

endmodule"
N/A,N/A,-1,23,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP,
        DONE
    } state_t;
    
    state_t state, next_state;
    logic [2:0] bit_count;
    logic [7:0] shift_reg;

    // FSM state transition
    always_ff @(posedge clk or posedge reset) begin
        if (reset) 
            state <= IDLE;
        else 
            state <= next_state;
    end

    // Next state logic
    always_comb begin
        next_state = state;
        case (state)
            IDLE: begin
                if (in == 1'b0)  // Detect start bit
                    next_state = START;
            end
            START: begin
                next_state = DATA;
            end
            DATA: begin
                if (bit_count == 3'd7)
                    next_state = STOP;
            end
            STOP: begin
                if (in == 1'b1)  // Check stop bit
                    next_state = DONE;
                else
                    next_state = IDLE;
            end
            DONE: begin
                next_state = IDLE;  // Go back to IDLE after completing byte reception
            end
        endcase
    end

    // Output logic and shift register
    always_ff @(posedge clk or posedge reset) begin
        if (reset) begin
            bit_count <= 3'd0;
            shift_reg <= 8'd0;
        end
        else begin
            done <= 1'b0;
            case (state)
                START: begin
                    bit_count <= 3'd0;
                end
                DATA: begin
                    shift_reg <= {in, shift_reg[7:1]};  // Shift in the data bit
                    bit_count <= bit_count + 1'b1;
                end
                STOP: begin
                    if (in == 1'b1)  // Stop bit is correct
                        done <= 1'b1;  // Indicate a valid byte is received
                end
                DONE: begin
                    done <= 1'b1;
                end
            endcase
        end
    end

    assign out_byte = (done) ? shift_reg : 8'dx;  // Output valid byte only when done

endmodule"
N/A,N/A,-1,24,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    // State and next-state logic
    state_t state, next_state;

    // Bit counter for data bits
    logic [2:0] bit_count;

    // Shift register for assembling the data byte
    logic [7:0] shift_reg;

    // Combinational logic to update next state
    always_comb begin
        case (state)
            IDLE: next_state = in ? IDLE : START; // Wait for start bit (0)
            START: next_state = DATA;             // Start bit detected, shift to DATA state
            DATA: next_state = (bit_count == 3'd7) ? STOP : DATA; // Shift until 8 bits received
            STOP: next_state = in ? IDLE : START; // If stop bit (1), return to IDLE; else START
            default: next_state = IDLE;
        endcase
    end

    // Sequential logic to update state and perform actions
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 3'd0;
            shift_reg <= 8'd0;
            done <= 1'b0;
        end else begin
            state <= next_state;

            case (state)
                IDLE: begin
                    done <= 1'b0;
                end

                DATA: begin
                    bit_count <= bit_count + 1'b1;
                    shift_reg <= {in, shift_reg[7:1]}; // Shift in the least significant bit first
                end

                STOP: begin
                    done <= 1'b1;  // Indicate a valid output byte
                    bit_count <= 3'd0;
                end
            endcase
        end
    end

    // Output logic
    assign out_byte = shift_reg;  // Parallel output of the data byte

endmodule"
N/A,N/A,-1,25,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum reg [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    // State and next-state variables
    state_t state, next_state;

    // Bit counter and shift register
    reg [2:0] bit_count;
    reg [7:0] shift_reg;

    // Output signals
    reg done_reg;

    // Combinational logic to determine next state
    always @(*) begin
        case (state)
            IDLE: next_state = (in == 1'b0) ? START : IDLE;
            START: next_state = DATA;
            DATA: next_state = (bit_count == 3'd7) ? STOP : DATA;
            STOP: next_state = (in == 1'b1) ? IDLE : STOP;
            default: next_state = IDLE;
        endcase
    end

    // Sequential logic for state transition and output logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            shift_reg <= 8'b0;
            bit_count <= 3'b0;
            done_reg <= 1'b0;
        end else begin
            state <= next_state;
            
            case (state)
                START: begin
                    bit_count <= 3'b0;
                    done_reg <= 1'b0;
                end

                DATA: begin
                    shift_reg <= {in, shift_reg[7:1]};
                    bit_count <= bit_count + 3'b1;
                end

                STOP: begin
                    done_reg <= (in == 1'b1);
                end
            endcase
        end
    end

    // Assign outputs
    assign out_byte = shift_reg;
    assign done = done_reg;

endmodule"
N/A,N/A,-1,26,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    // State and next-state logic
    state_t state, next_state;

    // Bit counter for data bits
    logic [2:0] bit_counter;

    // Shift register for assembling the data byte
    logic [7:0] shift_reg;

    // Combinational logic to determine next state
    always_comb begin
        case (state)
            IDLE: next_state = in ? IDLE : START; // Wait for start bit (0)
            START: next_state = DATA;             // Start bit detected, shift to DATA state
            DATA: next_state = (bit_counter == 3'd7) ? STOP : DATA; // Shift in 8 data bits
            STOP: next_state = in ? IDLE : DATA;  // Check stop bit, if correct move to IDLE
            default: next_state = IDLE;           // Default state
        endcase
    end

    // State transition and output logic
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_counter <= 3'd0;
            shift_reg <= 8'd0;
            done <= 1'b0;
        end else begin
            state <= next_state;

            case (state)
                IDLE: begin
                    bit_counter <= 3'd0;
                    shift_reg <= 8'd0;
                    done <= 1'b0;
                end
                START: begin
                    shift_reg <= 8'd0;
                    done <= 1'b0;
                end
                DATA: begin
                    shift_reg <= {in, shift_reg[7:1]}; // Shift in data bits
                    bit_counter <= bit_counter + 1;
                end
                STOP: begin
                    done <= (in == 1'b1); // Done only if stop bit is 1
                end
            endcase
        end
    end

    // Assign output byte when done
    assign out_byte = done ? shift_reg : 8'bx;

endmodule"
N/A,N/A,-1,27,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    // State and next-state logic
    state_t state, next_state;

    // Bit counter for data bits
    logic [2:0] bit_counter;

    // Shift register for assembling the data byte
    logic [7:0] shift_reg;

    // Combinational logic to determine next state
    always_comb begin
        case (state)
            IDLE: next_state = in ? IDLE : START; // Wait for start bit (0)
            START: next_state = DATA;             // Start bit detected, shift to DATA state
            DATA: next_state = (bit_counter == 3'd7) ? STOP : DATA; // Shift until 8 bits received
            STOP: next_state = in ? IDLE : START; // Validate stop bit (1), return to IDLE if valid
            default: next_state = IDLE;           // Explicit default state
        endcase
    end

    // Sequential logic to update state and output signals
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_counter <= 3'd0;
            shift_reg <= 8'h00;
        end else begin
            state <= next_state;

            case (state)
                DATA: begin
                    shift_reg <= {in, shift_reg[7:1]}; // Shift in the LSB first
                    bit_counter <= bit_counter + 1;
                end
                STOP: begin
                    bit_counter <= 3'd0;
                end
                default: ;
            endcase
        end
    end

    // Output logic for done signal and out_byte
    assign done = (state == STOP) && in;
    assign out_byte = done ? shift_reg : 8'bx;

endmodule"
N/A,N/A,-1,28,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    // State and next-state logic
    state_t state, next_state;

    // Bit counter for data bits
    logic [2:0] bit_count;

    // Shift register for assembling the data byte
    logic [7:0] shift_reg;

    // Combinational logic to determine next state
    always_comb begin
        case (state)
            IDLE: next_state = in ? IDLE : START; // Wait for start bit (0)
            START: next_state = DATA;             // Start bit detected, shift to DATA state
            DATA: next_state = (bit_count == 3'd7) ? STOP : DATA; // Shift until 8 bits received
            STOP: next_state = in ? IDLE : START; // Validate stop bit (1), return to IDLE if valid
            default: next_state = IDLE;           // Explicit default state
        endcase
    end

    // Sequential logic to update state and output signals
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 3'd0;
            shift_reg <= 8'h00;
        end else begin
            state <= next_state;

            case (state)
                IDLE: begin
                    bit_count <= 3'd0;
                    shift_reg <= 8'h00;
                end
                START: begin
                    // Do nothing - just transition state
                end
                DATA: begin
                    shift_reg <= {in, shift_reg[7:1]}; // Shift in the new bit
                    bit_count <= bit_count + 1'b1;
                end
                STOP: begin
                    if (in) begin  // Stop bit must be 1
                        out_byte <= shift_reg;  // Capture the byte
                    end
                    bit_count <= 3'd0;  // Reset bit counter
                end
            endcase
        end
    end

    // Output logic
    assign done = (state == STOP) && in;   // Byte is valid after STOP state with valid stop bit

endmodule"
N/A,N/A,-1,29,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    // State and next-state logic
    state_t state, next_state;

    // Bit counter for data bits
    logic [2:0] bit_counter;

    // Shift register for assembling the data byte
    logic [7:0] shift_reg;

    // Combinational logic to determine next state
    always_comb begin
        case (state)
            IDLE: next_state = in ? IDLE : START; // Wait for start bit (0)
            START: next_state = DATA;             // Start bit detected, shift to DATA state
            DATA: next_state = (bit_counter == 3'd7) ? STOP : DATA; // Shift until 8 bits received
            STOP: next_state = in ? IDLE : START; // If stop bit (1), return to IDLE; else START
            default: next_state = IDLE;
        endcase
    end

    // Sequential logic to update state and perform actions
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_counter <= 3'd0;
            shift_reg <= 8'd0;
            done <= 1'b0;
        end else begin
            state <= next_state;

            case (state)
                IDLE: begin
                    done <= 1'b0;
                end

                DATA: begin
                    bit_counter <= bit_counter + 1'b1;
                    shift_reg <= {in, shift_reg[7:1]}; // Shift in the least significant bit first
                end

                STOP: begin
                    done <= 1'b1;  // Indicate that we have received a full valid byte
                end

                default: begin
                    // Reset default actions if needed
                end
            endcase

            if (state == STOP) begin
                bit_counter <= 3'd0;   // Reset bit counter after STOP state
            end
        end
    end

    // Output logic
    assign out_byte = (done) ? shift_reg : 8'bx; // Output valid byte when done
endmodule"
N/A,N/A,-1,30,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    // State and next-state logic
    state_t state, next_state;

    // Bit counter for data bits
    logic [2:0] bit_counter;

    // Shift register for assembling the data byte
    logic [7:0] shift_reg;

    // Combinational logic to update next state
    always_comb begin
        case (state)
            IDLE: next_state = in ? IDLE : START; // Wait for start bit (0)
            START: next_state = DATA;             // Start bit detected, shift to DATA state
            DATA: next_state = (bit_counter == 3'd7) ? STOP : DATA; // Shift until 8 bits received
            STOP: next_state = in ? IDLE : START; // If stop bit (1), return to IDLE; else START
            default: next_state = IDLE;
        endcase
    end

    // Sequential logic to update state and perform actions
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_counter <= 3'd0;
            shift_reg <= 8'd0;
            done <= 1'b0;
        end else begin
            state <= next_state;

            case (state)
                IDLE: begin
                    done <= 1'b0;
                end

                DATA: begin
                    bit_counter <= bit_counter + 1'b1;
                    shift_reg <= {in, shift_reg[7:1]}; // Shift in the least significant bit first
                end

                STOP: begin
                    done <= 1'b1;  // Indicate a valid output byte
                    bit_counter <= 3'd0;
                end
            endcase

            if (state == STOP && next_state == IDLE) begin
                // Capture the output byte when done is asserted
                out_byte <= shift_reg;
            end
        end
    end
endmodule"
N/A,N/A,-1,31,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    // State and next-state logic
    state_t state, next_state;

    // Bit counter for data bits
    logic [2:0] bit_counter;

    // Shift register for assembling the data byte
    logic [7:0] shift_reg;

    // Combinational logic to determine next state
    always_comb begin
        case (state)
            IDLE: next_state = in ? IDLE : START; // Wait for start bit (0)
            START: next_state = DATA;             // Start bit detected, shift to DATA state
            DATA: next_state = (bit_counter == 3'd7) ? STOP : DATA; // Shift until 8 bits received
            STOP: next_state = in ? IDLE : DATA;  // Check stop bit, if correct move to IDLE
            default: next_state = IDLE;           // Default state
        endcase
    end

    // State transition and output logic
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_counter <= 3'd0;
            shift_reg <= 8'd0;
            done <= 1'b0;
        end else begin
            state <= next_state;

            case (state)
                IDLE: begin
                    bit_counter <= 3'd0;
                    shift_reg <= 8'd0;
                    done <= 1'b0;
                end
                START: begin
                    shift_reg <= 8'd0;
                    done <= 1'b0;
                end
                DATA: begin
                    shift_reg <= {in, shift_reg[7:1]}; // Shift in data bits
                    bit_counter <= bit_counter + 1;
                end
                STOP: begin
                    done <= (in == 1'b1); // Done only if stop bit is 1
                end
            endcase
        end
    end

    // Assign output byte when done
    assign out_byte = done ? shift_reg : 8'bx;

endmodule"
N/A,N/A,-1,32,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    // State and next-state logic
    state_t state, next_state;

    // Bit counter for data bits
    logic [2:0] bit_counter;

    // Shift register for assembling the data byte
    logic [7:0] shift_reg;

    // Combinational logic to update next state
    always_comb begin
        case (state)
            IDLE: next_state = in ? IDLE : START; // Wait for start bit (0)
            START: next_state = DATA;             // Start bit detected, shift to DATA state
            DATA: next_state = (bit_counter == 3'd7) ? STOP : DATA; // Shift until 8 bits received
            STOP: next_state = in ? IDLE : DATA;  // Check stop bit, if correct move to IDLE
            default: next_state = IDLE;           // Default state
        endcase
    end

    // State transition and output logic
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_counter <= 3'd0;
            shift_reg <= 8'd0;
            done <= 1'b0;
        end else begin
            state <= next_state;

            case (state)
                IDLE: begin
                    bit_counter <= 3'd0;
                    shift_reg <= 8'd0;
                    done <= 1'b0;
                end
                START: begin
                    shift_reg <= 8'd0;
                    done <= 1'b0;
                end
                DATA: begin
                    shift_reg <= {in, shift_reg[7:1]}; // Shift in data bits
                    bit_counter <= bit_counter + 1;
                end
                STOP: begin
                    done <= (in == 1'b1); // Done only if stop bit is 1
                end
            endcase
        end
    end

    // Assign output byte when done
    assign out_byte = done ? shift_reg : 8'bx;

endmodule"
N/A,N/A,-1,33,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    // State and next-state logic
    state_t state, next_state;

    // Bit counter for data bits
    logic [2:0] bit_counter;

    // Shift register for assembling the data byte
    logic [7:0] shift_reg;

    // Combinational logic to determine next state
    always_comb begin
        case (state)
            IDLE: next_state = in ? IDLE : START; // Wait for start bit (0)
            START: next_state = DATA;             // Start bit detected, shift to DATA state
            DATA: next_state = (bit_counter == 3'd7) ? STOP : DATA; // Shift until 8 bits received
            STOP: next_state = in ? IDLE : DATA;  // Check stop bit, if correct move to IDLE
            default: next_state = IDLE;           // Default state
        endcase
    end

    // State transition and output logic
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_counter <= 3'd0;
            shift_reg <= 8'd0;
            done <= 1'b0;
        end else begin
            state <= next_state;

            case (state)
                IDLE: begin
                    bit_counter <= 3'd0;
                    done <= 1'b0;
                end
                START: begin
                    // No action needed on start
                end
                DATA: begin
                    shift_reg <= {in, shift_reg[7:1]}; // Shift in the incoming bit
                    bit_counter <= bit_counter + 1;
                end
                STOP: begin
                    if (in) begin
                        done <= 1'b1; // Stop bit correct, done with byte reception
                        out_byte <= shift_reg; // Parallel load of the data byte
                    end else begin
                        done <= 1'b0; // Incorrect stop bit, output is not valid
                    end
                end
            endcase
        end
    end
endmodule"
N/A,N/A,-1,34,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    // State and next-state logic
    state_t state, next_state;

    // Bit counter for data bits
    logic [2:0] bit_counter;

    // Shift register for assembling the data byte
    logic [7:0] shift_reg;

    // Combinational logic to update next state
    always_comb begin
        case (state)
            IDLE: next_state = in ? IDLE : START; // Wait for start bit (0)
            START: next_state = DATA;             // Start bit detected, shift to DATA state
            DATA: next_state = (bit_counter == 3'd7) ? STOP : DATA; // Shift until 8 bits received
            STOP: next_state = in ? IDLE : START; // If stop bit (1), return to IDLE; else START
            default: next_state = IDLE;
        endcase
    end

    // Sequential logic to update state and perform actions
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_counter <= 3'd0;
            shift_reg <= 8'd0;
            done <= 1'b0;
        end else begin
            state <= next_state;

            case (state)
                IDLE: begin
                    done <= 1'b0;
                end

                DATA: begin
                    bit_counter <= bit_counter + 1'b1;
                    shift_reg <= {in, shift_reg[7:1]}; // Shift in the least significant bit first
                end

                STOP: begin
                    done <= 1'b1;  // Indicate a valid output byte
                    bit_counter <= 3'd0;
                end
            endcase
        end
    end

    // Output logic
    assign out_byte = shift_reg;  // Parallel output of the data byte

endmodule"
N/A,N/A,-1,35,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    // State and next-state logic
    state_t state, next_state;

    // Bit counter for data bits
    logic [2:0] bit_counter;

    // Shift register for assembling the data byte
    logic [7:0] shift_reg;

    // Combinational logic to update next state
    always_comb begin
        case (state)
            IDLE: next_state = in ? IDLE : START; // Wait for start bit (0)
            START: next_state = DATA;             // Start bit detected, shift to DATA state
            DATA: next_state = (bit_counter == 3'd7) ? STOP : DATA; // Shift until 8 bits received
            STOP: next_state = in ? IDLE : START; // If stop bit (1), return to IDLE; else START
            default: next_state = IDLE;
        endcase
    end

    // Sequential logic to update state and perform actions
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_counter <= 3'd0;
            shift_reg <= 8'd0;
            done <= 1'b0;
        end else begin
            state <= next_state;

            case (state)
                IDLE: begin
                    done <= 1'b0;
                end

                DATA: begin
                    bit_counter <= bit_counter + 1'b1;
                    shift_reg <= {in, shift_reg[7:1]}; // Shift in the least significant bit first
                end

                STOP: begin
                    done <= 1'b1;  // Indicate that we have received a full valid byte
                end

                default: begin
                    // Reset default actions if needed
                end
            endcase

            if (state == STOP) begin
                bit_counter <= 3'd0;   // Reset bit counter after STOP state
            end
        end
    end

    assign out_byte = shift_reg; // Output the latched byte
endmodule"
N/A,N/A,-1,36,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum reg [2:0] {
        IDLE,
        START,
        DATA,
        STOP,
        WAIT_FOR_STOP
    } state_t;
    
    state_t state, next_state;
    reg [7:0] shift_reg;
    reg [2:0] bit_count;

    // FSM state transition
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
        end else begin
            state <= next_state;
        end
    end
    
    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 0)
                    next_state = START;
                else
                    next_state = IDLE;
            end
            START: begin
                next_state = DATA;
            end
            DATA: begin
                if (bit_count == 3'd7)
                    next_state = STOP;
                else
                    next_state = DATA;
            end
            STOP: begin
                if (in == 1)
                    next_state = IDLE;
                else
                    next_state = WAIT_FOR_STOP;
            end
            WAIT_FOR_STOP: begin
                if (in == 1)
                    next_state = IDLE;
                else
                    next_state = WAIT_FOR_STOP;
            end
            default: next_state = IDLE;
        endcase
    end

    // Output logic
    always @(posedge clk) begin
        if (reset) begin
            shift_reg <= 8'b0;
            bit_count <= 3'b0;
        end else begin
            case (state)
                START: begin
                    bit_count <= 3'b0;
                end
                DATA: begin
                    shift_reg <= {in, shift_reg[7:1]};
                    bit_count <= bit_count + 1;
                end
                default: begin
                    // No change to shift_reg and bit_count
                end
            endcase
        end
    end

    assign done = (state == STOP && in == 1);
    assign out_byte = done ? shift_reg : 8'bx;

endmodule"
N/A,N/A,-1,37,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    // State and next-state logic
    state_t state, next_state;

    // Bit counter for data bits
    logic [2:0] bit_counter;

    // Shift register for assembling the data byte
    logic [7:0] shift_reg;

    // Combinational logic to update next state
    always_comb begin
        case (state)
            IDLE: next_state = in ? IDLE : START; // Wait for start bit (0)
            START: next_state = DATA;             // Start bit detected, shift to DATA state
            DATA: next_state = (bit_counter == 3'd7) ? STOP : DATA; // Shift until 8 bits received
            STOP: next_state = in ? IDLE : START; // If stop bit (1), return to IDLE; else START
            default: next_state = IDLE;
        endcase
    end

    // Sequential logic to update state and perform actions
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_counter <= 3'd0;
            shift_reg <= 8'd0;
            done <= 1'b0;
        end else begin
            state <= next_state;

            case (state)
                IDLE: begin
                    done <= 1'b0;
                end

                DATA: begin
                    bit_counter <= bit_counter + 1'b1;
                    shift_reg <= {in, shift_reg[7:1]}; // Shift in the least significant bit first
                end

                STOP: begin
                    done <= 1'b1;  // Indicate that we have received a full valid byte
                end

                default: begin
                    // Reset default actions if needed
                end
            endcase

            if (state == STOP) begin
                bit_counter <= 3'd0;   // Reset bit counter after STOP state
            end
        end
    end

    // Output logic
    assign out_byte = (done) ? shift_reg : 8'bx; // Output valid byte when done
endmodule"
N/A,N/A,-1,38,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    // State and next-state logic
    state_t state, next_state;

    // Bit counter for data bits
    logic [2:0] bit_counter;

    // Shift register for assembling the data byte
    logic [7:0] shift_reg;

    // Combinational logic to update next state
    always_comb begin
        case (state)
            IDLE: next_state = in ? IDLE : START; // Wait for start bit (0)
            START: next_state = DATA;             // Start bit detected, shift to DATA state
            DATA: next_state = (bit_counter == 3'd7) ? STOP : DATA; // Shift until 8 bits received
            STOP: next_state = in ? IDLE : DATA;  // Check stop bit, if correct move to IDLE
            default: next_state = IDLE;           // Default state
        endcase
    end

    // Sequential logic for state transitions
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_counter <= 3'd0;
        end else begin
            state <= next_state;
            if (state == DATA) begin
                bit_counter <= bit_counter + 3'd1;
                shift_reg <= {in, shift_reg[7:1]}; // Shift in data bits
            end
            if (state == STOP) begin
                bit_counter <= 3'd0;
            end
        end
    end

    // Output logic
    assign done = (state == STOP) && in; // Done when in STOP state with correct stop bit
    assign out_byte = done ? shift_reg : 8'dx; // Output valid data when done

endmodule"
N/A,N/A,-1,39,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    // State and next-state logic
    state_t state, next_state;

    // Bit counter for data bits
    logic [2:0] bit_count;

    // Shift register for assembling the data byte
    logic [7:0] shift_reg;

    // Combinational logic to determine next state
    always_comb begin
        case (state)
            IDLE: next_state = in ? IDLE : START; // Wait for start bit (0)
            START: next_state = DATA;             // Start bit detected, shift to DATA state
            DATA: next_state = (bit_count == 3'd7) ? STOP : DATA; // Shift in 8 data bits
            STOP: next_state = in ? IDLE : START; // If stop bit (1), return to IDLE; else, look for new start
            default: next_state = IDLE;
        endcase
    end

    // Sequential logic for state transitions and bit counting
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 3'd0;
            shift_reg <= 8'b0;
        end else begin
            state <= next_state;
            if (state == DATA) begin
                shift_reg <= {in, shift_reg[7:1]}; // Shift data in, LSB first
                bit_count <= bit_count + 3'd1;
            end
            else if (state == STOP && !in) begin
                // Waiting for stop condition to detect start bit
                bit_count <= 3'd0;
            end
        end
    end

    // Output logic
    assign out_byte = shift_reg;
    assign done = (state == STOP) && in; // done when in stop state and bit is high

endmodule"
N/A,N/A,-1,40,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    // State and next-state logic
    state_t state, next_state;

    // Bit counter for data bits
    logic [2:0] bit_count;

    // Shift register for incoming data bits
    logic [7:0] shift_reg;

    // Datapath
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 3'd0;
            shift_reg <= 8'b0;
        end else begin
            state <= next_state;
            // Shift in the incoming bit when in DATA state
            if (state == DATA) begin
                shift_reg <= {in, shift_reg[7:1]};
                bit_count <= bit_count + 1;
            end else if (state != DATA) begin
                // Reset bit counter when not in DATA state
                bit_count <= 3'd0;
            end
        end
    end

    // Next-state logic
    always_comb begin
        next_state = state; // Default state stays the same
        done = 0; // Default done is 0

        case (state)
            IDLE: begin
                if (in == 0)
                    next_state = START;
            end

            START: begin
                next_state = DATA;
            end

            DATA: begin
                if (bit_count == 3'd7) // All 8 data bits received
                    next_state = STOP;
            end

            STOP: begin
                if (in == 1) begin
                    next_state = IDLE;
                    done = 1; // Indicate that byte is fully received
                end
            end
        endcase
    end

    // Output logic
    assign out_byte = shift_reg;

endmodule"
N/A,N/A,-1,41,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum reg [2:0] {
        IDLE,
        START,
        DATA,
        STOP,
        DONE
    } state_t;
    
    state_t state, next_state;
    reg [7:0] data_shift_reg;
    reg [2:0] bit_counter;
    
    // FSM state transition
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
        end else begin
            state <= next_state;
        end
    end
    
    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 0)
                    next_state = START;
                else
                    next_state = IDLE;
            end
            
            START: begin
                next_state = DATA;
            end

            DATA: begin
                if (bit_counter == 3'd7)
                    next_state = STOP;
                else
                    next_state = DATA;
            end

            STOP: begin
                if (in == 1)
                    next_state = DONE;
                else
                    next_state = START;
            end

            DONE: begin
                next_state = IDLE;
            end
            
            default: begin
                next_state = IDLE;
            end
        endcase
    end

    // Data shifting logic
    always @(posedge clk) begin
        if (reset) begin
            data_shift_reg <= 8'd0;
            bit_counter <= 3'd0;
        end else if (state == DATA) begin
            data_shift_reg <= {in, data_shift_reg[7:1]};
            bit_counter <= bit_counter + 3'd1;
        end else if (state != DATA) begin
            bit_counter <= 3'd0;
        end
    end

    // Output logic
    assign out_byte = data_shift_reg;
    assign done = (state == DONE);

endmodule"
N/A,N/A,-1,42,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    // State and next-state logic
    state_t state, next_state;

    // Bit counter for data bits
    logic [2:0] bit_count;

    // Shift register for assembling the data byte
    logic [7:0] shift_reg;

    // Combinational logic to determine next state
    always_comb begin
        case (state)
            IDLE: next_state = in ? IDLE : START; // Wait for start bit (0)
            START: next_state = DATA;             // Start bit detected, shift to DATA state
            DATA: next_state = (bit_count == 3'd7) ? STOP : DATA; // Shift until 8 bits received
            STOP: next_state = in ? IDLE : START; // If stop bit (1), return to IDLE; else START
            default: next_state = IDLE;
        endcase
    end

    // Sequential logic to update state and perform actions
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 3'd0;
            shift_reg <= 8'd0;
            done <= 1'b0;
        end else begin
            state <= next_state;

            case (state)
                IDLE: begin
                    bit_count <= 3'd0;
                    done <= 1'b0;
                end
                START: begin
                    // Prepare for data collection
                end
                DATA: begin
                    // Shift in data bits
                    shift_reg <= {in, shift_reg[7:1]};
                    bit_count <= bit_count + 3'd1;
                end
                STOP: begin
                    // Check for stop bit
                    if (in) begin
                        // Valid byte received
                        done <= 1'b1;
                        out_byte <= shift_reg;
                    end
                end
            endcase
        end
    end
endmodule"
N/A,N/A,-1,43,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    // State and next-state logic
    state_t state, next_state;

    // Bit counter for data bits
    logic [2:0] bit_counter;

    // Shift register for assembling the data byte
    logic [7:0] shift_reg;

    // Combinational logic to update next state
    always_comb begin
        case (state)
            IDLE: next_state = in ? IDLE : START; // Wait for start bit (0)
            START: next_state = DATA;             // Start bit detected, shift to DATA state
            DATA: next_state = (bit_counter == 3'd7) ? STOP : DATA; // Shift until 8 bits received
            STOP: next_state = in ? IDLE : START; // If stop bit (1), return to IDLE; else START
            default: next_state = IDLE;
        endcase
    end

    // Sequential logic to update state and perform actions
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_counter <= 3'd0;
            shift_reg <= 8'd0;
            done <= 1'b0;
        end else begin
            state <= next_state;

            case (state)
                IDLE: begin
                    done <= 1'b0;
                end
                DATA: begin
                    bit_counter <= bit_counter + 1'b1;
                    shift_reg <= {in, shift_reg[7:1]}; // Shift in the least significant bit first
                end
                STOP: begin
                    done <= 1'b1;  // Indicate a valid output byte
                    bit_counter <= 3'd0;
                end
            endcase

            if (state == STOP && next_state == IDLE) begin
                done <= 1'b0; // Clear done flag except for during state transition
            end
        end
    end

    // Assign output
    assign out_byte = shift_reg; // Output the latched byte
endmodule"
N/A,N/A,-1,44,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    // State and next-state logic
    state_t state, next_state;

    // Bit counter for data bits
    logic [2:0] bit_counter;

    // Shift register for assembling the data byte
    logic [7:0] shift_reg;

    // Combinational logic to update next state
    always_comb begin
        case (state)
            IDLE: next_state = in ? IDLE : START; // Wait for start bit (0)
            START: next_state = DATA;             // Start bit detected, shift to DATA state
            DATA: next_state = (bit_counter == 3'd7) ? STOP : DATA; // Shift until 8 bits received
            STOP: next_state = in ? IDLE : START; // If stop bit (1), return to IDLE; else START
            default: next_state = IDLE;
        endcase
    end

    // Sequential logic to update state and perform actions
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_counter <= 3'd0;
            shift_reg <= 8'd0;
            done <= 1'b0;
        end else begin
            state <= next_state;

            case (state)
                IDLE: begin
                    done <= 1'b0;
                end

                DATA: begin
                    bit_counter <= bit_counter + 1'b1;
                    shift_reg <= {in, shift_reg[7:1]}; // Shift in the least significant bit first
                end

                STOP: begin
                    done <= 1'b1;  // Indicate a valid output byte
                    bit_counter <= 3'd0;
                end
            endcase

            if (state == STOP && next_state == IDLE) begin
                // Capture the output byte when done is asserted
                out_byte <= shift_reg;
            end
        end
    end
endmodule"
N/A,N/A,-1,45,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    // State and next-state logic
    state_t state, next_state;

    // Bit counter for data bits
    logic [2:0] bit_counter;

    // Shift register for assembling the data byte
    logic [7:0] shift_reg;

    // Combinational logic to update next state
    always_comb begin
        case (state)
            IDLE: next_state = in ? IDLE : START; // Wait for start bit (0)
            START: next_state = DATA;             // Start bit detected, shift to DATA state
            DATA: next_state = (bit_counter == 3'd7) ? STOP : DATA; // Shift until 8 bits received
            STOP: next_state = in ? IDLE : START; // If stop bit (1), return to IDLE; else START
            default: next_state = IDLE;
        endcase
    end

    // Sequential logic to update state and perform actions
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_counter <= 3'd0;
            shift_reg <= 8'd0;
            done <= 1'b0;
        end else begin
            state <= next_state;

            case (state)
                IDLE: begin
                    done <= 1'b0;
                end

                DATA: begin
                    bit_counter <= bit_counter + 1'b1;
                    shift_reg <= {in, shift_reg[7:1]}; // Shift in the least significant bit first
                end

                STOP: begin
                    done <= 1'b1;  // Indicate that we have received a full valid byte
                end

                default: ;
            endcase

            if (state == STOP && in) begin
                bit_counter <= 3'd0;  // Reset the counter only when a valid stop bit is detected
            end
        end
    end

    // Assign output
    assign out_byte = (done) ? shift_reg : 8'bz; // Byte is valid only when done is 1

endmodule"
N/A,N/A,-1,46,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    // State and next-state logic
    state_t state, next_state;

    // Bit counter for data bits
    logic [2:0] bit_counter;

    // Shift register for assembling the data byte
    logic [7:0] shift_reg;

    // Combinational logic to update next state
    always_comb begin
        case (state)
            IDLE: next_state = in ? IDLE : START; // Wait for start bit (0)
            START: next_state = DATA;             // Start bit detected, shift to DATA state
            DATA: next_state = (bit_counter == 3'd7) ? STOP : DATA; // Shift until 8 bits received
            STOP: next_state = in ? IDLE : START; // If stop bit (1), return to IDLE; else START
            default: next_state = IDLE;
        endcase
    end

    // Sequential logic to update state and perform bit shifting
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_counter <= 3'd0;
            shift_reg <= 8'd0;
        end else begin
            state <= next_state;

            if (state == DATA) begin
                shift_reg <= {in, shift_reg[7:1]}; // Shift in LSB-first
                bit_counter <= bit_counter + 1;
            end

            if (state == STOP && next_state == IDLE) begin
                bit_counter <= 3'd0; // Reset the bit counter after completing byte
            end
        end
    end

    // Output logic
    assign out_byte = (state == STOP) ? shift_reg : 8'bx; // Valid when STOP state
    assign done = (state == STOP);

endmodule"
N/A,N/A,-1,47,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum reg [2:0] {
        IDLE,
        START,
        DATA,
        STOP,
        WAIT_FOR_STOP
    } state_t;
    
    state_t state, next_state;
    reg [7:0] shift_reg;
    reg [2:0] bit_count;

    // FSM state transition
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
        end else begin
            state <= next_state;
        end
    end
    
    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 0)
                    next_state = START;
                else
                    next_state = IDLE;
            end
            START: begin
                next_state = DATA;
            end
            DATA: begin
                if (bit_count == 3'd7)
                    next_state = STOP;
                else
                    next_state = DATA;
            end
            STOP: begin
                if (in == 1)
                    next_state = IDLE;
                else
                    next_state = WAIT_FOR_STOP;
            end
            WAIT_FOR_STOP: begin
                if (in == 1)
                    next_state = IDLE;
                else
                    next_state = WAIT_FOR_STOP;
            end
            default: next_state = IDLE;
        endcase
    end

    // Output logic
    always @(posedge clk) begin
        if (reset) begin
            shift_reg <= 8'b0;
            bit_count <= 3'b0;
        end else begin
            case (state)
                START: begin
                    bit_count <= 3'b0;
                end
                DATA: begin
                    shift_reg <= {in, shift_reg[7:1]};
                    bit_count <= bit_count + 1;
                end
                default: begin
                    // No operations for other states
                end
            endcase
        end
    end

    assign out_byte = (state == STOP) ? shift_reg : 8'b0;
    assign done = (state == STOP);

endmodule"
N/A,N/A,-1,48,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    // State and next-state logic
    state_t state, next_state;

    // Bit counter for data bits
    logic [2:0] bit_counter;

    // Shift register for assembling the data byte
    logic [7:0] shift_reg;

    // Combinational logic to update next state
    always_comb begin
        case (state)
            IDLE: next_state = in ? IDLE : START; // Wait for start bit (0)
            START: next_state = DATA;             // Start bit detected, shift to DATA state
            DATA: next_state = (bit_counter == 3'd7) ? STOP : DATA; // Shift until 8 bits received
            STOP: next_state = in ? IDLE : START; // If stop bit (1), return to IDLE; else START
            default: next_state = IDLE;
        endcase
    end

    // Sequential logic to update state and perform actions
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_counter <= 3'd0;
            shift_reg <= 8'd0;
            done <= 1'b0;
        end else begin
            state <= next_state;

            case (state)
                IDLE: begin
                    bit_counter <= 3'd0;
                    done <= 1'b0;
                end
                START: begin
                    // Prepare for data collection
                end
                DATA: begin
                    // Shift data in
                    shift_reg <= {in, shift_reg[7:1]};
                    bit_counter <= bit_counter + 1;
                end
                STOP: begin
                    done <= in;  // Done if stop bit is correct
                end
            endcase

        end
    end

    // Output the received byte when done
    assign out_byte = done ? shift_reg : 8'dx; // Use don't-care when done is 0

endmodule"
N/A,N/A,-1,49,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    // State and next-state logic
    state_t state, next_state;

    // Bit counter for data bits
    logic [2:0] bit_count;

    // Shift register for assembling the data byte
    logic [7:0] shift_reg;

    // Combinational logic to update next state
    always_comb begin
        case (state)
            IDLE: next_state = in ? IDLE : START; // Wait for start bit (0)
            START: next_state = DATA;             // Start bit detected, shift to DATA state
            DATA: next_state = (bit_count == 3'd7) ? STOP : DATA; // Shift until 8 bits received
            STOP: next_state = in ? IDLE : START; // Validate stop bit (1), return to IDLE if valid
            default: next_state = IDLE;           // Explicit default state
        endcase
    end

    // Sequential logic to update state and output signals
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 3'd0;
            shift_reg <= 8'h00;
        end else begin
            state <= next_state;

            case (state)
                DATA: begin
                    shift_reg <= {in, shift_reg[7:1]}; // Shift in the LSB first
                    bit_count <= bit_count + 1'b1;
                end
                STOP: begin
                    if (in) begin
                        done <= 1'b1; // Set done, valid stop bit
                        out_byte <= shift_reg; // Latch the valid output byte
                    end
                    bit_count <= 3'd0; // Reset bit counter
                end
                default: begin
                    done <= 1'b0; // Done is 0 in IDLE and START
                end
            endcase
        end
    end

endmodule"
N/A,N/A,-1,50,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP,
        WAIT_FOR_STOP
    } state_t;

    state_t state, next_state;
    reg [7:0] shift_reg;
    reg [2:0] bit_counter;
    
    // FSM state transition
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
        end else begin
            state <= next_state;
        end
    end
    
    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 0)
                    next_state = START;
                else
                    next_state = IDLE;
            end
            START: begin
                next_state = DATA;
            end
            DATA: begin
                if (bit_counter == 3'd7)
                    next_state = STOP;
                else
                    next_state = DATA;
            end
            STOP: begin
                if (in == 1)
                    next_state = IDLE;
                else
                    next_state = WAIT_FOR_STOP;
            end
            WAIT_FOR_STOP: begin
                if (in == 1)
                    next_state = IDLE;
                else
                    next_state = WAIT_FOR_STOP;
            end
            default: next_state = IDLE;
        endcase
    end

    // Output logic
    always @(posedge clk) begin
        if (reset) begin
            shift_reg <= 8'b0;
            bit_counter <= 3'b0;
        end else begin
            case (state)
                START: begin
                    bit_counter <= 3'b0;
                end
                DATA: begin
                    shift_reg <= {in, shift_reg[7:1]};
                    bit_counter <= bit_counter + 1;
                end
                default: begin
                    // No operations for other states
                end
            endcase
        end
    end

    assign out_byte = (state == STOP) ? shift_reg : 8'b0;
    assign done = (state == STOP);

endmodule"
N/A,N/A,-1,51,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    // State and next-state logic
    state_t state, next_state;

    // Bit counter for data bits
    logic [2:0] bit_counter;

    // Shift register for assembling the data byte
    logic [7:0] shift_reg;

    // Combinational logic to update next state
    always_comb begin
        case (state)
            IDLE: next_state = in ? IDLE : START; // Wait for start bit (0)
            START: next_state = DATA;             // Start bit detected, shift to DATA
            DATA: next_state = (bit_counter == 3'b111) ? STOP : DATA; // Receive 8 data bits
            STOP: next_state = in ? IDLE : STOP;  // Verify stop bit (1)
            default: next_state = IDLE;
        endcase
    end

    // Sequential logic for state transitions
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_counter <= 3'b0;
            shift_reg <= 8'b0;
        end else begin
            state <= next_state;

            // State-specific behavior
            if (state == DATA) begin
                shift_reg <= {in, shift_reg[7:1]}; // Shift in LSB first
                bit_counter <= bit_counter + 1;
            end

            if (state == STOP && next_state == IDLE) begin
                shift_reg <= 8'b0;
                bit_counter <= 3'b0;
            end
        end
    end

    // Output assignments
    assign out_byte = shift_reg;
    assign done = (state == STOP) && (next_state == IDLE) && in;
endmodule"
N/A,N/A,-1,52,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    // State and next-state logic
    state_t state, next_state;

    // Bit counter for data bits
    logic [2:0] bit_counter;

    // Shift register for assembling the data byte
    logic [7:0] shift_reg;

    // Combinational logic to determine next state
    always_comb begin
        case (state)
            IDLE: next_state = in ? IDLE : START; // Wait for start bit (0)
            START: next_state = DATA;             // Start bit detected, shift to DATA state
            DATA: next_state = (bit_counter == 3'd7) ? STOP : DATA; // Shift until 8 bits received
            STOP: next_state = in ? IDLE : DATA;  // Check stop bit, if correct move to IDLE
            default: next_state = IDLE;           // Default state
        endcase
    end

    // State transition and output logic
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_counter <= 3'd0;
            shift_reg <= 8'd0;
            done <= 1'b0;
        end else begin
            state <= next_state;

            case (state)
                IDLE: begin
                    bit_counter <= 3'd0;
                    shift_reg <= 8'd0;
                    done <= 1'b0;
                end
                START: begin
                    shift_reg <= 8'd0;
                    done <= 1'b0;
                end
                DATA: begin
                    shift_reg <= {in, shift_reg[7:1]}; // Shift in the LSB first
                    bit_counter <= bit_counter + 3'd1;
                    done <= 1'b0;
                end
                STOP: begin
                    if (in) begin // Stop bit correct
                        out_byte <= shift_reg; // Output the received byte
                        done <= 1'b1;
                    end else begin
                        done <= 1'b0;
                    end
                end
            endcase
        end
    end

endmodule"
N/A,N/A,-1,53,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum reg [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    // State and next-state logic
    state_t state, next_state;

    // Bit counter for data bits
    reg [2:0] bit_counter;

    // Shift register for assembling the data byte
    reg [7:0] shift_reg;

    // Combinational logic to determine next state
    always @(*) begin
        case (state)
            IDLE: next_state = (in == 1'b0) ? START : IDLE;
            START: next_state = DATA;
            DATA: next_state = (bit_counter == 3'd7) ? STOP : DATA;
            STOP: next_state = (in == 1'b1) ? IDLE : STOP;
            default: next_state = IDLE;
        endcase
    end

    // Sequential logic for state transition and output logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            shift_reg <= 8'b0;
            bit_counter <= 3'b0;
            done <= 1'b0;
        end else begin
            state <= next_state;  // updates the current state to next state
            
            // Output logic
            case (state)
                START: begin
                    bit_counter <= 3'b0;         // Reset bit counter
                    done <= 1'b0;                // Output is invalid during START
                end
                
                DATA: begin
                    shift_reg <= {in, shift_reg[7:1]}; // Shift in data from the serial input
                    bit_counter <= bit_counter + 1;    // Increment bit counter
                end

                STOP: begin
                    if (in == 1'b1) done <= 1'b1; // Data valid when a stop bit is detected
                end

                default: begin
                    done <= 1'b0; // Default case: done is reset to 0 (for IDLE and error cases)
                end
            endcase
        end
    end

    // Output assignment
    assign out_byte = shift_reg;

endmodule"
N/A,N/A,-1,54,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    // State and next-state logic
    state_t state, next_state;

    // Bit counter for data bits
    logic [2:0] bit_count;

    // Shift register for assembling the data byte
    logic [7:0] shift_reg;

    // Combinational logic to update next state
    always_comb begin
        case (state)
            IDLE: next_state = in ? IDLE : START; // Wait for start bit (0)
            START: next_state = DATA;             // Start bit detected, shift to DATA state
            DATA: next_state = (bit_count == 3'd7) ? STOP : DATA; // Shift until 8 bits received
            STOP: next_state = in ? IDLE : DATA;  // Check stop bit, if correct move to IDLE
            default: next_state = IDLE;           // Default state
        endcase
    end

    // Sequential logic for state transitions and output assignments
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 3'd0;
            shift_reg <= 8'd0;
        end
        else begin
            state <= next_state;

            case (state)
                IDLE: begin
                    bit_count <= 3'd0;
                    shift_reg <= 8'd0;
                end
                START: begin
                    // Do nothing, just move to DATA
                end
                DATA: begin
                    shift_reg <= {in, shift_reg[7:1]}; // Shift in the incoming bit
                    bit_count <= bit_count + 1;
                end
                STOP: begin
                    // Check for stop bit was done in next state logic
                    // Ensure `done` goes high once full byte is received
                end
            endcase
        end
    end

    // Output logic
    assign out_byte = shift_reg;
    assign done = (state == STOP) && (in == 1); // Done goes high if stop bit is correct

endmodule"
N/A,N/A,-1,55,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    // State and next-state logic
    state_t state, next_state;

    // Bit counter for data bits
    logic [2:0] bit_count;

    // Shift register for assembling the data byte
    logic [7:0] shift_reg;

    // Combinational logic to determine next state
    always_comb begin
        case (state)
            IDLE: next_state = in ? IDLE : START; // Wait for start bit (0)
            START: next_state = DATA;             // Start bit detected, shift to DATA state
            DATA: next_state = (bit_count == 3'd7) ? STOP : DATA; // Shift until 8 bits received
            STOP: next_state = in ? IDLE : START; // Validate stop bit (1), return to IDLE if valid
            default: next_state = IDLE;           // Explicit default state
        endcase
    end

    // Sequential logic to update state and output signals
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 3'd0;
            shift_reg <= 8'd0;
        end else begin
            state <= next_state;

            case (state)
                DATA: begin
                    shift_reg <= {in, shift_reg[7:1]}; // Shift in the new bit
                    bit_count <= bit_count + 3'd1;
                end
                STOP: bit_count <= 3'd0; // Reset bit counter
                default: ;
            endcase
        end
    end

    // Output logic for done signal
    assign done = (state == STOP) && in;  // Done is high when stop bit is valid

    // Output logic for the data byte
    assign out_byte = (state == STOP) ? shift_reg : 8'dX; // Output the received byte when done

endmodule"
N/A,N/A,-1,56,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    // State and next-state logic
    state_t state, next_state;

    // Bit counter for data bits
    logic [2:0] bit_counter;

    // Shift register for assembling the data byte
    logic [7:0] shift_reg;

    // Combinational logic to update next state
    always_comb begin
        case (state)
            IDLE: next_state = in ? IDLE : START; // Wait for start bit (0)
            START: next_state = DATA;             // Start bit detected, shift to DATA state
            DATA: next_state = (bit_counter == 3'd7) ? STOP : DATA; // Shift until 8 bits received
            STOP: next_state = in ? IDLE : START; // If stop bit (1), return to IDLE; else START
            default: next_state = IDLE;
        endcase
    end

    // Sequential logic to update state and perform actions
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_counter <= 3'd0;
            shift_reg <= 8'd0;
            done <= 1'b0;
        end else begin
            state <= next_state;

            case (state)
                IDLE: begin
                    done <= 1'b0;
                end
                DATA: begin
                    bit_counter <= bit_counter + 1'b1;
                    shift_reg <= {in, shift_reg[7:1]}; // Shift in the least significant bit first
                end
                STOP: begin
                    done <= 1'b1;  // Indicate a valid output byte
                    bit_counter <= 3'd0;
                end
            endcase

            if (state == STOP && next_state == IDLE) begin
                // Capture the output byte when done is asserted
                out_byte <= shift_reg;
            end
        end
    end
endmodule"
N/A,N/A,-1,57,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    // State and next-state logic
    state_t state, next_state;

    // Bit counter for data bits
    logic [2:0] bit_counter;

    // Shift register for assembling the data byte
    logic [7:0] shift_reg;

    // Combinational logic to update next state
    always_comb begin
        case (state)
            IDLE: next_state = in ? IDLE : START; // Wait for start bit (0)
            START: next_state = DATA;             // Start bit detected, shift to DATA state
            DATA: next_state = (bit_counter == 3'd7) ? STOP : DATA; // Shift until 8 bits received
            STOP: next_state = in ? IDLE : DATA;  // Check stop bit, if correct move to IDLE
            default: next_state = IDLE;           // Default state
        endcase
    end

    // Sequential logic for state transitions and output assignments
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_counter <= 3'd0;
            shift_reg <= 8'd0;
        end
        else begin
            state <= next_state;

            case (state)
                IDLE: begin
                    bit_counter <= 3'd0;
                    shift_reg <= 8'd0;
                end
                START: begin
                    // Do nothing, just move to DATA
                end
                DATA: begin
                    shift_reg <= {in, shift_reg[7:1]}; // Shift in the incoming bit
                    bit_counter <= bit_counter + 3'd1;
                end
                STOP: begin
                    // In this state, check the stop bit
                    // If `in` is 1, a valid stop bit, we're done
                end
            endcase
        end
    end

    // Done signal logic: when in STOP and `in`=1, the transmission is done
    assign done = (state == STOP) && in;

    // Out byte is valid when done is 1
    assign out_byte = (done) ? shift_reg : 8'dx;

endmodule"
N/A,N/A,-1,58,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum reg [2:0] {
        IDLE,
        START,
        DATA,
        STOP,
        WAIT_FOR_STOP
    } state_t;
    
    state_t state, next_state;
    reg [7:0] shift_reg;
    reg [3:0] bit_count;

    // FSM state transition
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
        end else begin
            state <= next_state;
        end
    end
    
    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 0)
                    next_state = START;
                else
                    next_state = IDLE;
            end
            START: begin
                next_state = DATA;
            end
            DATA: begin
                if (bit_count == 8)
                    next_state = STOP;
                else
                    next_state = DATA;
            end
            STOP: begin
                if (in == 1)
                    next_state = IDLE;
                else
                    next_state = WAIT_FOR_STOP;
            end
            WAIT_FOR_STOP: begin
                if (in == 1)
                    next_state = IDLE;
                else
                    next_state = WAIT_FOR_STOP;
            end
        endcase
    end
    
    // Datapath
    always @(posedge clk) begin
        if (reset) begin
            bit_count <= 0;
            shift_reg <= 8'd0;
        end else begin
            case (state)
                IDLE: begin
                    bit_count <= 0;
                end
                START: begin
                    // Do nothing, just transition
                end
                DATA: begin
                    shift_reg <= {in, shift_reg[7:1]};
                    bit_count <= bit_count + 1;
                end
                STOP: begin
                    // Do nothing, checking stop bit
                end
                WAIT_FOR_STOP: begin
                    // Do nothing, waiting for stop bit
                end
            endcase
        end
    end

    // Output logic
    assign done = (state == STOP) && (in == 1);
    assign out_byte = (done) ? shift_reg : 8'd0;

endmodule"
N/A,N/A,-1,59,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    // State and next-state logic
    state_t state, next_state;

    // Bit counter for data bits
    logic [2:0] bit_counter;

    // Shift register for assembling the data byte
    logic [7:0] shift_reg;

    // Combinational logic to update next state
    always_comb begin
        case (state)
            IDLE: next_state = in ? IDLE : START; // Wait for start bit (0)
            START: next_state = DATA;             // Start bit detected, shift to DATA state
            DATA: next_state = (bit_counter == 3'd7) ? STOP : DATA; // Shift until 8 bits received
            STOP: next_state = in ? IDLE : START; // If stop bit (1), return to IDLE; else START
            default: next_state = IDLE;
        endcase
    end

    // Sequential logic to update state and perform actions
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_counter <= 3'd0;
            shift_reg <= 8'd0;
            done <= 1'b0;
        end else begin
            state <= next_state;

            case (state)
                IDLE: begin
                    done <= 1'b0;
                end
                DATA: begin
                    bit_counter <= bit_counter + 1'b1;
                    shift_reg <= {in, shift_reg[7:1]}; // Shift in the least significant bit first
                end
                STOP: begin
                    done <= 1'b1;  // Indicate a valid output byte
                    bit_counter <= 3'd0;
                end
            endcase

            if (state == STOP && next_state == IDLE) begin
                // Capture the output byte when done is asserted
                out_byte <= shift_reg;
            end
        end
    end
endmodule"
N/A,N/A,-1,60,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    // State and next-state logic
    state_t state, next_state;

    // Bit counter for data bits
    logic [2:0] bit_counter;

    // Shift register for assembling the data byte
    logic [7:0] shift_reg;

    // Combinational logic to update next state
    always_comb begin
        case (state)
            IDLE: next_state = in ? IDLE : START; // Wait for start bit (0)
            START: next_state = DATA;             // Start bit detected, shift to DATA state
            DATA: next_state = (bit_counter == 3'd7) ? STOP : DATA; // Shift until 8 bits received
            STOP: next_state = in ? IDLE : START; // If stop bit (1), return to IDLE; else START
            default: next_state = IDLE;
        endcase
    end

    // Sequential logic to update state and perform actions
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_counter <= 3'd0;
            shift_reg <= 8'd0;
            done <= 1'b0;
        end else begin
            state <= next_state;

            case (state)
                IDLE: begin
                    bit_counter <= 3'd0;
                    done <= 1'b0;
                end
                START: begin
                    done <= 1'b0;
                end
                DATA: begin
                    shift_reg <= {in, shift_reg[7:1]}; // Shift in the serial bit
                    bit_counter <= bit_counter + 1;
                end
                STOP: begin
                    if (in) begin
                        done <= 1'b1; // Valid stop bit detected
                    end else begin
                        done <= 1'b0; // Invalid stop bit
                    end
                end
            endcase
        end
    end

    // Output
    assign out_byte = shift_reg; // Output the latched byte
endmodule"
N/A,N/A,-1,61,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    // State and next-state logic
    state_t state, next_state;

    // Bit counter for data bits
    logic [2:0] bit_counter;

    // Shift register for assembling the data byte
    logic [7:0] shift_reg;

    // Combinational logic to update next state
    always_comb begin
        case (state)
            IDLE: next_state = in ? IDLE : START; // Wait for start bit (0)
            START: next_state = DATA;             // Start bit detected, shift to DATA state
            DATA: next_state = (bit_counter == 3'd7) ? STOP : DATA; // Shift until 8 bits received
            STOP: next_state = in ? IDLE : DATA;  // Check stop bit, if correct move to IDLE
            default: next_state = IDLE;           // Default state
        endcase
    end

    // State transition and output logic
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_counter <= 3'd0;
            shift_reg <= 8'd0;
            done <= 1'b0;
        end else begin
            state <= next_state;

            case (state)
                IDLE: begin
                    bit_counter <= 3'd0;
                    shift_reg <= 8'd0;
                    done <= 1'b0;
                end
                START: begin
                    shift_reg <= 8'd0;
                    done <= 1'b0;
                end
                DATA: begin
                    shift_reg <= {in, shift_reg[7:1]}; // Shift in the LSB received
                    bit_counter <= bit_counter + 3'd1;
                    done <= 1'b0;
                end
                STOP: begin
                    if (in) begin // Stop bit correct
                        done <= 1'b1; // Indicate a valid byte is received
                    end else begin
                        done <= 1'b0; // Stay in STOP until a stop is correctly detected
                    end
                end
            endcase
        end
    end

    // Output the byte when done
    assign out_byte = done ? shift_reg : 8'b0; // Output byte only when done
endmodule"
N/A,N/A,-1,62,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    // State and next-state logic
    state_t state, next_state;

    // Bit counter for data bits
    logic [2:0] bit_counter;

    // Shift register for assembling the data byte
    logic [7:0] shift_reg;

    // Combinational logic to update next state
    always_comb begin
        case (state)
            IDLE: next_state = in ? IDLE : START; // Wait for start bit (0)
            START: next_state = DATA;             // Start bit detected, shift to DATA state
            DATA: next_state = (bit_counter == 3'd7) ? STOP : DATA; // Shift until 8 bits received
            STOP: next_state = in ? IDLE : START; // If stop bit (1), return to IDLE; else START
            default: next_state = IDLE;
        endcase
    end

    // Sequential logic to update state and perform actions
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_counter <= 3'd0;
            shift_reg <= 8'd0;
            done <= 1'b0;
        end else begin
            state <= next_state;

            case (state)
                IDLE: begin
                    done <= 1'b0;
                end

                DATA: begin
                    bit_counter <= bit_counter + 1'b1;
                    shift_reg <= {in, shift_reg[7:1]}; // Shift in the least significant bit first
                end

                STOP: begin
                    done <= 1'b1;  // Indicate that we have received a full valid byte
                end

                default: begin
                    // Reset default actions if needed
                end
            endcase

            if (state == STOP) begin
                bit_counter <= 3'd0;   // Reset bit counter after STOP state
            end
        end
    end

    assign out_byte = shift_reg; // Output the latched byte
endmodule"
N/A,N/A,-1,63,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    // State and next-state logic
    state_t state, next_state;

    // Bit counter for data bits
    logic [2:0] bit_counter;

    // Shift register for assembling the data byte
    logic [7:0] shift_reg;

    // Combinational logic to update next state
    always_comb begin
        case (state)
            IDLE: next_state = in ? IDLE : START; // Wait for start bit (0)
            START: next_state = DATA;             // Start bit detected, shift to DATA state
            DATA: next_state = (bit_counter == 3'd7) ? STOP : DATA; // Shift until 8 bits received
            STOP: next_state = in ? IDLE : START; // If stop bit (1), return to IDLE; else START
            default: next_state = IDLE;
        endcase
    end

    // Sequential logic to update state and perform actions
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_counter <= 3'd0;
            shift_reg <= 8'd0;
            done <= 1'b0;
        end else begin
            state <= next_state;

            case (state)
                IDLE: begin
                    bit_counter <= 3'd0;
                    done <= 1'b0;
                end
                START: begin
                    // Prepare for data collection
                end
                DATA: begin
                    // Shift data in
                    shift_reg <= {in, shift_reg[7:1]};
                    bit_counter <= bit_counter + 1;
                end
                STOP: begin
                    done <= in;  // Done if stop bit is correct
                end
            endcase

        end
    end

    // Output the received byte
    assign out_byte = shift_reg;

endmodule"
N/A,N/A,-1,64,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    // State and next-state logic
    state_t state, next_state;

    // Bit counter for data bits
    logic [2:0] bit_count;

    // Shift register for assembling the data byte
    logic [7:0] shift_reg;

    // Combinational logic to update next state
    always_comb begin
        case (state)
            IDLE: next_state = in ? IDLE : START; // Wait for start bit (0)
            START: next_state = DATA;             // Start bit detected, shift to DATA
            DATA: next_state = (bit_count == 3'b111) ? STOP : DATA; // Receive 8 data bits
            STOP: next_state = in ? IDLE : STOP;  // Verify stop bit (1)
            default: next_state = IDLE;
        endcase
    end

    // Sequential logic for state transitions
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 3'b0;
            shift_reg <= 8'b0;
        end else begin
            state <= next_state;

            // State-specific behavior
            if (state == DATA) begin
                shift_reg <= {in, shift_reg[7:1]}; // Shift in LSB first
                bit_count <= bit_count + 1;
            end

            if (state == STOP && next_state == IDLE) begin
                shift_reg <= 8'b0;
                bit_count <= 3'b0;
            end
        end
    end

    // Output assignments
    assign out_byte = shift_reg;
    assign done = (state == STOP) && (next_state == IDLE) && in;
endmodule"
N/A,N/A,-1,65,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    // State and next-state logic
    state_t state, next_state;

    // Bit counter for data bits
    logic [2:0] bit_counter;

    // Shift register for assembling the data byte
    logic [7:0] shift_reg;

    // Combinational logic to determine next state
    always_comb begin
        case (state)
            IDLE: next_state = in ? IDLE : START; // Wait for start bit (0)
            START: next_state = DATA;             // Start bit detected, shift to DATA state
            DATA: next_state = (bit_counter == 3'd7) ? STOP : DATA; // Shift until 8 bits received
            STOP: next_state = in ? IDLE : DATA;  // Check stop bit, if correct move to IDLE
            default: next_state = IDLE;           // Default state
        endcase
    end

    // State transition and output logic
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_counter <= 3'd0;
            shift_reg <= 8'd0;
            done <= 1'b0;
        end else begin
            state <= next_state;

            case (state)
                IDLE: begin
                    done <= 1'b0;
                end

                START: begin
                    bit_counter <= 3'd0;
                    done <= 1'b0;
                end

                DATA: begin
                    shift_reg <= {in, shift_reg[7:1]}; // Shift in the serial bit
                    bit_counter <= bit_counter + 1;
                end

                STOP: begin
                    if (in) begin
                        done <= 1'b1; // Stop bit correct, done with byte reception
                        out_byte <= shift_reg; // Parallel load of the data byte
                    end else begin
                        done <= 1'b0; // Incorrect stop bit, output is don't-care
                    end
                end
            endcase
        end
    end
endmodule"
N/A,N/A,-1,66,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    // State and next-state logic
    state_t state, next_state;

    // Bit counter for data bits
    logic [2:0] bit_counter;

    // Shift register for assembling the data byte
    logic [7:0] shift_reg;

    // Combinational logic to update next state
    always_comb begin
        case (state)
            IDLE: next_state = in ? IDLE : START; // Wait for start bit (0)
            START: next_state = DATA;             // Start bit detected, shift to DATA state
            DATA: next_state = (bit_counter == 3'd7) ? STOP : DATA; // Shift until 8 bits received
            STOP: next_state = in ? IDLE : START; // If stop bit (1), return to IDLE; else START
            default: next_state = IDLE;
        endcase
    end

    // Sequential logic to update state and perform actions
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_counter <= 3'd0;
            shift_reg <= 8'd0;
            done <= 1'b0;
        end else begin
            state <= next_state;

            case (state)
                IDLE: begin
                    done <= 1'b0;
                end

                START: begin
                    bit_counter <= 3'd0;
                    shift_reg <= 8'd0;
                end

                DATA: begin
                    shift_reg <= {in, shift_reg[7:1]}; // Shift in the serial data
                    bit_counter <= bit_counter + 3'd1;
                end

                STOP: begin
                    if (in) begin // Verify stop bit
                        out_byte <= shift_reg; // Output the assembled data byte
                        done <= 1'b1;         // Indicate done for one cycle
                    end else begin
                        done <= 1'b0;
                    end
                end
            endcase
        end
    end
endmodule"
N/A,N/A,-1,67,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    // State and next-state logic
    state_t state, next_state;

    // Bit counter for data bits
    logic [2:0] bit_counter;

    // Shift register for assembling the data byte
    logic [7:0] shift_reg;

    // Combinational logic to determine next state
    always_comb begin
        case (state)
            IDLE: next_state = in ? IDLE : START; // Wait for start bit (0)
            START: next_state = DATA;             // Start bit detected, shift to DATA state
            DATA: next_state = (bit_counter == 3'd7) ? STOP : DATA; // Shift until 8 bits received
            STOP: next_state = in ? IDLE : START; // Validate stop bit (1), return to IDLE if valid
            default: next_state = IDLE;           // Explicit default state
        endcase
    end

    // Sequential logic to update state and output signals
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_counter <= 3'd0;
            shift_reg <= 8'h00;
        end else begin
            state <= next_state;

            case (state)
                DATA: begin
                    shift_reg <= {in, shift_reg[7:1]}; // Shift in the LSB first
                    bit_counter <= bit_counter + 1'b1;
                end
                STOP: begin
                    if (in) begin
                        done <= 1'b1; // Set done, valid stop bit
                    end
                end
                default: begin
                    done <= 1'b0; // Ensure done is low otherwise
                    bit_counter <= 3'd0; // Reset bit counter
                end
            endcase
        end
    end

    // Output assignment
    assign out_byte = (done) ? shift_reg : 8'hXX; // Only output when done is 1

endmodule"
N/A,N/A,-1,68,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum reg [2:0] {
        IDLE,
        START,
        DATA,
        STOP,
        WAIT_FOR_STOP
    } state_t;
    
    state_t state, next_state;
    reg [7:0] shift_reg;
    reg [2:0] bit_count;

    // FSM state transition
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
        end else begin
            state <= next_state;
        end
    end
    
    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 0)
                    next_state = START;
                else
                    next_state = IDLE;
            end
            START: begin
                next_state = DATA;
            end
            DATA: begin
                if (bit_count == 3'd7)
                    next_state = STOP;
                else
                    next_state = DATA;
            end
            STOP: begin
                if (in == 1)
                    next_state = IDLE;
                else
                    next_state = WAIT_FOR_STOP;
            end
            WAIT_FOR_STOP: begin
                if (in == 1)
                    next_state = IDLE;
                else
                    next_state = WAIT_FOR_STOP;
            end
            default: next_state = IDLE;
        endcase
    end

    // Output logic
    always @(posedge clk) begin
        if (reset) begin
            shift_reg <= 8'b0;
            bit_count <= 3'b0;
        end else begin
            case (state)
                START: begin
                    bit_count <= 3'b0;
                end
                DATA: begin
                    shift_reg <= {in, shift_reg[7:1]};
                    bit_count <= bit_count + 1;
                end
                default: begin
                    // No change to shift_reg and bit_count
                end
            endcase
        end
    end

    assign done = (state == STOP && in == 1);
    assign out_byte = done ? shift_reg : 8'bx;

endmodule"
N/A,N/A,-1,69,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum reg [2:0] {
        IDLE,
        START,
        DATA,
        STOP,
        WAIT_FOR_STOP
    } state_t;
    
    state_t state, next_state;
    reg [7:0] shift_reg;
    reg [3:0] bit_count;

    // FSM state transition
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
        end else begin
            state <= next_state;
        end
    end
    
    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 0)
                    next_state = START;
                else
                    next_state = IDLE;
            end
            START: begin
                next_state = DATA;
            end
            DATA: begin
                if (bit_count == 8)
                    next_state = STOP;
                else
                    next_state = DATA;
            end
            STOP: begin
                if (in == 1)
                    next_state = IDLE;
                else
                    next_state = WAIT_FOR_STOP;
            end
            WAIT_FOR_STOP: begin
                if (in == 1)
                    next_state = IDLE;
                else
                    next_state = WAIT_FOR_STOP;
            end
        endcase
    end
    
    // Datapath
    always @(posedge clk) begin
        if (reset) begin
            bit_count <= 0;
            shift_reg <= 8'd0;
        end else begin
            case (state)
                IDLE: begin
                    bit_count <= 0;
                end
                START: begin
                    // Do nothing, just transition
                end
                DATA: begin
                    shift_reg <= {in, shift_reg[7:1]};
                    bit_count <= bit_count + 1;
                end
                STOP: begin
                    // Do nothing, checking stop bit
                end
                WAIT_FOR_STOP: begin
                    // Do nothing, waiting for stop bit
                end
            endcase
        end
    end

    // Output logic
    assign done = (state == STOP) && (in == 1);
    assign out_byte = (done) ? shift_reg : 8'd0;

endmodule"
N/A,N/A,-1,70,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    // State and next-state logic
    state_t state, next_state;

    // Bit counter for data bits
    logic [2:0] bit_count;

    // Shift register for assembling the data byte
    logic [7:0] shift_reg;

    // Combinational logic to update next state
    always_comb begin
        case (state)
            IDLE: next_state = in ? IDLE : START; // Wait for start bit (0)
            START: next_state = DATA;             // Start bit detected, shift to DATA
            DATA: next_state = (bit_count == 3'b111) ? STOP : DATA; // Receive 8 data bits
            STOP: next_state = in ? IDLE : STOP;  // Verify stop bit (1)
            default: next_state = IDLE;
        endcase
    end

    // Sequential logic
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            shift_reg <= 8'b0;
            bit_count <= 3'b0;
            done <= 1'b0;
        end else begin
            state <= next_state;
            done <= 1'b0;

            case (state)
                START: begin
                    bit_count <= 3'b0;
                end
                DATA: begin
                    shift_reg <= {in, shift_reg[7:1]};  // Shift in new bit
                    bit_count <= bit_count + 1'b1;
                end
                STOP: begin
                    if (in == 1'b1) begin
                        done <= 1'b1;   // Valid stop bit, indicate done
                    end
                end
            endcase
        end
    end

    // Output the received byte when done
    assign out_byte = done ? shift_reg : 8'bxxxx_xxxx;

endmodule"
N/A,N/A,-1,71,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    // State and next-state logic
    state_t state, next_state;

    // Bit counter for data bits
    logic [2:0] bit_counter;

    // Shift register for assembling the data byte
    logic [7:0] shift_reg;

    // Combinational logic to determine next state
    always_comb begin
        case (state)
            IDLE: next_state = in ? IDLE : START; // Wait for start bit (0)
            START: next_state = DATA;             // Start bit detected, shift to DATA state
            DATA: next_state = (bit_counter == 3'd7) ? STOP : DATA; // Shift until 8 bits received
            STOP: next_state = in ? IDLE : DATA;  // Check stop bit, if correct move to IDLE
            default: next_state = IDLE;           // Default state
        endcase
    end

    // State transition and output logic
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_counter <= 3'd0;
            shift_reg <= 8'd0;
            done <= 1'b0;
        end else begin
            state <= next_state;

            case (state)
                IDLE: begin
                    bit_counter <= 3'd0;
                    done <= 1'b0;
                end
                START: begin
                    done <= 1'b0;
                end
                DATA: begin
                    shift_reg <= {in, shift_reg[7:1]}; // Shift in the incoming bit
                    bit_counter <= bit_counter + 1;
                end
                STOP: begin
                    if (in) begin
                        done <= 1'b1; // Stop bit correct, done with byte reception
                        out_byte <= shift_reg; // Parallel load of the data byte
                    end else begin
                        done <= 1'b0; // Incorrect stop bit, output is don't-care
                    end
                end
            endcase
        end
    end
endmodule"
N/A,N/A,-1,72,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    // State and next-state logic
    state_t state, next_state;

    // Bit counter for data bits
    logic [2:0] bit_counter;

    // Shift register for assembling the data byte
    logic [7:0] shift_reg;

    // Combinational logic to update next state
    always_comb begin
        case (state)
            IDLE: next_state = in ? IDLE : START; // Wait for start bit (0)
            START: next_state = DATA;             // Start bit detected, shift to DATA state
            DATA: next_state = (bit_counter == 3'd7) ? STOP : DATA; // Shift until 8 bits received
            STOP: next_state = in ? IDLE : DATA;  // Check stop bit, if correct move to IDLE
            default: next_state = IDLE;           // Default state
        endcase
    end

    // State transition and output logic
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_counter <= 3'd0;
            shift_reg <= 8'd0;
            done <= 1'b0;
        end else begin
            state <= next_state;

            case (state)
                IDLE: begin
                    done <= 1'b0;
                end

                START: begin
                    bit_counter <= 3'd0;
                    shift_reg <= 8'd0;
                end

                DATA: begin
                    shift_reg[bit_counter] <= in; // Shift in the incoming bit
                    bit_counter <= bit_counter + 1'b1;
                end

                STOP: begin
                    if (in) begin
                        done <= 1'b1;
                    end
                end
            endcase
        end
    end

    // Assign outputs
    assign out_byte = done ? shift_reg : 8'bx;

endmodule"
N/A,N/A,-1,73,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    // State and next-state logic
    state_t state, next_state;

    // Bit counter and shift register
    logic [2:0] bit_count;
    logic [7:0] shift_reg;

    // Output signals
    assign out_byte = (done) ? shift_reg : 8'bx;
    
    // State transition logic
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 3'b0;
            shift_reg <= 8'b0;
        end else begin
            state <= next_state;
            if (state == DATA) begin
                shift_reg <= {in, shift_reg[7:1]}; // shift in new bit, LSb first
            end
            if (state == DATA && next_state == STOP) begin
                bit_count <= 3'b0; // Reset bit counter when done
            end else if (state == DATA) begin
                bit_count <= bit_count + 1;
            end
        end
    end

    // Next-state logic
    always_comb begin
        next_state = state;
        done = 1'b0;
        
        case (state)
            IDLE: begin
                if (~in) begin         // Start bit detected
                    next_state = START;
                end
            end
            
            START: begin
                next_state = DATA;     // Move to DATA state on next clock
            end
            
            DATA: begin
                if (bit_count == 3'b111) begin // Received 8 bits
                    next_state = STOP;
                end
            end
            
            STOP: begin
                done = 1'b1;
                if (in) begin          // Stop bit detected
                    next_state = IDLE; // Go back to IDLE for next byte
                end
            end
            
            default: begin
                next_state = IDLE;
            end
        endcase
    end

endmodule"
N/A,N/A,-1,74,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum reg [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    // State and next-state logic
    state_t state, next_state;

    // Bit counter for data bits
    reg [2:0] bit_counter;

    // Shift register for assembling the data byte
    reg [7:0] shift_reg;

    // Combinational logic to determine next state
    always @(*) begin
        case (state)
            IDLE: next_state = (in == 1'b0) ? START : IDLE;
            START: next_state = DATA;
            DATA: next_state = (bit_counter == 3'd7) ? STOP : DATA;
            STOP: next_state = (in == 1'b1) ? IDLE : STOP;
            default: next_state = IDLE;
        endcase
    end

    // Sequential logic for state transition and output logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            shift_reg <= 8'b0;
            bit_counter <= 3'b0;
            done <= 1'b0;
        end else begin
            state <= next_state;  // State transition

            case (state)
                DATA: begin
                    shift_reg <= {in, shift_reg[7:1]};
                    bit_counter <= bit_counter + 1'b1;
                end
                STOP: begin
                    if (in == 1'b1) begin
                        done <= 1'b1;
                        out_byte <= shift_reg;
                    end
                end
                default: begin
                    bit_counter <= 3'b0;
                    done <= 1'b0;
                end
            endcase
        end
    end
endmodule"
N/A,N/A,-1,75,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    // State and next-state logic
    state_t state, next_state;

    // Bit counter for data bits
    logic [2:0] bit_counter;

    // Shift register for assembling the data byte
    logic [7:0] shift_reg;

    // Combinational logic to update next state
    always_comb begin
        case (state)
            IDLE: next_state = in ? IDLE : START; // Wait for start bit (0)
            START: next_state = DATA;             // Start bit detected, shift to DATA state
            DATA: next_state = (bit_counter == 3'd7) ? STOP : DATA; // Shift until 8 bits received
            STOP: next_state = in ? IDLE : DATA;  // Check stop bit, if correct move to IDLE
            default: next_state = IDLE;           // Default state
        endcase
    end

    // Sequential logic for state transitions and output assignments
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_counter <= 3'd0;
            shift_reg <= 8'd0;
        end
        else begin
            state <= next_state;

            case (state)
                IDLE: begin
                    bit_counter <= 3'd0;
                    shift_reg <= 8'd0;
                end
                START: begin
                    // Do nothing, just move to DATA
                end
                DATA: begin
                    shift_reg <= {in, shift_reg[7:1]}; // Shift in the incoming bit
                    bit_counter <= bit_counter + 3'd1;
                end
                STOP: begin
                    // In this state, check the stop bit
                    // If `in` is 1, a valid stop bit, we're done
                end
            endcase
        end
    end

    // Done signal logic: when in STOP state and stop bit valid
    assign done = (state == STOP) && in;

    // Output logic: only valid when done is high
    assign out_byte = done ? shift_reg : 8'hxx;

endmodule"
N/A,N/A,-1,76,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    // State and next-state logic
    state_t state, next_state;

    // Bit counter for data bits
    logic [2:0] bit_count;

    // Shift register for assembling the data byte
    logic [7:0] shift_reg;

    // Combinational logic to determine next state
    always_comb begin
        case (state)
            IDLE: next_state = in ? IDLE : START; // Wait for start bit (0)
            START: next_state = DATA;             // Start bit detected, shift to DATA state
            DATA: next_state = (bit_count == 3'd7) ? STOP : DATA; // Shift in 8 data bits
            STOP: next_state = in ? IDLE : START; // Validate stop bit (1), return to IDLE if valid
            default: next_state = IDLE;           // Explicit default state
        endcase
    end

    // Sequential logic to update state and output signals
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 3'd0;
            shift_reg <= 8'h00;
        end else begin
            state <= next_state;

            case (state)
                DATA: begin
                    shift_reg <= {in, shift_reg[7:1]}; // Shift in the new data bit
                    bit_count <= bit_count + 1'b1;
                end
                STOP: begin
                    if (in) begin
                        done <= 1'b1; // Set done, valid stop bit
                    end
                end
                default: begin
                    done <= 1'b0; // Ensure done is low otherwise
                    bit_count <= 3'd0; // Reset bit counter
                end
            endcase
        end
    end

    // Output assignment
    assign out_byte = (done) ? shift_reg : 8'hXX; // Only output valid data when done is high

endmodule"
N/A,N/A,-1,77,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    // State and next-state logic
    state_t state, next_state;

    // Bit counter for data bits
    logic [2:0] bit_counter;

    // Shift register for assembling the data byte
    logic [7:0] shift_reg;

    // Combinational logic to determine next state
    always_comb begin
        case (state)
            IDLE: next_state = in ? IDLE : START; // Wait for start bit (0)
            START: next_state = DATA;             // Start bit detected, shift to DATA state
            DATA: next_state = (bit_counter == 3'd7) ? STOP : DATA; // Shift until 8 bits received
            STOP: next_state = in ? IDLE : DATA;  // Check stop bit, if correct move to IDLE
            default: next_state = IDLE;           // Default state
        endcase
    end

    // State transition and output logic
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_counter <= 3'd0;
            shift_reg <= 8'd0;
            done <= 1'b0;
        end else begin
            state <= next_state;

            case (state)
                IDLE: begin
                    bit_counter <= 3'd0;
                    done <= 1'b0;
                end
                START: begin
                    // No action needed on start
                end
                DATA: begin
                    shift_reg <= {in, shift_reg[7:1]}; // Shift in the incoming bit
                    bit_counter <= bit_counter + 1;
                end
                STOP: begin
                    if (in) begin
                        done <= 1'b1; // Stop bit correct, done with byte reception
                        out_byte <= shift_reg; // Parallel load of the data byte
                    end else begin
                        done <= 1'b0; // Incorrect stop bit, output is not valid
                    end
                end
            endcase
        end
    end
endmodule"
N/A,N/A,-1,78,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    // State and next-state logic
    state_t state, next_state;

    // Bit counter for data bits
    logic [2:0] bit_count;

    // Shift register for assembling the data byte
    logic [7:0] shift_reg;

    // Combinational logic to update next state
    always_comb begin
        case (state)
            IDLE: next_state = in ? IDLE : START; // Wait for start bit (0)
            START: next_state = DATA;             // Start bit detected, shift to DATA state
            DATA: next_state = (bit_count == 3'd7) ? STOP : DATA; // Shift until 8 bits received
            STOP: next_state = in ? IDLE : START; // If stop bit (1), return to IDLE; else START
            default: next_state = IDLE;
        endcase
    end

    // Sequential logic to update state and perform actions
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 3'd0;
            shift_reg <= 8'd0;
            done <= 1'b0;
        end else begin
            state <= next_state;

            case (state)
                IDLE: begin
                    done <= 1'b0;
                end
                DATA: begin
                    bit_count <= bit_count + 1'b1;
                    shift_reg <= {in, shift_reg[7:1]}; // Shift in the least significant bit first
                end
                STOP: begin
                    done <= 1'b1;  // Indicate a valid output byte
                    bit_count <= 3'd0;
                end
            endcase

            if (state == STOP && next_state == IDLE) begin
                // Capture the output byte when done is asserted
                out_byte <= shift_reg;
            end
        end
    end
endmodule"
N/A,N/A,-1,79,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    // State and next-state logic
    state_t state, next_state;

    // Bit counter for data bits
    logic [2:0] bit_counter;

    // Shift register for assembling the data byte
    logic [7:0] shift_reg;

    // Combinational logic to determine next state
    always_comb begin
        case (state)
            IDLE: next_state = in ? IDLE : START; // Wait for start bit (0)
            START: next_state = DATA;             // Start bit detected, shift to DATA
            DATA: next_state = (bit_counter == 3'b111) ? STOP : DATA; // Receive 8 data bits
            STOP: next_state = in ? IDLE : STOP;  // Verify stop bit (1)
            default: next_state = IDLE;
        endcase
    end

    // Sequential logic for state transitions
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_counter <= 3'b0;
            shift_reg <= 8'b0;
        end else begin
            state <= next_state;

            // State-specific behavior
            case (state)
                DATA: begin
                    shift_reg <= {in, shift_reg[7:1]}; // Shift in new bit
                    bit_counter <= bit_counter + 1; // Increment bit counter
                end
                default: begin
                    bit_counter <= 3'b0; // Reset bit counter
                end
            endcase
        end
    end

    // Output logic
    assign out_byte = shift_reg;
    assign done = (state == STOP) && in; // Ensure stop bit is valid

endmodule"
N/A,N/A,-1,80,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum reg [2:0] {
        IDLE,
        START,
        DATA,
        STOP,
        WAIT_FOR_STOP
    } state_t;
    
    state_t state, next_state;
    reg [7:0] shift_reg;
    reg [2:0] bit_count;

    // FSM state transition
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
        end else begin
            state <= next_state;
        end
    end
    
    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 0)
                    next_state = START;
                else
                    next_state = IDLE;
            end
            START: begin
                next_state = DATA;
            end
            DATA: begin
                if (bit_count == 3'd7)
                    next_state = STOP;
                else
                    next_state = DATA;
            end
            STOP: begin
                if (in == 1)
                    next_state = IDLE;
                else
                    next_state = WAIT_FOR_STOP;
            end
            WAIT_FOR_STOP: begin
                if (in == 1)
                    next_state = IDLE;
                else
                    next_state = WAIT_FOR_STOP;
            end
            default: next_state = IDLE;
        endcase
    end

    // Output logic
    always @(posedge clk) begin
        if (reset) begin
            shift_reg <= 8'b0;
            bit_count <= 3'b0;
        end else begin
            case (state)
                START: begin
                    bit_count <= 3'b0;
                end
                DATA: begin
                    shift_reg <= {in, shift_reg[7:1]};
                    bit_count <= bit_count + 1;
                end
                default: begin
                    // No operations for other states
                end
            endcase
        end
    end

    assign out_byte = (state == STOP) ? shift_reg : 8'b0;
    assign done = (state == STOP);

endmodule"
N/A,N/A,-1,81,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    // State and next-state logic
    state_t state, next_state;

    // Bit counter for data bits
    logic [2:0] bit_counter;

    // Shift register for assembling the data byte
    logic [7:0] shift_reg;

    // Combinational logic to update next state
    always_comb begin
        case (state)
            IDLE: next_state = in ? IDLE : START; // Wait for start bit (0)
            START: next_state = DATA;             // Start bit detected, shift to DATA state
            DATA: next_state = (bit_counter == 3'd7) ? STOP : DATA; // Shift until 8 bits received
            STOP: next_state = in ? IDLE : DATA;  // Check stop bit, if correct move to IDLE
            default: next_state = IDLE;           // Default state
        endcase
    end

    // State transition and output logic
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_counter <= 3'd0;
            shift_reg <= 8'd0;
            done <= 1'b0;
        end else begin
            state <= next_state;

            case (state)
                IDLE: begin
                    bit_counter <= 3'd0;
                    shift_reg <= 8'd0;
                    done <= 1'b0;
                end
                START: begin
                    shift_reg <= 8'd0;
                    done <= 1'b0;
                end
                DATA: begin
                    shift_reg <= {in, shift_reg[7:1]}; // Shift in the LSB first
                    bit_counter <= bit_counter + 3'd1;
                    done <= 1'b0;
                end
                STOP: begin
                    if (in) begin // Stop bit correct
                        out_byte <= shift_reg; // Output the received byte
                        done <= 1'b1;
                    end
                end
            endcase
        end
    end

endmodule"
N/A,N/A,-1,82,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    // State and next-state logic
    state_t state, next_state;

    // Bit counter for data bits
    logic [2:0] bit_count;

    // Shift register for assembling the data byte
    logic [7:0] shift_reg;

    // Combinational logic to determine next state
    always_comb begin
        case (state)
            IDLE: next_state = in ? IDLE : START; // Wait for start bit (0)
            START: next_state = DATA;             // Start bit detected, shift to DATA state
            DATA: next_state = (bit_count == 3'd7) ? STOP : DATA; // Shift until 8 bits received
            STOP: next_state = in ? IDLE : DATA;  // Check stop bit, if correct move to IDLE
            default: next_state = IDLE;           // Default state
        endcase
    end

    // State transition and output logic
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 3'd0;
            shift_reg <= 8'd0;
            done <= 1'b0;
        end else begin
            state <= next_state;

            case (state)
                IDLE: begin
                    bit_count <= 3'd0;
                    done <= 1'b0;
                end
                START: begin
                    // No action needed on start
                end
                DATA: begin
                    shift_reg <= {in, shift_reg[7:1]}; // Shift in the serial bit
                    bit_count <= bit_count + 1;
                end
                STOP: begin
                    if (in) begin
                        done <= 1'b1; // Stop bit correct, done with byte reception
                        out_byte <= shift_reg; // Parallel load of the data byte
                    end else begin
                        done <= 1'b0; // Incorrect stop bit, output is not valid
                    end
                end
            endcase
        end
    end
endmodule"
N/A,N/A,-1,83,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    // State and next-state logic
    state_t state, next_state;

    // Bit counter for data bits
    logic [2:0] bit_counter;

    // Shift register for assembling the data byte
    logic [7:0] shift_reg;

    // Combinational logic to determine next state
    always_comb begin
        case (state)
            IDLE: next_state = in ? IDLE : START; // Wait for start bit (0)
            START: next_state = DATA;             // Start bit detected, shift to DATA state
            DATA: next_state = (bit_counter == 3'd7) ? STOP : DATA; // Shift until 8 bits received
            STOP: next_state = in ? IDLE : DATA;  // Check stop bit, if correct move to IDLE
            default: next_state = IDLE;           // Default state
        endcase
    end

    // State transition and output logic
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_counter <= 3'd0;
            shift_reg <= 8'd0;
            done <= 1'b0;
        end else begin
            state <= next_state;

            case (state)
                IDLE: begin
                    bit_counter <= 3'd0;
                    shift_reg <= 8'd0;
                    done <= 1'b0;
                end
                START: begin
                    shift_reg <= 8'd0;
                    done <= 1'b0;
                end
                DATA: begin
                    shift_reg <= {in, shift_reg[7:1]}; // Shift in data bits
                    bit_counter <= bit_counter + 1;
                end
                STOP: begin
                    done <= (in == 1'b1); // Done only if stop bit is 1
                end
            endcase
        end
    end

    // Assign output byte when done
    assign out_byte = done ? shift_reg : 8'hXX;

endmodule"
N/A,N/A,-1,84,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    // State and next-state logic
    state_t state, next_state;

    // Bit counter for data bits
    logic [2:0] bit_counter;

    // Shift register for assembling the data byte
    logic [7:0] shift_reg;

    // Combinational logic to update next state
    always_comb begin
        case (state)
            IDLE: next_state = in ? IDLE : START; // Wait for start bit (0)
            START: next_state = DATA;             // Start bit detected, shift to DATA state
            DATA: next_state = (bit_counter == 3'd7) ? STOP : DATA; // Shift until 8 bits received
            STOP: next_state = in ? IDLE : START; // If stop bit (1), return to IDLE; else START
            default: next_state = IDLE;
        endcase
    end

    // Sequential logic to update state and perform actions
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_counter <= 3'd0;
            shift_reg <= 8'd0;
            done <= 1'b0;
        end else begin
            state <= next_state;

            case (state)
                IDLE: begin
                    done <= 1'b0;
                end

                DATA: begin
                    bit_counter <= bit_counter + 1'b1;
                    shift_reg <= {in, shift_reg[7:1]}; // Shift in the least significant bit first
                end

                STOP: begin
                    done <= 1'b1;  // Indicate a valid output byte
                    bit_counter <= 3'd0;
                end
            endcase

            if (state == STOP && next_state == IDLE) begin
                done <= 1'b0; // Clear done flag except for during state transition
            end
        end
    end

    // Assign output
    assign out_byte = shift_reg; // Output the latched byte
endmodule"
N/A,N/A,-1,85,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    // State and next-state logic
    state_t state, next_state;

    // Bit counter for data bits
    logic [2:0] bit_counter;

    // Shift register for assembling the data byte
    logic [7:0] shift_reg;

    // Combinational logic to update next state
    always_comb begin
        case (state)
            IDLE: next_state = in ? IDLE : START; // Wait for start bit (0)
            START: next_state = DATA;             // Start bit detected, shift to DATA state
            DATA: next_state = (bit_counter == 3'd7) ? STOP : DATA; // Shift until 8 bits received
            STOP: next_state = in ? IDLE : DATA;  // Check stop bit, if correct move to IDLE
            default: next_state = IDLE;           // Default state
        endcase
    end

    // State transition and output logic
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_counter <= 3'd0;
            shift_reg <= 8'd0;
            done <= 1'b0;
        end else begin
            state <= next_state;

            case (state)
                IDLE: begin
                    done <= 1'b0;
                end

                START: begin
                    bit_counter <= 3'd0;
                    shift_reg <= 8'd0;
                end

                DATA: begin
                    shift_reg <= {in, shift_reg[7:1]}; // Shift in the serial data
                    bit_counter <= bit_counter + 3'd1;
                end

                STOP: begin
                    if (in) begin // Stop bit is 1
                        out_byte <= shift_reg; // Output the received byte
                        done <= 1'b1;          // Set done flag
                    end
                end
            endcase
        end
    end
endmodule"
N/A,N/A,-1,86,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    // State and next-state logic
    state_t state, next_state;

    // Bit counter for data bits
    logic [2:0] bit_counter;

    // Shift register for assembling the data byte
    logic [7:0] shift_reg;

    // Combinational logic to determine next state
    always_comb begin
        case (state)
            IDLE: next_state = in ? IDLE : START; // Wait for start bit (0)
            START: next_state = DATA;             // Start bit detected, shift to DATA state
            DATA: next_state = (bit_counter == 3'd7) ? STOP : DATA; // Shift until 8 bits received
            STOP: next_state = in ? IDLE : DATA;  // Check stop bit, if correct move to IDLE
            default: next_state = IDLE;           // Default state
        endcase
    end

    // State transition and output logic
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_counter <= 3'd0;
            shift_reg <= 8'd0;
            done <= 1'b0;
        end else begin
            state <= next_state;

            case (state)
                IDLE: begin
                    done <= 1'b0;
                end

                START: begin
                    bit_counter <= 3'd0;
                    shift_reg <= 8'd0;
                end

                DATA: begin
                    shift_reg <= {in, shift_reg[7:1]}; // Shift in the serial data
                    bit_counter <= bit_counter + 3'd1;
                end

                STOP: begin
                    if (in) begin // Verify stop bit (1)
                        out_byte <= shift_reg; // Output the received byte
                        done <= 1'b1;          // Set done flag
                    end else begin
                        done <= 1'b0;          // Stop bit incorrect, wait for correct stop
                    end
                end
            endcase
        end
    end
endmodule"
N/A,N/A,-1,87,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    // State and next-state logic
    state_t state, next_state;

    // Bit counter for data bits
    logic [2:0] bit_count;

    // Shift register for assembling the data byte
    logic [7:0] shift_reg;

    // Combinational logic to determine next state
    always_comb begin
        case (state)
            IDLE: next_state = in ? IDLE : START; // Wait for start bit (0)
            START: next_state = DATA;             // Start bit detected, shift to DATA state
            DATA: next_state = (bit_count == 3'd7) ? STOP : DATA; // Shift until 8 bits received
            STOP: next_state = in ? IDLE : START; // If stop bit (1), return to IDLE; else START
            default: next_state = IDLE;
        endcase
    end

    // Sequential logic to update state and perform actions
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 3'd0;
            shift_reg <= 8'd0;
            done <= 1'b0;
        end else begin
            state <= next_state;

            case (state)
                IDLE: begin
                    done <= 1'b0;
                end
                DATA: begin
                    bit_count <= bit_count + 1'b1;
                    shift_reg <= {in, shift_reg[7:1]}; // Shift in the least significant bit first
                end
                STOP: begin
                    done <= 1'b1;  // Indicate a valid output byte
                    bit_count <= 3'd0;
                end
            endcase

            if (state == STOP && next_state == START) begin
                done <= 1'b0; // Clear the done flag if stop bit is not received correctly
            end
        end
    end

    // Output the correctly-received data byte
    assign out_byte = shift_reg;

endmodule"
N/A,N/A,-1,88,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    // State and next-state logic
    state_t state, next_state;

    // Bit counter for data bits
    logic [2:0] bit_count;

    // Shift register for assembling the data byte
    logic [7:0] shift_reg;

    // Combinational logic to update next state
    always_comb begin
        case (state)
            IDLE: next_state = in ? IDLE : START; // Wait for start bit (0)
            START: next_state = DATA;             // Start bit detected, shift to DATA
            DATA: next_state = (bit_count == 3'b111) ? STOP : DATA; // Receive 8 data bits
            STOP: next_state = in ? IDLE : STOP;  // Verify stop bit (1)
            default: next_state = IDLE;
        endcase
    end

    // Sequential logic
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            shift_reg <= 8'b0;
            bit_count <= 3'b0;
            done <= 1'b0;
        end else begin
            state <= next_state;
            done <= 1'b0;

            case (state)
                START: begin
                    bit_count <= 3'b0;
                end
                DATA: begin
                    shift_reg <= {in, shift_reg[7:1]};  // Shift in new bit
                    bit_count <= bit_count + 1'b1;
                end
                STOP: begin
                    if (in == 1'b1) begin
                        done <= 1'b1;   // Valid output
                    end
                end
            endcase
        end
    end

    assign out_byte = shift_reg;

endmodule"
N/A,N/A,-1,89,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    // State and next-state logic
    state_t state, next_state;

    // Bit counter for data bits
    logic [2:0] bit_counter;

    // Shift register for assembling the data byte
    logic [7:0] shift_reg;

    // Combinational logic to determine next state
    always_comb begin
        case (state)
            IDLE: next_state = in ? IDLE : START; // Wait for start bit (0)
            START: next_state = DATA;             // Start bit detected, shift to DATA state
            DATA: next_state = (bit_counter == 3'd7) ? STOP : DATA; // Shift in 8 data bits
            STOP: next_state = in ? IDLE : START; // Validate stop bit (1), return to IDLE if valid
            default: next_state = IDLE;           // Explicit default state
        endcase
    end

    // Sequential logic to update state and output signals
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_counter <= 3'd0;
            shift_reg <= 8'h00;
        end else begin
            state <= next_state;

            case (state)
                DATA: begin
                    shift_reg <= {in, shift_reg[7:1]}; // Shift in the new data bit
                    bit_counter <= bit_counter + 1'b1;
                end
                STOP: begin
                    if (in) begin
                        done <= 1'b1; // Set done, valid stop bit
                    end
                end
                default: begin
                    done <= 1'b0; // Ensure done is low otherwise
                    bit_counter <= 3'd0; // Reset bit counter
                end
            endcase
        end
    end

    // Output assignment
    assign out_byte = (done) ? shift_reg : 8'hXX; // Only output valid data when done is high

endmodule"
N/A,N/A,-1,90,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    // State and next-state logic
    state_t state, next_state;

    // Bit counter for data bits
    logic [2:0] bit_counter;

    // Shift register for assembling the data byte
    logic [7:0] shift_reg;

    // Combinational logic to determine next state
    always_comb begin
        case (state)
            IDLE: next_state = in ? IDLE : START; // Wait for start bit (0)
            START: next_state = DATA;             // Start bit detected, shift to DATA state
            DATA: next_state = (bit_counter == 3'd7) ? STOP : DATA; // Shift until 8 bits received
            STOP: next_state = in ? IDLE : START; // If stop bit (1), return to IDLE; else START
            default: next_state = IDLE;
        endcase
    end

    // Sequential logic to update state and perform actions
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_counter <= 3'd0;
            shift_reg <= 8'd0;
            done <= 1'b0;
        end else begin
            state <= next_state;

            case (state)
                IDLE: begin
                    done <= 1'b0;
                end
                DATA: begin
                    bit_counter <= bit_counter + 1'b1;
                    shift_reg <= {in, shift_reg[7:1]}; // Shift in the least significant bit first
                end
                STOP: begin
                    done <= 1'b1;  // Indicate a valid output byte
                    bit_counter <= 3'd0;
                end
            endcase

            if (state == STOP && next_state == IDLE) begin
                // Capture the output byte when done is asserted
                out_byte <= shift_reg;
            end
        end
    end
endmodule"
N/A,N/A,-1,91,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    // State and next-state logic
    state_t state, next_state;

    // Bit counter for data bits
    logic [2:0] bit_count;

    // Shift register for assembling the data byte
    logic [7:0] shift_reg;

    // Combinational logic to determine next state
    always_comb begin
        case (state)
            IDLE: next_state = in ? IDLE : START; // Wait for start bit (0)
            START: next_state = DATA;             // Start bit detected, shift to DATA state
            DATA: next_state = (bit_count == 3'd7) ? STOP : DATA; // Shift until 8 bits received
            STOP: next_state = in ? IDLE : DATA;  // Check stop bit, if correct move to IDLE
            default: next_state = IDLE;           // Default state
        endcase
    end

    // State transition and output logic
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 3'd0;
            shift_reg <= 8'd0;
            done <= 1'b0;
        end else begin
            state <= next_state;

            case (state)
                IDLE: begin
                    bit_count <= 3'd0;
                    done <= 1'b0;
                end
                START: begin
                    // Prepare for data collection
                end
                DATA: begin
                    shift_reg <= {in, shift_reg[7:1]}; // Shift in the new bit
                    bit_count <= bit_count + 1'b1;
                end
                STOP: begin
                    done <= in; // Stop bit should be 1 to consider it valid
                end
                default: ;
            endcase
        end
    end

    assign out_byte = done ? shift_reg : 8'hxx; // Output valid byte when done is true
endmodule"
N/A,N/A,-1,92,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    // State and next-state logic
    state_t state, next_state;

    // Bit counter for data bits
    logic [2:0] bit_counter;

    // Shift register for assembling the data byte
    logic [7:0] shift_reg;

    // Combinational logic to update next state
    always_comb begin
        case (state)
            IDLE: next_state = in ? IDLE : START; // Wait for start bit (0)
            START: next_state = DATA;             // Start bit detected, shift to DATA state
            DATA: next_state = (bit_counter == 3'd7) ? STOP : DATA; // Shift until 8 bits received
            STOP: next_state = in ? IDLE : DATA;  // Check stop bit, if correct move to IDLE
            default: next_state = IDLE;           // Default state
        endcase
    end

    // Sequential logic for state transitions and output assignments
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_counter <= 3'd0;
            shift_reg <= 8'd0;
        end
        else begin
            state <= next_state;

            case (state)
                START: begin
                    bit_counter <= 3'd0; // Reset bit counter at start bit
                end
                DATA: begin
                    shift_reg <= {in, shift_reg[7:1]}; // Shift in bits
                    bit_counter <= bit_counter + 3'd1; // Increment bit counter
                end
                STOP: begin
                    if (next_state == IDLE) begin
                        done <= 1'b1; // Byte received correctly
                    end
                end
                default: done <= 1'b0; // Not done unless confirmed
            endcase
        end
    end

    // Output logic (valid when done is high)
    assign out_byte = done ? shift_reg : 8'bx; // Output the latched byte
endmodule"
N/A,N/A,-1,93,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    // State and next-state logic
    state_t state, next_state;

    // Bit counter for data bits
    logic [2:0] bit_counter;

    // Shift register for assembling the data byte
    logic [7:0] shift_reg;

    // Combinational logic to determine next state
    always_comb begin
        case (state)
            IDLE: next_state = in ? IDLE : START; // Wait for start bit (0)
            START: next_state = DATA;             // Start bit detected, shift to DATA
            DATA: next_state = (bit_counter == 3'b111) ? STOP : DATA; // Receive 8 data bits
            STOP: next_state = in ? IDLE : STOP;  // Verify stop bit (1)
            default: next_state = IDLE;
        endcase
    end

    // Sequential logic for state transitions
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_counter <= 3'b0;
            shift_reg <= 8'b0;
        end else begin
            state <= next_state;

            // State-specific behavior
            case (state)
                DATA: begin
                    shift_reg <= {in, shift_reg[7:1]}; // Shift in new bit
                    bit_counter <= bit_counter + 1; // Increment bit counter
                end
                default: begin
                    bit_counter <= 3'b0; // Reset bit counter
                end
            endcase
        end
    end

    // Output logic
    assign out_byte = shift_reg;
    assign done = (state == STOP) && in; // Ensure stop bit is valid

endmodule"
N/A,N/A,-1,94,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    // State and next-state logic
    state_t state, next_state;

    // Bit counter for data bits
    logic [2:0] bit_count;

    // Shift register for assembling the data byte
    logic [7:0] shift_reg;

    // Combinational logic to determine next state
    always_comb begin
        case (state)
            IDLE: next_state = in ? IDLE : START; // Wait for start bit (0)
            START: next_state = DATA;             // Start bit detected, shift to DATA state
            DATA: next_state = (bit_count == 3'd7) ? STOP : DATA; // Shift in 8 data bits
            STOP: next_state = in ? IDLE : START; // Validate stop bit (1), return to IDLE if valid
            default: next_state = IDLE;           // Explicit default state
        endcase
    end

    // Sequential logic to update state and output signals
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 3'd0;
            shift_reg <= 8'h00;
        end else begin
            state <= next_state;

            case (state)
                DATA: begin
                    shift_reg <= {in, shift_reg[7:1]}; // Shift in the new data bit
                    bit_count <= bit_count + 1'b1;
                end
                STOP: begin
                    if (in) begin
                        done <= 1'b1; // Set done, valid stop bit
                    end
                end
                default: begin
                    done <= 1'b0; // Ensure done is low otherwise
                    bit_count <= 3'd0; // Reset bit counter
                end
            endcase
        end
    end

    // Output assignment
    assign out_byte = (done) ? shift_reg : 8'hXX; // Only output valid data when done is high

endmodule"
N/A,N/A,-1,95,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP,
        DONE
    } state_t;

    state_t state, next_state;
    logic [7:0] shift_reg;
    logic [2:0] bit_counter;

    // State transition logic
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            shift_reg <= 8'b0;
            bit_counter <= 3'd0;
        end else begin
            state <= next_state;
            if (state == DATA) begin
                shift_reg[bit_counter] <= in;
            end
        end
    end

    // Next state logic
    always_comb begin
        next_state = state; // Default to keeping current state
        case (state)
            IDLE: begin
                if (in == 1'b0) // Start bit detected
                    next_state = START;
            end
            START: next_state = DATA;
            DATA: begin
                if (bit_counter == 3'd7)
                    next_state = STOP;
            end
            STOP: begin
                if (in == 1'b1) // Stop bit detected
                    next_state = DONE;
                else
                    next_state = IDLE; // Error, return to IDLE to find new start
            end
            DONE: next_state = IDLE; // Automatically return to IDLE
        endcase
    end

    // Output logic
    always_ff @(posedge clk) begin
        if (state == DATA && next_state == DATA) begin
            bit_counter <= bit_counter + 1'b1;
        end else if (next_state != DATA) begin
            bit_counter <= 3'd0;
        end
    end

    assign out_byte = shift_reg;
    assign done = (state == DONE);

endmodule"
N/A,N/A,-1,96,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    // State and next-state logic
    state_t state, next_state;

    // Bit counter for data bits
    logic [2:0] bit_count;

    // Shift register for assembling the data byte
    logic [7:0] shift_reg;

    // Combinational logic to determine next state
    always_comb begin
        case (state)
            IDLE: next_state = in ? IDLE : START; // Wait for start bit (0)
            START: next_state = DATA;             // Start bit detected, shift to DATA state
            DATA: next_state = (bit_count == 3'd7) ? STOP : DATA; // Shift until 8 bits received
            STOP: next_state = in ? IDLE : DATA;  // Check stop bit, if correct move to IDLE
            default: next_state = IDLE;           // Default state
        endcase
    end

    // State transition and output logic
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 3'd0;
            shift_reg <= 8'd0;
            done <= 1'b0;
        end else begin
            state <= next_state;

            case (state)
                IDLE: begin
                    bit_count <= 3'd0;
                    done <= 1'b0;
                end
                START: begin
                    // Prepare for data collection
                end
                DATA: begin
                    // Shift data in
                    shift_reg <= {in, shift_reg[7:1]};
                    bit_count <= bit_count + 1;
                end
                STOP: begin
                    done <= in;  // Done if stop bit is correct
                end
            endcase

        end
    end

    // Output the received byte when done
    assign out_byte = done ? shift_reg : 8'dx; // Use don't-care when done is 0

endmodule"
N/A,N/A,-1,97,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    // State and next-state logic
    state_t state, next_state;

    // Bit counter for data bits
    logic [2:0] bit_counter;

    // Shift register for assembling the data byte
    logic [7:0] shift_reg;

    // Combinational logic to determine next state
    always_comb begin
        case (state)
            IDLE: next_state = in ? IDLE : START; // Wait for start bit (0)
            START: next_state = DATA;             // Start bit detected, shift to DATA
            DATA: next_state = (bit_counter == 3'b111) ? STOP : DATA; // Receive 8 data bits
            STOP: next_state = in ? IDLE : STOP;  // Verify stop bit (1)
            default: next_state = IDLE;
        endcase
    end

    // Sequential logic for state transitions
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_counter <= 3'b0;
            shift_reg <= 8'b0;
        end else begin
            state <= next_state;

            // State-specific behavior
            case (state)
                DATA: begin
                    shift_reg <= {in, shift_reg[7:1]}; // Shift in new bit
                    bit_counter <= bit_counter + 1; // Increment bit counter
                end
                default: begin
                    if (state == START || state == STOP) begin
                        bit_counter <= 3'b0;
                    end
                end
            endcase
        end
    end

    // Output logic
    assign out_byte = (state == STOP) ? shift_reg : 8'bx; // Valid when in STOP
    assign done = (state == STOP);

endmodule"
N/A,N/A,-1,98,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum reg [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    // State and next-state logic
    state_t state, next_state;

    // Bit counter for data bits
    reg [2:0] bit_counter;

    // Shift register for assembling the data byte
    reg [7:0] shift_reg;

    // Combinational logic to determine next state
    always @(*) begin
        case (state)
            IDLE: next_state = (in == 1'b0) ? START : IDLE;
            START: next_state = DATA;
            DATA: next_state = (bit_counter == 3'd7) ? STOP : DATA;
            STOP: next_state = (in == 1'b1) ? IDLE : STOP;
            default: next_state = IDLE;
        endcase
    end

    // Sequential logic for state transition and output logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            shift_reg <= 8'b0;
            bit_counter <= 3'b0;
            done <= 1'b0;
        end else begin
            state <= next_state;  // State transition

            case (state)
                DATA: begin
                    shift_reg <= {in, shift_reg[7:1]};
                    bit_counter <= bit_counter + 1'b1;
                end
                STOP: begin
                    if (in == 1'b1) begin
                        done <= 1'b1;
                        out_byte <= shift_reg;
                    end
                end
                default: begin
                    bit_counter <= 3'b0;
                    done <= 1'b0;
                end
            endcase
        end
    end
endmodule"
N/A,N/A,-1,99,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    // State and next-state logic
    state_t state, next_state;

    // Bit counter for data bits
    logic [2:0] bit_counter;

    // Shift register for assembling the data byte
    logic [7:0] shift_reg;

    // Combinational logic to update next state
    always_comb begin
        case (state)
            IDLE: next_state = in ? IDLE : START; // Wait for start bit (0)
            START: next_state = DATA;             // Start bit detected, shift to DATA
            DATA: next_state = (bit_counter == 3'b111) ? STOP : DATA; // Receive 8 data bits
            STOP: next_state = in ? IDLE : STOP;  // Verify stop bit (1)
            default: next_state = IDLE;
        endcase
    end

    // Sequential logic for state transitions
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_counter <= 3'b0;
            shift_reg <= 8'b0;
        end else begin
            state <= next_state;

            // State-specific behavior
            if (state == DATA) begin
                shift_reg <= {in, shift_reg[7:1]}; // Shift in LSB first
                bit_counter <= bit_counter + 1;
            end

            if (state == STOP && next_state == IDLE) begin
                shift_reg <= 8'b0;
                bit_counter <= 3'b0;
            end
        end
    end

    // Output assignments
    assign out_byte = shift_reg;
    assign done = (state == STOP) && (next_state == IDLE) && in;
endmodule"
