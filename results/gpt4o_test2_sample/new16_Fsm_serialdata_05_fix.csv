Area,Delay,Score,Current Run,Episode,Verilog
N/A,N/A,-1,0,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    // State and next state variables
    state_t state, next_state;

    // Bit counter for data bits
    logic [2:0] bit_count;

    // Shift register for assembling the data byte
    logic [7:0] shift_reg;

    // Sequential logic for state transitions
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 3'd0;
            shift_reg <= 8'd0;
        end else begin
            state <= next_state;
            if (state == DATA) begin
                shift_reg <= {in, shift_reg[7:1]}; // Shift in the new bit
                bit_count <= bit_count + 3'd1;
            end else if (state == START) begin
                bit_count <= 3'd0; // Reset bit counter at start of new byte
            end
        end
    end

    // Combinational logic for next state and output logic
    always_comb begin
        // Default assignments
        next_state = state;
        done = 1'b0;

        case (state)
            IDLE: begin
                if (in == 1'b0) // Detect start bit (active low)
                    next_state = START;
            end
            START: begin
                next_state = DATA;
            end
            DATA: begin
                if (bit_count == 3'd7)
                    next_state = STOP;
            end
            STOP: begin
                if (in == 1'b1) begin // Detect stop bit (active high)
                    done = 1'b1;
                    next_state = IDLE;
                end else begin
                    next_state = IDLE; // If stop bit is incorrect, return to IDLE
                end
            end
        endcase
    end

    // Output the correctly received byte when done
    assign out_byte = (done) ? shift_reg : 8'd0;

endmodule"
N/A,N/A,-1,1,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    // State registers
    state_t current_state, next_state;
    logic [2:0] bit_counter; // Counter for data bits
    logic [7:0] shift_reg;   // Shift register for data bits

    // Output logic
    assign done = (current_state == STOP);

    // State transition logic
    always_ff @(posedge clk) begin
        if (reset) begin
            current_state <= IDLE;
            bit_counter <= 3'd0;
            shift_reg <= 8'd0;
        end else begin
            current_state <= next_state;
            if (current_state == DATA) begin
                shift_reg <= {in, shift_reg[7:1]}; // Shift in the new bit
                bit_counter <= bit_counter + 1;
            end
        end
    end

    // Next state logic
    always_comb begin
        next_state = current_state; // Default to hold state
        case (current_state)
            IDLE: begin
                if (in == 0) // Detect start bit
                    next_state = START;
            end
            START: begin
                next_state = DATA;
            end
            DATA: begin
                if (bit_counter == 3'd7)
                    next_state = STOP;
            end
            STOP: begin
                if (in == 1) // Detect stop bit
                    next_state = IDLE;
            end
        endcase
    end

    // Output data byte when done is high
    assign out_byte = (done) ? shift_reg : 8'dx;

endmodule"
N/A,N/A,-1,2,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP,
        DONE
    } state_t;

    state_t state, next_state;
    logic [7:0] shift_reg;
    logic [2:0] bit_count;

    // State transition logic
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            shift_reg <= 8'b0;
            bit_count <= 3'd0;
        end else begin
            state <= next_state;
            if (state == DATA) begin
                shift_reg <= {in, shift_reg[7:1]};
            end
            if (state == DATA || state == START) begin
                bit_count <= bit_count + 3'd1;
            end else begin
                bit_count <= 3'd0;
            end
        end
    end

    // Next state logic
    always_comb begin
        next_state = state;
        done = 1'b0;
        case (state)
            IDLE: begin
                if (in == 1'b0) begin  // Detect start bit
                    next_state = START;
                end
            end
            START: begin
                if (bit_count == 3'd1) begin
                    next_state = DATA;
                end
            end
            DATA: begin
                if (bit_count == 3'd8) begin
                    next_state = STOP;
                end
            end
            STOP: begin
                if (in == 1'b1) begin  // Detect stop bit
                    next_state = DONE;
                end else begin
                    next_state = IDLE;  // Error, reset to IDLE
                end
            end
            DONE: begin
                done = 1'b1;
                next_state = IDLE;
            end
        endcase
    end

    // Output logic
    assign out_byte = (done) ? shift_reg : 8'b0;

endmodule"
N/A,N/A,-1,3,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    // State and next state variables
    state_t state, next_state;

    // Bit counter for data bits
    logic [2:0] bit_count;

    // Shift register for assembling the data byte
    logic [7:0] shift_reg;

    // Sequential logic for state transitions
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 3'd0;
            shift_reg <= 8'd0;
        end else begin
            state <= next_state;
            if (state == DATA) begin
                shift_reg <= {in, shift_reg[7:1]}; // Shift in the new bit
                bit_count <= bit_count + 3'd1;
            end else if (state == START) begin
                bit_count <= 3'd0; // Reset bit counter at start of new byte
            end
        end
    end

    // Combinational logic for next state and output logic
    always_comb begin
        // Default assignments
        next_state = state;
        done = 1'b0;
        
        case (state)
            IDLE: begin
                if (in == 1'b0) // Detect start bit
                    next_state = START;
            end

            START: begin
                next_state = DATA;
            end

            DATA: begin
                if (bit_count == 3'd7) // All 8 data bits received
                    next_state = STOP;
            end

            STOP: begin
                if (in == 1'b1) begin // Detect stop bit
                    next_state = IDLE;
                    done = 1'b1; // Signal that a valid byte has been received
                end else begin
                    next_state = IDLE; // Go back to IDLE if stop bit is incorrect
                end
            end

            default: next_state = IDLE;
        endcase
    end

    // Output the received byte when done
    assign out_byte = (done) ? shift_reg : 8'd0;

endmodule"
N/A,N/A,-1,4,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    // State variables
    state_t current_state, next_state;
    logic [2:0] bit_counter;
    logic [7:0] shift_register;

    // State transition logic
    always_ff @(posedge clk) begin
        if (reset) begin
            current_state <= IDLE;
            bit_counter <= 3'd0;
            shift_register <= 8'd0;
        end else begin
            current_state <= next_state;
            if (current_state == DATA) begin
                shift_register <= {in, shift_register[7:1]};
                bit_counter <= bit_counter + 1;
            end else if (current_state == IDLE) begin
                bit_counter <= 3'd0;
            end
        end
    end

    // Next state logic
    always_comb begin
        next_state = current_state; // Default to no state change
        done = 1'b0; // Default to not done
        case (current_state)
            IDLE: begin
                if (in == 1'b0) begin // Start bit detected
                    next_state = START;
                end
            end
            START: begin
                next_state = DATA;
            end
            DATA: begin
                if (bit_counter == 3'd7) begin
                    next_state = STOP;
                end
            end
            STOP: begin
                if (in == 1'b1) begin // Stop bit detected
                    done = 1'b1;
                    next_state = IDLE;
                end else begin
                    next_state = IDLE; // Wait for next start bit
                end
            end
        endcase
    end

    // Output logic
    assign out_byte = shift_register;

endmodule"
N/A,N/A,-1,5,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    // State and next state variables
    state_t state, next_state;

    // Bit counter for data bits
    logic [2:0] bit_count;

    // Shift register for assembling the data byte
    logic [7:0] shift_reg;

    // Output registers
    logic [7:0] data_byte;
    logic done_reg;

    // State transition logic
    always_ff @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 3'd0;
            shift_reg <= 8'b0;
            done_reg <= 1'b0;
        end else begin
            state <= next_state;
            if (state == DATA) begin
                shift_reg <= {in, shift_reg[7:1]}; // Shift in the new bit
                bit_count <= bit_count + 3'd1;
            end
            if (state == STOP && in == 1'b1) begin
                data_byte <= shift_reg;
                done_reg <= 1'b1;
            end else begin
                done_reg <= 1'b0;
            end
        end
    end

    // Next state logic
    always_comb begin
        next_state = state;
        case (state)
            IDLE: begin
                if (in == 1'b0) // Start bit detected
                    next_state = START;
            end
            START: begin
                next_state = DATA;
            end
            DATA: begin
                if (bit_count == 3'd7) // All 8 data bits received
                    next_state = STOP;
            end
            STOP: begin
                if (in == 1'b1) // Stop bit detected
                    next_state = IDLE;
                else
                    next_state = STOP; // Wait for stop bit
            end
            default: next_state = IDLE;
        endcase
    end

    // Output assignments
    assign out_byte = data_byte;
    assign done = done_reg;

endmodule"
N/A,N/A,-1,6,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    // State registers
    state_t current_state, next_state;
    reg [7:0] shift_reg;
    reg [2:0] bit_count;

    // FSM state transition
    always_ff @(posedge clk) begin
        if (reset) begin
            current_state <= IDLE;
            shift_reg <= 8'b0;
            bit_count <= 3'b0;
        end else begin
            current_state <= next_state;
            if (current_state == DATA) begin
                shift_reg <= {in, shift_reg[7:1]};
                bit_count <= bit_count + 1;
            end
        end
    end

    // FSM next state logic
    always_comb begin
        next_state = current_state;
        done = 1'b0;

        case (current_state)
            IDLE: begin
                if (in == 0) // Start bit detected
                    next_state = START;
            end
            START: begin
                next_state = DATA;
                bit_count = 3'b0;
            end
            DATA: begin
                if (bit_count == 3'd7)
                    next_state = STOP;
            end
            STOP: begin
                if (in == 1) begin // Stop bit detected
                    done = 1'b1;
                    next_state = IDLE;
                end else begin
                    // Remain in STOP state, wait for correct stop bit
                end
            end
        endcase
    end

    // Output logic
    assign out_byte = shift_reg;

endmodule"
N/A,N/A,-1,7,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP,
        DONE
    } state_t;

    state_t state, next_state;
    logic [7:0] shift_reg;
    logic [2:0] bit_count;

    // State transition logic
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            shift_reg <= 8'b0;
            bit_count <= 3'd0;
        end else begin
            state <= next_state;
            if (state == DATA) begin
                shift_reg <= {in, shift_reg[7:1]};
            end
            if (state == DATA || state == START) begin
                bit_count <= bit_count + 3'd1;
            end else begin
                bit_count <= 3'd0;
            end
        end
    end

    // Next state logic
    always_comb begin
        next_state = state;
        done = 1'b0;
        case (state)
            IDLE: begin
                if (in == 1'b0) begin  // Detect start bit
                    next_state = START;
                end
            end
            START: begin
                if (bit_count == 3'd1) begin
                    next_state = DATA;
                end
            end
            DATA: begin
                if (bit_count == 3'd8) begin
                    next_state = STOP;
                end
            end
            STOP: begin
                if (in == 1'b1) begin  // Detect stop bit
                    next_state = DONE;
                end else begin
                    next_state = IDLE;  // Error, reset to IDLE
                end
            end
            DONE: begin
                done = 1'b1;
                next_state = IDLE;
            end
        endcase
    end

    // Output logic
    assign out_byte = (done) ? shift_reg : 8'bx;

endmodule"
N/A,N/A,-0.1,8,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

parameter IDLE = 0, START = 1, DATA = 2, STOP = 3;
    reg [1:0] state, next_state;
    reg [7:0] shift_reg;
    reg [2:0] bit_count;
    reg done_reg;

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
        end else begin
            state <= next_state;
        end
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: next_state = in ? IDLE : START; // Wait for start bit (0)
            START: next_state = DATA;
            DATA: next_state = (bit_count == 3'd7) ? STOP : DATA;
            STOP: next_state = in ? IDLE : STOP; // Wait for stop bit (1)
            default: next_state = IDLE;
        endcase
    end

    // Output and datapath logic
    always @(posedge clk) begin
        if (reset) begin
            shift_reg <= 8'b0;
            bit_count <= 3'b0;
            done_reg <= 1'b0;
        end else begin
            case (state)
                IDLE: begin
                    shift_reg <= 8'b0;
                    bit_count <= 3'b0;
                    done_reg <= 1'b0;
                end
                START: begin
                    bit_count <= 3'b0;
                end
                DATA: begin
                    shift_reg <= {in, shift_reg[7:1]}; // Shift in bits
                    bit_count <= bit_count + 1;
                end
                STOP: begin
                    if (in) begin // Stop bit is correct
                        done_reg <= 1'b1;
                    end
                end
            endcase
        end
    end

    assign done = done_reg;
    assign out_byte = done ? shift_reg : 8'b0; // Output valid byte when done

endmodule"
N/A,N/A,-1,9,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    // State and next state variables
    state_t state, next_state;

    // Bit counter for data bits
    logic [2:0] bit_count;

    // Shift register for incoming data bits
    logic [7:0] shift_reg;

    // State transition logic
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 3'd0;
            shift_reg <= 8'd0;
        end else begin
            state <= next_state;
            if (state == DATA) begin
                shift_reg <= {in, shift_reg[7:1]}; // Shift in the incoming bit
                bit_count <= bit_count + 1;
            end else if (state == STOP) begin
                bit_count <= 3'd0;
            end
        end
    end

    // Next state logic
    always_comb begin
        next_state = state;
        done = 1'b0;
        case (state)
            IDLE: begin
                if (in == 1'b0) // Detect start bit
                    next_state = START;
            end
            START: begin
                next_state = DATA;
            end
            DATA: begin
                if (bit_count == 3'd7) // Received all 8 data bits
                    next_state = STOP;
            end
            STOP: begin
                if (in == 1'b1) begin // Detect stop bit
                    done = 1'b1;
                    next_state = IDLE;
                end
            end
        endcase
    end

    // Output logic
    assign out_byte = (done) ? shift_reg : 8'd0;

endmodule"
N/A,N/A,-1,10,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    // State and next state variables
    state_t state, next_state;

    // Bit counter for data bits
    logic [2:0] bit_count;

    // Shift register for assembling the data byte
    logic [7:0] shift_reg;

    // Output registers
    logic [7:0] data_byte;
    logic done_reg;

    // State transition logic
    always_ff @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 3'd0;
            shift_reg <= 8'b0;
            done_reg <= 1'b0;
        end else begin
            state <= next_state;
            if (state == DATA) begin
                shift_reg <= {in, shift_reg[7:1]}; // Shift in the new bit
                bit_count <= bit_count + 3'd1;
            end
            if (state == STOP && in == 1'b1) begin
                data_byte <= shift_reg;
                done_reg <= 1'b1;
            end else begin
                done_reg <= 1'b0;
            end
        end
    end

    // Next state logic
    always_comb begin
        next_state = state;
        case (state)
            IDLE: begin
                if (in == 1'b0) // Start bit detected
                    next_state = START;
            end
            START: begin
                next_state = DATA;
            end
            DATA: begin
                if (bit_count == 3'd7) // All 8 data bits received
                    next_state = STOP;
            end
            STOP: begin
                if (in == 1'b1) // Stop bit detected
                    next_state = IDLE;
                else
                    next_state = STOP; // Wait for stop bit
            end
            default: next_state = IDLE;
        endcase
    end

    // Output assignments
    assign out_byte = data_byte;
    assign done = done_reg;

endmodule"
N/A,N/A,-1,11,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    // State and next state variables
    state_t state, next_state;

    // Bit counter for data bits
    logic [2:0] bit_count;

    // Shift register for assembling the data byte
    logic [7:0] shift_reg;

    // Output signals
    assign out_byte = shift_reg;
    assign done = (state == STOP);

    // State transition logic
    always_ff @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 3'b0;
            shift_reg <= 8'b0;
        end else begin
            state <= next_state;
            if (state == DATA) begin
                shift_reg <= {in, shift_reg[7:1]};
                bit_count <= bit_count + 1;
            end
        end
    end

    // Next state logic
    always_comb begin
        next_state = state;
        case (state)
            IDLE: begin
                if (in == 0)  // Detect start bit
                    next_state = START;
            end
            START: begin
                next_state = DATA;
            end
            DATA: begin
                if (bit_count == 7)
                    next_state = STOP;
            end
            STOP: begin
                if (in == 1)  // Detect stop bit
                    next_state = IDLE;
                else
                    next_state = STOP;  // Wait for stop bit
            end
        endcase
    end

endmodule"
N/A,N/A,-1,12,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    // State and next state variables
    state_t state, next_state;

    // Bit counter for data bits
    logic [2:0] bit_count;

    // Shift register for assembling the data byte
    logic [7:0] shift_reg;

    // Sequential logic for state transitions and data latching
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 3'd0;
            shift_reg <= 8'd0;
        end else begin
            state <= next_state;
            if (state == DATA) begin
                shift_reg <= {in, shift_reg[7:1]};
                bit_count <= bit_count + 1;
            end else if (state != DATA) begin
                bit_count <= 3'd0;
            end
        end
    end

    // Combinational logic for next state logic
    always_comb begin
        next_state = state;
        done = 1'b0;
        case (state)
            IDLE: begin
                if (in == 1'b0) begin  // Start bit detected
                    next_state = START;
                end
            end
            START: begin
                next_state = DATA;
            end
            DATA: begin
                if (bit_count == 3'd7) begin  // All 8 data bits received
                    next_state = STOP;
                end
            end
            STOP: begin
                if (in == 1'b1) begin  // Stop bit detected
                    next_state = IDLE;
                    done = 1'b1;
                end else begin
                    next_state = IDLE;  // Wait for a valid stop bit
                end
            end
        endcase
    end

    // Output logic
    assign out_byte = shift_reg;

endmodule"
N/A,N/A,-1,13,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

parameter IDLE = 0, START = 1, DATA = 2, STOP = 3;
    reg [1:0] state, next_state;
    reg [7:0] shift_reg;
    reg [2:0] bit_count;

    // State transition logic
    always @ (posedge clk) begin
        if (reset) begin
            state <= IDLE;
        end else begin
            state <= next_state;
        end
    end

    // Next state logic
    always @ (*) begin
        case (state)
            IDLE: begin
                if (in == 0) // Start bit detected
                    next_state = START;
                else
                    next_state = IDLE;
            end
            START: begin
                next_state = DATA;
            end
            DATA: begin
                if (bit_count == 7)
                    next_state = STOP;
                else
                    next_state = DATA;
            end
            STOP: begin
                if (in == 1) // Stop bit detected
                    next_state = IDLE;
                else
                    next_state = STOP;
            end
            default: next_state = IDLE;
        endcase
    end

    // Output and shift register logic
    always @ (posedge clk) begin
        if (reset) begin
            shift_reg <= 8'b0;
            bit_count <= 3'b0;
        end else begin
            case (state)
                IDLE: begin
                    bit_count <= 3'b0;
                end
                START: begin
                    bit_count <= 3'b0;
                end
                DATA: begin
                    shift_reg <= {in, shift_reg[7:1]};
                    bit_count <= bit_count + 1;
                end
                STOP: begin
                    if (in == 1) begin
                        out_byte <= shift_reg;
                    end
                end
            endcase
        end
    end

    // Done signal logic
    assign done = (state == STOP && in == 1);

endmodule"
N/A,N/A,-1,14,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    state_t current_state, next_state;
    logic [7:0] shift_reg;
    logic [2:0] bit_counter;

    // State transition logic
    always_ff @(posedge clk) begin
        if (reset) begin
            current_state <= IDLE;
            shift_reg <= 8'b0;
            bit_counter <= 3'b0;
        end else begin
            current_state <= next_state;
            if (current_state == DATA) begin
                shift_reg <= {in, shift_reg[7:1]};
                bit_counter <= bit_counter + 1'b1;
            end
        end
    end

    // Next state logic
    always_comb begin
        next_state = current_state;
        done = 1'b0;

        case (current_state)
            IDLE: begin
                if (in == 1'b0) // Start bit detected
                    next_state = START;
            end
            START: begin
                next_state = DATA;
            end
            DATA: begin
                if (bit_counter == 3'd7)
                    next_state = STOP;
            end
            STOP: begin
                if (in == 1'b1) begin // Stop bit detected
                    done = 1'b1;
                    next_state = IDLE;
                end
            end
        endcase
    end

    // Output logic
    assign out_byte = shift_reg;

endmodule"
N/A,N/A,-1,15,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    // State registers
    state_t current_state, next_state;
    reg [7:0] shift_reg;
    reg [2:0] bit_count;

    // FSM state transition
    always_ff @(posedge clk) begin
        if (reset) begin
            current_state <= IDLE;
            shift_reg <= 8'b0;
            bit_count <= 3'b0;
        end else begin
            current_state <= next_state;
            if (current_state == DATA) begin
                shift_reg <= {in, shift_reg[7:1]};
                bit_count <= bit_count + 1;
            end else if (current_state == IDLE) begin
                bit_count <= 3'b0;
            end
        end
    end

    // FSM next state logic
    always_comb begin
        next_state = current_state;
        done = 0;
        
        case (current_state)
            IDLE: begin
                if (in == 0)  // Start bit detected
                    next_state = START;
            end
            START: begin
                next_state = DATA;  // Move to data state
            end
            DATA: begin
                if (bit_count == 3'd7)  // All 8 data bits received
                    next_state = STOP;
            end
            STOP: begin
                if (in == 1) begin  // Valid stop bit
                    done = 1;
                    next_state = IDLE;
                end else begin
                    next_state = IDLE;  // Wait for a valid stop bit
                end
            end
        endcase
    end

    // Output logic
    assign out_byte = (done) ? shift_reg : 8'b0;

endmodule"
N/A,N/A,-1,16,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    // State registers
    state_t current_state, next_state;
    logic [2:0] bit_count;
    logic [7:0] shift_reg;

    // State transition logic
    always_ff @(posedge clk) begin
        if (reset) begin
            current_state <= IDLE;
            bit_count <= 3'd0;
            shift_reg <= 8'd0;
        end else begin
            current_state <= next_state;
            if (current_state == DATA) begin
                shift_reg <= {in, shift_reg[7:1]};
                bit_count <= bit_count + 1;
            end else if (current_state == IDLE) begin
                bit_count <= 3'd0;
            end
        end
    end

    // Next state logic
    always_comb begin
        next_state = current_state;
        done = 1'b0;
        case (current_state)
            IDLE: begin
                if (in == 1'b0) begin // Detect start bit
                    next_state = START;
                end
            end
            START: begin
                next_state = DATA;
            end
            DATA: begin
                if (bit_count == 3'd7) begin
                    next_state = STOP;
                end
            end
            STOP: begin
                if (in == 1'b1) begin // Detect stop bit
                    done = 1'b1;
                    next_state = IDLE;
                end else begin
                    next_state = IDLE; // Wait for stop bit
                end
            end
        endcase
    end

    // Output logic
    assign out_byte = shift_reg;

endmodule"
N/A,N/A,-1,17,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    // State registers
    state_t current_state, next_state;
    logic [2:0] bit_counter; // Counter for data bits
    logic [7:0] shift_reg;   // Shift register for data bits

    // Output logic
    assign done = (current_state == STOP);
    assign out_byte = (done) ? shift_reg : 8'b0;

    // State transition logic
    always_ff @(posedge clk) begin
        if (reset) begin
            current_state <= IDLE;
            bit_counter <= 3'b0;
            shift_reg <= 8'b0;
        end else begin
            current_state <= next_state;
            if (current_state == DATA) begin
                shift_reg <= {in, shift_reg[7:1]};
                bit_counter <= bit_counter + 1;
            end
        end
    end

    // Next state logic
    always_comb begin
        next_state = current_state;
        case (current_state)
            IDLE: begin
                if (in == 0) // Start bit detected
                    next_state = START;
            end
            START: begin
                next_state = DATA;
            end
            DATA: begin
                if (bit_counter == 3'd7)
                    next_state = STOP;
            end
            STOP: begin
                if (in == 1) // Stop bit detected
                    next_state = IDLE;
                else
                    next_state = STOP; // Wait for stop bit to be high
            end
        endcase
    end
endmodule"
N/A,N/A,-0.1,18,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

parameter IDLE = 0, START = 1, DATA = 2, STOP = 3;
    reg [1:0] state, next_state;
    reg [7:0] shift_reg;
    reg [2:0] bit_count;
    reg done_reg;

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
        end else begin
            state <= next_state;
        end
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: next_state = (in == 0) ? START : IDLE;
            START: next_state = DATA;
            DATA: next_state = (bit_count == 7) ? STOP : DATA;
            STOP: next_state = (in == 1) ? IDLE : STOP;
            default: next_state = IDLE;
        endcase
    end

    // Output logic and bit shifting
    always @(posedge clk) begin
        if (reset) begin
            shift_reg <= 8'b0;
            bit_count <= 3'b0;
            done_reg <= 1'b0;
        end else begin
            case (state)
                IDLE: begin
                    shift_reg <= 8'b0;
                    bit_count <= 3'b0;
                    done_reg <= 1'b0;
                end
                START: begin
                    bit_count <= 3'b0;
                end
                DATA: begin
                    shift_reg <= {in, shift_reg[7:1]};
                    bit_count <= bit_count + 1;
                end
                STOP: begin
                    if (in == 1) begin
                        done_reg <= 1'b1;
                    end
                end
            endcase
        end
    end

    assign out_byte = shift_reg;
    assign done = done_reg;

endmodule"
N/A,N/A,-1,19,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    state_t current_state, next_state;
    logic [7:0] shift_reg;
    logic [2:0] bit_count;

    // State transition logic
    always_ff @(posedge clk) begin
        if (reset) begin
            current_state <= IDLE;
            shift_reg <= 8'b0;
            bit_count <= 3'b0;
        end
        else begin
            current_state <= next_state;
            if (current_state == DATA) begin
                shift_reg <= {in, shift_reg[7:1]};
                bit_count <= bit_count + 1;
            end
            else begin
                bit_count <= 3'b0;
            end
        end
    end

    // Next state logic
    always_comb begin
        next_state = current_state;
        done = 1'b0;
        case (current_state)
            IDLE: begin
                if (in == 1'b0) // Start bit detected
                    next_state = START;
            end
            START: begin
                next_state = DATA;
            end
            DATA: begin
                if (bit_count == 3'd7)
                    next_state = STOP;
            end
            STOP: begin
                if (in == 1'b1) begin // Valid stop bit
                    done = 1'b1;
                    next_state = IDLE;
                end
            end
        endcase
    end

    // Output logic
    assign out_byte = shift_reg;

endmodule"
N/A,N/A,-1,20,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP,
        DONE
    } state_t;

    state_t state, next_state;
    logic [7:0] shift_reg;
    logic [2:0] bit_count;

    // State transition logic
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            shift_reg <= 8'b0;
            bit_count <= 3'd0;
        end else begin
            state <= next_state;
            if (state == DATA) begin
                shift_reg <= {in, shift_reg[7:1]};
            end
            if (state == DATA || state == START) begin
                bit_count <= bit_count + 3'd1;
            end else begin
                bit_count <= 3'd0;
            end
        end
    end

    // Next state logic
    always_comb begin
        next_state = state;
        done = 1'b0;
        case (state)
            IDLE: begin
                if (in == 1'b0) begin  // Detect start bit (0)
                    next_state = START;
                end
            end
            START: begin
                if (bit_count == 3'd1) begin  // Wait for the start bit period
                    next_state = DATA;
                end
            end
            DATA: begin
                if (bit_count == 3'd8) begin  // 8 bits received
                    next_state = STOP;
                end
            end
            STOP: begin
                if (in == 1'b1) begin  // Detect stop bit (1)
                    next_state = DONE;
                end else begin  // If stop bit is not correct, wait in STOP
                    next_state = STOP;
                end
            end
            DONE: begin
                done = 1'b1;
                next_state = IDLE;  // Ready for next byte
            end
        endcase
    end

    // Output logic
    assign out_byte = (done) ? shift_reg : 8'bxxxx_xxxx;

endmodule"
N/A,N/A,-1,21,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    // State registers
    state_t current_state, next_state;
    logic [2:0] bit_counter; // Counter for data bits
    logic [7:0] shift_reg;   // Shift register for data bits

    // Output logic
    assign done = (current_state == STOP);

    // State transition logic
    always_ff @(posedge clk) begin
        if (reset) begin
            current_state <= IDLE;
            bit_counter <= 3'd0;
            shift_reg <= 8'd0;
        end else begin
            current_state <= next_state;
            if (current_state == DATA) begin
                shift_reg <= {in, shift_reg[7:1]}; // Shift in the new bit
                bit_counter <= bit_counter + 1;
            end else begin
                bit_counter <= 3'd0;
            end
        end
    end

    // Next state logic
    always_comb begin
        case (current_state)
            IDLE: begin
                if (in == 0) // Start bit detected
                    next_state = START;
                else
                    next_state = IDLE;
            end
            START: begin
                next_state = DATA;
            end
            DATA: begin
                if (bit_counter == 3'd7) // All 8 data bits received
                    next_state = STOP;
                else
                    next_state = DATA;
            end
            STOP: begin
                if (in == 1) // Stop bit detected
                    next_state = IDLE;
                else
                    next_state = STOP; // Wait for stop bit
            end
            default: next_state = IDLE;
        endcase
    end

    // Output data byte
    assign out_byte = (done) ? shift_reg : 8'bx;

endmodule"
N/A,N/A,-1,22,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    // State variables
    state_t current_state, next_state;
    logic [7:0] shift_reg;
    logic [2:0] bit_count;

    // State transition logic
    always_ff @(posedge clk) begin
        if (reset) begin
            current_state <= IDLE;
            shift_reg <= 8'b0;
            bit_count <= 3'b0;
        end else begin
            current_state <= next_state;
            if (current_state == DATA) begin
                shift_reg <= {in, shift_reg[7:1]};
                bit_count <= bit_count + 1;
            end else if (current_state == IDLE) begin
                bit_count <= 3'b0;
            end
        end
    end

    // Next state logic
    always_comb begin
        next_state = current_state;
        done = 1'b0;
        case (current_state)
            IDLE: begin
                if (in == 1'b0) // Detect start bit
                    next_state = START;
            end
            START: begin
                next_state = DATA;
            end
            DATA: begin
                if (bit_count == 3'b111) // 8 bits received
                    next_state = STOP;
            end
            STOP: begin
                if (in == 1'b1) begin // Detect stop bit
                    done = 1'b1;
                    next_state = IDLE;
                end else begin
                    next_state = IDLE; // Wait for stop bit
                end
            end
        endcase
    end

    // Output logic
    assign out_byte = (done) ? shift_reg : 8'b0;

endmodule"
N/A,N/A,-1,23,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP,
        DONE
    } state_t;

    state_t state, next_state;
    logic [7:0] shift_reg;
    logic [2:0] bit_count;

    // State transition logic
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            shift_reg <= 8'b0;
            bit_count <= 3'd0;
        end else begin
            state <= next_state;
            if (state == DATA) begin
                shift_reg <= {in, shift_reg[7:1]};
            end
            if (state == DATA || state == START) begin
                bit_count <= bit_count + 3'd1;
            end else begin
                bit_count <= 3'd0;
            end
        end
    end

    // Next state logic
    always_comb begin
        next_state = state;
        done = 1'b0;
        case (state)
            IDLE: begin
                if (in == 1'b0) begin  // Detect start bit
                    next_state = START;
                end
            end
            START: begin
                if (bit_count == 3'd1) begin
                    next_state = DATA;
                end
            end
            DATA: begin
                if (bit_count == 3'd8) begin
                    next_state = STOP;
                end
            end
            STOP: begin
                if (in == 1'b1) begin  // Detect stop bit
                    next_state = DONE;
                end else begin
                    next_state = IDLE;  // Error, reset to IDLE
                end
            end
            DONE: begin
                done = 1'b1;
                next_state = IDLE;
            end
        endcase
    end

    // Output logic
    assign out_byte = (done) ? shift_reg : 8'b0;

endmodule"
N/A,N/A,-1,24,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP,
        DONE
    } state_t;

    state_t state, next_state;
    logic [7:0] shift_reg;
    logic [2:0] bit_count;

    // State transition logic
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            shift_reg <= 8'b0;
            bit_count <= 3'd0;
        end else begin
            state <= next_state;
            if (state == DATA) begin
                shift_reg <= {in, shift_reg[7:1]};
            end
            if (state == DATA || state == START) begin
                bit_count <= bit_count + 3'd1;
            end else begin
                bit_count <= 3'd0;
            end
        end
    end

    // Next state logic
    always_comb begin
        next_state = state;
        done = 1'b0;
        case (state)
            IDLE: begin
                if (in == 1'b0) begin  // Detect start bit (0)
                    next_state = START;
                end
            end
            START: begin
                if (bit_count == 3'd1) begin  // Wait for the start bit period
                    next_state = DATA;
                end
            end
            DATA: begin
                if (bit_count == 3'd8) begin  // 8 bits received
                    next_state = STOP;
                end
            end
            STOP: begin
                if (in == 1'b1) begin  // Detect stop bit (1)
                    next_state = DONE;
                end else begin  // If stop bit is not correct, wait in STOP
                    next_state = STOP;
                end
            end
            DONE: begin
                done = 1'b1;
                next_state = IDLE;  // Ready for next byte
            end
        endcase
    end

    // Output logic
    assign out_byte = (done) ? shift_reg : 8'bx;

endmodule"
N/A,N/A,-1,25,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    // State registers
    state_t current_state, next_state;
    logic [7:0] shift_reg;
    logic [2:0] bit_count;

    // Sequential logic for state transition and data shifting
    always_ff @(posedge clk) begin
        if (reset) begin
            current_state <= IDLE;
            shift_reg <= 8'd0;
            bit_count <= 3'd0;
        end else begin
            current_state <= next_state;
            if (current_state == DATA) begin
                shift_reg <= {in, shift_reg[7:1]};
                bit_count <= bit_count + 1;
            end else begin
                bit_count <= 3'd0;
            end
        end
    end

    // Combinational logic for next state logic
    always_comb begin
        next_state = current_state;
        case (current_state)
            IDLE: begin
                if (in == 0) // Start bit detected
                    next_state = START;
            end
            START: begin
                next_state = DATA;
            end
            DATA: begin
                if (bit_count == 3'd7)
                    next_state = STOP;
            end
            STOP: begin
                if (in == 1) // Stop bit detected
                    next_state = IDLE;
                else
                    next_state = IDLE; // Wait for stop bit
            end
        endcase
    end

    // Output logic
    assign done = (current_state == STOP) && (in == 1);
    assign out_byte = done ? shift_reg : 8'dx;

endmodule"
N/A,N/A,-1,26,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    state_t current_state, next_state;
    logic [7:0] shift_reg;
    logic [2:0] bit_counter;

    // State transition logic
    always_ff @(posedge clk) begin
        if (reset) begin
            current_state <= IDLE;
            shift_reg <= 8'b0;
            bit_counter <= 3'b0;
        end else begin
            current_state <= next_state;
            if (current_state == DATA) begin
                shift_reg <= {in, shift_reg[7:1]};
                bit_counter <= bit_counter + 1'b1;
            end
        end
    end

    // Next state logic
    always_comb begin
        next_state = current_state;
        done = 1'b0;

        case (current_state)
            IDLE: begin
                if (in == 1'b0) // Start bit detected
                    next_state = START;
            end
            START: begin
                next_state = DATA;
            end
            DATA: begin
                if (bit_counter == 3'd7)
                    next_state = STOP;
            end
            STOP: begin
                if (in == 1'b1) begin // Stop bit detected
                    done = 1'b1;
                    next_state = IDLE;
                end
            end
        endcase
    end

    // Output logic
    assign out_byte = shift_reg;

endmodule"
N/A,N/A,-1,27,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    // State registers
    state_t current_state, next_state;
    logic [7:0] shift_reg;
    logic [2:0] bit_count;

    // State transition logic
    always_ff @(posedge clk) begin
        if (reset) begin
            current_state <= IDLE;
            shift_reg <= 8'b0;
            bit_count <= 3'b0;
        end else begin
            current_state <= next_state;
            if (current_state == DATA) begin
                shift_reg <= {in, shift_reg[7:1]};
                bit_count <= bit_count + 1;
            end else if (current_state == IDLE) begin
                bit_count <= 3'b0;
            end
        end
    end

    // Next state logic
    always_comb begin
        next_state = current_state;
        done = 1'b0;
        case (current_state)
            IDLE: begin
                if (in == 1'b0) begin // Detect start bit
                    next_state = START;
                end
            end
            START: begin
                next_state = DATA;
            end
            DATA: begin
                if (bit_count == 3'd7) begin
                    next_state = STOP;
                end
            end
            STOP: begin
                if (in == 1'b1) begin // Detect stop bit
                    done = 1'b1;
                    next_state = IDLE;
                end else begin
                    next_state = IDLE; // Wait for stop bit
                end
            end
        endcase
    end

    // Output logic
    assign out_byte = shift_reg;

endmodule"
N/A,N/A,-1,28,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    // State registers
    state_t current_state, next_state;
    reg [7:0] shift_reg;
    reg [2:0] bit_count;

    // FSM state transition
    always_ff @(posedge clk) begin
        if (reset) begin
            current_state <= IDLE;
            shift_reg <= 8'b0;
            bit_count <= 3'b0;
        end else begin
            current_state <= next_state;
            if (current_state == DATA) begin
                shift_reg <= {in, shift_reg[7:1]};
                bit_count <= bit_count + 1;
            end else if (current_state == IDLE) begin
                bit_count <= 3'b0;
            end
        end
    end

    // FSM next state logic
    always_comb begin
        next_state = current_state;
        done = 0;
        
        case (current_state)
            IDLE: begin
                if (in == 0)  // Start bit detected
                    next_state = START;
            end
            START: begin
                next_state = DATA;  // Move to data state after start bit
            end
            DATA: begin
                if (bit_count == 3'd7)  // All 8 bits received
                    next_state = STOP;
            end
            STOP: begin
                if (in == 1) begin  // Stop bit detected
                    done = 1;
                    next_state = IDLE;
                end
            end
        endcase
    end

    // Output logic
    assign out_byte = (done) ? shift_reg : 8'bx;

endmodule"
N/A,N/A,-1,29,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    // State and next state variables
    state_t state, next_state;

    // Bit counter for data bits
    logic [2:0] bit_count;

    // Shift register for assembling the data byte
    logic [7:0] shift_reg;

    // Sequential logic for state transitions
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 3'd0;
            shift_reg <= 8'd0;
        end else begin
            state <= next_state;
            if (state == DATA) begin
                shift_reg <= {in, shift_reg[7:1]}; // Shift in the new bit
                bit_count <= bit_count + 3'd1;
            end else if (state == START) begin
                bit_count <= 3'd0; // Reset bit counter at start of new byte
            end
        end
    end

    // Combinational logic for next state and output logic
    always_comb begin
        // Default assignments
        next_state = state;
        done = 1'b0;

        case (state)
            IDLE: begin
                if (in == 1'b0) // Detect start bit (active low)
                    next_state = START;
            end
            START: begin
                next_state = DATA;
            end
            DATA: begin
                if (bit_count == 3'd7)
                    next_state = STOP;
            end
            STOP: begin
                if (in == 1'b1) begin // Detect stop bit (active high)
                    done = 1'b1;
                    next_state = IDLE;
                end else begin
                    next_state = IDLE; // If stop bit is incorrect, return to IDLE
                end
            end
        endcase
    end

    // Output the byte when done is asserted
    assign out_byte = (done) ? shift_reg : 8'd0;

endmodule"
N/A,N/A,-1,30,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP,
        DONE
    } state_t;

    state_t state, next_state;
    logic [7:0] shift_reg;
    logic [2:0] bit_count;

    // State transition logic
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            shift_reg <= 8'b0;
            bit_count <= 3'd0;
        end else begin
            state <= next_state;
            if (state == DATA) begin
                shift_reg <= {in, shift_reg[7:1]};
            end
            if (state == DATA || state == START) begin
                bit_count <= bit_count + 3'd1;
            end else begin
                bit_count <= 3'd0;
            end
        end
    end

    // Next state logic
    always_comb begin
        next_state = state;
        done = 1'b0;
        case (state)
            IDLE: begin
                if (in == 1'b0) begin  // Detect start bit
                    next_state = START;
                end
            end
            START: begin
                if (bit_count == 3'd1) begin
                    next_state = DATA;
                end
            end
            DATA: begin
                if (bit_count == 3'd8) begin
                    next_state = STOP;
                end
            end
            STOP: begin
                if (in == 1'b1) begin  // Detect stop bit
                    next_state = DONE;
                end else begin
                    next_state = IDLE;  // Error, reset to IDLE
                end
            end
            DONE: begin
                done = 1'b1;
                next_state = IDLE;
            end
        endcase
    end

    // Output logic
    assign out_byte = (done) ? shift_reg : 8'bx;

endmodule"
N/A,N/A,-1,31,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP,
        DONE
    } state_t;

    state_t state, next_state;
    logic [7:0] shift_reg;
    logic [2:0] bit_count;

    // State transition logic
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            shift_reg <= 8'b0;
            bit_count <= 3'd0;
        end else begin
            state <= next_state;
            if (state == DATA) begin
                shift_reg <= {in, shift_reg[7:1]};
            end
            if (state == DATA || state == START) begin
                bit_count <= bit_count + 3'd1;
            end else begin
                bit_count <= 3'd0;
            end
        end
    end

    // Next state logic
    always_comb begin
        next_state = state;
        done = 1'b0;
        case (state)
            IDLE: begin
                if (in == 1'b0) begin  // Detect start bit
                    next_state = START;
                end
            end
            START: begin
                if (bit_count == 3'd1) begin
                    next_state = DATA;
                end
            end
            DATA: begin
                if (bit_count == 3'd8) begin
                    next_state = STOP;
                end
            end
            STOP: begin
                if (in == 1'b1) begin  // Detect stop bit
                    next_state = DONE;
                end else begin
                    next_state = IDLE;  // Error, reset to IDLE
                end
            end
            DONE: begin
                done = 1'b1;
                next_state = IDLE;
            end
        endcase
    end

    // Output logic
    assign out_byte = (done) ? shift_reg : 8'bx;

endmodule"
N/A,N/A,-1,32,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP,
        DONE
    } state_t;

    state_t state, next_state;
    logic [7:0] shift_reg;
    logic [2:0] bit_count;

    // State transition logic
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            shift_reg <= 8'b0;
            bit_count <= 3'd0;
        end else begin
            state <= next_state;
            if (state == DATA) begin
                shift_reg <= {in, shift_reg[7:1]};
            end
            if (state == DATA || state == START) begin
                bit_count <= bit_count + 3'd1;
            end else begin
                bit_count <= 3'd0;
            end
        end
    end

    // Next state logic
    always_comb begin
        next_state = state;
        done = 1'b0;
        case (state)
            IDLE: begin
                if (in == 1'b0) // Start bit detected
                    next_state = START;
            end
            START: begin
                if (bit_count == 3'd0)
                    next_state = DATA;
            end
            DATA: begin
                if (bit_count == 3'd8)
                    next_state = STOP;
            end
            STOP: begin
                if (in == 1'b1) begin // Stop bit detected
                    next_state = DONE;
                end else begin
                    next_state = IDLE; // Incorrect stop bit, wait for a new start bit
                end
            end
            DONE: begin
                done = 1'b1;
                next_state = IDLE;
            end
        endcase
    end

    // Output logic
    assign out_byte = (done) ? shift_reg : 8'b0;

endmodule"
N/A,N/A,-1,33,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP,
        DONE
    } state_t;

    state_t state, next_state;
    logic [7:0] shift_reg;
    logic [2:0] bit_count;

    // State transition logic
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            shift_reg <= 8'b0;
            bit_count <= 3'd0;
        end else begin
            state <= next_state;
            if (state == DATA) begin
                shift_reg <= {in, shift_reg[7:1]};
            end
            if (state == DATA || state == START) begin
                bit_count <= bit_count + 3'd1;
            end else begin
                bit_count <= 3'd0;
            end
        end
    end

    // Next state logic
    always_comb begin
        next_state = state;
        done = 1'b0;
        case (state)
            IDLE: begin
                if (in == 1'b0) begin  // Detect start bit (0)
                    next_state = START;
                end
            end
            START: begin
                if (bit_count == 3'd1) begin  // Wait for the start bit period
                    next_state = DATA;
                end
            end
            DATA: begin
                if (bit_count == 3'd8) begin  // 8 bits received
                    next_state = STOP;
                end
            end
            STOP: begin
                if (in == 1'b1) begin  // Detect stop bit (1)
                    next_state = DONE;
                end else begin  // If stop bit is not correct, wait in STOP
                    next_state = STOP;
                end
            end
            DONE: begin
                done = 1'b1;
                next_state = IDLE;  // Ready for next byte
            end
        endcase
    end

    // Output logic
    assign out_byte = (done) ? shift_reg : 8'bxxxx_xxxx;

endmodule"
N/A,N/A,-1,34,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP,
        DONE
    } state_t;

    state_t state, next_state;
    logic [7:0] shift_reg;
    logic [2:0] bit_count;

    // State transition logic
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            shift_reg <= 8'b0;
            bit_count <= 3'd0;
        end else begin
            state <= next_state;
            if (state == DATA) begin
                shift_reg <= {in, shift_reg[7:1]};
            end
            if (state == DATA || state == START) begin
                bit_count <= bit_count + 3'd1;
            end else begin
                bit_count <= 3'd0;
            end
        end
    end

    // Next state logic
    always_comb begin
        next_state = state;
        done = 1'b0;
        case (state)
            IDLE: begin
                if (in == 1'b0) begin  // Detect start bit (0)
                    next_state = START;
                end
            end
            START: begin
                if (bit_count == 3'd1) begin  // Wait for the start bit period
                    next_state = DATA;
                end
            end
            DATA: begin
                if (bit_count == 3'd8) begin  // 8 bits received
                    next_state = STOP;
                end
            end
            STOP: begin
                if (in == 1'b1) begin  // Detect stop bit (1)
                    next_state = DONE;
                end else begin  // If stop bit is not correct, wait in STOP state
                    next_state = IDLE;
                end
            end
            DONE: begin
                done = 1'b1;
                next_state = IDLE;
            end
        endcase
    end

    // Output logic
    assign out_byte = (done) ? shift_reg : 8'b0;

endmodule"
N/A,N/A,-1,35,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP,
        DONE
    } state_t;

    state_t state, next_state;
    logic [7:0] shift_reg;
    logic [2:0] bit_count;

    // State transition logic
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            shift_reg <= 8'b0;
            bit_count <= 3'd0;
        end else begin
            state <= next_state;
            if (state == DATA) begin
                shift_reg <= {in, shift_reg[7:1]};
            end
            if (state == DATA || state == START) begin
                bit_count <= bit_count + 3'd1;
            end else begin
                bit_count <= 3'd0;
            end
        end
    end

    // Next state logic
    always_comb begin
        next_state = state;
        done = 1'b0;
        case (state)
            IDLE: begin
                if (in == 1'b0) // Start bit detected
                    next_state = START;
            end
            START: begin
                if (bit_count == 3'd0)
                    next_state = DATA;
            end
            DATA: begin
                if (bit_count == 3'd7)
                    next_state = STOP;
            end
            STOP: begin
                if (in == 1'b1) begin // Stop bit detected
                    next_state = DONE;
                end else begin
                    next_state = IDLE; // Incorrect stop bit, wait for a new start bit
                end
            end
            DONE: begin
                done = 1'b1;
                next_state = IDLE;
            end
        endcase
    end

    // Output logic
    assign out_byte = (done) ? shift_reg : 8'b0;

endmodule"
N/A,N/A,-0.1,36,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

parameter IDLE = 0, START = 1, DATA = 2, STOP = 3;
    reg [1:0] state, next_state;
    reg [7:0] shift_reg;
    reg [2:0] bit_count;
    reg done_reg;

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
        end else begin
            state <= next_state;
        end
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 0) // Start bit detected
                    next_state = START;
                else
                    next_state = IDLE;
            end
            START: begin
                next_state = DATA;
            end
            DATA: begin
                if (bit_count == 7)
                    next_state = STOP;
                else
                    next_state = DATA;
            end
            STOP: begin
                if (in == 1) // Stop bit detected
                    next_state = IDLE;
                else
                    next_state = STOP; // Wait for stop bit
            end
            default: next_state = IDLE;
        endcase
    end

    // Output logic and data path
    always @(posedge clk) begin
        if (reset) begin
            shift_reg <= 8'b0;
            bit_count <= 3'b0;
            done_reg <= 0;
        end else begin
            case (state)
                IDLE: begin
                    shift_reg <= 8'b0;
                    bit_count <= 3'b0;
                    done_reg <= 0;
                end
                START: begin
                    bit_count <= 3'b0;
                end
                DATA: begin
                    shift_reg <= {in, shift_reg[7:1]}; // Shift in LSB first
                    bit_count <= bit_count + 1;
                end
                STOP: begin
                    if (in == 1) begin
                        done_reg <= 1;
                    end
                end
            endcase
        end
    end

    assign out_byte = shift_reg;
    assign done = done_reg;

endmodule"
N/A,N/A,-1,37,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP,
        DONE
    } state_t;

    state_t state, next_state;
    logic [7:0] shift_reg;
    logic [2:0] bit_count;

    // State transition logic
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            shift_reg <= 8'b0;
            bit_count <= 3'd0;
        end else begin
            state <= next_state;
            if (state == DATA) begin
                shift_reg <= {in, shift_reg[7:1]};
            end
            if (state == DATA || state == START) begin
                bit_count <= bit_count + 3'd1;
            end else begin
                bit_count <= 3'd0;
            end
        end
    end

    // Next state logic
    always_comb begin
        next_state = state;
        done = 1'b0;
        case (state)
            IDLE: begin
                if (in == 1'b0) // Start bit detected
                    next_state = START;
            end
            START: begin
                if (bit_count == 3'd0)
                    next_state = DATA;
            end
            DATA: begin
                if (bit_count == 3'd7)
                    next_state = STOP;
            end
            STOP: begin
                if (in == 1'b1) begin // Stop bit detected
                    next_state = DONE;
                end else begin
                    next_state = IDLE; // Incorrect stop bit, wait for a new start bit
                end
            end
            DONE: begin
                done = 1'b1;
                next_state = IDLE;
            end
        endcase
    end

    // Output logic
    assign out_byte = (done) ? shift_reg : 8'b0;

endmodule"
N/A,N/A,-1,38,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP,
        DONE
    } state_t;

    state_t state, next_state;
    logic [7:0] shift_reg;
    logic [2:0] bit_count;

    // State transition logic
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            shift_reg <= 8'b0;
            bit_count <= 3'd0;
        end else begin
            state <= next_state;
            if (state == DATA) begin
                shift_reg <= {in, shift_reg[7:1]};
            end
            if (state == DATA || state == START) begin
                bit_count <= bit_count + 3'd1;
            end else begin
                bit_count <= 3'd0;
            end
        end
    end

    // Next state logic
    always_comb begin
        next_state = state;
        done = 1'b0;
        case (state)
            IDLE: begin
                if (in == 1'b0) begin  // Detect start bit (0)
                    next_state = START;
                end
            end
            START: begin
                if (bit_count == 3'd1) begin  // Wait for the start bit period
                    next_state = DATA;
                end
            end
            DATA: begin
                if (bit_count == 3'd8) begin  // 8 bits received
                    next_state = STOP;
                end
            end
            STOP: begin
                if (in == 1'b1) begin  // Detect stop bit (1)
                    next_state = DONE;
                end else begin  // If stop bit is not correct, wait in STOP state
                    next_state = IDLE;
                end
            end
            DONE: begin
                done = 1'b1;
                next_state = IDLE;  // Return to IDLE after byte is processed
            end
        endcase
    end

    // Output logic
    assign out_byte = (done) ? shift_reg : 8'b0;

endmodule"
N/A,N/A,-1,39,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    // State and next state variables
    state_t state, next_state;

    // Bit counter for data bits
    logic [2:0] bit_count;

    // Shift register for assembling the data byte
    logic [7:0] shift_reg;

    // Output registers
    logic [7:0] data_byte;
    logic done_reg;

    // State transition logic
    always_ff @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 3'd0;
            shift_reg <= 8'b0;
            done_reg <= 1'b0;
        end else begin
            state <= next_state;
            if (state == DATA) begin
                shift_reg <= {in, shift_reg[7:1]}; // Shift in the new bit
                bit_count <= bit_count + 3'd1;
            end
            if (state == STOP && in == 1'b1) begin
                data_byte <= shift_reg;
                done_reg <= 1'b1;
            end else begin
                done_reg <= 1'b0;
            end
        end
    end

    // Next state logic
    always_comb begin
        next_state = state;
        case (state)
            IDLE: begin
                if (in == 1'b0) // Start bit detected
                    next_state = START;
            end
            START: begin
                next_state = DATA;
            end
            DATA: begin
                if (bit_count == 3'd7) // All 8 data bits received
                    next_state = STOP;
            end
            STOP: begin
                if (in == 1'b1) // Stop bit detected
                    next_state = IDLE;
                else
                    next_state = STOP; // Wait for stop bit
            end
            default: next_state = IDLE;
        endcase
    end

    // Output assignments
    assign out_byte = data_byte;
    assign done = done_reg;

endmodule"
N/A,N/A,-1,40,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP,
        DONE
    } state_t;

    state_t state, next_state;
    logic [7:0] shift_reg;
    logic [2:0] bit_count;

    // State transition logic
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            shift_reg <= 8'b0;
            bit_count <= 3'd0;
        end else begin
            state <= next_state;
            if (state == DATA) begin
                shift_reg <= {in, shift_reg[7:1]};
            end
            if (state == DATA || state == START) begin
                bit_count <= bit_count + 3'd1;
            end else begin
                bit_count <= 3'd0;
            end
        end
    end

    // Next state logic
    always_comb begin
        next_state = state;
        done = 1'b0;
        case (state)
            IDLE: begin
                if (in == 1'b0) begin  // Detect start bit (0)
                    next_state = START;
                end
            end
            START: begin
                if (bit_count == 3'd1) begin  // Wait for the start bit period
                    next_state = DATA;
                end
            end
            DATA: begin
                if (bit_count == 3'd8) begin  // 8 bits received
                    next_state = STOP;
                end
            end
            STOP: begin
                if (in == 1'b1) begin  // Detect stop bit (1)
                    next_state = DONE;
                end else begin  // If stop bit is not correct, wait in STOP
                    next_state = STOP;
                end
            end
            DONE: begin
                done = 1'b1;
                next_state = IDLE;  // Ready for next byte
            end
        endcase
    end

    // Output logic
    assign out_byte = (done) ? shift_reg : 8'b0;

endmodule"
N/A,N/A,-1,41,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    // State registers
    state_t current_state, next_state;
    logic [2:0] bit_counter; // Counter for data bits
    logic [7:0] shift_reg;   // Shift register for data bits

    // Output logic
    assign done = (current_state == STOP);

    // State transition logic
    always_ff @(posedge clk) begin
        if (reset) begin
            current_state <= IDLE;
            bit_counter <= 3'd0;
            shift_reg <= 8'd0;
        end else begin
            current_state <= next_state;
            if (current_state == DATA) begin
                shift_reg <= {in, shift_reg[7:1]}; // Shift in the new bit
                bit_counter <= bit_counter + 1;
            end
        end
    end

    // Next state logic
    always_comb begin
        next_state = current_state; // Default to hold state
        case (current_state)
            IDLE: begin
                if (in == 0) // Detect start bit
                    next_state = START;
            end
            START: begin
                next_state = DATA;
            end
            DATA: begin
                if (bit_counter == 3'd7)
                    next_state = STOP;
            end
            STOP: begin
                if (in == 1) // Detect stop bit
                    next_state = IDLE;
            end
        endcase
    end

    // Output data byte when done is high
    assign out_byte = (done) ? shift_reg : 8'dx;

endmodule"
N/A,N/A,-1,42,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP,
        DONE
    } state_t;

    state_t state, next_state;
    logic [7:0] shift_reg;
    logic [2:0] bit_count;

    // State transition logic
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            shift_reg <= 8'b0;
            bit_count <= 3'd0;
        end else begin
            state <= next_state;
            if (state == DATA) begin
                shift_reg <= {in, shift_reg[7:1]};
            end
            if (state == DATA || state == START) begin
                bit_count <= bit_count + 3'd1;
            end else begin
                bit_count <= 3'd0;
            end
        end
    end

    // Next state logic
    always_comb begin
        next_state = state;
        done = 1'b0;
        case (state)
            IDLE: begin
                if (in == 1'b0) begin  // Detect start bit (0)
                    next_state = START;
                end
            end
            START: begin
                if (bit_count == 3'd1) begin  // Wait for the start bit period
                    next_state = DATA;
                end
            end
            DATA: begin
                if (bit_count == 3'd8) begin  // 8 bits received
                    next_state = STOP;
                end
            end
            STOP: begin
                if (in == 1'b1) begin  // Detect stop bit (1)
                    next_state = DONE;
                end else begin  // If stop bit is not correct, wait in STOP state
                    next_state = STOP;
                end
            end
            DONE: begin
                done = 1'b1;
                next_state = IDLE;  // After done, go back to IDLE
            end
        endcase
    end

    // Output logic
    assign out_byte = (done) ? shift_reg : 8'b0;

endmodule"
N/A,N/A,-1,43,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP,
        DONE
    } state_t;

    state_t state, next_state;
    logic [7:0] shift_reg;
    logic [2:0] bit_count;

    // State transition logic
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            shift_reg <= 8'b0;
            bit_count <= 3'd0;
        end else begin
            state <= next_state;
            if (state == DATA) begin
                shift_reg <= {in, shift_reg[7:1]};
            end
            if (state == DATA || state == START) begin
                bit_count <= bit_count + 3'd1;
            end else begin
                bit_count <= 3'd0;
            end
        end
    end

    // Next state logic
    always_comb begin
        next_state = state;
        done = 1'b0;
        case (state)
            IDLE: begin
                if (in == 1'b0) begin  // Detect start bit
                    next_state = START;
                end
            end
            START: begin
                if (bit_count == 3'd1) begin
                    next_state = DATA;
                end
            end
            DATA: begin
                if (bit_count == 3'd8) begin
                    next_state = STOP;
                end
            end
            STOP: begin
                if (in == 1'b1) begin  // Detect stop bit
                    next_state = DONE;
                end else begin
                    next_state = IDLE;  // Error, reset to IDLE
                end
            end
            DONE: begin
                done = 1'b1;
                next_state = IDLE;
            end
        endcase
    end

    // Output logic
    assign out_byte = (done) ? shift_reg : 8'b0;

endmodule"
N/A,N/A,-1,44,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP,
        DONE
    } state_t;

    state_t state, next_state;
    logic [7:0] shift_reg;
    logic [2:0] bit_count;

    // State transition logic
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            shift_reg <= 8'b0;
            bit_count <= 3'd0;
        end else begin
            state <= next_state;
            if (state == DATA) begin
                shift_reg <= {in, shift_reg[7:1]};
            end
            if (state == DATA || state == START) begin
                bit_count <= bit_count + 3'd1;
            end else begin
                bit_count <= 3'd0;
            end
        end
    end

    // Next state logic
    always_comb begin
        next_state = state;
        done = 1'b0;
        case (state)
            IDLE: begin
                if (in == 1'b0) begin  // Detect start bit (0)
                    next_state = START;
                end
            end
            START: begin
                if (bit_count == 3'd1) begin  // Wait for the start bit period
                    next_state = DATA;
                end
            end
            DATA: begin
                if (bit_count == 3'd8) begin  // 8 bits received
                    next_state = STOP;
                end
            end
            STOP: begin
                if (in == 1'b1) begin  // Detect stop bit (1)
                    next_state = DONE;
                end else begin  // If stop bit is not correct, wait in STOP state
                    next_state = STOP;
                end
            end
            DONE: begin
                done = 1'b1;
                next_state = IDLE;  // Return to IDLE after done
            end
        endcase
    end

    // Output logic
    assign out_byte = (done) ? shift_reg : 8'bx;

endmodule"
N/A,N/A,-0.1,45,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

parameter IDLE = 0, START = 1, DATA = 2, STOP = 3;
    reg [1:0] state, next_state;
    reg [7:0] shift_reg;
    reg [2:0] bit_count;
    reg done_reg;

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
        end else begin
            state <= next_state;
        end
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 0) // Start bit detected
                    next_state = START;
                else
                    next_state = IDLE;
            end
            START: begin
                next_state = DATA;
            end
            DATA: begin
                if (bit_count == 7)
                    next_state = STOP;
                else
                    next_state = DATA;
            end
            STOP: begin
                if (in == 1) // Stop bit detected
                    next_state = IDLE;
                else
                    next_state = STOP;
            end
            default: next_state = IDLE;
        endcase
    end

    // Output logic and data path updates
    always @(posedge clk) begin
        if (reset) begin
            shift_reg <= 8'b0;
            bit_count <= 3'b0;
            done_reg <= 1'b0;
        end else begin
            case (state)
                IDLE: begin
                    done_reg <= 1'b0;
                end
                START: begin
                    bit_count <= 3'b0;
                end
                DATA: begin
                    shift_reg <= {in, shift_reg[7:1]};
                    bit_count <= bit_count + 1;
                end
                STOP: begin
                    if (in == 1) begin
                        done_reg <= 1'b1;
                    end
                end
            endcase
        end
    end

    // Assign outputs
    assign out_byte = shift_reg;
    assign done = done_reg;

endmodule"
N/A,N/A,-1,46,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP,
        DONE
    } state_t;

    state_t state, next_state;
    logic [7:0] shift_reg;
    logic [2:0] bit_count;

    // State transition logic
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            shift_reg <= 8'b0;
            bit_count <= 3'd0;
        end else begin
            state <= next_state;
            if (state == DATA) begin
                shift_reg <= {in, shift_reg[7:1]};
            end
            if (state == DATA || state == START) begin
                bit_count <= bit_count + 3'd1;
            end else begin
                bit_count <= 3'd0;
            end
        end
    end

    // Next state logic
    always_comb begin
        next_state = state;
        done = 1'b0;
        case (state)
            IDLE: begin
                if (in == 1'b0) begin  // Detect start bit (0)
                    next_state = START;
                end
            end
            START: begin
                if (bit_count == 3'd1) begin  // Wait for the start bit period
                    next_state = DATA;
                end
            end
            DATA: begin
                if (bit_count == 3'd8) begin  // 8 bits received
                    next_state = STOP;
                end
            end
            STOP: begin
                if (in == 1'b1) begin  // Detect stop bit (1)
                    next_state = DONE;
                end else begin  // If stop bit is not correct, wait in STOP state
                    next_state = STOP;
                end
            end
            DONE: begin
                done = 1'b1;
                next_state = IDLE;  // After done, go back to IDLE
            end
        endcase
    end

    // Output logic
    assign out_byte = (done) ? shift_reg : 8'b0;

endmodule"
N/A,N/A,-0.1,47,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

parameter IDLE = 0, START = 1, DATA = 2, STOP = 3;
    reg [1:0] state, next_state;
    reg [7:0] shift_reg;
    reg [2:0] bit_count;
    reg done_reg;

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
        end else begin
            state <= next_state;
        end
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 0) // Start bit detected
                    next_state = START;
                else
                    next_state = IDLE;
            end
            START: begin
                next_state = DATA;
            end
            DATA: begin
                if (bit_count == 7)
                    next_state = STOP;
                else
                    next_state = DATA;
            end
            STOP: begin
                if (in == 1) // Stop bit detected
                    next_state = IDLE;
                else
                    next_state = STOP;
            end
            default: next_state = IDLE;
        endcase
    end

    // Output and data path logic
    always @(posedge clk) begin
        if (reset) begin
            shift_reg <= 8'b0;
            bit_count <= 3'b0;
            done_reg <= 1'b0;
        end else begin
            case (state)
                IDLE: begin
                    shift_reg <= 8'b0;
                    bit_count <= 3'b0;
                    done_reg <= 1'b0;
                end
                START: begin
                    bit_count <= 3'b0;
                end
                DATA: begin
                    shift_reg <= {in, shift_reg[7:1]}; // Shift in the data bit
                    bit_count <= bit_count + 1;
                end
                STOP: begin
                    if (in == 1) begin // Stop bit correct
                        done_reg <= 1'b1;
                    end
                end
            endcase
        end
    end

    assign out_byte = shift_reg;
    assign done = done_reg;

endmodule"
N/A,N/A,-1,48,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP,
        DONE
    } state_t;
    
    state_t state, next_state;
    logic [2:0] bit_count;
    logic [7:0] shift_reg;

    // FSM state transition
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 3'd0;
            shift_reg <= 8'd0;
        end else begin
            state <= next_state;
            if (state == DATA) begin
                shift_reg <= {in, shift_reg[7:1]};
                bit_count <= bit_count + 1'b1;
            end
        end
    end

    // FSM next state logic
    always_comb begin
        next_state = state;
        done = 1'b0;
        case (state)
            IDLE: begin
                if (in == 1'b0) // Start bit detected
                    next_state = START;
            end
            START: begin
                next_state = DATA;
            end
            DATA: begin
                if (bit_count == 3'd7)
                    next_state = STOP;
            end
            STOP: begin
                if (in == 1'b1) begin // Stop bit detected
                    next_state = DONE;
                end else begin
                    next_state = IDLE; // Wait for start bit again
                end
            end
            DONE: begin
                done = 1'b1;
                next_state = IDLE;
            end
        endcase
    end

    // Output logic
    assign out_byte = (done) ? shift_reg : 8'd0;

endmodule"
N/A,N/A,-1,49,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP,
        DONE
    } state_t;

    state_t state, next_state;
    logic [7:0] shift_reg;
    logic [2:0] bit_count;

    // State transition logic
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            shift_reg <= 8'b0;
            bit_count <= 3'd0;
        end else begin
            state <= next_state;
            if (state == DATA) begin
                shift_reg <= {in, shift_reg[7:1]};
            end
            if (state == DATA || state == START) begin
                bit_count <= bit_count + 3'd1;
            end else begin
                bit_count <= 3'd0;
            end
        end
    end

    // Next state logic
    always_comb begin
        next_state = state;
        done = 1'b0;
        case (state)
            IDLE: begin
                if (in == 1'b0) begin  // Detect start bit
                    next_state = START;
                end
            end
            START: begin
                if (bit_count == 3'd1) begin
                    next_state = DATA;
                end
            end
            DATA: begin
                if (bit_count == 3'd8) begin
                    next_state = STOP;
                end
            end
            STOP: begin
                if (in == 1'b1) begin  // Detect stop bit
                    next_state = DONE;
                end else begin
                    next_state = IDLE;  // Error, reset to IDLE
                end
            end
            DONE: begin
                done = 1'b1;
                next_state = IDLE;
            end
        endcase
    end

    // Output logic
    assign out_byte = (done) ? shift_reg : 8'bx;

endmodule"
N/A,N/A,-1,50,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP,
        DONE
    } state_t;

    state_t state, next_state;
    logic [7:0] shift_reg;
    logic [2:0] bit_count;

    // State transition logic
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            shift_reg <= 8'b0;
            bit_count <= 3'd0;
        end else begin
            state <= next_state;
            if (state == DATA) begin
                shift_reg <= {in, shift_reg[7:1]};
            end
            if (state == DATA || state == START) begin
                bit_count <= bit_count + 3'd1;
            end else begin
                bit_count <= 3'd0;
            end
        end
    end

    // Next state logic
    always_comb begin
        next_state = state;
        done = 1'b0;
        case (state)
            IDLE: begin
                if (in == 1'b0) begin  // Detect start bit (0)
                    next_state = START;
                end
            end
            START: begin
                if (bit_count == 3'd1) begin  // Wait for the start bit period
                    next_state = DATA;
                end
            end
            DATA: begin
                if (bit_count == 3'd8) begin  // 8 bits received
                    next_state = STOP;
                end
            end
            STOP: begin
                if (in == 1'b1) begin  // Detect stop bit (1)
                    next_state = DONE;
                end else begin  // If stop bit is not correct, wait in STOP
                    next_state = STOP;
                end
            end
            DONE: begin
                done = 1'b1;
                next_state = IDLE;  // Ready for next byte
            end
        endcase
    end

    // Output logic
    assign out_byte = (done) ? shift_reg : 8'bx;

endmodule"
N/A,N/A,-0.1,51,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

parameter IDLE = 0, START = 1, DATA = 2, STOP = 3;
    reg [1:0] state, next_state;
    reg [7:0] shift_reg;
    reg [2:0] bit_count;
    reg done_reg;

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
        end else begin
            state <= next_state;
        end
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 0) // Start bit detected
                    next_state = START;
                else
                    next_state = IDLE;
            end
            START: begin
                next_state = DATA;
            end
            DATA: begin
                if (bit_count == 7)
                    next_state = STOP;
                else
                    next_state = DATA;
            end
            STOP: begin
                if (in == 1) // Stop bit detected
                    next_state = IDLE;
                else
                    next_state = STOP; // Wait for stop bit
            end
            default: next_state = IDLE;
        endcase
    end

    // Output logic and data path
    always @(posedge clk) begin
        if (reset) begin
            shift_reg <= 8'b0;
            bit_count <= 3'b0;
            done_reg <= 0;
        end else begin
            case (state)
                IDLE: begin
                    shift_reg <= 8'b0;
                    bit_count <= 3'b0;
                    done_reg <= 0;
                end
                START: begin
                    bit_count <= 3'b0;
                end
                DATA: begin
                    shift_reg <= {in, shift_reg[7:1]}; // Shift in LSB first
                    bit_count <= bit_count + 1;
                end
                STOP: begin
                    if (in == 1) begin
                        done_reg <= 1;
                    end
                end
            endcase
        end
    end

    assign out_byte = shift_reg;
    assign done = done_reg;

endmodule"
N/A,N/A,-1,52,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP,
        DONE
    } state_t;

    state_t state, next_state;
    logic [7:0] shift_reg;
    logic [2:0] bit_count;

    // State transition logic
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            shift_reg <= 8'b0;
            bit_count <= 3'd0;
        end else begin
            state <= next_state;
            if (state == DATA) begin
                shift_reg <= {in, shift_reg[7:1]};
            end
            if (state == DATA || state == START) begin
                bit_count <= bit_count + 3'd1;
            end else begin
                bit_count <= 3'd0;
            end
        end
    end

    // Next state logic
    always_comb begin
        next_state = state;
        done = 1'b0;
        case (state)
            IDLE: begin
                if (in == 1'b0) begin  // Detect start bit (0)
                    next_state = START;
                end
            end
            START: begin
                if (bit_count == 3'd1) begin  // Wait for the start bit period
                    next_state = DATA;
                end
            end
            DATA: begin
                if (bit_count == 3'd8) begin  // 8 bits received
                    next_state = STOP;
                end
            end
            STOP: begin
                if (in == 1'b1) begin  // Detect stop bit (1)
                    next_state = DONE;
                end else begin  // If stop bit is not correct, wait in STOP state
                    next_state = IDLE;
                end
            end
            DONE: begin
                done = 1'b1;
                next_state = IDLE;
            end
        endcase
    end

    // Output logic
    assign out_byte = (done) ? shift_reg : 8'b0;

endmodule"
N/A,N/A,-1,53,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP,
        DONE
    } state_t;

    state_t state, next_state;
    logic [7:0] shift_reg;
    logic [2:0] bit_count;

    // State transition logic
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            shift_reg <= 8'b0;
            bit_count <= 3'd0;
        end else begin
            state <= next_state;
            if (state == DATA) begin
                shift_reg <= {in, shift_reg[7:1]};
            end
            if (state == DATA || state == START) begin
                bit_count <= bit_count + 3'd1;
            end else begin
                bit_count <= 3'd0;
            end
        end
    end

    // Next state logic
    always_comb begin
        next_state = state;
        done = 1'b0;
        case (state)
            IDLE: begin
                if (in == 1'b0) begin  // Detect start bit (0)
                    next_state = START;
                end
            end
            START: begin
                if (bit_count == 3'd1) begin  // Wait for the start bit period
                    next_state = DATA;
                end
            end
            DATA: begin
                if (bit_count == 3'd8) begin  // 8 bits received
                    next_state = STOP;
                end
            end
            STOP: begin
                if (in == 1'b1) begin  // Detect stop bit (1)
                    next_state = DONE;
                end else begin  // If stop bit is not correct, wait in STOP
                    next_state = STOP;
                end
            end
            DONE: begin
                done = 1'b1;
                next_state = IDLE;  // Ready for the next byte
            end
        endcase
    end

    // Output logic
    assign out_byte = (done) ? shift_reg : 8'bx;

endmodule"
N/A,N/A,-1,54,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    // State registers
    state_t current_state, next_state;
    logic [2:0] bit_count;
    logic [7:0] shift_reg;

    // State transition logic
    always_ff @(posedge clk) begin
        if (reset) begin
            current_state <= IDLE;
            bit_count <= 3'd0;
            shift_reg <= 8'd0;
        end else begin
            current_state <= next_state;
            if (current_state == DATA) begin
                shift_reg <= {in, shift_reg[7:1]};
                bit_count <= bit_count + 1;
            end else if (current_state == IDLE) begin
                bit_count <= 3'd0;
            end
        end
    end

    // Next state logic
    always_comb begin
        next_state = current_state;
        done = 1'b0;
        case (current_state)
            IDLE: begin
                if (in == 1'b0) begin
                    next_state = START;
                end
            end
            START: begin
                next_state = DATA;
            end
            DATA: begin
                if (bit_count == 3'd7) begin
                    next_state = STOP;
                end
            end
            STOP: begin
                if (in == 1'b1) begin
                    next_state = IDLE;
                    done = 1'b1;
                end else begin
                    next_state = IDLE; // Wait for next start bit
                end
            end
        endcase
    end

    // Output logic
    assign out_byte = (done) ? shift_reg : 8'd0;

endmodule"
N/A,N/A,-1,55,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    // State registers
    state_t current_state, next_state;
    logic [2:0] bit_counter; // Counter for data bits
    logic [7:0] shift_reg;   // Shift register for data bits

    // Output logic
    assign done = (current_state == STOP);

    // State transition logic
    always_ff @(posedge clk) begin
        if (reset) begin
            current_state <= IDLE;
            bit_counter <= 3'd0;
            shift_reg <= 8'd0;
        end else begin
            current_state <= next_state;
            if (current_state == DATA) begin
                shift_reg <= {in, shift_reg[7:1]}; // Shift in the new bit
                bit_counter <= bit_counter + 1;
            end
        end
    end

    // Next state logic
    always_comb begin
        next_state = current_state; // Default to hold state
        case (current_state)
            IDLE: begin
                if (in == 0) // Detect start bit
                    next_state = START;
            end
            START: begin
                next_state = DATA;
            end
            DATA: begin
                if (bit_counter == 3'd7)
                    next_state = STOP;
            end
            STOP: begin
                if (in == 1) // Detect stop bit
                    next_state = IDLE;
                else
                    next_state = STOP; // Wait for stop bit
            end
        endcase
    end

    // Output data byte
    assign out_byte = (done) ? shift_reg : 8'bx; // Valid when done is 1

endmodule"
N/A,N/A,-0.1,56,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

parameter IDLE = 0, START = 1, DATA = 2, STOP = 3;
    reg [1:0] state, next_state;
    reg [7:0] shift_reg;
    reg [2:0] bit_count;
    reg done_reg;

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
        end else begin
            state <= next_state;
        end
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 0) // Start bit detected
                    next_state = START;
                else
                    next_state = IDLE;
            end
            START: begin
                next_state = DATA;
            end
            DATA: begin
                if (bit_count == 7)
                    next_state = STOP;
                else
                    next_state = DATA;
            end
            STOP: begin
                if (in == 1) // Stop bit detected
                    next_state = IDLE;
                else
                    next_state = STOP;
            end
            default: next_state = IDLE;
        endcase
    end

    // Output logic and data path
    always @(posedge clk) begin
        if (reset) begin
            shift_reg <= 8'b0;
            bit_count <= 3'b0;
            done_reg <= 1'b0;
        end else begin
            case (state)
                IDLE: begin
                    shift_reg <= 8'b0;
                    bit_count <= 3'b0;
                    done_reg <= 1'b0;
                end
                START: begin
                    bit_count <= 3'b0;
                end
                DATA: begin
                    shift_reg <= {in, shift_reg[7:1]}; // Shift in the data bit
                    bit_count <= bit_count + 1;
                end
                STOP: begin
                    if (in == 1) begin // Stop bit detected
                        done_reg <= 1'b1;
                    end
                end
            endcase
        end
    end

    assign out_byte = shift_reg;
    assign done = done_reg;

endmodule"
N/A,N/A,-1,57,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP,
        DONE
    } state_t;

    state_t state, next_state;
    logic [7:0] shift_reg;
    logic [2:0] bit_count;

    // State transition logic
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            shift_reg <= 8'b0;
            bit_count <= 3'd0;
        end else begin
            state <= next_state;
            if (state == DATA) begin
                shift_reg <= {in, shift_reg[7:1]};
            end
            if (state == DATA || state == START) begin
                bit_count <= bit_count + 3'd1;
            end else begin
                bit_count <= 3'd0;
            end
        end
    end

    // Next state logic
    always_comb begin
        next_state = state;
        done = 1'b0;
        case (state)
            IDLE: begin
                if (in == 1'b0) begin  // Detect start bit
                    next_state = START;
                end
            end
            START: begin
                if (bit_count == 3'd1) begin
                    next_state = DATA;
                end
            end
            DATA: begin
                if (bit_count == 3'd8) begin
                    next_state = STOP;
                end
            end
            STOP: begin
                if (in == 1'b1) begin  // Detect stop bit
                    next_state = DONE;
                end else begin
                    next_state = IDLE;  // Error, reset to IDLE
                end
            end
            DONE: begin
                done = 1'b1;
                next_state = IDLE;
            end
        endcase
    end

    // Output logic
    assign out_byte = (done) ? shift_reg : 8'bx;

endmodule"
N/A,N/A,-1,58,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    // State variables
    state_t state, next_state;
    logic [2:0] bit_count;
    logic [7:0] shift_reg;

    // State transition
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
            shift_reg <= 8'b0;
        end else begin
            state <= next_state;
            if (state == DATA) begin
                bit_count <= bit_count + 1;
                shift_reg <= {in, shift_reg[7:1]};
            end else if (state != DATA) begin
                bit_count <= 0;
            end
        end
    end

    // Next state logic
    always_comb begin
        next_state = state;
        case (state)
            IDLE: begin
                if (in == 0) // Start bit detected
                    next_state = START;
            end
            START: begin
                next_state = DATA;
            end
            DATA: begin
                if (bit_count == 7)
                    next_state = STOP;
            end
            STOP: begin
                if (in == 1) // Stop bit detected
                    next_state = IDLE;
                else
                    next_state = STOP; // Wait for stop bit
            end
        endcase
    end

    // Output logic
    assign done = (state == STOP) && (in == 1);
    assign out_byte = (done) ? shift_reg : 8'bx;

endmodule"
N/A,N/A,-1,59,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP,
        DONE
    } state_t;

    state_t state, next_state;
    logic [7:0] shift_reg;
    logic [2:0] bit_count;

    // State transition logic
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            shift_reg <= 8'b0;
            bit_count <= 3'd0;
        end else begin
            state <= next_state;
            if (state == DATA) begin
                shift_reg <= {in, shift_reg[7:1]};
            end
            if (state == DATA || state == START) begin
                bit_count <= bit_count + 3'd1;
            end else begin
                bit_count <= 3'd0;
            end
        end
    end

    // Next state logic
    always_comb begin
        next_state = state;
        done = 1'b0;
        case (state)
            IDLE: begin
                if (in == 1'b0) begin  // Detect start bit (0)
                    next_state = START;
                end
            end
            START: begin
                if (bit_count == 3'd1) begin  // Wait for the start bit period
                    next_state = DATA;
                end
            end
            DATA: begin
                if (bit_count == 3'd8) begin  // 8 bits received
                    next_state = STOP;
                end
            end
            STOP: begin
                if (in == 1'b1) begin  // Detect stop bit (1)
                    next_state = DONE;
                end else begin  // If stop bit is not correct, wait in STOP state
                    next_state = STOP;
                end
            end
            DONE: begin
                done = 1'b1;
                next_state = IDLE;
            end
        endcase
    end

    // Output logic
    assign out_byte = (done) ? shift_reg : 8'bx;
endmodule"
N/A,N/A,-1,60,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP,
        DONE
    } state_t;

    state_t state, next_state;
    logic [7:0] shift_reg;
    logic [2:0] bit_count;

    // State transition logic
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            shift_reg <= 8'b0;
            bit_count <= 3'd0;
        end else begin
            state <= next_state;
            if (state == DATA) begin
                shift_reg <= {in, shift_reg[7:1]};
            end
            if (state == DATA || state == START) begin
                bit_count <= bit_count + 3'd1;
            end else begin
                bit_count <= 3'd0;
            end
        end
    end

    // Next state logic
    always_comb begin
        next_state = state;
        done = 1'b0;
        case (state)
            IDLE: begin
                if (in == 1'b0) begin  // Detect start bit (0)
                    next_state = START;
                end
            end
            START: begin
                if (bit_count == 3'd1) begin  // Wait for the start bit period
                    next_state = DATA;
                end
            end
            DATA: begin
                if (bit_count == 3'd8) begin  // 8 bits received
                    next_state = STOP;
                end
            end
            STOP: begin
                if (in == 1'b1) begin  // Detect stop bit (1)
                    next_state = DONE;
                end else if (bit_count == 3'd8) begin  // If stop bit not detected, wait
                    next_state = IDLE;
                end
            end
            DONE: begin
                done = 1'b1;
                next_state = IDLE;
            end
        endcase
    end

    // Output logic
    assign out_byte = (done) ? shift_reg : 8'bx;

endmodule"
N/A,N/A,-1,61,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    // State and next state variables
    state_t state, next_state;

    // Bit counter for data bits
    logic [2:0] bit_count;

    // Shift register for assembling the data byte
    logic [7:0] shift_reg;

    // Output registers
    logic [7:0] data_byte;
    logic done_reg;

    // State transition logic
    always_ff @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 3'd0;
            shift_reg <= 8'b0;
            done_reg <= 1'b0;
        end else begin
            state <= next_state;
            if (state == DATA) begin
                shift_reg <= {in, shift_reg[7:1]}; // Shift in the new bit
                bit_count <= bit_count + 3'd1;
            end
            if (state == STOP && in == 1'b1) begin
                data_byte <= shift_reg;
                done_reg <= 1'b1;
            end else begin
                done_reg <= 1'b0;
            end
        end
    end

    // Next state logic
    always_comb begin
        next_state = state;
        case (state)
            IDLE: begin
                if (in == 1'b0) // Start bit detected
                    next_state = START;
            end
            START: begin
                next_state = DATA;
            end
            DATA: begin
                if (bit_count == 3'd7) // All 8 data bits received
                    next_state = STOP;
            end
            STOP: begin
                if (in == 1'b1) // Stop bit detected
                    next_state = IDLE;
                else
                    next_state = STOP; // Wait for stop bit
            end
            default: next_state = IDLE;
        endcase
    end

    // Output assignments
    assign out_byte = data_byte;
    assign done = done_reg;

endmodule"
N/A,N/A,-1,62,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP,
        DONE
    } state_t;

    state_t state, next_state;
    logic [7:0] shift_reg;
    logic [2:0] bit_count;

    // State transition logic
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            shift_reg <= 8'b0;
            bit_count <= 3'd0;
        end else begin
            state <= next_state;
            if (state == DATA) begin
                shift_reg <= {in, shift_reg[7:1]};
            end
            if (state == DATA || state == START) begin
                bit_count <= bit_count + 3'd1;
            end else begin
                bit_count <= 3'd0;
            end
        end
    end

    // Next state logic
    always_comb begin
        next_state = state;
        done = 1'b0;
        case (state)
            IDLE: begin
                if (in == 1'b0) begin  // Detect start bit (0)
                    next_state = START;
                end
            end
            START: begin
                if (bit_count == 3'd1) begin  // Wait for the start bit period
                    next_state = DATA;
                end
            end
            DATA: begin
                if (bit_count == 3'd8) begin  // 8 bits received
                    next_state = STOP;
                end
            end
            STOP: begin
                if (in == 1'b1) begin  // Detect stop bit (1)
                    next_state = DONE;
                end else begin  // If stop bit is not correct, wait in STOP state
                    next_state = STOP;
                end
            end
            DONE: begin
                done = 1'b1;
                next_state = IDLE;  // Return to IDLE to wait for the next byte
            end
        endcase
    end

    // Output logic
    assign out_byte = (done) ? shift_reg : 8'b0;

endmodule"
N/A,N/A,-1,63,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    // State registers
    state_t current_state, next_state;
    logic [2:0] bit_counter; // Counter for data bits
    logic [7:0] shift_reg;   // Shift register for data bits

    // Output logic
    assign done = (current_state == STOP);

    // State transition logic
    always_ff @(posedge clk) begin
        if (reset) begin
            current_state <= IDLE;
            bit_counter <= 3'd0;
            shift_reg <= 8'd0;
        end else begin
            current_state <= next_state;
            if (current_state == DATA) begin
                shift_reg <= {in, shift_reg[7:1]}; // Shift in the new bit
                bit_counter <= bit_counter + 1;
            end else begin
                bit_counter <= 3'd0;
            end
        end
    end

    // Next state logic
    always_comb begin
        case (current_state)
            IDLE: begin
                if (in == 0) // Start bit detected
                    next_state = START;
                else
                    next_state = IDLE;
            end
            START: begin
                next_state = DATA;
            end
            DATA: begin
                if (bit_counter == 3'd7) // All 8 data bits received
                    next_state = STOP;
                else
                    next_state = DATA;
            end
            STOP: begin
                if (in == 1) // Stop bit detected
                    next_state = IDLE;
                else
                    next_state = STOP; // Wait for stop bit
            end
            default: next_state = IDLE;
        endcase
    end

    // Output data byte
    always_ff @(posedge clk) begin
        if (done)
            out_byte <= shift_reg;
        else
            out_byte <= 8'd0; // Don't care when not done
    end

endmodule"
N/A,N/A,-1,64,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    // State variables
    state_t state, next_state;
    logic [2:0] bit_count;
    logic [7:0] shift_reg;

    // State transition
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 3'd0;
            shift_reg <= 8'd0;
        end else begin
            state <= next_state;
            if (state == DATA) begin
                shift_reg <= {in, shift_reg[7:1]};
                bit_count <= bit_count + 1'b1;
            end
        end
    end

    // Next state logic
    always_comb begin
        next_state = state;
        done = 1'b0;
        case (state)
            IDLE: begin
                if (in == 1'b0) begin // Start bit detected
                    next_state = START;
                end
            end
            START: begin
                next_state = DATA;
            end
            DATA: begin
                if (bit_count == 3'd7) begin
                    next_state = STOP;
                end
            end
            STOP: begin
                if (in == 1'b1) begin // Stop bit detected
                    done = 1'b1;
                    next_state = IDLE;
                end else begin
                    next_state = IDLE; // Wait for stop bit
                end
            end
        endcase
    end

    // Output logic
    assign out_byte = shift_reg;

endmodule"
N/A,N/A,-1,65,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    // State and next state variables
    state_t state, next_state;

    // Bit counter for data bits
    logic [2:0] bit_count;

    // Shift register for incoming data bits
    logic [7:0] shift_reg;

    // State transition logic
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 3'd0;
            shift_reg <= 8'd0;
        end else begin
            state <= next_state;
            if (state == DATA) begin
                shift_reg <= {in, shift_reg[7:1]}; // Shift in the incoming bit
                bit_count <= bit_count + 1;
            end else if (state == STOP) begin
                bit_count <= 3'd0;
            end
        end
    end

    // Next state logic
    always_comb begin
        next_state = state;
        done = 1'b0;
        case (state)
            IDLE: begin
                if (in == 1'b0) // Detect start bit
                    next_state = START;
            end
            START: begin
                next_state = DATA;
            end
            DATA: begin
                if (bit_count == 3'd7) // Received all 8 data bits
                    next_state = STOP;
            end
            STOP: begin
                if (in == 1'b1) begin // Detect stop bit
                    done = 1'b1;
                    next_state = IDLE;
                end
            end
        endcase
    end

    // Output logic
    assign out_byte = (done) ? shift_reg : 8'd0;

endmodule"
N/A,N/A,-1,66,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP,
        DONE
    } state_t;

    state_t state, next_state;
    logic [7:0] shift_reg;
    logic [2:0] bit_count;

    // State transition logic
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            shift_reg <= 8'b0;
            bit_count <= 3'd0;
        end else begin
            state <= next_state;
            if (state == DATA) begin
                shift_reg <= {in, shift_reg[7:1]};
            end
            if (state == DATA || state == START) begin
                bit_count <= bit_count + 3'd1;
            end else begin
                bit_count <= 3'd0;
            end
        end
    end

    // Next state logic
    always_comb begin
        next_state = state;
        done = 1'b0;
        case (state)
            IDLE: begin
                if (in == 1'b0) begin  // Detect start bit (0)
                    next_state = START;
                end
            end
            START: begin
                if (bit_count == 3'd1) begin  // Wait for the start bit period
                    next_state = DATA;
                end
            end
            DATA: begin
                if (bit_count == 3'd8) begin  // 8 bits received
                    next_state = STOP;
                end
            end
            STOP: begin
                if (in == 1'b1) begin  // Detect stop bit (1)
                    next_state = DONE;
                end else begin  // If stop bit is not correct, wait in STOP
                    next_state = STOP;
                end
            end
            DONE: begin
                done = 1'b1;
                next_state = IDLE;  // Ready for next byte
            end
        endcase
    end

    // Output logic
    assign out_byte = (done) ? shift_reg : 8'b0;

endmodule"
N/A,N/A,-0.1,67,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

parameter IDLE = 0, START = 1, DATA = 2, STOP = 3;
    reg [1:0] state, next_state;
    reg [2:0] bit_count;
    reg [7:0] shift_reg;
    reg done_reg;

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
        end else begin
            state <= next_state;
        end
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 0) // Start bit detected
                    next_state = START;
                else
                    next_state = IDLE;
            end
            START: begin
                next_state = DATA;
            end
            DATA: begin
                if (bit_count == 7)
                    next_state = STOP;
                else
                    next_state = DATA;
            end
            STOP: begin
                if (in == 1) // Stop bit detected
                    next_state = IDLE;
                else
                    next_state = STOP; // Wait for stop bit
            end
            default: next_state = IDLE;
        endcase
    end

    // Output logic and bit counter
    always @(posedge clk) begin
        if (reset) begin
            bit_count <= 0;
            shift_reg <= 0;
            done_reg <= 0;
        end else begin
            case (state)
                IDLE: begin
                    bit_count <= 0;
                    done_reg <= 0;
                end
                START: begin
                    bit_count <= 0;
                end
                DATA: begin
                    shift_reg <= {in, shift_reg[7:1]};
                    bit_count <= bit_count + 1;
                end
                STOP: begin
                    if (in == 1) begin // Valid stop bit
                        done_reg <= 1;
                    end else begin
                        done_reg <= 0;
                    end
                end
            endcase
        end
    end

    assign out_byte = shift_reg;
    assign done = done_reg;

endmodule"
N/A,N/A,-1,68,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP,
        DONE
    } state_t;

    state_t state, next_state;
    logic [7:0] shift_reg;
    logic [2:0] bit_count;

    // State transition logic
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            shift_reg <= 8'b0;
            bit_count <= 3'd0;
        end else begin
            state <= next_state;
            if (state == DATA) begin
                shift_reg <= {in, shift_reg[7:1]};
            end
            if (state == DATA || state == START) begin
                bit_count <= bit_count + 3'd1;
            end else begin
                bit_count <= 3'd0;
            end
        end
    end

    // Next state logic
    always_comb begin
        next_state = state;
        done = 1'b0;
        case (state)
            IDLE: begin
                if (in == 1'b0) // Start bit detected
                    next_state = START;
            end
            START: begin
                if (bit_count == 3'd0)
                    next_state = DATA;
            end
            DATA: begin
                if (bit_count == 3'd7)
                    next_state = STOP;
            end
            STOP: begin
                if (in == 1'b1) begin // Stop bit detected
                    next_state = DONE;
                end else begin
                    next_state = IDLE; // Incorrect stop bit, wait for a new start bit
                end
            end
            DONE: begin
                done = 1'b1;
                next_state = IDLE;
            end
        endcase
    end

    // Output logic
    assign out_byte = (done) ? shift_reg : 8'b0;

endmodule"
N/A,N/A,-0.1,69,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

parameter IDLE = 0, START = 1, DATA = 2, STOP = 3;
    reg [1:0] state, next_state;
    reg [7:0] shift_reg;
    reg [2:0] bit_count;
    reg done_reg;

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
        end else begin
            state <= next_state;
        end
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 0) // Start bit detected
                    next_state = START;
                else
                    next_state = IDLE;
            end
            START: begin
                next_state = DATA;
            end
            DATA: begin
                if (bit_count == 7)
                    next_state = STOP;
                else
                    next_state = DATA;
            end
            STOP: begin
                if (in == 1) // Stop bit detected
                    next_state = IDLE;
                else
                    next_state = STOP; // Wait for stop bit
            end
            default: next_state = IDLE;
        endcase
    end

    // Output logic and data path
    always @(posedge clk) begin
        if (reset) begin
            shift_reg <= 8'b0;
            bit_count <= 3'b0;
            done_reg <= 0;
        end else begin
            case (state)
                IDLE: begin
                    shift_reg <= 8'b0;
                    bit_count <= 3'b0;
                    done_reg <= 0;
                end
                START: begin
                    bit_count <= 0;
                end
                DATA: begin
                    shift_reg <= {in, shift_reg[7:1]}; // Shift in LSB first
                    bit_count <= bit_count + 1;
                end
                STOP: begin
                    if (in == 1) begin // Stop bit correct
                        done_reg <= 1;
                    end else begin
                        done_reg <= 0;
                    end
                end
            endcase
        end
    end

    assign out_byte = shift_reg;
    assign done = done_reg;

endmodule"
N/A,N/A,-1,70,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    // State variables
    state_t state, next_state;
    logic [2:0] bit_count;
    logic [7:0] shift_reg;

    // State transition
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
            shift_reg <= 8'b0;
        end else begin
            state <= next_state;
            if (state == DATA) begin
                shift_reg <= {in, shift_reg[7:1]};
                bit_count <= bit_count + 1;
            end
        end
    end

    // Next state logic
    always_comb begin
        next_state = state;
        case (state)
            IDLE: begin
                if (in == 0) // Start bit detected
                    next_state = START;
            end
            START: begin
                next_state = DATA;
            end
            DATA: begin
                if (bit_count == 7)
                    next_state = STOP;
            end
            STOP: begin
                if (in == 1) // Correct stop bit
                    next_state = IDLE;
                else
                    next_state = STOP; // Wait for stop bit
            end
        endcase
    end

    // Output logic
    assign done = (state == STOP) && (in == 1);
    assign out_byte = shift_reg;

endmodule"
N/A,N/A,-1,71,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP,
        DONE
    } state_t;

    state_t state, next_state;
    logic [7:0] shift_reg;
    logic [2:0] bit_count;

    // State transition logic
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            shift_reg <= 8'b0;
            bit_count <= 3'd0;
        end else begin
            state <= next_state;
            if (state == DATA) begin
                shift_reg <= {in, shift_reg[7:1]};
            end
            if (state == DATA || state == START) begin
                bit_count <= bit_count + 3'd1;
            end else begin
                bit_count <= 3'd0;
            end
        end
    end

    // Next state logic
    always_comb begin
        next_state = state;
        done = 1'b0;
        case (state)
            IDLE: begin
                if (in == 1'b0) begin  // Detect start bit (0)
                    next_state = START;
                end
            end
            START: begin
                if (bit_count == 3'd1) begin  // Wait for the start bit period
                    next_state = DATA;
                end
            end
            DATA: begin
                if (bit_count == 3'd8) begin  // 8 bits received
                    next_state = STOP;
                end
            end
            STOP: begin
                if (in == 1'b1) begin  // Detect stop bit (1)
                    next_state = DONE;
                end else begin  // If stop bit is not correct, wait in STOP state
                    next_state = IDLE;
                end
            end
            DONE: begin
                done = 1'b1;
                next_state = IDLE;
            end
        endcase
    end

    // Output logic
    assign out_byte = (done) ? shift_reg : 8'b0;

endmodule"
N/A,N/A,-1,72,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    // State registers
    state_t current_state, next_state;
    logic [2:0] bit_count;
    logic [7:0] shift_reg;

    // State transition logic
    always_ff @(posedge clk) begin
        if (reset) begin
            current_state <= IDLE;
            bit_count <= 3'd0;
            shift_reg <= 8'd0;
        end else begin
            current_state <= next_state;
            if (current_state == DATA) begin
                shift_reg <= {in, shift_reg[7:1]};
                bit_count <= bit_count + 1;
            end else if (current_state == IDLE) begin
                bit_count <= 3'd0;
            end
        end
    end

    // Next state logic
    always_comb begin
        next_state = current_state; // Default to stay in current state
        done = 1'b0;
        case (current_state)
            IDLE: begin
                if (!in) // Start bit detected (active low)
                    next_state = START;
            end
            START: begin
                next_state = DATA;
            end
            DATA: begin
                if (bit_count == 3'd7) // After 8 bits
                    next_state = STOP;
            end
            STOP: begin
                if (in) begin // Stop bit detected (active high)
                    done = 1'b1;
                    next_state = IDLE;
                end
            end
        endcase
    end

    // Output logic
    assign out_byte = (done) ? shift_reg : 8'bx;

endmodule"
N/A,N/A,-1,73,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP,
        DONE
    } state_t;

    state_t state, next_state;
    logic [7:0] shift_reg;
    logic [2:0] bit_count;

    // State transition logic
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            shift_reg <= 8'b0;
            bit_count <= 3'd0;
        end else begin
            state <= next_state;
            if (state == DATA) begin
                shift_reg <= {in, shift_reg[7:1]};
            end
            if (state == DATA || state == START) begin
                bit_count <= bit_count + 3'd1;
            end else begin
                bit_count <= 3'd0;
            end
        end
    end

    // Next state logic
    always_comb begin
        next_state = state;
        done = 1'b0;
        case (state)
            IDLE: begin
                if (in == 1'b0) begin  // Detect start bit
                    next_state = START;
                end
            end
            START: begin
                if (bit_count == 3'd1) begin
                    next_state = DATA;
                end
            end
            DATA: begin
                if (bit_count == 3'd8) begin
                    next_state = STOP;
                end
            end
            STOP: begin
                if (in == 1'b1) begin  // Detect stop bit
                    next_state = DONE;
                end else begin
                    next_state = IDLE;  // Error, return to IDLE
                end
            end
            DONE: begin
                done = 1'b1;
                next_state = IDLE;
            end
        endcase
    end

    // Output logic
    assign out_byte = (done) ? shift_reg : 8'bx;

endmodule"
N/A,N/A,-1,74,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    // State registers
    state_t current_state, next_state;
    reg [7:0] shift_reg; // Shift register to store the received byte
    reg [2:0] bit_count; // Counter for the data bits

    // State transition logic
    always_ff @(posedge clk) begin
        if (reset) begin
            current_state <= IDLE;
            shift_reg <= 8'b0;
            bit_count <= 3'b0;
        end else begin
            current_state <= next_state;
            if (current_state == DATA) begin
                shift_reg <= {in, shift_reg[7:1]}; // Shift in the new bit
                bit_count <= bit_count + 1;
            end else if (current_state == STOP) begin
                bit_count <= 3'b0;
            end
        end
    end

    // Next state logic
    always_comb begin
        next_state = current_state;
        case (current_state)
            IDLE: begin
                if (in == 0) // Detect start bit
                    next_state = START;
            end
            START: begin
                next_state = DATA;
            end
            DATA: begin
                if (bit_count == 3'b111) // After 8 bits
                    next_state = STOP;
            end
            STOP: begin
                if (in == 1) // Detect stop bit
                    next_state = IDLE;
            end
        endcase
    end

    // Output logic
    assign done = (current_state == STOP && in == 1);
    assign out_byte = (done) ? shift_reg : 8'b0;

endmodule"
N/A,N/A,-1,75,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP,
        DONE
    } state_t;

    state_t state, next_state;
    logic [7:0] shift_reg;
    logic [2:0] bit_count;

    // State transition logic
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            shift_reg <= 8'b0;
            bit_count <= 3'd0;
        end else begin
            state <= next_state;
            if (state == DATA) begin
                shift_reg <= {in, shift_reg[7:1]};
            end
            if (state == DATA || state == START) begin
                bit_count <= bit_count + 3'd1;
            end else begin
                bit_count <= 3'd0;
            end
        end
    end

    // Next state logic
    always_comb begin
        next_state = state;
        done = 1'b0;
        case (state)
            IDLE: begin
                if (in == 1'b0) begin  // Detect start bit
                    next_state = START;
                end
            end
            START: begin
                if (bit_count == 3'd1) begin
                    next_state = DATA;
                end
            end
            DATA: begin
                if (bit_count == 3'd8) begin
                    next_state = STOP;
                end
            end
            STOP: begin
                if (in == 1'b1) begin  // Detect stop bit
                    next_state = DONE;
                end else begin
                    next_state = IDLE;  // Error, reset to IDLE
                end
            end
            DONE: begin
                done = 1'b1;
                next_state = IDLE;
            end
        endcase
    end

    // Output logic
    assign out_byte = (done) ? shift_reg : 8'b0;

endmodule"
N/A,N/A,-1,76,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    // State and next state variables
    state_t state, next_state;

    // Bit counter for data bits
    logic [2:0] bit_count;

    // Shift register for assembling the data byte
    logic [7:0] shift_reg;

    // Sequential logic for state transitions
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 3'd0;
            shift_reg <= 8'd0;
        end else begin
            state <= next_state;
            if (state == DATA) begin
                shift_reg <= {in, shift_reg[7:1]}; // Shift in the new bit
                bit_count <= bit_count + 3'd1;
            end else if (state == START) begin
                bit_count <= 3'd0; // Reset bit counter for new byte
            end
        end
    end

    // Combinational logic for next state and outputs
    always_comb begin
        next_state = state;
        done = 1'b0;

        case (state)
            IDLE: begin
                if (in == 1'b0) begin // Detect start bit
                    next_state = START;
                end
            end

            START: begin
                next_state = DATA; // Move to data state after start bit
            end

            DATA: begin
                if (bit_count == 3'd7) begin
                    next_state = STOP; // Move to stop state after 8 bits
                end
            end

            STOP: begin
                if (in == 1'b1) begin // Check for stop bit
                    done = 1'b1;
                    next_state = IDLE;
                end else begin
                    next_state = IDLE; // Wait for stop bit
                end
            end

            default: next_state = IDLE;
        endcase
    end

    // Output the data byte when done
    assign out_byte = (done) ? shift_reg : 8'd0;

endmodule"
N/A,N/A,-1,77,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP,
        DONE
    } state_t;

    state_t state, next_state;
    logic [7:0] shift_reg;
    logic [2:0] bit_count;

    // State transition logic
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            shift_reg <= 8'b0;
            bit_count <= 3'd0;
        end else begin
            state <= next_state;
            if (state == DATA) begin
                shift_reg <= {in, shift_reg[7:1]};
            end
            if (state == DATA || state == START) begin
                bit_count <= bit_count + 3'd1;
            end else begin
                bit_count <= 3'd0;
            end
        end
    end

    // Next state logic
    always_comb begin
        next_state = state;
        done = 1'b0;
        case (state)
            IDLE: begin
                if (in == 1'b0) begin  // Detect start bit (0)
                    next_state = START;
                end
            end
            START: begin
                if (bit_count == 3'd1) begin  // Wait for the start bit period
                    next_state = DATA;
                end
            end
            DATA: begin
                if (bit_count == 3'd8) begin  // 8 bits received
                    next_state = STOP;
                end
            end
            STOP: begin
                if (in == 1'b1) begin  // Detect stop bit (1)
                    next_state = DONE;
                end else begin  // If stop bit is not correct, wait in STOP state
                    next_state = STOP;
                end
            end
            DONE: begin
                done = 1'b1;
                next_state = IDLE;  // After done, go back to IDLE
            end
        endcase
    end

    // Output logic
    assign out_byte = (done) ? shift_reg : 8'b0;

endmodule"
N/A,N/A,-0.1,78,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

parameter IDLE = 0, START = 1, DATA = 2, STOP = 3;
    reg [1:0] state, next_state;
    reg [7:0] shift_reg;
    reg [2:0] bit_count;
    reg done_reg;

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
        end else begin
            state <= next_state;
        end
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 0) // Start bit detected
                    next_state = START;
                else
                    next_state = IDLE;
            end
            START: begin
                next_state = DATA;
            end
            DATA: begin
                if (bit_count == 7)
                    next_state = STOP;
                else
                    next_state = DATA;
            end
            STOP: begin
                if (in == 1) // Stop bit detected
                    next_state = IDLE;
                else
                    next_state = STOP; // Wait for stop bit
            end
            default: next_state = IDLE;
        endcase
    end

    // Output logic and bit counter
    always @(posedge clk) begin
        if (reset) begin
            shift_reg <= 8'b0;
            bit_count <= 3'b0;
            done_reg <= 0;
        end else begin
            case (state)
                IDLE: begin
                    bit_count <= 3'b0;
                    done_reg <= 0;
                end
                START: begin
                    // Do nothing, just transition
                end
                DATA: begin
                    shift_reg <= {in, shift_reg[7:1]};
                    bit_count <= bit_count + 1;
                end
                STOP: begin
                    if (in == 1) begin
                        done_reg <= 1;
                    end
                end
            endcase
        end
    end

    assign out_byte = shift_reg;
    assign done = done_reg;

endmodule"
N/A,N/A,-1,79,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    // State registers
    state_t current_state, next_state;
    logic [2:0] bit_counter;
    logic [7:0] shift_register;

    // State transition logic
    always_ff @(posedge clk) begin
        if (reset) begin
            current_state <= IDLE;
            bit_counter <= 3'd0;
            shift_register <= 8'd0;
        end else begin
            current_state <= next_state;
            if (current_state == DATA) begin
                shift_register <= {in, shift_register[7:1]};
                bit_counter <= bit_counter + 1;
            end else if (current_state == IDLE) begin
                bit_counter <= 3'd0;
            end
        end
    end

    // Next state logic
    always_comb begin
        next_state = current_state;
        done = 1'b0;
        case (current_state)
            IDLE: begin
                if (in == 1'b0)  // Detect start bit
                    next_state = START;
            end
            START: begin
                next_state = DATA;
            end
            DATA: begin
                if (bit_counter == 3'd7)
                    next_state = STOP;
            end
            STOP: begin
                if (in == 1'b1) begin  // Detect stop bit
                    next_state = IDLE;
                    done = 1'b1;
                end else begin
                    next_state = IDLE; // Error recovery to IDLE
                end
            end
        endcase
    end

    // Output logic
    assign out_byte = (done) ? shift_register : 8'bx;

endmodule"
N/A,N/A,-1,80,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    // State registers
    state_t current_state, next_state;
    logic [2:0] bit_count;
    logic [7:0] shift_reg;

    // State transition logic
    always_ff @(posedge clk) begin
        if (reset) begin
            current_state <= IDLE;
            bit_count <= 3'd0;
            shift_reg <= 8'd0;
        end else begin
            current_state <= next_state;
            if (current_state == DATA) begin
                shift_reg <= {in, shift_reg[7:1]};
                bit_count <= bit_count + 1;
            end else if (current_state == IDLE) begin
                bit_count <= 3'd0;
            end
        end
    end

    // Next state logic
    always_comb begin
        next_state = current_state; // Default to stay in current state
        done = 1'b0; // Default output
        case (current_state)
            IDLE: begin
                if (in == 1'b0) begin
                    next_state = START;
                end
            end
            START: begin
                next_state = DATA;
            end
            DATA: begin
                if (bit_count == 3'd7) begin
                    next_state = STOP;
                end
            end
            STOP: begin
                if (in == 1'b1) begin
                    next_state = IDLE;
                    done = 1'b1;
                end else begin
                    next_state = IDLE; // Wait for a valid stop bit
                end
            end
        endcase
    end

    // Output logic
    assign out_byte = (done) ? shift_reg : 8'bx;

endmodule"
N/A,N/A,-1,81,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP,
        DONE
    } state_t;

    state_t state, next_state;
    logic [7:0] shift_reg;
    logic [2:0] bit_count;

    // State transition logic
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            shift_reg <= 8'b0;
            bit_count <= 3'd0;
        end else begin
            state <= next_state;
            if (state == DATA) begin
                shift_reg <= {in, shift_reg[7:1]};
            end
            if (state == DATA || state == START) begin
                bit_count <= bit_count + 3'd1;
            end else begin
                bit_count <= 3'd0;
            end
        end
    end

    // Next state logic
    always_comb begin
        next_state = state;
        done = 1'b0;
        case (state)
            IDLE: begin
                if (in == 1'b0) begin  // Detect start bit (0)
                    next_state = START;
                end
            end
            START: begin
                if (bit_count == 3'd1) begin  // Wait for the start bit period
                    next_state = DATA;
                end
            end
            DATA: begin
                if (bit_count == 3'd8) begin  // 8 bits received
                    next_state = STOP;
                end
            end
            STOP: begin
                if (in == 1'b1) begin  // Detect stop bit (1)
                    next_state = DONE;
                end else begin  // If stop bit is not correct, wait in STOP
                    next_state = STOP;
                end
            end
            DONE: begin
                done = 1'b1;
                next_state = IDLE;  // Ready for next byte
            end
        endcase
    end

    // Output logic
    assign out_byte = (done) ? shift_reg : 8'bxxxx_xxxx;

endmodule"
N/A,N/A,-0.1,82,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

parameter IDLE = 0, START = 1, DATA = 2, STOP = 3;
    reg [1:0] state, next_state;
    reg [7:0] shift_reg;
    reg [2:0] bit_count;
    reg done_reg;

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
        end else begin
            state <= next_state;
        end
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 0) // Start bit detected
                    next_state = START;
                else
                    next_state = IDLE;
            end
            START: begin
                next_state = DATA;
            end
            DATA: begin
                if (bit_count == 7)
                    next_state = STOP;
                else
                    next_state = DATA;
            end
            STOP: begin
                if (in == 1) // Stop bit detected
                    next_state = IDLE;
                else
                    next_state = STOP; // Wait for stop bit
            end
            default: next_state = IDLE;
        endcase
    end

    // Output logic and data path
    always @(posedge clk) begin
        if (reset) begin
            shift_reg <= 8'b0;
            bit_count <= 3'b0;
            done_reg <= 0;
        end else begin
            case (state)
                IDLE: begin
                    shift_reg <= 8'b0;
                    bit_count <= 3'b0;
                    done_reg <= 0;
                end
                START: begin
                    bit_count <= 0;
                end
                DATA: begin
                    shift_reg <= {in, shift_reg[7:1]}; // Shift in LSB first
                    bit_count <= bit_count + 1;
                end
                STOP: begin
                    if (in == 1) begin // Stop bit correct
                        done_reg <= 1;
                    end else begin
                        done_reg <= 0;
                    end
                end
            endcase
        end
    end

    assign out_byte = shift_reg;
    assign done = done_reg;

endmodule"
N/A,N/A,-0.1,83,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

parameter IDLE = 0, START = 1, DATA = 2, STOP = 3;
    reg [1:0] state, next_state;
    reg [7:0] shift_reg;
    reg [2:0] bit_count;
    reg done_reg;

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
        end else begin
            state <= next_state;
        end
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 0) // Start bit detected
                    next_state = START;
                else
                    next_state = IDLE;
            end
            START: begin
                next_state = DATA;
            end
            DATA: begin
                if (bit_count == 7)
                    next_state = STOP;
                else
                    next_state = DATA;
            end
            STOP: begin
                if (in == 1) // Stop bit detected
                    next_state = IDLE;
                else
                    next_state = STOP; // Wait for stop bit
            end
            default: next_state = IDLE;
        endcase
    end

    // Output logic and data path
    always @(posedge clk) begin
        if (reset) begin
            shift_reg <= 8'b0;
            bit_count <= 3'b0;
            done_reg <= 0;
        end else begin
            case (state)
                IDLE: begin
                    shift_reg <= 8'b0;
                    bit_count <= 3'b0;
                    done_reg <= 0;
                end
                START: begin
                    bit_count <= 0;
                end
                DATA: begin
                    shift_reg <= {in, shift_reg[7:1]}; // Shift in the data bit
                    bit_count <= bit_count + 1;
                end
                STOP: begin
                    if (in == 1) begin // Stop bit correct
                        done_reg <= 1;
                    end else begin
                        done_reg <= 0;
                    end
                end
            endcase
        end
    end

    assign out_byte = shift_reg;
    assign done = done_reg;

endmodule"
N/A,N/A,-1,84,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    // State variables
    state_t state, next_state;
    logic [2:0] bit_count;
    logic [7:0] shift_reg;

    // State transition
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
            shift_reg <= 8'b0;
        end
        else begin
            state <= next_state;
            if (state == DATA) begin
                shift_reg <= {in, shift_reg[7:1]};
                bit_count <= bit_count + 1;
            end
        end
    end

    // Next state logic
    always_comb begin
        next_state = state;
        done = 0;

        case (state)
            IDLE: begin
                if (in == 0)  // Start bit detected
                    next_state = START;
            end

            START: begin
                next_state = DATA;
            end

            DATA: begin
                if (bit_count == 7)  // All 8 data bits received
                    next_state = STOP;
            end

            STOP: begin
                if (in == 1) begin  // Stop bit detected
                    done = 1;
                    next_state = IDLE;
                end
                else begin  // Stop bit not detected, wait for next stop bit
                    next_state = STOP;
                end
            end
        endcase
    end

    // Output logic
    assign out_byte = shift_reg;

endmodule"
N/A,N/A,-1,85,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP,
        DONE
    } state_t;

    state_t state, next_state;
    logic [7:0] shift_reg;
    logic [2:0] bit_count;

    // State transition logic
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            shift_reg <= 8'b0;
            bit_count <= 3'd0;
        end else begin
            state <= next_state;
            if (state == DATA) begin
                shift_reg <= {in, shift_reg[7:1]};
            end
            if (state == DATA || state == START) begin
                bit_count <= bit_count + 3'd1;
            end else begin
                bit_count <= 3'd0;
            end
        end
    end

    // Next state logic
    always_comb begin
        next_state = state;
        done = 1'b0;
        case (state)
            IDLE: begin
                if (in == 1'b0) begin  // Detect start bit (0)
                    next_state = START;
                end
            end
            START: begin
                if (bit_count == 3'd1) begin  // Wait for the start bit period
                    next_state = DATA;
                end
            end
            DATA: begin
                if (bit_count == 3'd8) begin  // 8 bits received
                    next_state = STOP;
                end
            end
            STOP: begin
                if (in == 1'b1) begin  // Detect stop bit (1)
                    next_state = DONE;
                end else begin  // If stop bit is not correct, wait in STOP
                    next_state = STOP;
                end
            end
            DONE: begin
                done = 1'b1;
                next_state = IDLE;  // Ready for next byte
            end
        endcase
    end

    // Output logic
    assign out_byte = (done) ? shift_reg : 8'bxxxx_xxxx;

endmodule"
N/A,N/A,-1,86,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP,
        DONE
    } state_t;

    state_t state, next_state;
    logic [7:0] shift_reg;
    logic [2:0] bit_count;

    // State transition logic
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            shift_reg <= 8'b0;
            bit_count <= 3'd0;
        end else begin
            state <= next_state;
            if (state == DATA) begin
                shift_reg <= {in, shift_reg[7:1]};
            end
            if (state == DATA || state == START) begin
                bit_count <= bit_count + 3'd1;
            end else begin
                bit_count <= 3'd0;
            end
        end
    end

    // Next state logic
    always_comb begin
        next_state = state;
        done = 1'b0;
        case (state)
            IDLE: begin
                if (in == 1'b0) begin  // Detect start bit (0)
                    next_state = START;
                end
            end
            START: begin
                if (bit_count == 3'd1) begin  // Wait for the start bit period
                    next_state = DATA;
                end
            end
            DATA: begin
                if (bit_count == 3'd8) begin  // 8 bits received
                    next_state = STOP;
                end
            end
            STOP: begin
                if (in == 1'b1) begin  // Detect stop bit (1)
                    next_state = DONE;
                end else begin  // If stop bit is not correct, wait in STOP
                    next_state = STOP;
                end
            end
            DONE: begin
                done = 1'b1;
                next_state = IDLE;  // Ready for next byte
            end
        endcase
    end

    // Output logic
    assign out_byte = (done) ? shift_reg : 8'bx;

endmodule"
N/A,N/A,-1,87,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    // State registers
    state_t current_state, next_state;
    logic [2:0] bit_counter;
    logic [7:0] shift_register;

    // State transition logic
    always_ff @(posedge clk) begin
        if (reset) begin
            current_state <= IDLE;
            bit_counter <= 3'd0;
            shift_register <= 8'd0;
        end else begin
            current_state <= next_state;
            if (current_state == DATA) begin
                shift_register <= {in, shift_register[7:1]};
                bit_counter <= bit_counter + 1;
            end else if (current_state == IDLE) begin
                bit_counter <= 3'd0;
            end
        end
    end

    // Next state logic
    always_comb begin
        next_state = current_state; // Default to stay in current state
        done = 1'b0;
        case (current_state)
            IDLE: begin
                if (!in) begin // Detect start bit (0)
                    next_state = START;
                end
            end
            START: begin
                next_state = DATA; // Move to data state after start bit
            end
            DATA: begin
                if (bit_counter == 3'd7) begin
                    next_state = STOP; // Move to stop state after 8 data bits
                end
            end
            STOP: begin
                if (in) begin // Detect stop bit (1)
                    done = 1'b1;
                    next_state = IDLE; // Return to idle after successful byte reception
                end else begin
                    next_state = IDLE; // Error recovery, wait for next start bit
                end
            end
        endcase
    end

    // Output logic
    assign out_byte = shift_register;

endmodule"
N/A,N/A,-1,88,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP,
        DONE
    } state_t;

    state_t state, next_state;
    logic [7:0] shift_reg;
    logic [2:0] bit_count;

    // State transition logic
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            shift_reg <= 8'b0;
            bit_count <= 3'd0;
        end else begin
            state <= next_state;
            if (state == DATA) begin
                shift_reg <= {in, shift_reg[7:1]};
            end
            if (state == DATA || state == START) begin
                bit_count <= bit_count + 3'd1;
            end else begin
                bit_count <= 3'd0;
            end
        end
    end

    // Next state logic
    always_comb begin
        next_state = state;
        done = 1'b0;
        case (state)
            IDLE: begin
                if (in == 1'b0) begin  // Detect start bit (0)
                    next_state = START;
                end
            end
            START: begin
                if (bit_count == 3'd1) begin  // Wait for the start bit period
                    next_state = DATA;
                end
            end
            DATA: begin
                if (bit_count == 3'd8) begin  // 8 bits received
                    next_state = STOP;
                end
            end
            STOP: begin
                if (in == 1'b1) begin  // Detect stop bit (1)
                    next_state = DONE;
                end else begin  // If stop bit is not correct, wait in STOP
                    next_state = STOP;
                end
            end
            DONE: begin
                done = 1'b1;
                next_state = IDLE;  // Ready for next byte
            end
        endcase
    end

    // Output logic
    assign out_byte = (done) ? shift_reg : 8'bx;

endmodule"
N/A,N/A,-1,89,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP,
        DONE
    } state_t;
    
    state_t state, next_state;
    logic [2:0] bit_count;
    logic [7:0] shift_reg;

    // FSM state transition
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 3'd0;
            shift_reg <= 8'd0;
        end else begin
            state <= next_state;
        end
    end

    // FSM next state logic
    always_comb begin
        next_state = state; // Default to stay in current state
        case (state)
            IDLE: begin
                if (in == 1'b0) // Detect start bit
                    next_state = START;
            end
            START: begin
                next_state = DATA;
            end
            DATA: begin
                if (bit_count == 3'd7)
                    next_state = STOP;
            end
            STOP: begin
                if (in == 1'b1) // Detect stop bit
                    next_state = DONE;
                else
                    next_state = IDLE; // Wait for a valid stop bit
            end
            DONE: begin
                next_state = IDLE;
            end
        endcase
    end

    // Bit counter and shift register
    always_ff @(posedge clk) begin
        if (state == DATA) begin
            shift_reg <= {in, shift_reg[7:1]}; // Shift in bits
            bit_count <= bit_count + 1;
        end else if (state == START) begin
            bit_count <= 3'd0; // Reset bit count at start
        end
    end

    // Output logic
    assign out_byte = shift_reg;
    assign done = (state == DONE);

endmodule"
N/A,N/A,-1,90,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    // State and next state variables
    state_t state, next_state;

    // Bit counter for data bits
    logic [2:0] bit_count;

    // Shift register for assembling the data byte
    logic [7:0] shift_reg;

    // Output registers
    logic [7:0] data_byte;
    logic done_reg;

    // State transition
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 3'd0;
            shift_reg <= 8'd0;
            done_reg <= 1'b0;
        end else begin
            state <= next_state;
            if (state == DATA) begin
                shift_reg <= {in, shift_reg[7:1]};
                bit_count <= bit_count + 3'd1;
            end
        end
    end

    // Next state logic
    always_comb begin
        next_state = state;
        done_reg = 1'b0;
        case (state)
            IDLE: begin
                if (in == 1'b0) begin  // Start bit detected
                    next_state = START;
                end
            end
            START: begin
                next_state = DATA;
            end
            DATA: begin
                if (bit_count == 3'd7) begin  // All 8 data bits received
                    next_state = STOP;
                end
            end
            STOP: begin
                if (in == 1'b1) begin  // Stop bit detected
                    next_state = IDLE;
                    done_reg = 1'b1;
                    data_byte = shift_reg;
                end else begin
                    next_state = IDLE;  // Error: wait for a new start bit
                end
            end
        endcase
    end

    // Output assignments
    assign out_byte = (done_reg) ? data_byte : 8'dx;
    assign done = done_reg;

endmodule"
N/A,N/A,-0.1,91,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

parameter IDLE = 0, START = 1, DATA = 2, STOP = 3;
    reg [1:0] state, next_state;
    reg [7:0] shift_reg;
    reg [2:0] bit_count;
    reg done_reg;

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
        end else begin
            state <= next_state;
        end
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 0) // Start bit detected
                    next_state = START;
                else
                    next_state = IDLE;
            end
            START: begin
                next_state = DATA;
            end
            DATA: begin
                if (bit_count == 7)
                    next_state = STOP;
                else
                    next_state = DATA;
            end
            STOP: begin
                if (in == 1) // Stop bit detected
                    next_state = IDLE;
                else
                    next_state = STOP; // Wait for stop bit
            end
            default: next_state = IDLE;
        endcase
    end

    // Output logic and data path
    always @(posedge clk) begin
        if (reset) begin
            shift_reg <= 8'b0;
            bit_count <= 3'b0;
            done_reg <= 0;
        end else begin
            case (state)
                IDLE: begin
                    shift_reg <= 8'b0;
                    bit_count <= 3'b0;
                    done_reg <= 0;
                end
                START: begin
                    bit_count <= 0;
                end
                DATA: begin
                    shift_reg <= {in, shift_reg[7:1]}; // Shift in LSB first
                    bit_count <= bit_count + 1;
                end
                STOP: begin
                    if (in == 1) begin
                        done_reg <= 1;
                    end else begin
                        done_reg <= 0;
                    end
                end
            endcase
        end
    end

    assign out_byte = shift_reg;
    assign done = done_reg;

endmodule"
N/A,N/A,-1,92,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP,
        DONE
    } state_t;
    
    state_t state, next_state;
    logic [2:0] bit_count;
    logic [7:0] shift_reg;

    // FSM state transition
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 3'd0;
            shift_reg <= 8'd0;
        end else begin
            state <= next_state;
            if (state == DATA) begin
                shift_reg <= {in, shift_reg[7:1]};
                bit_count <= bit_count + 1'b1;
            end
        end
    end

    // FSM next state logic
    always_comb begin
        next_state = state;
        done = 1'b0;
        case (state)
            IDLE: begin
                if (in == 1'b0) // Start bit detected
                    next_state = START;
            end
            START: begin
                next_state = DATA;
            end
            DATA: begin
                if (bit_count == 3'd7)
                    next_state = STOP;
            end
            STOP: begin
                if (in == 1'b1) // Stop bit detected
                    next_state = DONE;
                else
                    next_state = IDLE; // Wait for the next start bit
            end
            DONE: begin
                done = 1'b1;
                next_state = IDLE;
            end
        endcase
    end

    // Output logic
    assign out_byte = (done) ? shift_reg : 8'dx;

endmodule"
N/A,N/A,-1,93,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP,
        DONE
    } state_t;

    state_t state, next_state;
    logic [7:0] shift_reg;
    logic [2:0] bit_count;

    // State transition logic
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            shift_reg <= 8'b0;
            bit_count <= 3'd0;
        end else begin
            state <= next_state;
            if (state == DATA) begin
                shift_reg <= {in, shift_reg[7:1]};
            end
            if (state == DATA || state == START) begin
                bit_count <= bit_count + 3'd1;
            end else begin
                bit_count <= 3'd0;
            end
        end
    end

    // Next state logic
    always_comb begin
        next_state = state;
        done = 1'b0;
        case (state)
            IDLE: begin
                if (in == 1'b0) begin  // Detect start bit (0)
                    next_state = START;
                end
            end
            START: begin
                if (bit_count == 3'd1) begin  // Wait for the start bit period
                    next_state = DATA;
                end
            end
            DATA: begin
                if (bit_count == 3'd8) begin  // 8 bits received
                    next_state = STOP;
                end
            end
            STOP: begin
                if (in == 1'b1) begin  // Detect stop bit (1)
                    next_state = DONE;
                end else begin  // If stop bit is not correct, wait in STOP state
                    next_state = STOP;
                end
            end
            DONE: begin
                done = 1'b1;
                next_state = IDLE;  // After done, go back to IDLE
            end
        endcase
    end

    // Output logic
    assign out_byte = (done) ? shift_reg : 8'b0;

endmodule"
N/A,N/A,-1,94,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP,
        DONE
    } state_t;

    state_t state, next_state;
    logic [7:0] shift_reg;
    logic [2:0] bit_count;

    // State transition logic
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            shift_reg <= 8'b0;
            bit_count <= 3'd0;
        end else begin
            state <= next_state;
            if (state == DATA) begin
                shift_reg <= {in, shift_reg[7:1]};
            end
            if (state == DATA || state == START) begin
                bit_count <= bit_count + 3'd1;
            end else begin
                bit_count <= 3'd0;
            end
        end
    end

    // Next state logic
    always_comb begin
        next_state = state;
        done = 1'b0;
        case (state)
            IDLE: begin
                if (in == 1'b0) begin  // Detect start bit (0)
                    next_state = START;
                end
            end
            START: begin
                if (bit_count == 3'd1) begin  // Wait for the start bit period
                    next_state = DATA;
                end
            end
            DATA: begin
                if (bit_count == 3'd8) begin  // 8 bits received
                    next_state = STOP;
                end
            end
            STOP: begin
                if (in == 1'b1) begin  // Detect stop bit (1)
                    next_state = DONE;
                end else begin  // If stop bit is not correct, wait in STOP
                    next_state = STOP;
                end
            end
            DONE: begin
                done = 1'b1;
                next_state = IDLE;  // Ready for next byte
            end
        endcase
    end

    // Output logic
    assign out_byte = (done) ? shift_reg : 8'b0;

endmodule"
N/A,N/A,-1,95,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    // State and next state variables
    state_t state, next_state;

    // Bit counter for data bits
    logic [2:0] bit_count;

    // Shift register for assembling the data byte
    logic [7:0] shift_reg;

    // Sequential logic for state transitions and data latching
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 3'd0;
            shift_reg <= 8'd0;
        end else begin
            state <= next_state;
            if (state == DATA) begin
                shift_reg <= {in, shift_reg[7:1]};
                bit_count <= bit_count + 1;
            end else if (state != DATA) begin
                bit_count <= 3'd0;
            end
        end
    end

    // Combinational logic for next state logic
    always_comb begin
        next_state = state;
        done = 1'b0;
        case (state)
            IDLE: begin
                if (in == 1'b0) begin  // Start bit detected
                    next_state = START;
                end
            end
            START: begin
                next_state = DATA;
            end
            DATA: begin
                if (bit_count == 3'd7) begin  // All 8 data bits received
                    next_state = STOP;
                end
            end
            STOP: begin
                if (in == 1'b1) begin  // Stop bit detected
                    next_state = IDLE;
                    done = 1'b1;
                end else begin
                    next_state = IDLE;  // Wait for a valid stop bit
                end
            end
        endcase
    end

    // Output logic
    assign out_byte = (done) ? shift_reg : 8'd0;

endmodule"
N/A,N/A,-1,96,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP,
        DONE
    } state_t;

    state_t state, next_state;
    logic [7:0] shift_reg;
    logic [2:0] bit_count;

    // State transition logic
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            shift_reg <= 8'b0;
            bit_count <= 3'd0;
        end else begin
            state <= next_state;
            if (state == DATA) begin
                shift_reg <= {in, shift_reg[7:1]};
            end
            if (state == DATA || state == START) begin
                bit_count <= bit_count + 3'd1;
            end else begin
                bit_count <= 3'd0;
            end
        end
    end

    // Next state logic
    always_comb begin
        next_state = state;
        done = 1'b0;
        case (state)
            IDLE: begin
                if (in == 1'b0) begin  // Detect start bit
                    next_state = START;
                end
            end
            START: begin
                if (bit_count == 3'd1) begin
                    next_state = DATA;
                end
            end
            DATA: begin
                if (bit_count == 3'd8) begin
                    next_state = STOP;
                end
            end
            STOP: begin
                if (in == 1'b1) begin  // Detect stop bit
                    next_state = DONE;
                end else begin
                    next_state = IDLE;  // Error, reset to IDLE
                end
            end
            DONE: begin
                done = 1'b1;
                next_state = IDLE;
            end
        endcase
    end

    // Output logic
    assign out_byte = (done) ? shift_reg : 8'b0;

endmodule"
N/A,N/A,-1,97,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP,
        DONE
    } state_t;

    state_t state, next_state;
    logic [7:0] shift_reg;
    logic [2:0] bit_count;

    // State transition logic
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            shift_reg <= 8'b0;
            bit_count <= 3'd0;
        end else begin
            state <= next_state;
            if (state == DATA) begin
                shift_reg <= {in, shift_reg[7:1]};
            end
            if (state == DATA || state == START) begin
                bit_count <= bit_count + 3'd1;
            end else begin
                bit_count <= 3'd0;
            end
        end
    end

    // Next state logic
    always_comb begin
        next_state = state;
        done = 1'b0;
        case (state)
            IDLE: begin
                if (in == 1'b0) begin  // Detect start bit (0)
                    next_state = START;
                end
            end
            START: begin
                if (bit_count == 3'd1) begin  // Wait for the start bit period
                    next_state = DATA;
                end
            end
            DATA: begin
                if (bit_count == 3'd8) begin  // 8 bits received
                    next_state = STOP;
                end
            end
            STOP: begin
                if (in == 1'b1) begin  // Detect stop bit (1)
                    next_state = DONE;
                end else begin  // If stop bit is not correct, wait in STOP
                    next_state = STOP;
                end
            end
            DONE: begin
                done = 1'b1;
                next_state = IDLE;  // Ready for next byte
            end
        endcase
    end

    // Output logic
    assign out_byte = (done) ? shift_reg : 8'bxxxx_xxxx;

endmodule"
N/A,N/A,-1,98,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP,
        DONE
    } state_t;

    state_t state, next_state;
    logic [7:0] shift_reg;
    logic [2:0] bit_count;

    // State transition logic
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            shift_reg <= 8'b0;
            bit_count <= 3'd0;
        end else begin
            state <= next_state;
            if (state == DATA) begin
                shift_reg <= {in, shift_reg[7:1]};
            end
            if (state == DATA || state == START) begin
                bit_count <= bit_count + 3'd1;
            end else begin
                bit_count <= 3'd0;
            end
        end
    end

    // Next state logic
    always_comb begin
        next_state = state;
        done = 1'b0;
        case (state)
            IDLE: begin
                if (in == 1'b0) begin  // Detect start bit (0)
                    next_state = START;
                end
            end
            START: begin
                if (bit_count == 3'd1) begin  // Wait for the start bit period
                    next_state = DATA;
                end
            end
            DATA: begin
                if (bit_count == 3'd8) begin  // 8 bits received
                    next_state = STOP;
                end
            end
            STOP: begin
                if (in == 1'b1) begin  // Detect stop bit (1)
                    next_state = DONE;
                end else begin  // If stop bit is not correct, wait in STOP state
                    next_state = IDLE;
                end
            end
            DONE: begin
                done = 1'b1;
                next_state = IDLE;  // Go back to IDLE for next byte
            end
        endcase
    end

    // Output logic
    assign out_byte = (done) ? shift_reg : 8'b0;

endmodule"
N/A,N/A,-0.1,99,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

parameter IDLE = 0, START = 1, DATA = 2, STOP = 3;
    reg [1:0] state, next_state;
    reg [7:0] shift_reg;
    reg [2:0] bit_count;
    reg done_reg;

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
        end else begin
            state <= next_state;
        end
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 0) // Start bit detected
                    next_state = START;
                else
                    next_state = IDLE;
            end
            START: begin
                next_state = DATA;
            end
            DATA: begin
                if (bit_count == 7)
                    next_state = STOP;
                else
                    next_state = DATA;
            end
            STOP: begin
                if (in == 1) // Stop bit detected
                    next_state = IDLE;
                else
                    next_state = STOP;
            end
            default: next_state = IDLE;
        endcase
    end

    // Output logic and data path
    always @(posedge clk) begin
        if (reset) begin
            shift_reg <= 8'b0;
            bit_count <= 3'b0;
            done_reg <= 1'b0;
        end else begin
            case (state)
                IDLE: begin
                    shift_reg <= 8'b0;
                    bit_count <= 3'b0;
                    done_reg <= 1'b0;
                end
                START: begin
                    bit_count <= 3'b0;
                end
                DATA: begin
                    shift_reg <= {in, shift_reg[7:1]}; // Shift in the data bit
                    bit_count <= bit_count + 1;
                end
                STOP: begin
                    if (in == 1) begin // Stop bit correct
                        done_reg <= 1'b1;
                    end
                end
            endcase
        end
    end

    assign out_byte = shift_reg;
    assign done = done_reg;

endmodule"
