Area,Delay,Score,Current Run,Episode,Verilog
N/A,N/A,-0.1,0,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    localparam IDLE = 2'b00;
    localparam RECEIVE = 2'b01;
    localparam STOP = 2'b10;

    reg [1:0] state, next_state;
    reg [7:0] shift_reg;
    reg [2:0] bit_count;

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 3'b0;
        end
        else begin
            state <= next_state;
            if (state == RECEIVE) begin
                bit_count <= bit_count + 1;
            end
            else begin
                bit_count <= 3'b0;
            end
        end
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 1'b0) begin // Start bit detected
                    next_state = RECEIVE;
                end
                else begin
                    next_state = IDLE;
                end
            end
            RECEIVE: begin
                if (bit_count == 3'b111) begin // All 8 data bits received
                    next_state = STOP;
                end
                else begin
                    next_state = RECEIVE;
                end
            end
            STOP: begin
                if (in == 1'b1) begin // Stop bit detected
                    next_state = IDLE;
                end
                else begin
                    next_state = STOP; // Wait for stop bit
                end
            end
            default: next_state = IDLE;
        endcase
    end

    // Output logic and datapath
    always @(posedge clk) begin
        if (state == RECEIVE) begin
            shift_reg <= {in, shift_reg[7:1]}; // Shift in the serial bit
        end
    end

    assign out_byte = (state == STOP && in == 1'b1) ? shift_reg : 8'bx;
    assign done = (state == STOP && in == 1'b1);

endmodule"
N/A,N/A,-0.1,1,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    localparam IDLE = 2'b00;
    localparam RECEIVE = 2'b01;
    localparam STOP = 2'b10;

    reg [1:0] state, next_state;
    reg [7:0] shift_reg;
    reg [2:0] bit_count;

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 3'b0;
        end else begin
            state <= next_state;
            if (state == RECEIVE) begin
                shift_reg <= {in, shift_reg[7:1]};
                bit_count <= bit_count + 1;
            end
        end
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 0) // Start bit detected
                    next_state = RECEIVE;
                else
                    next_state = IDLE;
            end
            RECEIVE: begin
                if (bit_count == 3'b111) // All 8 data bits received
                    next_state = STOP;
                else
                    next_state = RECEIVE;
            end
            STOP: begin
                if (in == 1) // Stop bit detected
                    next_state = IDLE;
                else
                    next_state = STOP; // Wait for stop bit
            end
            default: next_state = IDLE;
        endcase
    end

    // Output logic
    assign done = (state == STOP) && (in == 1);
    assign out_byte = shift_reg;

endmodule"
N/A,N/A,-0.1,2,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    localparam IDLE = 2'd0;
    localparam START = 2'd1;
    localparam DATA = 2'd2;
    localparam STOP = 2'd3;

    reg [1:0] state, next_state;
    reg [2:0] bit_count;
    reg [7:0] shift_reg;

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
        end else begin
            state <= next_state;
        end
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 0) // Start bit detected
                    next_state = START;
                else
                    next_state = IDLE;
            end
            START: begin
                next_state = DATA;
            end
            DATA: begin
                if (bit_count == 3'd7)
                    next_state = STOP;
                else
                    next_state = DATA;
            end
            STOP: begin
                if (in == 1) // Stop bit detected
                    next_state = IDLE;
                else
                    next_state = STOP; // Wait for stop bit
            end
            default: next_state = IDLE;
        endcase
    end

    // Datapath to latch input bits
    always @(posedge clk) begin
        if (reset) begin
            shift_reg <= 8'd0;
            bit_count <= 3'd0;
        end else begin
            case (state)
                START: begin
                    bit_count <= 3'd0;
                end
                DATA: begin
                    shift_reg <= {in, shift_reg[7:1]}; // Shift in LSB first
                    bit_count <= bit_count + 1;
                end
                STOP: begin
                    // Do nothing
                end
            endcase
        end
    end

    // Output logic
    assign out_byte = shift_reg;
    assign done = (state == STOP) && (in == 1);

endmodule"
N/A,N/A,-0.1,3,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    localparam IDLE = 2'b00;
    localparam RECEIVE = 2'b01;
    localparam STOP = 2'b10;

    reg [1:0] state, next_state;
    reg [7:0] shift_reg;
    reg [2:0] bit_count;

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 3'b0;
        end
        else begin
            state <= next_state;
            if (state == RECEIVE) begin
                bit_count <= bit_count + 1;
            end
            else begin
                bit_count <= 3'b0;
            end
        end
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 1'b0) begin // Start bit detected
                    next_state = RECEIVE;
                end
                else begin
                    next_state = IDLE;
                end
            end
            RECEIVE: begin
                if (bit_count == 3'b111) begin // All 8 data bits received
                    next_state = STOP;
                end
                else begin
                    next_state = RECEIVE;
                end
            end
            STOP: begin
                if (in == 1'b1) begin // Stop bit detected
                    next_state = IDLE;
                end
                else begin
                    next_state = STOP; // Wait for stop bit
                end
            end
            default: next_state = IDLE;
        endcase
    end

    // Output logic
    always @(posedge clk) begin
        if (state == RECEIVE) begin
            shift_reg <= {in, shift_reg[7:1]};
        end
    end

    assign done = (state == STOP && in == 1'b1);
    assign out_byte = done ? shift_reg : 8'bxxxx_xxxx;

endmodule"
N/A,N/A,-0.1,4,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    localparam IDLE = 2'b00;
    localparam RECEIVE = 2'b01;
    localparam STOP = 2'b10;

    reg [1:0] state, next_state;
    reg [7:0] shift_reg;
    reg [2:0] bit_count;

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 3'b0;
        end else begin
            state <= next_state;
            if (state == RECEIVE) begin
                shift_reg <= {in, shift_reg[7:1]};
                bit_count <= bit_count + 1;
            end else if (state == IDLE) begin
                bit_count <= 3'b0;
            end
        end
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 0) begin  // Start bit detected
                    next_state = RECEIVE;
                end else begin
                    next_state = IDLE;
                end
            end
            RECEIVE: begin
                if (bit_count == 3'd7) begin  // All 8 data bits received
                    next_state = STOP;
                end else begin
                    next_state = RECEIVE;
                end
            end
            STOP: begin
                if (in == 1) begin  // Stop bit detected
                    next_state = IDLE;
                end else begin
                    next_state = STOP;  // Wait for stop bit
                end
            end
            default: next_state = IDLE;
        endcase
    end

    // Output logic
    assign done = (state == STOP && in == 1);
    assign out_byte = (done) ? shift_reg : 8'bx;

endmodule"
N/A,N/A,-0.1,5,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    localparam IDLE = 2'b00;
    localparam RECEIVE = 2'b01;
    localparam STOP = 2'b10;

    reg [1:0] state, next_state;
    reg [7:0] shift_reg;
    reg [2:0] bit_count;

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 3'b0;
        end
        else begin
            state <= next_state;
            if (state == RECEIVE) begin
                bit_count <= bit_count + 1;
            end
            else begin
                bit_count <= 3'b0;
            end
        end
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 1'b0) begin // Start bit detected
                    next_state = RECEIVE;
                end
                else begin
                    next_state = IDLE;
                end
            end
            RECEIVE: begin
                if (bit_count == 3'b111) begin // All 8 data bits received
                    next_state = STOP;
                end
                else begin
                    next_state = RECEIVE;
                end
            end
            STOP: begin
                if (in == 1'b1) begin // Stop bit detected
                    next_state = IDLE;
                end
                else begin
                    next_state = STOP; // Wait for stop bit
                end
            end
            default: next_state = IDLE;
        endcase
    end

    // Output logic and datapath
    always @(posedge clk) begin
        if (state == RECEIVE) begin
            shift_reg <= {in, shift_reg[7:1]}; // Shift in the serial bit
        end
    end

    assign out_byte = (state == STOP && in == 1'b1) ? shift_reg : 8'bx;
    assign done = (state == STOP && in == 1'b1);

endmodule"
N/A,N/A,-0.1,6,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    localparam IDLE = 2'b00;
    localparam START = 2'b01;
    localparam DATA = 2'b10;
    localparam STOP = 2'b11;

    reg [1:0] state, next_state;
    reg [2:0] bit_count;  // Counter for 8 data bits
    reg [7:0] shift_reg;  // Shift register to store incoming bits

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
        end else begin
            state <= next_state;
        end
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 1'b0)  // Detect start bit
                    next_state = START;
                else
                    next_state = IDLE;
            end

            START: begin
                next_state = DATA;
            end

            DATA: begin
                if (bit_count == 3'd7)
                    next_state = STOP;
                else
                    next_state = DATA;
            end

            STOP: begin
                if (in == 1'b1)  // Detect stop bit
                    next_state = IDLE;
                else
                    next_state = STOP;  // Wait for stop bit if not detected
            end

            default: next_state = IDLE;
        endcase
    end

    // Output logic and bit counting
    always @(posedge clk) begin
        if (reset) begin
            bit_count <= 3'd0;
            shift_reg <= 8'd0;
        end else begin
            case (state)
                IDLE: begin
                    bit_count <= 3'd0;
                end

                START: begin
                    bit_count <= 3'd0;
                end

                DATA: begin
                    shift_reg <= {in, shift_reg[7:1]};  // Shift in the LSB first
                    bit_count <= bit_count + 3'd1;
                end

                STOP: begin
                    if (in == 1'b1) begin  // If stop bit is correct
                        bit_count <= 3'd0;
                    end
                end
            endcase
        end
    end

    // Output valid data
    assign done = (state == STOP && in == 1'b1);
    assign out_byte = shift_reg;

endmodule"
N/A,N/A,-0.1,7,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    localparam IDLE = 2'b00;
    localparam RECEIVE = 2'b01;
    localparam STOP = 2'b10;

    reg [1:0] state, next_state;
    reg [7:0] shift_reg;
    reg [2:0] bit_count;

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 3'b0;
        end else begin
            state <= next_state;
            if (state == RECEIVE) begin
                shift_reg <= {in, shift_reg[7:1]};
                bit_count <= bit_count + 1;
            end else if (state == IDLE) begin
                bit_count <= 3'b0;
            end
        end
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 0) begin  // Start bit detected
                    next_state = RECEIVE;
                end else begin
                    next_state = IDLE;
                end
            end
            RECEIVE: begin
                if (bit_count == 3'd7) begin  // All 8 data bits received
                    next_state = STOP;
                end else begin
                    next_state = RECEIVE;
                end
            end
            STOP: begin
                if (in == 1) begin  // Stop bit detected
                    next_state = IDLE;
                end else begin
                    next_state = STOP;  // Wait for stop bit
                end
            end
            default: next_state = IDLE;
        endcase
    end

    // Output logic
    assign done = (state == STOP && in == 1);
    assign out_byte = (done) ? shift_reg : 8'bx;

endmodule"
N/A,N/A,-0.1,8,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    localparam IDLE = 2'b00;
    localparam RECEIVE = 2'b01;
    localparam STOP = 2'b10;

    reg [1:0] state, next_state;
    reg [7:0] shift_reg;
    reg [2:0] bit_count;

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 3'b0;
        end else begin
            state <= next_state;
            if (state == RECEIVE) begin
                shift_reg <= {in, shift_reg[7:1]};
                bit_count <= bit_count + 1;
            end else if (state == IDLE) begin
                bit_count <= 3'b0;
            end
        end
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 0) begin  // Start bit detected
                    next_state = RECEIVE;
                end else begin
                    next_state = IDLE;
                end
            end
            RECEIVE: begin
                if (bit_count == 3'd7) begin  // All 8 data bits received
                    next_state = STOP;
                end else begin
                    next_state = RECEIVE;
                end
            end
            STOP: begin
                if (in == 1) begin  // Stop bit detected
                    next_state = IDLE;
                end else begin
                    next_state = STOP;  // Wait for stop bit
                end
            end
            default: next_state = IDLE;
        endcase
    end

    // Output logic
    assign done = (state == STOP && in == 1);
    assign out_byte = (done) ? shift_reg : 8'bx;

endmodule"
N/A,N/A,-0.1,9,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    localparam IDLE = 2'b00;
    localparam RECEIVE = 2'b01;
    localparam STOP = 2'b10;

    reg [1:0] state, next_state;
    reg [7:0] shift_reg;
    reg [2:0] bit_count;

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 3'b0;
        end else begin
            state <= next_state;
            if (state == RECEIVE) begin
                shift_reg <= {in, shift_reg[7:1]};
                bit_count <= bit_count + 1;
            end
        end
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 0) // Start bit detected
                    next_state = RECEIVE;
                else
                    next_state = IDLE;
            end
            RECEIVE: begin
                if (bit_count == 3'b111) // All 8 data bits received
                    next_state = STOP;
                else
                    next_state = RECEIVE;
            end
            STOP: begin
                if (in == 1) // Stop bit detected
                    next_state = IDLE;
                else
                    next_state = STOP; // Wait for stop bit
            end
            default: next_state = IDLE;
        endcase
    end

    // Output logic
    assign done = (state == STOP) && (in == 1);
    assign out_byte = shift_reg;

endmodule"
N/A,N/A,-0.1,10,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    localparam IDLE = 2'b00;
    localparam RECEIVE = 2'b01;
    localparam STOP = 2'b10;

    reg [1:0] state, next_state;
    reg [7:0] shift_reg;
    reg [2:0] bit_count;

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 3'b0;
        end else begin
            state <= next_state;
            if (state == RECEIVE) begin
                shift_reg <= {in, shift_reg[7:1]};
                bit_count <= bit_count + 1;
            end
        end
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 0) // Start bit detected
                    next_state = RECEIVE;
                else
                    next_state = IDLE;
            end
            RECEIVE: begin
                if (bit_count == 3'b111) // All 8 data bits received
                    next_state = STOP;
                else
                    next_state = RECEIVE;
            end
            STOP: begin
                if (in == 1) // Stop bit detected
                    next_state = IDLE;
                else
                    next_state = STOP;
            end
            default: next_state = IDLE;
        endcase
    end

    // Output logic
    assign done = (state == STOP) && (in == 1);
    assign out_byte = (done) ? shift_reg : 8'b0;

endmodule"
N/A,N/A,-0.1,11,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    localparam IDLE = 2'b00;
    localparam RECEIVE = 2'b01;
    localparam STOP = 2'b10;

    reg [1:0] state, next_state;
    reg [7:0] shift_reg;
    reg [2:0] bit_count;

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 3'b0;
        end
        else begin
            state <= next_state;
            if (state == RECEIVE) begin
                bit_count <= bit_count + 1;
            end
            else begin
                bit_count <= 3'b0;
            end
        end
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 1'b0) begin // Start bit detected
                    next_state = RECEIVE;
                end
                else begin
                    next_state = IDLE;
                end
            end
            RECEIVE: begin
                if (bit_count == 3'b111) begin // All 8 data bits received
                    next_state = STOP;
                end
                else begin
                    next_state = RECEIVE;
                end
            end
            STOP: begin
                if (in == 1'b1) begin // Stop bit detected
                    next_state = IDLE;
                end
                else begin
                    next_state = STOP; // Wait for stop bit
                end
            end
            default: next_state = IDLE;
        endcase
    end

    // Output logic
    always @(posedge clk) begin
        if (state == RECEIVE) begin
            shift_reg <= {in, shift_reg[7:1]};
        end
    end

    assign done = (state == STOP && in == 1'b1);
    assign out_byte = done ? shift_reg : 8'bxxxx_xxxx;

endmodule"
N/A,N/A,-0.1,12,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    localparam IDLE = 2'b00;
    localparam RECEIVE = 2'b01;
    localparam STOP = 2'b10;

    reg [1:0] state, next_state;
    reg [7:0] shift_reg;
    reg [2:0] bit_count;

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 3'b0;
        end
        else begin
            state <= next_state;
            if (state == RECEIVE) begin
                bit_count <= bit_count + 1;
            end
            else begin
                bit_count <= 3'b0;
            end
        end
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 1'b0) begin // Start bit detected
                    next_state = RECEIVE;
                end
                else begin
                    next_state = IDLE;
                end
            end
            RECEIVE: begin
                if (bit_count == 3'b111) begin // All 8 data bits received
                    next_state = STOP;
                end
                else begin
                    next_state = RECEIVE;
                end
            end
            STOP: begin
                if (in == 1'b1) begin // Stop bit detected
                    next_state = IDLE;
                end
                else begin
                    next_state = STOP; // Wait for stop bit
                end
            end
            default: next_state = IDLE;
        endcase
    end

    // Output logic
    always @(posedge clk) begin
        if (state == RECEIVE) begin
            shift_reg <= {in, shift_reg[7:1]}; // Shift in the serial bitstream
        end
    end

    assign out_byte = shift_reg;
    assign done = (state == STOP && in == 1'b1); // Done when stop bit is detected

endmodule"
N/A,N/A,-0.1,13,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    localparam IDLE = 2'b00;
    localparam RECEIVE = 2'b01;
    localparam STOP = 2'b10;

    reg [1:0] state, next_state;
    reg [7:0] shift_reg;
    reg [2:0] bit_count;

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 3'b0;
        end else begin
            state <= next_state;
            if (state == RECEIVE) begin
                shift_reg <= {in, shift_reg[7:1]};
                bit_count <= bit_count + 1;
            end else if (state == IDLE) begin
                bit_count <= 3'b0;
            end
        end
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 0) begin  // Start bit detected
                    next_state = RECEIVE;
                end else begin
                    next_state = IDLE;
                end
            end
            RECEIVE: begin
                if (bit_count == 3'd7) begin  // All 8 data bits received
                    next_state = STOP;
                end else begin
                    next_state = RECEIVE;
                end
            end
            STOP: begin
                if (in == 1) begin  // Stop bit detected
                    next_state = IDLE;
                end else begin
                    next_state = STOP;  // Wait for stop bit
                end
            end
            default: next_state = IDLE;
        endcase
    end

    // Output logic
    assign done = (state == STOP && in == 1);
    assign out_byte = (done) ? shift_reg : 8'bx;

endmodule"
N/A,N/A,-0.1,14,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    localparam IDLE = 2'b00;
    localparam RECEIVE = 2'b01;
    localparam STOP = 2'b10;

    reg [1:0] state, next_state;
    reg [7:0] shift_reg;
    reg [2:0] bit_count;

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 3'b0;
        end else begin
            state <= next_state;
            if (state == RECEIVE) begin
                shift_reg <= {in, shift_reg[7:1]};
                bit_count <= bit_count + 1;
            end
        end
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 0) // Start bit detected
                    next_state = RECEIVE;
                else
                    next_state = IDLE;
            end
            RECEIVE: begin
                if (bit_count == 3'b111) // All 8 data bits received
                    next_state = STOP;
                else
                    next_state = RECEIVE;
            end
            STOP: begin
                if (in == 1) // Stop bit detected
                    next_state = IDLE;
                else
                    next_state = STOP; // Wait for stop bit
            end
            default: next_state = IDLE;
        endcase
    end

    // Output logic
    assign done = (state == STOP) && (in == 1);
    assign out_byte = shift_reg;

endmodule"
N/A,N/A,-0.1,15,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    localparam IDLE = 2'd0;
    localparam RECEIVE = 2'd1;
    localparam STOP = 2'd2;

    reg [1:0] state, next_state;
    reg [7:0] shift_reg;
    reg [2:0] bit_count;

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 3'd0;
        end
        else begin
            state <= next_state;
            if (state == RECEIVE) begin
                bit_count <= bit_count + 1;
            end
            else begin
                bit_count <= 3'd0;
            end
        end
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 1'b0) begin // Start bit detected
                    next_state = RECEIVE;
                end
                else begin
                    next_state = IDLE;
                end
            end
            RECEIVE: begin
                if (bit_count == 3'd7) begin
                    next_state = STOP;
                end
                else begin
                    next_state = RECEIVE;
                end
            end
            STOP: begin
                if (in == 1'b1) begin // Stop bit detected
                    next_state = IDLE;
                end
                else begin
                    next_state = STOP; // Wait for stop bit
                end
            end
            default: next_state = IDLE;
        endcase
    end

    // Output logic
    always @(posedge clk) begin
        if (state == RECEIVE) begin
            shift_reg <= {in, shift_reg[7:1]}; // Shift in the serial data
        end
    end

    assign done = (state == STOP) && (in == 1'b1);
    assign out_byte = (done) ? shift_reg : 8'bx; // Valid when done is 1

endmodule"
N/A,N/A,-0.1,16,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    localparam IDLE = 2'b00;
    localparam RECEIVE = 2'b01;
    localparam STOP = 2'b10;

    reg [1:0] state, next_state;
    reg [7:0] shift_reg;
    reg [2:0] bit_count;

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 3'b0;
        end
        else begin
            state <= next_state;
            if (state == RECEIVE) begin
                bit_count <= bit_count + 1;
            end
            else begin
                bit_count <= 3'b0;
            end
        end
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 1'b0) begin // Start bit detected
                    next_state = RECEIVE;
                end
                else begin
                    next_state = IDLE;
                end
            end
            RECEIVE: begin
                if (bit_count == 3'b111) begin // All 8 data bits received
                    next_state = STOP;
                end
                else begin
                    next_state = RECEIVE;
                end
            end
            STOP: begin
                if (in == 1'b1) begin // Stop bit detected
                    next_state = IDLE;
                end
                else begin
                    next_state = STOP; // Wait for stop bit
                end
            end
            default: next_state = IDLE;
        endcase
    end

    // Output logic and datapath
    always @(posedge clk) begin
        if (state == RECEIVE) begin
            shift_reg <= {in, shift_reg[7:1]}; // Shift in the serial bit
        end
    end

    assign out_byte = shift_reg;
    assign done = (state == STOP) && (in == 1'b1);

endmodule"
N/A,N/A,-0.1,17,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    localparam IDLE = 2'b00;
    localparam RECEIVE = 2'b01;
    localparam STOP = 2'b10;

    reg [1:0] state, next_state;
    reg [7:0] shift_reg;
    reg [2:0] bit_count;

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 3'b0;
        end else begin
            state <= next_state;
            if (state == RECEIVE) begin
                shift_reg <= {in, shift_reg[7:1]};
                bit_count <= bit_count + 1;
            end else if (state == IDLE) begin
                bit_count <= 3'b0;
            end
        end
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 0) begin  // Start bit detected
                    next_state = RECEIVE;
                end else begin
                    next_state = IDLE;
                end
            end
            RECEIVE: begin
                if (bit_count == 3'd7) begin  // All 8 data bits received
                    next_state = STOP;
                end else begin
                    next_state = RECEIVE;
                end
            end
            STOP: begin
                if (in == 1) begin  // Stop bit detected
                    next_state = IDLE;
                end else begin
                    next_state = STOP;  // Wait for stop bit
                end
            end
            default: next_state = IDLE;
        endcase
    end

    // Output logic
    assign done = (state == STOP && in == 1);
    assign out_byte = (done) ? shift_reg : 8'bx;

endmodule"
N/A,N/A,-0.1,18,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    localparam IDLE = 2'b00;
    localparam RECEIVE = 2'b01;
    localparam STOP = 2'b10;

    reg [1:0] state, next_state;
    reg [7:0] shift_reg;
    reg [2:0] bit_count;

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 3'b0;
        end
        else begin
            state <= next_state;
            if (state == RECEIVE) begin
                bit_count <= bit_count + 1;
            end
            else begin
                bit_count <= 3'b0;
            end
        end
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 1'b0) begin // Start bit detected
                    next_state = RECEIVE;
                end
                else begin
                    next_state = IDLE;
                end
            end
            RECEIVE: begin
                if (bit_count == 3'b111) begin // All 8 data bits received
                    next_state = STOP;
                end
                else begin
                    next_state = RECEIVE;
                end
            end
            STOP: begin
                if (in == 1'b1) begin // Stop bit detected
                    next_state = IDLE;
                end
                else begin
                    next_state = STOP; // Wait for stop bit
                end
            end
            default: next_state = IDLE;
        endcase
    end

    // Output logic and datapath
    always @(posedge clk) begin
        if (state == RECEIVE) begin
            shift_reg <= {in, shift_reg[7:1]}; // Shift in the serial data
        end
    end

    assign out_byte = (state == STOP && in == 1'b1) ? shift_reg : 8'bx;
    assign done = (state == STOP && in == 1'b1);

endmodule"
N/A,N/A,-0.1,19,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    localparam IDLE = 2'b00;
    localparam RECEIVE = 2'b01;
    localparam STOP = 2'b10;

    reg [1:0] state, next_state;
    reg [7:0] shift_reg;
    reg [2:0] bit_count;

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 3'b0;
        end
        else begin
            state <= next_state;
            if (state == RECEIVE) begin
                bit_count <= bit_count + 1;
            end
            else begin
                bit_count <= 3'b0;
            end
        end
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 1'b0) // Start bit detected
                    next_state = RECEIVE;
                else
                    next_state = IDLE;
            end
            RECEIVE: begin
                if (bit_count == 3'b111) // 8 data bits received
                    next_state = STOP;
                else
                    next_state = RECEIVE;
            end
            STOP: begin
                if (in == 1'b1) // Stop bit detected
                    next_state = IDLE;
                else
                    next_state = STOP;
            end
            default: next_state = IDLE;
        endcase
    end

    // Output logic
    always @(posedge clk) begin
        if (state == RECEIVE) begin
            shift_reg <= {in, shift_reg[7:1]}; // Shift in the incoming bit
        end
    end

    assign out_byte = shift_reg;
    assign done = (state == STOP) && (in == 1'b1);

endmodule"
N/A,N/A,-0.1,20,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    localparam IDLE = 2'b00;
    localparam RECEIVE = 2'b01;
    localparam STOP = 2'b10;

    reg [1:0] state, next_state;
    reg [7:0] shift_reg;
    reg [2:0] bit_count;

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 3'b0;
        end
        else begin
            state <= next_state;
            if (state == RECEIVE) begin
                bit_count <= bit_count + 1;
            end
            else begin
                bit_count <= 3'b0;
            end
        end
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 1'b0) begin // Start bit detected
                    next_state = RECEIVE;
                end
                else begin
                    next_state = IDLE;
                end
            end
            RECEIVE: begin
                if (bit_count == 3'b111) begin // All 8 data bits received
                    next_state = STOP;
                end
                else begin
                    next_state = RECEIVE;
                end
            end
            STOP: begin
                if (in == 1'b1) begin // Stop bit detected
                    next_state = IDLE;
                end
                else begin
                    next_state = STOP; // Wait for stop bit
                end
            end
            default: next_state = IDLE;
        endcase
    end

    // Output logic and datapath
    always @(posedge clk) begin
        if (state == RECEIVE) begin
            shift_reg <= {in, shift_reg[7:1]}; // Shift in the serial bit
        end
    end

    assign out_byte = (state == STOP && in == 1'b1) ? shift_reg : 8'bx;
    assign done = (state == STOP && in == 1'b1);

endmodule"
N/A,N/A,-0.1,21,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    localparam IDLE = 2'b00;
    localparam RECEIVE = 2'b01;
    localparam STOP = 2'b10;

    reg [1:0] state, next_state;
    reg [7:0] shift_reg;
    reg [2:0] bit_count;

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 3'b0;
        end else begin
            state <= next_state;
            if (state == RECEIVE) begin
                shift_reg <= {in, shift_reg[7:1]};
                bit_count <= bit_count + 1;
            end
        end
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 0) // Start bit detected
                    next_state = RECEIVE;
                else
                    next_state = IDLE;
            end
            RECEIVE: begin
                if (bit_count == 3'b111) // All 8 data bits received
                    next_state = STOP;
                else
                    next_state = RECEIVE;
            end
            STOP: begin
                if (in == 1) // Stop bit detected
                    next_state = IDLE;
                else
                    next_state = STOP; // Wait for stop bit
            end
            default: next_state = IDLE;
        endcase
    end

    // Output logic
    assign done = (state == STOP) && (in == 1);
    assign out_byte = shift_reg;

endmodule"
N/A,N/A,-0.1,22,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    localparam IDLE = 2'd0;
    localparam START = 2'd1;
    localparam DATA = 2'd2;
    localparam STOP = 2'd3;

    reg [1:0] state, next_state;
    reg [2:0] bit_count;
    reg [7:0] shift_reg;

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
        end else begin
            state <= next_state;
        end
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 0) // Start bit detected
                    next_state = START;
                else
                    next_state = IDLE;
            end
            START: begin
                next_state = DATA;
            end
            DATA: begin
                if (bit_count == 3'd7)
                    next_state = STOP;
                else
                    next_state = DATA;
            end
            STOP: begin
                if (in == 1) // Stop bit detected
                    next_state = IDLE;
                else
                    next_state = STOP;
            end
            default: next_state = IDLE;
        endcase
    end

    // Output logic and bit counting
    always @(posedge clk) begin
        if (reset) begin
            bit_count <= 3'd0;
            shift_reg <= 8'd0;
        end else begin
            case (state)
                IDLE: begin
                    bit_count <= 3'd0;
                end
                START: begin
                    // Do nothing, just transition to DATA
                end
                DATA: begin
                    shift_reg <= {in, shift_reg[7:1]}; // Shift in the incoming bit
                    bit_count <= bit_count + 1;
                end
                STOP: begin
                    // Do nothing, just wait for IDLE transition
                end
            endcase
        end
    end

    // Output assignments
    assign out_byte = shift_reg;
    assign done = (state == STOP && in == 1);

endmodule"
N/A,N/A,-0.1,23,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    localparam IDLE = 2'b00;
    localparam RECEIVE = 2'b01;
    localparam STOP = 2'b10;

    reg [1:0] state, next_state;
    reg [7:0] shift_reg;
    reg [2:0] bit_count;

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 3'b0;
        end
        else begin
            state <= next_state;
            if (state == RECEIVE) begin
                bit_count <= bit_count + 1;
            end
            else begin
                bit_count <= 3'b0;
            end
        end
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 1'b0) begin // Start bit detected
                    next_state = RECEIVE;
                end
                else begin
                    next_state = IDLE;
                end
            end
            RECEIVE: begin
                if (bit_count == 3'b111) begin // All 8 data bits received
                    next_state = STOP;
                end
                else begin
                    next_state = RECEIVE;
                end
            end
            STOP: begin
                if (in == 1'b1) begin // Stop bit detected
                    next_state = IDLE;
                end
                else begin
                    next_state = STOP; // Wait for stop bit
                end
            end
            default: next_state = IDLE;
        endcase
    end

    // Output logic and datapath
    always @(posedge clk) begin
        if (state == RECEIVE) begin
            shift_reg <= {in, shift_reg[7:1]}; // Shift in the serial data
        end
    end

    assign out_byte = (state == STOP && in == 1'b1) ? shift_reg : 8'bx; // Only valid when done
    assign done = (state == STOP && in == 1'b1); // Done when stop bit is correct

endmodule"
N/A,N/A,-0.1,24,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    localparam IDLE = 2'b00;
    localparam RECEIVE = 2'b01;
    localparam STOP = 2'b10;

    reg [1:0] state, next_state;
    reg [7:0] shift_reg;
    reg [2:0] bit_count;

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 3'b0;
        end
        else begin
            state <= next_state;
            if (state == RECEIVE) begin
                bit_count <= bit_count + 1;
            end
            else begin
                bit_count <= 3'b0;
            end
        end
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 1'b0) begin // Start bit detected
                    next_state = RECEIVE;
                end
                else begin
                    next_state = IDLE;
                end
            end
            RECEIVE: begin
                if (bit_count == 3'b111) begin // All 8 data bits received
                    next_state = STOP;
                end
                else begin
                    next_state = RECEIVE;
                end
            end
            STOP: begin
                if (in == 1'b1) begin // Stop bit detected
                    next_state = IDLE;
                end
                else begin
                    next_state = STOP; // Wait for stop bit
                end
            end
            default: next_state = IDLE;
        endcase
    end

    // Output logic
    always @(posedge clk) begin
        if (state == RECEIVE) begin
            shift_reg <= {in, shift_reg[7:1]}; // Shift in the data bits
        end
    end

    assign out_byte = (state == STOP && in == 1'b1) ? shift_reg : 8'bx; // Output valid byte
    assign done = (state == STOP && in == 1'b1); // Done signal when stop bit is correct

endmodule"
N/A,N/A,-0.1,25,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    localparam IDLE = 2'b00;
    localparam RECEIVE = 2'b01;
    localparam STOP = 2'b10;

    reg [1:0] state, next_state;
    reg [7:0] shift_reg;
    reg [2:0] bit_count;

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 3'b0;
        end
        else begin
            state <= next_state;
            if (state == RECEIVE) begin
                bit_count <= bit_count + 1;
            end
            else begin
                bit_count <= 3'b0;
            end
        end
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 0) // Start bit detected
                    next_state = RECEIVE;
                else
                    next_state = IDLE;
            end

            RECEIVE: begin
                if (bit_count == 3'b111) // 8 bits received
                    next_state = STOP;
                else
                    next_state = RECEIVE;
            end

            STOP: begin
                if (in == 1) // Stop bit detected
                    next_state = IDLE;
                else
                    next_state = STOP; // Wait for stop bit
            end

            default: next_state = IDLE;
        endcase
    end

    // Output logic
    always @(posedge clk) begin
        if (state == RECEIVE) begin
            shift_reg <= {in, shift_reg[7:1]}; // Shift in the serial input
        end
    end

    assign out_byte = shift_reg;
    assign done = (state == STOP) && (in == 1); // Valid output when in STOP state with correct stop bit

endmodule"
N/A,N/A,-0.1,26,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    localparam IDLE = 2'b00;
    localparam RECEIVE = 2'b01;
    localparam STOP = 2'b10;

    reg [1:0] state, next_state;
    reg [7:0] shift_reg;
    reg [2:0] bit_count;

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 3'b0;
        end else begin
            state <= next_state;
            if (state == RECEIVE) begin
                shift_reg <= {in, shift_reg[7:1]};
                bit_count <= bit_count + 1;
            end else if (state == IDLE) begin
                bit_count <= 3'b0;
            end
        end
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 0) begin  // Start bit detected
                    next_state = RECEIVE;
                end else begin
                    next_state = IDLE;
                end
            end
            RECEIVE: begin
                if (bit_count == 3'b111) begin  // 8 bits received
                    next_state = STOP;
                end else begin
                    next_state = RECEIVE;
                end
            end
            STOP: begin
                if (in == 1) begin  // Stop bit detected
                    next_state = IDLE;
                end else begin
                    next_state = STOP;
                end
            end
            default: begin
                next_state = IDLE;
            end
        endcase
    end

    // Output logic
    assign done = (state == STOP && in == 1);
    assign out_byte = (done) ? shift_reg : 8'bx;

endmodule"
N/A,N/A,-1,27,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    localparam IDLE = 2'd0;
    localparam START = 2'd1;
    localparam DATA = 2'd2;
    localparam STOP = 2'd3;

    reg [1:0] state, next_state;
    reg [2:0] bit_count;  // Counter for 8 data bits
    reg [7:0] shift_reg;  // Shift register to store incoming bits

    // State transition logic
    always @ (posedge clk) begin
        if (reset) begin
            state <= IDLE;
        end else begin
            state <= next_state;
        end
    end

    // Next state logic
    always @ (*) begin
        case (state)
            IDLE: begin
                if (in == 0) // Detect start bit
                    next_state = START;
                else
                    next_state = IDLE;
            end
            START: begin
                next_state = DATA;
            end
            DATA: begin
                if (bit_count == 3'd7) // All data bits received
                    next_state = STOP;
                else
                    next_state = DATA;
            end
            STOP: begin
                if (in == 1) // Detect stop bit
                    next_state = IDLE;
                else
                    next_state = STOP; // Wait for stop bit
            end
            default: begin
                next_state = IDLE;
            end
        endcase
    end

    // Output logic and datapath
    always @ (posedge clk) begin
        if (reset) begin
            bit_count <= 3'd0;
            shift_reg <= 8'b0;
        end else begin
            case (state)
                IDLE: begin
                    bit_count <= 3'd0;
                end
                START: begin
                    bit_count <= 3'd0;
                end
                DATA: begin
                    shift_reg <= {in, shift_reg[7:1]}; // Shift in the new bit
                    bit_count <= bit_count + 1;
                end
                STOP: begin
                    if (in == 1) begin
                        out_byte <= shift_reg; // Latch the output byte
                    end
                end
            endcase
        end
    end

    // Done signal
    assign done = (state == STOP) && (in == 1);

endmodule"
N/A,N/A,-0.1,28,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    localparam IDLE = 2'b00;
    localparam RECEIVE = 2'b01;
    localparam STOP = 2'b10;

    reg [1:0] state, next_state;
    reg [7:0] shift_reg;
    reg [2:0] bit_count;

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 3'b0;
        end else begin
            state <= next_state;
            if (state == RECEIVE) begin
                shift_reg <= {in, shift_reg[7:1]};
                bit_count <= bit_count + 1;
            end
        end
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 0) // Start bit detected
                    next_state = RECEIVE;
                else
                    next_state = IDLE;
            end
            RECEIVE: begin
                if (bit_count == 3'b111) // All 8 data bits received
                    next_state = STOP;
                else
                    next_state = RECEIVE;
            end
            STOP: begin
                if (in == 1) // Stop bit detected
                    next_state = IDLE;
                else
                    next_state = STOP; // Wait for stop bit
            end
            default: next_state = IDLE;
        endcase
    end

    // Output logic
    assign done = (state == STOP) && (in == 1);
    assign out_byte = (done) ? shift_reg : 8'bxxxx_xxxx;

endmodule"
N/A,N/A,-0.1,29,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    localparam IDLE = 2'b00;
    localparam RECEIVE = 2'b01;
    localparam STOP = 2'b10;

    reg [1:0] state, next_state;
    reg [7:0] shift_reg;
    reg [2:0] bit_count;

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 3'b0;
        end else begin
            state <= next_state;
            if (state == RECEIVE) begin
                shift_reg <= {in, shift_reg[7:1]};
                bit_count <= bit_count + 1;
            end else if (state == IDLE) begin
                bit_count <= 3'b0;
            end
        end
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 0) begin  // Start bit detected
                    next_state = RECEIVE;
                end else begin
                    next_state = IDLE;
                end
            end
            RECEIVE: begin
                if (bit_count == 3'd7) begin  // All 8 data bits received
                    next_state = STOP;
                end else begin
                    next_state = RECEIVE;
                end
            end
            STOP: begin
                if (in == 1) begin  // Stop bit detected
                    next_state = IDLE;
                end else begin
                    next_state = STOP;  // Wait for stop bit
                end
            end
            default: next_state = IDLE;
        endcase
    end

    // Output logic
    assign done = (state == STOP && in == 1);
    assign out_byte = (done) ? shift_reg : 8'bx;

endmodule"
N/A,N/A,-0.1,30,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    localparam IDLE = 2'b00;
    localparam RECEIVE = 2'b01;
    localparam STOP = 2'b10;

    reg [1:0] state, next_state;
    reg [7:0] shift_reg;
    reg [2:0] bit_count;

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 3'b0;
        end
        else begin
            state <= next_state;
            if (state == RECEIVE) begin
                bit_count <= bit_count + 1;
            end
            else begin
                bit_count <= 3'b0;
            end
        end
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 1'b0) begin // Start bit detected
                    next_state = RECEIVE;
                end
                else begin
                    next_state = IDLE;
                end
            end
            RECEIVE: begin
                if (bit_count == 3'b111) begin // All 8 data bits received
                    next_state = STOP;
                end
                else begin
                    next_state = RECEIVE;
                end
            end
            STOP: begin
                if (in == 1'b1) begin // Stop bit detected
                    next_state = IDLE;
                end
                else begin
                    next_state = STOP; // Wait for stop bit
                end
            end
            default: next_state = IDLE;
        endcase
    end

    // Output logic and datapath
    always @(posedge clk) begin
        if (state == RECEIVE) begin
            shift_reg <= {in, shift_reg[7:1]}; // Shift in the serial bit
        end
    end

    assign out_byte = (state == STOP && in == 1'b1) ? shift_reg : 8'bx;
    assign done = (state == STOP && in == 1'b1);

endmodule"
N/A,N/A,-0.1,31,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    localparam IDLE = 2'b00;
    localparam RECEIVE = 2'b01;
    localparam STOP = 2'b10;

    reg [1:0] state, next_state;
    reg [7:0] shift_reg;
    reg [2:0] bit_count;

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 3'b0;
        end else begin
            state <= next_state;
            if (state == RECEIVE) begin
                shift_reg <= {in, shift_reg[7:1]};
                bit_count <= bit_count + 1;
            end else if (state == IDLE) begin
                bit_count <= 3'b0;
            end
        end
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 0) begin  // Start bit detected
                    next_state = RECEIVE;
                end else begin
                    next_state = IDLE;
                end
            end
            RECEIVE: begin
                if (bit_count == 3'd7) begin  // All 8 data bits received
                    next_state = STOP;
                end else begin
                    next_state = RECEIVE;
                end
            end
            STOP: begin
                if (in == 1) begin  // Stop bit detected
                    next_state = IDLE;
                end else begin
                    next_state = STOP;  // Wait for stop bit
                end
            end
            default: next_state = IDLE;
        endcase
    end

    // Output logic
    assign done = (state == STOP && in == 1);
    assign out_byte = done ? shift_reg : 8'bxxxx_xxxx;

endmodule"
N/A,N/A,-0.1,32,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    localparam IDLE = 2'b00;
    localparam RECEIVE = 2'b01;
    localparam STOP = 2'b10;

    reg [1:0] state, next_state;
    reg [7:0] shift_reg;
    reg [2:0] bit_count;

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 3'b0;
        end else begin
            state <= next_state;
            if (state == RECEIVE) begin
                shift_reg <= {in, shift_reg[7:1]};
                bit_count <= bit_count + 1;
            end
        end
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 0) // Start bit detected
                    next_state = RECEIVE;
                else
                    next_state = IDLE;
            end
            RECEIVE: begin
                if (bit_count == 3'b111) // All 8 data bits received
                    next_state = STOP;
                else
                    next_state = RECEIVE;
            end
            STOP: begin
                if (in == 1) // Stop bit detected
                    next_state = IDLE;
                else
                    next_state = STOP; // Wait for stop bit
            end
            default: next_state = IDLE;
        endcase
    end

    // Output logic
    assign done = (state == STOP) && (in == 1);
    assign out_byte = shift_reg;

endmodule"
N/A,N/A,-0.1,33,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    localparam IDLE = 2'b00;
    localparam RECEIVE = 2'b01;
    localparam STOP = 2'b10;

    reg [1:0] state, next_state;
    reg [7:0] shift_reg;
    reg [2:0] bit_count;

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 3'b0;
        end
        else begin
            state <= next_state;
            if (state == RECEIVE) begin
                bit_count <= bit_count + 1;
            end
            else begin
                bit_count <= 3'b0;
            end
        end
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 1'b0) begin // Start bit detected
                    next_state = RECEIVE;
                end
                else begin
                    next_state = IDLE;
                end
            end
            RECEIVE: begin
                if (bit_count == 3'b111) begin // All 8 data bits received
                    next_state = STOP;
                end
                else begin
                    next_state = RECEIVE;
                end
            end
            STOP: begin
                if (in == 1'b1) begin // Stop bit detected
                    next_state = IDLE;
                end
                else begin
                    next_state = STOP; // Wait for stop bit
                end
            end
            default: next_state = IDLE;
        endcase
    end

    // Output logic and datapath
    always @(posedge clk) begin
        if (state == RECEIVE) begin
            shift_reg <= {in, shift_reg[7:1]}; // Shift in the serial data
        end
    end

    assign out_byte = (state == STOP && in == 1'b1) ? shift_reg : 8'bx;
    assign done = (state == STOP && in == 1'b1);

endmodule"
N/A,N/A,-0.1,34,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    localparam IDLE = 2'd0;
    localparam START = 2'd1;
    localparam DATA = 2'd2;
    localparam STOP = 2'd3;

    reg [1:0] state, next_state;
    reg [2:0] bit_count;
    reg [7:0] shift_reg;

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
        end else begin
            state <= next_state;
        end
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 0) // Start bit detected
                    next_state = START;
                else
                    next_state = IDLE;
            end
            START: begin
                next_state = DATA;
            end
            DATA: begin
                if (bit_count == 3'd7)
                    next_state = STOP;
                else
                    next_state = DATA;
            end
            STOP: begin
                if (in == 1) // Stop bit detected
                    next_state = IDLE;
                else
                    next_state = STOP;
            end
            default: next_state = IDLE;
        endcase
    end

    // Output logic and bit counting
    always @(posedge clk) begin
        if (reset) begin
            bit_count <= 3'd0;
            shift_reg <= 8'd0;
        end else begin
            case (state)
                IDLE: begin
                    bit_count <= 3'd0;
                end
                START: begin
                    bit_count <= 3'd0;
                end
                DATA: begin
                    shift_reg <= {in, shift_reg[7:1]};
                    bit_count <= bit_count + 1;
                end
                STOP: begin
                    // Do nothing, wait for next byte
                end
            endcase
        end
    end

    // Output assignments
    assign out_byte = (state == STOP && in == 1) ? shift_reg : 8'dx;
    assign done = (state == STOP && in == 1);

endmodule"
N/A,N/A,-0.1,35,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    localparam IDLE = 2'b00;
    localparam RECEIVE = 2'b01;
    localparam STOP = 2'b10;

    reg [1:0] state, next_state;
    reg [7:0] shift_reg;
    reg [2:0] bit_count;

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 3'b0;
        end else begin
            state <= next_state;
            if (state == RECEIVE) begin
                shift_reg <= {in, shift_reg[7:1]};
                bit_count <= bit_count + 1;
            end else if (state == IDLE) begin
                bit_count <= 3'b0;
            end
        end
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 0) begin  // Start bit detected
                    next_state = RECEIVE;
                end else begin
                    next_state = IDLE;
                end
            end
            RECEIVE: begin
                if (bit_count == 3'd7) begin  // All 8 data bits received
                    next_state = STOP;
                end else begin
                    next_state = RECEIVE;
                end
            end
            STOP: begin
                if (in == 1) begin  // Stop bit detected
                    next_state = IDLE;
                end else begin
                    next_state = STOP;  // Wait for stop bit
                end
            end
            default: next_state = IDLE;
        endcase
    end

    // Output logic
    assign done = (state == STOP && in == 1);
    assign out_byte = done ? shift_reg : 8'bxxxx_xxxx;

endmodule"
N/A,N/A,-0.1,36,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    localparam IDLE = 2'b00;
    localparam RECEIVE = 2'b01;
    localparam STOP = 2'b10;

    reg [1:0] state, next_state;
    reg [7:0] shift_reg;
    reg [2:0] bit_count;

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 3'b0;
        end else begin
            state <= next_state;
            if (state == RECEIVE) begin
                shift_reg <= {in, shift_reg[7:1]};
                bit_count <= bit_count + 1;
            end else if (state == IDLE) begin
                bit_count <= 3'b0;
            end
        end
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 0) begin  // Start bit detected
                    next_state = RECEIVE;
                end else begin
                    next_state = IDLE;
                end
            end
            RECEIVE: begin
                if (bit_count == 3'd7) begin  // All 8 data bits received
                    next_state = STOP;
                end else begin
                    next_state = RECEIVE;
                end
            end
            STOP: begin
                if (in == 1) begin  // Stop bit detected
                    next_state = IDLE;
                end else begin
                    next_state = STOP;  // Wait for stop bit
                end
            end
            default: next_state = IDLE;
        endcase
    end

    // Output logic
    assign done = (state == STOP && in == 1);
    assign out_byte = done ? shift_reg : 8'bx;

endmodule"
N/A,N/A,-1,37,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    localparam IDLE = 2'b00;
    localparam START = 2'b01;
    localparam DATA = 2'b10;
    localparam STOP = 2'b11;

    reg [1:0] state, next_state;
    reg [7:0] shift_reg;
    reg [2:0] bit_count;

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
        end else begin
            state <= next_state;
        end
    end

    // Next state logic and output logic
    always @(*) begin
        next_state = state;
        done = 1'b0;
        case (state)
            IDLE: begin
                if (in == 1'b0) // Detect start bit
                    next_state = START;
            end
            START: begin
                next_state = DATA;
            end
            DATA: begin
                if (bit_count == 3'd7)
                    next_state = STOP;
            end
            STOP: begin
                if (in == 1'b1) begin // Detect stop bit
                    done = 1'b1;
                    next_state = IDLE;
                end
            end
        endcase
    end

    // Bit counter and shift register logic
    always @(posedge clk) begin
        if (reset) begin
            bit_count <= 3'd0;
            shift_reg <= 8'd0;
        end else begin
            case (state)
                START: begin
                    bit_count <= 3'd0;
                end
                DATA: begin
                    shift_reg <= {in, shift_reg[7:1]}; // Shift in bits
                    bit_count <= bit_count + 1'b1;
                end
                STOP: begin
                    // Do nothing, just wait for stop bit
                end
            endcase
        end
    end

    assign out_byte = shift_reg;

endmodule"
N/A,N/A,-0.1,38,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    localparam IDLE = 2'b00;
    localparam RECEIVE = 2'b01;
    localparam STOP = 2'b10;

    reg [1:0] state, next_state;
    reg [7:0] shift_reg;
    reg [2:0] bit_count;

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 3'b0;
        end
        else begin
            state <= next_state;
            if (state == RECEIVE) begin
                bit_count <= bit_count + 1;
            end
            else begin
                bit_count <= 3'b0;
            end
        end
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 1'b0) begin // Start bit detected
                    next_state = RECEIVE;
                end
                else begin
                    next_state = IDLE;
                end
            end
            RECEIVE: begin
                if (bit_count == 3'b111) begin // All 8 data bits received
                    next_state = STOP;
                end
                else begin
                    next_state = RECEIVE;
                end
            end
            STOP: begin
                if (in == 1'b1) begin // Stop bit detected
                    next_state = IDLE;
                end
                else begin
                    next_state = STOP; // Wait for stop bit
                end
            end
            default: next_state = IDLE;
        endcase
    end

    // Output logic and datapath
    always @(posedge clk) begin
        if (state == RECEIVE) begin
            shift_reg <= {in, shift_reg[7:1]}; // Shift in the serial data
        end
    end

    assign out_byte = (state == STOP && in == 1'b1) ? shift_reg : 8'bx;
    assign done = (state == STOP && in == 1'b1);

endmodule"
N/A,N/A,-0.1,39,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    localparam IDLE = 2'b00;
    localparam RECEIVE = 2'b01;
    localparam STOP = 2'b10;

    reg [1:0] state, next_state;
    reg [7:0] shift_reg;
    reg [2:0] bit_count;

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 3'b0;
        end else begin
            state <= next_state;
            if (state == RECEIVE) begin
                shift_reg <= {in, shift_reg[7:1]};
                bit_count <= bit_count + 1;
            end
        end
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 0) // Start bit detected
                    next_state = RECEIVE;
                else
                    next_state = IDLE;
            end
            RECEIVE: begin
                if (bit_count == 3'b111) // All 8 data bits received
                    next_state = STOP;
                else
                    next_state = RECEIVE;
            end
            STOP: begin
                if (in == 1) // Stop bit detected
                    next_state = IDLE;
                else
                    next_state = STOP; // Wait for stop bit
            end
            default: next_state = IDLE;
        endcase
    end

    // Output logic
    assign done = (state == STOP) && (in == 1);
    assign out_byte = shift_reg;

endmodule"
N/A,N/A,-0.1,40,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    localparam IDLE = 2'b00;
    localparam RECEIVE = 2'b01;
    localparam STOP = 2'b10;

    reg [1:0] state, next_state;
    reg [7:0] shift_reg;
    reg [2:0] bit_count;

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 3'b0;
        end
        else begin
            state <= next_state;
            if (state == RECEIVE) begin
                bit_count <= bit_count + 1;
            end
            else begin
                bit_count <= 3'b0;
            end
        end
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 1'b0) begin // Start bit detected
                    next_state = RECEIVE;
                end
                else begin
                    next_state = IDLE;
                end
            end
            RECEIVE: begin
                if (bit_count == 3'b111) begin // All 8 data bits received
                    next_state = STOP;
                end
                else begin
                    next_state = RECEIVE;
                end
            end
            STOP: begin
                if (in == 1'b1) begin // Stop bit detected
                    next_state = IDLE;
                end
                else begin
                    next_state = STOP; // Wait for stop bit
                end
            end
            default: next_state = IDLE;
        endcase
    end

    // Output logic and datapath
    always @(posedge clk) begin
        if (state == RECEIVE) begin
            shift_reg <= {in, shift_reg[7:1]}; // Shift in the serial data
        end
    end

    assign out_byte = (state == STOP && in == 1'b1) ? shift_reg : 8'bx;
    assign done = (state == STOP && in == 1'b1);

endmodule"
N/A,N/A,-0.1,41,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    localparam IDLE = 2'b00;
    localparam RECEIVE = 2'b01;
    localparam STOP = 2'b10;

    reg [1:0] state, next_state;
    reg [7:0] shift_reg;
    reg [2:0] bit_count;

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 3'b0;
        end
        else begin
            state <= next_state;
            if (state == RECEIVE) begin
                bit_count <= bit_count + 1;
            end
            else begin
                bit_count <= 3'b0;
            end
        end
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 0) // Start bit detected
                    next_state = RECEIVE;
                else
                    next_state = IDLE;
            end
            RECEIVE: begin
                if (bit_count == 3'b111) // 8 bits received
                    next_state = STOP;
                else
                    next_state = RECEIVE;
            end
            STOP: begin
                if (in == 1) // Stop bit detected
                    next_state = IDLE;
                else
                    next_state = STOP; // Wait for stop bit
            end
            default: next_state = IDLE;
        endcase
    end

    // Output logic
    always @(posedge clk) begin
        if (state == RECEIVE) begin
            shift_reg <= {in, shift_reg[7:1]}; // Shift in the serial input
        end
    end

    assign out_byte = shift_reg;
    assign done = (state == STOP) && (in == 1); // Valid output when stop bit is correct

endmodule"
N/A,N/A,-0.1,42,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    localparam IDLE = 2'b00;
    localparam RECEIVE = 2'b01;
    localparam STOP = 2'b10;

    reg [1:0] state, next_state;
    reg [7:0] shift_reg;
    reg [2:0] bit_count;

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 3'b0;
        end
        else begin
            state <= next_state;
            if (state == RECEIVE) begin
                bit_count <= bit_count + 1;
            end
            else begin
                bit_count <= 3'b0;
            end
        end
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 1'b0) begin // Start bit detected
                    next_state = RECEIVE;
                end
                else begin
                    next_state = IDLE;
                end
            end
            RECEIVE: begin
                if (bit_count == 3'b111) begin // All 8 data bits received
                    next_state = STOP;
                end
                else begin
                    next_state = RECEIVE;
                end
            end
            STOP: begin
                if (in == 1'b1) begin // Stop bit detected
                    next_state = IDLE;
                end
                else begin
                    next_state = STOP; // Wait for stop bit
                end
            end
            default: next_state = IDLE;
        endcase
    end

    // Output logic and datapath
    always @(posedge clk) begin
        if (state == RECEIVE) begin
            shift_reg <= {in, shift_reg[7:1]}; // Shift in the serial bit
        end
    end

    assign out_byte = (state == STOP && in == 1'b1) ? shift_reg : 8'bx;
    assign done = (state == STOP && in == 1'b1);

endmodule"
N/A,N/A,-0.1,43,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    localparam IDLE = 2'b00;
    localparam RECEIVE = 2'b01;
    localparam STOP = 2'b10;

    reg [1:0] state, next_state;
    reg [7:0] shift_reg;
    reg [2:0] bit_count;

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 3'b0;
        end
        else begin
            state <= next_state;
            if (state == RECEIVE) begin
                bit_count <= bit_count + 1;
            end
            else begin
                bit_count <= 3'b0;
            end
        end
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 0) // Start bit detected
                    next_state = RECEIVE;
                else
                    next_state = IDLE;
            end
            RECEIVE: begin
                if (bit_count == 3'b111) // 8 bits received
                    next_state = STOP;
                else
                    next_state = RECEIVE;
            end
            STOP: begin
                if (in == 1) // Stop bit detected
                    next_state = IDLE;
                else
                    next_state = STOP; // Wait for stop bit
            end
            default: next_state = IDLE;
        endcase
    end

    // Output logic
    always @(posedge clk) begin
        if (state == RECEIVE) begin
            shift_reg <= {in, shift_reg[7:1]}; // Shift in the serial input
        end
    end

    assign out_byte = shift_reg;
    assign done = (state == STOP) && (in == 1); // Valid output when in STOP state with correct stop bit

endmodule"
N/A,N/A,-0.1,44,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    localparam IDLE = 2'b00;
    localparam RECEIVE = 2'b01;
    localparam STOP = 2'b10;

    reg [1:0] state, next_state;
    reg [7:0] shift_reg;
    reg [2:0] bit_count;

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 3'b0;
        end else begin
            state <= next_state;
            if (state == RECEIVE) begin
                shift_reg <= {in, shift_reg[7:1]};
                bit_count <= bit_count + 1;
            end else if (state == IDLE) begin
                bit_count <= 3'b0;
            end
        end
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 0) begin  // Start bit detected
                    next_state = RECEIVE;
                end else begin
                    next_state = IDLE;
                end
            end
            RECEIVE: begin
                if (bit_count == 3'd7) begin  // All 8 data bits received
                    next_state = STOP;
                end else begin
                    next_state = RECEIVE;
                end
            end
            STOP: begin
                if (in == 1) begin  // Stop bit detected
                    next_state = IDLE;
                end else begin
                    next_state = STOP;  // Wait for stop bit
                end
            end
            default: next_state = IDLE;
        endcase
    end

    // Output logic
    assign done = (state == STOP && in == 1);
    assign out_byte = (done) ? shift_reg : 8'bx;

endmodule"
N/A,N/A,-0.1,45,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    localparam IDLE = 2'd0;
    localparam START = 2'd1;
    localparam DATA = 2'd2;
    localparam STOP = 2'd3;

    reg [1:0] state, next_state;
    reg [2:0] bit_count;
    reg [7:0] shift_reg;

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
        end else begin
            state <= next_state;
        end
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 0) // Start bit detected
                    next_state = START;
                else
                    next_state = IDLE;
            end
            START: begin
                next_state = DATA;
            end
            DATA: begin
                if (bit_count == 3'd7)
                    next_state = STOP;
                else
                    next_state = DATA;
            end
            STOP: begin
                if (in == 1) // Stop bit detected
                    next_state = IDLE;
                else
                    next_state = STOP; // Wait for stop bit
            end
            default: next_state = IDLE;
        endcase
    end

    // Output logic and bit counter
    always @(posedge clk) begin
        if (reset) begin
            bit_count <= 3'd0;
            shift_reg <= 8'd0;
        end else if (state == DATA) begin
            shift_reg <= {in, shift_reg[7:1]}; // Shift in the incoming bit
            bit_count <= bit_count + 1;
        end else if (state == STOP) begin
            bit_count <= 3'd0; // Reset bit counter after data is fully received
        end
    end

    // Output assignments
    assign out_byte = shift_reg;
    assign done = (state == STOP) && (in == 1);

endmodule"
N/A,N/A,-0.1,46,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    localparam IDLE = 2'b00;
    localparam RECEIVE = 2'b01;
    localparam STOP = 2'b10;

    reg [1:0] state, next_state;
    reg [7:0] shift_reg;
    reg [2:0] bit_count;

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 3'b0;
        end else begin
            state <= next_state;
            if (state == RECEIVE) begin
                shift_reg <= {in, shift_reg[7:1]};
                bit_count <= bit_count + 1;
            end
        end
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 0) // Start bit detected
                    next_state = RECEIVE;
                else
                    next_state = IDLE;
            end
            RECEIVE: begin
                if (bit_count == 3'b111) // All 8 data bits received
                    next_state = STOP;
                else
                    next_state = RECEIVE;
            end
            STOP: begin
                if (in == 1) // Stop bit detected
                    next_state = IDLE;
                else
                    next_state = STOP; // Wait for stop bit
            end
            default: next_state = IDLE;
        endcase
    end

    // Output logic
    assign done = (state == STOP) && (in == 1);
    assign out_byte = shift_reg;

endmodule"
N/A,N/A,-0.1,47,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    localparam IDLE = 2'b00;
    localparam RECEIVE = 2'b01;
    localparam STOP = 2'b10;

    reg [1:0] state, next_state;
    reg [7:0] shift_reg;
    reg [2:0] bit_count;

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 3'b0;
        end else begin
            state <= next_state;
            if (state == RECEIVE) begin
                shift_reg <= {in, shift_reg[7:1]};
                bit_count <= bit_count + 1;
            end else if (state == IDLE) begin
                bit_count <= 3'b0;
            end
        end
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 0) begin  // Start bit detected
                    next_state = RECEIVE;
                end else begin
                    next_state = IDLE;
                end
            end
            RECEIVE: begin
                if (bit_count == 3'd7) begin  // All 8 data bits received
                    next_state = STOP;
                end else begin
                    next_state = RECEIVE;
                end
            end
            STOP: begin
                if (in == 1) begin  // Stop bit detected
                    next_state = IDLE;
                end else begin
                    next_state = STOP;  // Wait for stop bit
                end
            end
            default: next_state = IDLE;
        endcase
    end

    // Output logic
    assign done = (state == STOP && in == 1);
    assign out_byte = (done) ? shift_reg : 8'bx;

endmodule"
N/A,N/A,-0.1,48,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    localparam IDLE = 2'b00;
    localparam RECEIVE = 2'b01;
    localparam STOP = 2'b10;

    reg [1:0] state, next_state;
    reg [7:0] shift_reg;
    reg [2:0] bit_count;

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 3'b0;
        end
        else begin
            state <= next_state;
            if (state == RECEIVE) begin
                bit_count <= bit_count + 1;
            end
            else begin
                bit_count <= 3'b0;
            end
        end
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 1'b0) begin // Start bit detected
                    next_state = RECEIVE;
                end
                else begin
                    next_state = IDLE;
                end
            end
            RECEIVE: begin
                if (bit_count == 3'b111) begin // All 8 data bits received
                    next_state = STOP;
                end
                else begin
                    next_state = RECEIVE;
                end
            end
            STOP: begin
                if (in == 1'b1) begin // Stop bit detected
                    next_state = IDLE;
                end
                else begin
                    next_state = STOP; // Wait for stop bit
                end
            end
            default: next_state = IDLE;
        endcase
    end

    // Output logic
    always @(posedge clk) begin
        if (state == RECEIVE) begin
            shift_reg <= {in, shift_reg[7:1]}; // Shift in the data bits
        end
    end

    assign out_byte = shift_reg;
    assign done = (state == STOP) && (in == 1'b1);

endmodule"
N/A,N/A,-0.1,49,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    localparam IDLE = 2'd0;
    localparam START = 2'd1;
    localparam DATA = 2'd2;
    localparam STOP = 2'd3;

    reg [1:0] state, next_state;
    reg [2:0] bit_count;
    reg [7:0] shift_reg;

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
        end else begin
            state <= next_state;
        end
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 0) // Start bit detected
                    next_state = START;
                else
                    next_state = IDLE;
            end
            START: begin
                next_state = DATA;
            end
            DATA: begin
                if (bit_count == 3'd7)
                    next_state = STOP;
                else
                    next_state = DATA;
            end
            STOP: begin
                if (in == 1) // Stop bit detected
                    next_state = IDLE;
                else
                    next_state = STOP;
            end
            default: next_state = IDLE;
        endcase
    end

    // Output logic and bit counting
    always @(posedge clk) begin
        if (reset) begin
            bit_count <= 3'd0;
            shift_reg <= 8'd0;
        end else begin
            case (state)
                IDLE: begin
                    bit_count <= 3'd0;
                end
                START: begin
                    bit_count <= 3'd0;
                end
                DATA: begin
                    shift_reg <= {in, shift_reg[7:1]}; // Shift in the LSB first
                    bit_count <= bit_count + 1;
                end
                STOP: begin
                    // Do nothing
                end
            endcase
        end
    end

    // Output assignments
    assign out_byte = shift_reg;
    assign done = (state == STOP) && (in == 1);

endmodule"
N/A,N/A,-0.1,50,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    localparam IDLE = 2'd0;
    localparam RECEIVE = 2'd1;
    localparam STOP = 2'd2;

    reg [1:0] state, next_state;
    reg [7:0] shift_reg;
    reg [2:0] bit_count;

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 3'd0;
        end
        else begin
            state <= next_state;
            if (state == RECEIVE) begin
                bit_count <= bit_count + 1;
            end
            else begin
                bit_count <= 3'd0;
            end
        end
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 1'b0) begin // Start bit detected
                    next_state = RECEIVE;
                end
                else begin
                    next_state = IDLE;
                end
            end
            RECEIVE: begin
                if (bit_count == 3'd7) begin
                    next_state = STOP;
                end
                else begin
                    next_state = RECEIVE;
                end
            end
            STOP: begin
                if (in == 1'b1) begin // Stop bit detected
                    next_state = IDLE;
                end
                else begin
                    next_state = STOP; // Wait for stop bit
                end
            end
            default: begin
                next_state = IDLE;
            end
        endcase
    end

    // Output logic
    always @(posedge clk) begin
        if (state == RECEIVE) begin
            shift_reg <= {in, shift_reg[7:1]};
        end
    end

    assign out_byte = shift_reg;
    assign done = (state == STOP && in == 1'b1);

endmodule"
N/A,N/A,-0.1,51,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    localparam IDLE = 2'b00;
    localparam RECEIVE = 2'b01;
    localparam STOP = 2'b10;

    reg [1:0] state, next_state;
    reg [7:0] shift_reg;
    reg [2:0] bit_count;

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 3'b0;
        end
        else begin
            state <= next_state;
            if (state == RECEIVE) begin
                bit_count <= bit_count + 1;
            end
            else begin
                bit_count <= 3'b0;
            end
        end
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 1'b0) begin // Start bit detected
                    next_state = RECEIVE;
                end
                else begin
                    next_state = IDLE;
                end
            end
            RECEIVE: begin
                if (bit_count == 3'b111) begin // All 8 data bits received
                    next_state = STOP;
                end
                else begin
                    next_state = RECEIVE;
                end
            end
            STOP: begin
                if (in == 1'b1) begin // Stop bit detected
                    next_state = IDLE;
                end
                else begin
                    next_state = STOP; // Wait for stop bit
                end
            end
            default: next_state = IDLE;
        endcase
    end

    // Output logic
    always @(posedge clk) begin
        if (state == RECEIVE) begin
            shift_reg <= {in, shift_reg[7:1]};
        end
    end

    assign done = (state == STOP && in == 1'b1);
    assign out_byte = done ? shift_reg : 8'bxxxx_xxxx;

endmodule"
N/A,N/A,-0.1,52,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    localparam IDLE = 2'b00;
    localparam RECEIVE = 2'b01;
    localparam STOP = 2'b10;

    reg [1:0] state, next_state;
    reg [7:0] shift_reg;
    reg [2:0] bit_count;

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 3'b0;
        end
        else begin
            state <= next_state;
            if (state == RECEIVE) begin
                bit_count <= bit_count + 1;
            end
            else begin
                bit_count <= 3'b0;
            end
        end
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 1'b0) begin // Start bit detected
                    next_state = RECEIVE;
                end
                else begin
                    next_state = IDLE;
                end
            end
            RECEIVE: begin
                if (bit_count == 3'b111) begin // All 8 data bits received
                    next_state = STOP;
                end
                else begin
                    next_state = RECEIVE;
                end
            end
            STOP: begin
                if (in == 1'b1) begin // Stop bit detected
                    next_state = IDLE;
                end
                else begin
                    next_state = STOP; // Wait for stop bit
                end
            end
            default: next_state = IDLE;
        endcase
    end

    // Output logic and datapath
    always @(posedge clk) begin
        if (state == RECEIVE) begin
            shift_reg <= {in, shift_reg[7:1]}; // Shift in the serial bit
        end
    end

    assign out_byte = (state == STOP && in == 1'b1) ? shift_reg : 8'bx;
    assign done = (state == STOP && in == 1'b1);

endmodule"
N/A,N/A,-0.1,53,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    localparam IDLE = 2'b00;
    localparam RECEIVE = 2'b01;
    localparam STOP = 2'b10;

    reg [1:0] state, next_state;
    reg [7:0] shift_reg;
    reg [2:0] bit_count;

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 3'b0;
        end
        else begin
            state <= next_state;
            if (state == RECEIVE) begin
                bit_count <= bit_count + 1;
            end
            else begin
                bit_count <= 3'b0;
            end
        end
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 1'b0) begin // Start bit detected
                    next_state = RECEIVE;
                end
                else begin
                    next_state = IDLE;
                end
            end
            RECEIVE: begin
                if (bit_count == 3'b111) begin // All 8 data bits received
                    next_state = STOP;
                end
                else begin
                    next_state = RECEIVE;
                end
            end
            STOP: begin
                if (in == 1'b1) begin // Stop bit detected
                    next_state = IDLE;
                end
                else begin
                    next_state = STOP;
                end
            end
            default: begin
                next_state = IDLE;
            end
        endcase
    end

    // Output logic and datapath
    always @(posedge clk) begin
        if (state == RECEIVE) begin
            shift_reg <= {in, shift_reg[7:1]}; // Shift in the serial bit
        end
    end

    assign out_byte = (state == STOP && in == 1'b1) ? shift_reg : 8'bx;
    assign done = (state == STOP && in == 1'b1);

endmodule"
N/A,N/A,-0.1,54,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    localparam IDLE = 2'b00;
    localparam RECEIVE = 2'b01;
    localparam STOP = 2'b10;

    reg [1:0] state, next_state;
    reg [7:0] shift_reg;
    reg [2:0] bit_count;

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 3'b0;
        end else begin
            state <= next_state;
            if (state == RECEIVE) begin
                shift_reg <= {in, shift_reg[7:1]};
                bit_count <= bit_count + 1;
            end else if (state == IDLE) begin
                bit_count <= 3'b0;
            end
        end
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 0) begin  // Start bit detected
                    next_state = RECEIVE;
                end else begin
                    next_state = IDLE;
                end
            end
            RECEIVE: begin
                if (bit_count == 3'd7) begin  // All 8 data bits received
                    next_state = STOP;
                end else begin
                    next_state = RECEIVE;
                end
            end
            STOP: begin
                if (in == 1) begin  // Stop bit detected
                    next_state = IDLE;
                end else begin
                    next_state = STOP;  // Wait for stop bit
                end
            end
            default: next_state = IDLE;
        endcase
    end

    // Output logic
    assign done = (state == STOP && in == 1);
    assign out_byte = (done) ? shift_reg : 8'bx;

endmodule"
N/A,N/A,-0.1,55,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    localparam IDLE = 2'b00;
    localparam RECEIVE = 2'b01;
    localparam STOP = 2'b10;

    reg [1:0] state, next_state;
    reg [7:0] shift_reg;
    reg [2:0] bit_count;

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 3'b0;
        end
        else begin
            state <= next_state;
            if (state == RECEIVE) begin
                bit_count <= bit_count + 1;
            end
            else begin
                bit_count <= 3'b0;
            end
        end
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 0) // Start bit detected
                    next_state = RECEIVE;
                else
                    next_state = IDLE;
            end

            RECEIVE: begin
                if (bit_count == 3'b111) // 8 bits received
                    next_state = STOP;
                else
                    next_state = RECEIVE;
            end

            STOP: begin
                if (in == 1) // Stop bit detected
                    next_state = IDLE;
                else
                    next_state = STOP; // Wait for stop bit
            end

            default: next_state = IDLE;
        endcase
    end

    // Output logic
    always @(posedge clk) begin
        if (state == RECEIVE) begin
            shift_reg <= {in, shift_reg[7:1]}; // Shift in the serial input
        end
    end

    assign out_byte = shift_reg;
    assign done = (state == STOP) && (in == 1); // Valid when in STOP state and stop bit is correct

endmodule"
N/A,N/A,-0.1,56,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    localparam IDLE = 2'b00;
    localparam START = 2'b01;
    localparam DATA = 2'b10;
    localparam STOP = 2'b11;

    reg [1:0] state, next_state;
    reg [7:0] shift_reg;
    reg [2:0] bit_count;

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
        end else begin
            state <= next_state;
        end
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 0) // Start bit detected
                    next_state = START;
                else
                    next_state = IDLE;
            end
            START: begin
                next_state = DATA;
            end
            DATA: begin
                if (bit_count == 3'd7)
                    next_state = STOP;
                else
                    next_state = DATA;
            end
            STOP: begin
                if (in == 1) // Stop bit detected
                    next_state = IDLE;
                else
                    next_state = STOP; // Wait for stop bit
            end
            default: next_state = IDLE;
        endcase
    end

    // Datapath to latch input bits
    always @(posedge clk) begin
        if (reset) begin
            shift_reg <= 8'b0;
            bit_count <= 3'b0;
        end else begin
            case (state)
                START: begin
                    shift_reg <= 8'b0;
                    bit_count <= 3'b0;
                end
                DATA: begin
                    shift_reg <= {in, shift_reg[7:1]}; // Shift in the least significant bit first
                    bit_count <= bit_count + 1;
                end
            endcase
        end
    end

    // Output logic
    assign out_byte = shift_reg;
    assign done = (state == STOP) && (in == 1);

endmodule"
N/A,N/A,-0.1,57,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    localparam IDLE = 2'd0;
    localparam RECEIVE = 2'd1;
    localparam STOP = 2'd2;

    reg [1:0] state, next_state;
    reg [7:0] shift_reg;
    reg [2:0] bit_count;

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 3'd0;
        end
        else begin
            state <= next_state;
            if (state == RECEIVE) begin
                bit_count <= bit_count + 1;
            end
            else begin
                bit_count <= 3'd0;
            end
        end
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 1'b0) begin // Start bit detected
                    next_state = RECEIVE;
                end
                else begin
                    next_state = IDLE;
                end
            end
            RECEIVE: begin
                if (bit_count == 3'd7) begin
                    next_state = STOP;
                end
                else begin
                    next_state = RECEIVE;
                end
            end
            STOP: begin
                if (in == 1'b1) begin // Stop bit detected
                    next_state = IDLE;
                end
                else begin
                    next_state = STOP; // Wait for stop bit
                end
            end
            default: begin
                next_state = IDLE;
            end
        endcase
    end

    // Output logic
    always @(posedge clk) begin
        if (state == RECEIVE) begin
            shift_reg <= {in, shift_reg[7:1]};
        end
    end

    assign out_byte = shift_reg;
    assign done = (state == STOP && in == 1'b1);

endmodule"
N/A,N/A,-0.1,58,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    localparam IDLE = 2'b00;
    localparam RECEIVE = 2'b01;
    localparam STOP = 2'b10;

    reg [1:0] state, next_state;
    reg [7:0] shift_reg;
    reg [2:0] bit_count;

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 3'b0;
        end else begin
            state <= next_state;
            if (state == RECEIVE) begin
                shift_reg <= {in, shift_reg[7:1]};
                bit_count <= bit_count + 1;
            end else if (state == IDLE) begin
                bit_count <= 3'b0;
            end
        end
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 0) begin  // Start bit detected
                    next_state = RECEIVE;
                end else begin
                    next_state = IDLE;
                end
            end
            RECEIVE: begin
                if (bit_count == 3'd7) begin  // All 8 data bits received
                    next_state = STOP;
                end else begin
                    next_state = RECEIVE;
                end
            end
            STOP: begin
                if (in == 1) begin  // Stop bit detected
                    next_state = IDLE;
                end else begin
                    next_state = STOP;  // Wait for stop bit
                end
            end
            default: next_state = IDLE;
        endcase
    end

    // Output logic
    assign done = (state == STOP && in == 1);
    assign out_byte = (done) ? shift_reg : 8'bx;

endmodule"
N/A,N/A,-0.1,59,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    localparam IDLE = 2'd0;
    localparam START = 2'd1;
    localparam DATA = 2'd2;
    localparam STOP = 2'd3;

    reg [1:0] state, next_state;
    reg [2:0] bit_count;
    reg [7:0] shift_reg;

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
        end else begin
            state <= next_state;
        end
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 0) // Start bit detected
                    next_state = START;
                else
                    next_state = IDLE;
            end
            START: begin
                next_state = DATA;
            end
            DATA: begin
                if (bit_count == 3'd7)
                    next_state = STOP;
                else
                    next_state = DATA;
            end
            STOP: begin
                if (in == 1) // Stop bit detected
                    next_state = IDLE;
                else
                    next_state = STOP;
            end
            default: next_state = IDLE;
        endcase
    end

    // Output logic and bit counting
    always @(posedge clk) begin
        if (reset) begin
            bit_count <= 3'd0;
            shift_reg <= 8'd0;
        end else begin
            case (state)
                IDLE: begin
                    bit_count <= 3'd0;
                end
                START: begin
                    bit_count <= 3'd0;
                end
                DATA: begin
                    shift_reg <= {in, shift_reg[7:1]};
                    bit_count <= bit_count + 1;
                end
                STOP: begin
                    // Do nothing, wait for next byte
                end
            endcase
        end
    end

    // Output assignments
    assign out_byte = (state == STOP && in == 1) ? shift_reg : 8'dx;
    assign done = (state == STOP && in == 1);

endmodule"
N/A,N/A,-0.1,60,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    localparam IDLE = 2'b00;
    localparam START = 2'b01;
    localparam DATA = 2'b10;
    localparam STOP = 2'b11;

    reg [1:0] state, next_state;
    reg [2:0] bit_count;
    reg [7:0] shift_reg;

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
        end else begin
            state <= next_state;
        end
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 0) // Start bit detected
                    next_state = START;
                else
                    next_state = IDLE;
            end
            START: begin
                next_state = DATA;
            end
            DATA: begin
                if (bit_count == 3'd7)
                    next_state = STOP;
                else
                    next_state = DATA;
            end
            STOP: begin
                if (in == 1) // Stop bit detected
                    next_state = IDLE;
                else
                    next_state = STOP;
            end
            default: next_state = IDLE;
        endcase
    end

    // Output logic and bit counting
    always @(posedge clk) begin
        if (reset) begin
            bit_count <= 3'd0;
            shift_reg <= 8'd0;
        end else begin
            case (state)
                IDLE: begin
                    bit_count <= 3'd0;
                end
                START: begin
                    bit_count <= 3'd0;
                end
                DATA: begin
                    shift_reg <= {in, shift_reg[7:1]};
                    bit_count <= bit_count + 1;
                end
                STOP: begin
                    // Do nothing, wait for stop bit to be detected
                end
            endcase
        end
    end

    // Output assignments
    assign out_byte = (state == STOP && in == 1) ? shift_reg : 8'bx;
    assign done = (state == STOP && in == 1);

endmodule"
N/A,N/A,-0.1,61,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    localparam IDLE = 2'd0;
    localparam START = 2'd1;
    localparam DATA = 2'd2;
    localparam STOP = 2'd3;

    reg [1:0] state, next_state;
    reg [2:0] bit_count;
    reg [7:0] shift_reg;

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
        end else begin
            state <= next_state;
        end
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 0) // Start bit detected
                    next_state = START;
                else
                    next_state = IDLE;
            end
            START: begin
                next_state = DATA;
            end
            DATA: begin
                if (bit_count == 3'd7)
                    next_state = STOP;
                else
                    next_state = DATA;
            end
            STOP: begin
                if (in == 1) // Stop bit detected
                    next_state = IDLE;
                else
                    next_state = STOP;
            end
            default: next_state = IDLE;
        endcase
    end

    // Output logic and bit counting
    always @(posedge clk) begin
        if (reset) begin
            bit_count <= 3'd0;
            shift_reg <= 8'd0;
        end else begin
            case (state)
                IDLE: begin
                    bit_count <= 3'd0;
                end
                START: begin
                    bit_count <= 3'd0;
                end
                DATA: begin
                    shift_reg <= {in, shift_reg[7:1]};
                    bit_count <= bit_count + 1;
                end
                STOP: begin
                    // Do nothing, wait for next byte
                end
            endcase
        end
    end

    // Output assignments
    assign out_byte = (state == STOP && in == 1) ? shift_reg : 8'dx;
    assign done = (state == STOP && in == 1);

endmodule"
N/A,N/A,-0.1,62,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    localparam IDLE = 2'b00;
    localparam RECEIVE = 2'b01;
    localparam STOP = 2'b10;

    reg [1:0] state, next_state;
    reg [7:0] shift_reg;
    reg [2:0] bit_count;

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 3'b0;
        end
        else begin
            state <= next_state;
            if (state == RECEIVE) begin
                bit_count <= bit_count + 1;
            end
            else begin
                bit_count <= 3'b0;
            end
        end
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 1'b0) begin // Start bit detected
                    next_state = RECEIVE;
                end
                else begin
                    next_state = IDLE;
                end
            end
            RECEIVE: begin
                if (bit_count == 3'b111) begin // All 8 data bits received
                    next_state = STOP;
                end
                else begin
                    next_state = RECEIVE;
                end
            end
            STOP: begin
                if (in == 1'b1) begin // Stop bit detected
                    next_state = IDLE;
                end
                else begin
                    next_state = STOP; // Wait for stop bit
                end
            end
            default: next_state = IDLE;
        endcase
    end

    // Output logic
    always @(posedge clk) begin
        if (state == RECEIVE) begin
            shift_reg <= {in, shift_reg[7:1]};
        end
    end

    assign done = (state == STOP && in == 1'b1);
    assign out_byte = done ? shift_reg : 8'bxxxx_xxxx;

endmodule"
N/A,N/A,-0.1,63,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    localparam IDLE = 2'b00;
    localparam RECEIVE = 2'b01;
    localparam STOP = 2'b10;

    reg [1:0] state, next_state;
    reg [7:0] shift_reg;
    reg [2:0] bit_count;

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 3'b0;
        end
        else begin
            state <= next_state;
            if (state == RECEIVE) begin
                bit_count <= bit_count + 1;
            end
            else begin
                bit_count <= 3'b0;
            end
        end
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 1'b0) begin // Start bit detected
                    next_state = RECEIVE;
                end
                else begin
                    next_state = IDLE;
                end
            end
            RECEIVE: begin
                if (bit_count == 3'b111) begin // All 8 data bits received
                    next_state = STOP;
                end
                else begin
                    next_state = RECEIVE;
                end
            end
            STOP: begin
                if (in == 1'b1) begin // Stop bit detected
                    next_state = IDLE;
                end
                else begin
                    next_state = STOP; // Wait for stop bit
                end
            end
            default: next_state = IDLE;
        endcase
    end

    // Output logic and datapath
    always @(posedge clk) begin
        if (state == RECEIVE) begin
            shift_reg <= {in, shift_reg[7:1]}; // Shift in the serial data
        end
    end

    assign out_byte = (state == STOP && in == 1'b1) ? shift_reg : 8'bx; // Output valid byte when stop bit is correct
    assign done = (state == STOP && in == 1'b1); // Done is high when a full byte is received with a valid stop bit

endmodule"
N/A,N/A,-0.1,64,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    localparam IDLE = 2'd0;
    localparam START = 2'd1;
    localparam DATA = 2'd2;
    localparam STOP = 2'd3;

    reg [1:0] state, next_state;
    reg [2:0] bit_count;
    reg [7:0] shift_reg;

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
        end else begin
            state <= next_state;
        end
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 0) // Start bit detected
                    next_state = START;
                else
                    next_state = IDLE;
            end
            START: begin
                next_state = DATA;
            end
            DATA: begin
                if (bit_count == 3'd7)
                    next_state = STOP;
                else
                    next_state = DATA;
            end
            STOP: begin
                if (in == 1) // Stop bit detected
                    next_state = IDLE;
                else
                    next_state = STOP;
            end
            default: next_state = IDLE;
        endcase
    end

    // Output logic and bit counting
    always @(posedge clk) begin
        if (reset) begin
            bit_count <= 3'd0;
            shift_reg <= 8'd0;
        end else begin
            case (state)
                IDLE: begin
                    bit_count <= 3'd0;
                end
                START: begin
                    bit_count <= 3'd0;
                end
                DATA: begin
                    shift_reg <= {in, shift_reg[7:1]};
                    bit_count <= bit_count + 1;
                end
                STOP: begin
                    // Do nothing, wait for next byte
                end
            endcase
        end
    end

    // Output assignments
    assign out_byte = (state == STOP && in == 1) ? shift_reg : 8'dx;
    assign done = (state == STOP && in == 1);

endmodule"
N/A,N/A,-0.1,65,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    localparam IDLE = 2'b00;
    localparam RECEIVE = 2'b01;
    localparam STOP = 2'b10;

    reg [1:0] state, next_state;
    reg [7:0] data_shift_reg;
    reg [2:0] bit_count;
    reg done_reg;

    // FSM state transition
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
        end else begin
            state <= next_state;
        end
    end

    // FSM next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 1'b0)  // Start bit detected
                    next_state = RECEIVE;
                else
                    next_state = IDLE;
            end
            RECEIVE: begin
                if (bit_count == 3'd7)  // All 8 data bits received
                    next_state = STOP;
                else
                    next_state = RECEIVE;
            end
            STOP: begin
                if (in == 1'b1)  // Stop bit detected
                    next_state = IDLE;
                else
                    next_state = STOP;
            end
            default: next_state = IDLE;
        endcase
    end

    // Data path and bit counting
    always @(posedge clk) begin
        if (reset) begin
            data_shift_reg <= 8'b0;
            bit_count <= 3'b0;
            done_reg <= 1'b0;
        end else begin
            done_reg <= 1'b0;
            case (state)
                IDLE: begin
                    bit_count <= 3'b0;
                end
                RECEIVE: begin
                    data_shift_reg <= {in, data_shift_reg[7:1]};
                    bit_count <= bit_count + 1'b1;
                end
                STOP: begin
                    if (in == 1'b1) begin
                        done_reg <= 1'b1;
                    end
                end
            endcase
        end
    end

    assign out_byte = data_shift_reg;
    assign done = done_reg;

endmodule"
N/A,N/A,-0.1,66,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    localparam IDLE = 2'b00;
    localparam RECEIVE = 2'b01;
    localparam STOP = 2'b10;

    reg [1:0] state, next_state;
    reg [7:0] shift_reg;
    reg [2:0] bit_count;

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 3'b0;
        end
        else begin
            state <= next_state;
            if (state == RECEIVE) begin
                bit_count <= bit_count + 1;
            end
            else begin
                bit_count <= 3'b0;
            end
        end
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 1'b0) begin // Start bit detected
                    next_state = RECEIVE;
                end
                else begin
                    next_state = IDLE;
                end
            end
            RECEIVE: begin
                if (bit_count == 3'b111) begin // All 8 data bits received
                    next_state = STOP;
                end
                else begin
                    next_state = RECEIVE;
                end
            end
            STOP: begin
                if (in == 1'b1) begin // Stop bit detected
                    next_state = IDLE;
                end
                else begin
                    next_state = STOP; // Wait for stop bit
                end
            end
            default: next_state = IDLE;
        endcase
    end

    // Output logic and datapath
    always @(posedge clk) begin
        if (state == RECEIVE) begin
            shift_reg <= {in, shift_reg[7:1]}; // Shift in the serial data
        end
    end

    assign out_byte = (state == STOP && in == 1'b1) ? shift_reg : 8'bx; // Output valid byte when stop bit is correct
    assign done = (state == STOP && in == 1'b1); // Done is high when a full byte is correctly received
endmodule"
N/A,N/A,-0.1,67,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    localparam IDLE = 2'd0;
    localparam START = 2'd1;
    localparam DATA = 2'd2;
    localparam STOP = 2'd3;

    reg [1:0] state, next_state;
    reg [2:0] bit_count;  // Counter for data bits
    reg [7:0] shift_reg;  // Shift register for data bits

    // State transition logic (combinational)
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 0)  // Detect start bit
                    next_state = START;
                else
                    next_state = IDLE;
            end
            START: begin
                next_state = DATA;
            end
            DATA: begin
                if (bit_count == 3'd7)  // All 8 bits received
                    next_state = STOP;
                else
                    next_state = DATA;
            end
            STOP: begin
                if (in == 1)  // Detect stop bit
                    next_state = IDLE;
                else
                    next_state = STOP;  // Wait for stop bit
            end
            default: next_state = IDLE;
        endcase
    end

    // State flip-flops (sequential)
    always @(posedge clk) begin
        if (reset)
            state <= IDLE;
        else
            state <= next_state;
    end

    // Datapath to latch input bits
    always @(posedge clk) begin
        if (reset) begin
            bit_count <= 3'd0;
            shift_reg <= 8'd0;
        end
        else begin
            case (state)
                START: begin
                    bit_count <= 3'd0;
                end
                DATA: begin
                    shift_reg <= {in, shift_reg[7:1]};  // Shift in the new bit
                    bit_count <= bit_count + 3'd1;
                end
                STOP: begin
                    // Do nothing, just wait for stop bit
                end
            endcase
        end
    end

    // Output logic
    assign out_byte = (state == STOP && in == 1) ? shift_reg : 8'bx;
    assign done = (state == STOP && in == 1);

endmodule"
N/A,N/A,-0.1,68,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    localparam IDLE = 2'b00;
    localparam RECEIVE = 2'b01;
    localparam STOP = 2'b10;

    reg [1:0] state, next_state;
    reg [7:0] shift_reg;
    reg [2:0] bit_count;

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 3'b0;
        end else begin
            state <= next_state;
            if (state == RECEIVE) begin
                shift_reg <= {in, shift_reg[7:1]};
                bit_count <= bit_count + 1;
            end else if (state == IDLE) begin
                bit_count <= 3'b0;
            end
        end
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 0) begin  // Start bit detected
                    next_state = RECEIVE;
                end else begin
                    next_state = IDLE;
                end
            end
            RECEIVE: begin
                if (bit_count == 3'd7) begin  // All 8 data bits received
                    next_state = STOP;
                end else begin
                    next_state = RECEIVE;
                end
            end
            STOP: begin
                if (in == 1) begin  // Stop bit detected
                    next_state = IDLE;
                end else begin
                    next_state = STOP;  // Wait for stop bit
                end
            end
            default: next_state = IDLE;
        endcase
    end

    // Output logic
    assign done = (state == STOP && in == 1);
    assign out_byte = (done) ? shift_reg : 8'bx;

endmodule"
N/A,N/A,-0.1,69,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    localparam IDLE = 2'b00;
    localparam RECEIVE = 2'b01;
    localparam STOP = 2'b10;

    reg [1:0] state, next_state;
    reg [7:0] shift_reg;
    reg [2:0] bit_count;

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 3'b0;
        end else begin
            state <= next_state;
            if (state == RECEIVE) begin
                shift_reg <= {in, shift_reg[7:1]};
                bit_count <= bit_count + 1;
            end else if (state == IDLE) begin
                bit_count <= 3'b0;
            end
        end
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 0) begin  // Start bit detected
                    next_state = RECEIVE;
                end else begin
                    next_state = IDLE;
                end
            end
            RECEIVE: begin
                if (bit_count == 3'd7) begin  // All 8 data bits received
                    next_state = STOP;
                end else begin
                    next_state = RECEIVE;
                end
            end
            STOP: begin
                if (in == 1) begin  // Stop bit detected
                    next_state = IDLE;
                end else begin
                    next_state = STOP;  // Wait for stop bit
                end
            end
            default: next_state = IDLE;
        endcase
    end

    // Output logic
    assign done = (state == STOP && in == 1);
    assign out_byte = (done) ? shift_reg : 8'bx;

endmodule"
N/A,N/A,-0.1,70,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    localparam IDLE = 2'b00;
    localparam RECEIVE = 2'b01;
    localparam STOP = 2'b10;

    reg [1:0] state, next_state;
    reg [7:0] shift_reg;
    reg [2:0] bit_count;

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 3'b0;
        end
        else begin
            state <= next_state;
            if (state == RECEIVE) begin
                bit_count <= bit_count + 1;
            end
            else begin
                bit_count <= 3'b0;
            end
        end
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 0) // Start bit detected
                    next_state = RECEIVE;
                else
                    next_state = IDLE;
            end
            RECEIVE: begin
                if (bit_count == 3'b111) // 8 bits received
                    next_state = STOP;
                else
                    next_state = RECEIVE;
            end
            STOP: begin
                if (in == 1) // Stop bit detected
                    next_state = IDLE;
                else
                    next_state = STOP; // Wait for stop bit
            end
            default: next_state = IDLE;
        endcase
    end

    // Output logic
    always @(posedge clk) begin
        if (state == RECEIVE) begin
            shift_reg <= {in, shift_reg[7:1]}; // Shift in the serial input
        end
    end

    assign out_byte = shift_reg;
    assign done = (state == STOP) && (in == 1); // Valid when in STOP state and stop bit is correct

endmodule"
N/A,N/A,-0.1,71,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    localparam IDLE = 2'b00;
    localparam RECEIVE = 2'b01;
    localparam STOP = 2'b10;

    reg [1:0] state, next_state;
    reg [7:0] shift_reg;
    reg [2:0] bit_count;

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 3'b0;
        end else begin
            state <= next_state;
            if (state == RECEIVE) begin
                shift_reg <= {in, shift_reg[7:1]};
                bit_count <= bit_count + 1;
            end else if (state == IDLE) begin
                bit_count <= 3'b0;
            end
        end
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 0) begin  // Start bit detected
                    next_state = RECEIVE;
                end else begin
                    next_state = IDLE;
                end
            end
            RECEIVE: begin
                if (bit_count == 3'b111) begin  // 8 bits received
                    next_state = STOP;
                end else begin
                    next_state = RECEIVE;
                end
            end
            STOP: begin
                if (in == 1) begin  // Stop bit detected
                    next_state = IDLE;
                end else begin
                    next_state = STOP;
                end
            end
            default: begin
                next_state = IDLE;
            end
        endcase
    end

    // Output logic
    assign done = (state == STOP) && (in == 1);
    assign out_byte = (done) ? shift_reg : 8'bx;

endmodule"
N/A,N/A,-1,72,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    localparam IDLE = 2'd0;
    localparam START = 2'd1;
    localparam DATA = 2'd2;
    localparam STOP = 2'd3;

    reg [1:0] state, next_state;
    reg [2:0] bit_count;
    reg [7:0] shift_reg;

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
        end else begin
            state <= next_state;
        end
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 0) // Start bit detected
                    next_state = START;
                else
                    next_state = IDLE;
            end
            START: begin
                next_state = DATA;
            end
            DATA: begin
                if (bit_count == 3'd7)
                    next_state = STOP;
                else
                    next_state = DATA;
            end
            STOP: begin
                if (in == 1) // Stop bit detected
                    next_state = IDLE;
                else
                    next_state = STOP;
            end
            default: next_state = IDLE;
        endcase
    end

    // Output logic and bit counting
    always @(posedge clk) begin
        if (reset) begin
            bit_count <= 3'd0;
            shift_reg <= 8'd0;
        end else begin
            case (state)
                IDLE: begin
                    bit_count <= 3'd0;
                end
                START: begin
                    bit_count <= 3'd0;
                end
                DATA: begin
                    shift_reg <= {in, shift_reg[7:1]};
                    bit_count <= bit_count + 1;
                end
                STOP: begin
                    if (in == 1) begin
                        done <= 1;
                    end else begin
                        done <= 0;
                    end
                end
            endcase
        end
    end

    // Output assignment
    assign out_byte = (state == STOP && in == 1) ? shift_reg : 8'bx;
    assign done = (state == STOP && in == 1);

endmodule"
N/A,N/A,-0.1,73,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    localparam IDLE = 2'b00;
    localparam RECEIVE = 2'b01;
    localparam STOP = 2'b10;

    reg [1:0] state, next_state;
    reg [7:0] shift_reg;
    reg [2:0] bit_count;

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 3'b0;
        end else begin
            state <= next_state;
            if (state == RECEIVE) begin
                shift_reg <= {in, shift_reg[7:1]};
                bit_count <= bit_count + 1;
            end else if (state == IDLE) begin
                bit_count <= 3'b0;
            end
        end
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 0) begin  // Start bit detected
                    next_state = RECEIVE;
                end else begin
                    next_state = IDLE;
                end
            end
            RECEIVE: begin
                if (bit_count == 3'd7) begin  // All 8 data bits received
                    next_state = STOP;
                end else begin
                    next_state = RECEIVE;
                end
            end
            STOP: begin
                if (in == 1) begin  // Stop bit detected
                    next_state = IDLE;
                end else begin
                    next_state = STOP;  // Wait for stop bit
                end
            end
            default: next_state = IDLE;
        endcase
    end

    // Output logic
    assign done = (state == STOP && in == 1);
    assign out_byte = (done) ? shift_reg : 8'bx;

endmodule"
N/A,N/A,-0.1,74,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    localparam IDLE = 2'd0;
    localparam START = 2'd1;
    localparam DATA = 2'd2;
    localparam STOP = 2'd3;

    reg [1:0] state, next_state;
    reg [2:0] bit_count;  // Counter for data bits
    reg [7:0] shift_reg;  // Shift register for data bits

    // State transition logic (combinational)
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 0)  // Detect start bit
                    next_state = START;
                else
                    next_state = IDLE;
            end
            START: begin
                next_state = DATA;
            end
            DATA: begin
                if (bit_count == 3'd7)  // All 8 bits received
                    next_state = STOP;
                else
                    next_state = DATA;
            end
            STOP: begin
                if (in == 1)  // Detect stop bit
                    next_state = IDLE;
                else
                    next_state = STOP;  // Wait for stop bit
            end
            default: next_state = IDLE;
        endcase
    end

    // State flip-flops (sequential)
    always @(posedge clk) begin
        if (reset)
            state <= IDLE;
        else
            state <= next_state;
    end

    // Datapath to latch input bits
    always @(posedge clk) begin
        if (reset) begin
            bit_count <= 3'd0;
            shift_reg <= 8'd0;
        end
        else begin
            case (state)
                START: begin
                    bit_count <= 3'd0;
                end
                DATA: begin
                    shift_reg <= {in, shift_reg[7:1]};  // Shift in the new bit
                    bit_count <= bit_count + 3'd1;
                end
                STOP: begin
                    // Do nothing, just wait for stop bit
                end
            endcase
        end
    end

    // Output logic
    assign out_byte = (state == STOP && in == 1) ? shift_reg : 8'bx;
    assign done = (state == STOP && in == 1);

endmodule"
N/A,N/A,-0.1,75,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    localparam IDLE = 2'b00;
    localparam RECEIVE = 2'b01;
    localparam STOP = 2'b10;

    reg [1:0] state, next_state;
    reg [7:0] shift_reg;
    reg [2:0] bit_count;

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 3'b0;
        end
        else begin
            state <= next_state;
            if (state == RECEIVE) begin
                bit_count <= bit_count + 1;
            end
            else begin
                bit_count <= 3'b0;
            end
        end
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 1'b0) begin // Start bit detected
                    next_state = RECEIVE;
                end
                else begin
                    next_state = IDLE;
                end
            end
            RECEIVE: begin
                if (bit_count == 3'b111) begin // All 8 data bits received
                    next_state = STOP;
                end
                else begin
                    next_state = RECEIVE;
                end
            end
            STOP: begin
                if (in == 1'b1) begin // Stop bit detected
                    next_state = IDLE;
                end
                else begin
                    next_state = STOP; // Wait for stop bit
                end
            end
            default: next_state = IDLE;
        endcase
    end

    // Output logic and datapath
    always @(posedge clk) begin
        if (state == RECEIVE) begin
            shift_reg <= {in, shift_reg[7:1]}; // Shift in the serial bit
        end
    end

    assign out_byte = (state == STOP && in == 1'b1) ? shift_reg : 8'bx;
    assign done = (state == STOP && in == 1'b1);

endmodule"
N/A,N/A,-0.1,76,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    localparam IDLE = 2'b00;
    localparam RECEIVE = 2'b01;
    localparam STOP = 2'b10;

    reg [1:0] state, next_state;
    reg [7:0] shift_reg;
    reg [2:0] bit_count;

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 3'b0;
        end else begin
            state <= next_state;
            if (state == RECEIVE) begin
                shift_reg <= {in, shift_reg[7:1]};
                bit_count <= bit_count + 1;
            end else if (state == IDLE) begin
                bit_count <= 3'b0;
            end
        end
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 0) begin  // Start bit detected
                    next_state = RECEIVE;
                end else begin
                    next_state = IDLE;
                end
            end
            RECEIVE: begin
                if (bit_count == 3'd7) begin  // All 8 data bits received
                    next_state = STOP;
                end else begin
                    next_state = RECEIVE;
                end
            end
            STOP: begin
                if (in == 1) begin  // Stop bit detected
                    next_state = IDLE;
                end else begin
                    next_state = STOP;  // Wait for stop bit
                end
            end
            default: next_state = IDLE;
        endcase
    end

    // Output logic
    assign done = (state == STOP && in == 1);
    assign out_byte = done ? shift_reg : 8'bx;

endmodule"
N/A,N/A,-0.1,77,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    localparam IDLE = 2'd0;
    localparam RECEIVE = 2'd1;
    localparam STOP = 2'd2;

    reg [1:0] state, next_state;
    reg [7:0] shift_reg;
    reg [2:0] bit_count;

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 3'd0;
        end else begin
            state <= next_state;
            if (state == RECEIVE) begin
                shift_reg <= {in, shift_reg[7:1]};
                bit_count <= bit_count + 3'd1;
            end
        end
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 1'b0) // Start bit detected
                    next_state = RECEIVE;
                else
                    next_state = IDLE;
            end
            RECEIVE: begin
                if (bit_count == 3'd7)
                    next_state = STOP;
                else
                    next_state = RECEIVE;
            end
            STOP: begin
                if (in == 1'b1) // Stop bit detected
                    next_state = IDLE;
                else
                    next_state = STOP;
            end
            default: next_state = IDLE;
        endcase
    end

    // Output logic
    assign done = (state == STOP) && (in == 1'b1);
    assign out_byte = (done) ? shift_reg : 8'd0;

endmodule"
N/A,N/A,-0.1,78,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    localparam IDLE = 2'b00;
    localparam RECEIVE = 2'b01;
    localparam STOP = 2'b10;

    reg [1:0] state, next_state;
    reg [7:0] shift_reg;
    reg [2:0] bit_count;

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 3'b0;
        end
        else begin
            state <= next_state;
            if (state == RECEIVE) begin
                bit_count <= bit_count + 1;
            end
            else begin
                bit_count <= 3'b0;
            end
        end
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 1'b0) begin // Start bit detected
                    next_state = RECEIVE;
                end
                else begin
                    next_state = IDLE;
                end
            end
            RECEIVE: begin
                if (bit_count == 3'b111) begin // All 8 data bits received
                    next_state = STOP;
                end
                else begin
                    next_state = RECEIVE;
                end
            end
            STOP: begin
                if (in == 1'b1) begin // Stop bit detected
                    next_state = IDLE;
                end
                else begin
                    next_state = STOP; // Wait for stop bit
                end
            end
            default: next_state = IDLE;
        endcase
    end

    // Output logic and datapath
    always @(posedge clk) begin
        if (state == RECEIVE) begin
            shift_reg <= {in, shift_reg[7:1]}; // Shift in the serial data
        end
    end

    assign out_byte = (state == STOP && in == 1'b1) ? shift_reg : 8'bx; // Output valid byte when stop bit is correct
    assign done = (state == STOP && in == 1'b1); // Done is high when a full byte is correctly received
endmodule"
N/A,N/A,-0.1,79,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    localparam IDLE = 2'd0;
    localparam START = 2'd1;
    localparam DATA = 2'd2;
    localparam STOP = 2'd3;

    reg [1:0] state, next_state;
    reg [2:0] bit_count;  // Counter for 8 data bits
    reg [7:0] shift_reg;  // Shift register to store incoming bits

    // State transition logic
    always @ (posedge clk) begin
        if (reset) begin
            state <= IDLE;
        end else begin
            state <= next_state;
        end
    end

    // Next state logic
    always @ (*) begin
        case (state)
            IDLE: begin
                if (in == 0) // Detect start bit
                    next_state = START;
                else
                    next_state = IDLE;
            end
            START: begin
                next_state = DATA;
            end
            DATA: begin
                if (bit_count == 3'd7) // All data bits received
                    next_state = STOP;
                else
                    next_state = DATA;
            end
            STOP: begin
                if (in == 1) // Detect stop bit
                    next_state = IDLE;
                else
                    next_state = STOP; // Wait for stop bit
            end
            default: begin
                next_state = IDLE;
            end
        endcase
    end

    // Output logic and datapath
    always @ (posedge clk) begin
        if (reset) begin
            bit_count <= 3'd0;
            shift_reg <= 8'b0;
        end else begin
            case (state)
                IDLE: begin
                    bit_count <= 3'd0;
                end
                START: begin
                    bit_count <= 3'd0;
                end
                DATA: begin
                    shift_reg <= {in, shift_reg[7:1]}; // Shift in the new bit
                    bit_count <= bit_count + 1;
                end
                STOP: begin
                    if (in == 1) begin
                        // Do nothing, waiting for next start bit
                    end
                end
            endcase
        end
    end

    assign out_byte = shift_reg;
    assign done = (state == STOP) && (in == 1);

endmodule"
N/A,N/A,-0.1,80,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    localparam IDLE = 2'b00;
    localparam RECEIVE = 2'b01;
    localparam STOP = 2'b10;

    reg [1:0] state, next_state;
    reg [7:0] shift_reg;
    reg [2:0] bit_count;

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 3'b0;
        end
        else begin
            state <= next_state;
            if (state == RECEIVE) begin
                bit_count <= bit_count + 1;
            end
            else begin
                bit_count <= 3'b0;
            end
        end
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 0) // Start bit detected
                    next_state = RECEIVE;
                else
                    next_state = IDLE;
            end
            RECEIVE: begin
                if (bit_count == 3'b111) // 8 bits received
                    next_state = STOP;
                else
                    next_state = RECEIVE;
            end
            STOP: begin
                if (in == 1) // Stop bit detected
                    next_state = IDLE;
                else
                    next_state = STOP; // Wait for stop bit
            end
            default: next_state = IDLE;
        endcase
    end

    // Output logic
    always @(posedge clk) begin
        if (state == RECEIVE) begin
            shift_reg <= {in, shift_reg[7:1]}; // Shift in the serial input
        end
    end

    assign out_byte = shift_reg;
    assign done = (state == STOP) && (in == 1); // Valid output when in STOP state with correct stop bit

endmodule"
N/A,N/A,-0.1,81,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    localparam IDLE = 2'b00;
    localparam RECEIVE = 2'b01;
    localparam STOP = 2'b10;

    reg [1:0] state, next_state;
    reg [7:0] shift_reg;
    reg [2:0] bit_count;

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 3'b0;
        end
        else begin
            state <= next_state;
            if (state == RECEIVE) begin
                bit_count <= bit_count + 1;
                shift_reg <= {in, shift_reg[7:1]};
            end
            else if (state == STOP && in) begin
                bit_count <= 3'b0;
            end
        end
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (!in) // Start bit detected
                    next_state = RECEIVE;
                else
                    next_state = IDLE;
            end
            RECEIVE: begin
                if (bit_count == 3'b111) // 8 bits received
                    next_state = STOP;
                else
                    next_state = RECEIVE;
            end
            STOP: begin
                if (in) // Stop bit detected
                    next_state = IDLE;
                else
                    next_state = STOP;
            end
            default: next_state = IDLE;
        endcase
    end

    // Output logic
    assign done = (state == STOP) && in;
    assign out_byte = (done) ? shift_reg : 8'bx;

endmodule"
N/A,N/A,-0.1,82,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    localparam IDLE = 2'b00;
    localparam RECEIVE = 2'b01;
    localparam STOP = 2'b10;

    reg [1:0] state, next_state;
    reg [7:0] shift_reg;
    reg [2:0] bit_count;

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 3'b0;
        end
        else begin
            state <= next_state;
            if (state == RECEIVE) begin
                bit_count <= bit_count + 1;
            end
            else begin
                bit_count <= 3'b0;
            end
        end
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 1'b0) begin // Start bit detected
                    next_state = RECEIVE;
                end
                else begin
                    next_state = IDLE;
                end
            end
            RECEIVE: begin
                if (bit_count == 3'b111) begin // All 8 data bits received
                    next_state = STOP;
                end
                else begin
                    next_state = RECEIVE;
                end
            end
            STOP: begin
                if (in == 1'b1) begin // Stop bit detected
                    next_state = IDLE;
                end
                else begin
                    next_state = STOP; // Wait for stop bit
                end
            end
            default: next_state = IDLE;
        endcase
    end

    // Output logic and datapath
    always @(posedge clk) begin
        if (state == RECEIVE) begin
            shift_reg <= {in, shift_reg[7:1]}; // Shift in the serial data
        end
    end

    assign out_byte = (state == STOP && in == 1'b1) ? shift_reg : 8'bx; // Only valid when done
    assign done = (state == STOP && in == 1'b1); // Done when stop bit is correct

endmodule"
N/A,N/A,-0.1,83,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    localparam IDLE = 2'b00;
    localparam RECEIVE = 2'b01;
    localparam STOP = 2'b10;

    reg [1:0] state, next_state;
    reg [7:0] shift_reg;
    reg [2:0] bit_count;

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 3'b0;
        end else begin
            state <= next_state;
            if (state == RECEIVE) begin
                shift_reg <= {in, shift_reg[7:1]};
                bit_count <= bit_count + 1;
            end
        end
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 0) // Start bit detected
                    next_state = RECEIVE;
                else
                    next_state = IDLE;
            end
            RECEIVE: begin
                if (bit_count == 3'b111) // All 8 data bits received
                    next_state = STOP;
                else
                    next_state = RECEIVE;
            end
            STOP: begin
                if (in == 1) // Stop bit detected
                    next_state = IDLE;
                else
                    next_state = STOP; // Wait for stop bit
            end
            default: next_state = IDLE;
        endcase
    end

    // Output logic
    assign done = (state == STOP) && (in == 1);
    assign out_byte = (done) ? shift_reg : 8'bxxxx_xxxx;

endmodule"
N/A,N/A,-0.1,84,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    localparam IDLE = 2'b00;
    localparam RECEIVE = 2'b01;
    localparam STOP = 2'b10;

    reg [1:0] state, next_state;
    reg [7:0] shift_reg;
    reg [2:0] bit_count;

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 3'b0;
        end
        else begin
            state <= next_state;
            if (state == RECEIVE) begin
                bit_count <= bit_count + 1;
            end
            else begin
                bit_count <= 3'b0;
            end
        end
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 1'b0) begin // Start bit detected
                    next_state = RECEIVE;
                end
                else begin
                    next_state = IDLE;
                end
            end
            RECEIVE: begin
                if (bit_count == 3'b111) begin // All 8 data bits received
                    next_state = STOP;
                end
                else begin
                    next_state = RECEIVE;
                end
            end
            STOP: begin
                if (in == 1'b1) begin // Stop bit detected
                    next_state = IDLE;
                end
                else begin
                    next_state = STOP; // Wait for stop bit
                end
            end
            default: next_state = IDLE;
        endcase
    end

    // Output logic and datapath
    always @(posedge clk) begin
        if (state == RECEIVE) begin
            shift_reg <= {in, shift_reg[7:1]}; // Shift in the serial bit
        end
    end

    assign out_byte = (state == STOP && in == 1'b1) ? shift_reg : 8'bx;
    assign done = (state == STOP && in == 1'b1);

endmodule"
N/A,N/A,-0.1,85,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    localparam IDLE = 2'b00;
    localparam RECEIVE = 2'b01;
    localparam STOP = 2'b10;

    reg [1:0] state, next_state;
    reg [7:0] data_shift_reg;
    reg [2:0] bit_count;
    reg done_reg;

    // FSM state transition
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
        end else begin
            state <= next_state;
        end
    end

    // FSM next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 0) // Start bit detected
                    next_state = RECEIVE;
                else
                    next_state = IDLE;
            end
            RECEIVE: begin
                if (bit_count == 3'b111) // All 8 data bits received
                    next_state = STOP;
                else
                    next_state = RECEIVE;
            end
            STOP: begin
                if (in == 1) // Stop bit detected
                    next_state = IDLE;
                else
                    next_state = STOP; // Wait for stop bit
            end
            default: next_state = IDLE;
        endcase
    end

    // Datapath operations
    always @(posedge clk) begin
        if (reset) begin
            data_shift_reg <= 8'b0;
            bit_count <= 3'b0;
            done_reg <= 1'b0;
        end else begin
            case (state)
                IDLE: begin
                    data_shift_reg <= 8'b0;
                    bit_count <= 3'b0;
                    done_reg <= 1'b0;
                end
                RECEIVE: begin
                    data_shift_reg <= {in, data_shift_reg[7:1]}; // Shift in LSB first
                    bit_count <= bit_count + 1;
                    done_reg <= 1'b0;
                end
                STOP: begin
                    if (in == 1) begin
                        done_reg <= 1'b1; // Byte is valid
                    end
                end
            endcase
        end
    end

    // Output assignments
    assign out_byte = data_shift_reg;
    assign done = done_reg;

endmodule"
N/A,N/A,-0.1,86,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    localparam IDLE = 2'b00;
    localparam RECEIVE = 2'b01;
    localparam STOP = 2'b10;

    reg [1:0] state, next_state;
    reg [7:0] shift_reg;
    reg [2:0] bit_count;

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 3'b0;
        end
        else begin
            state <= next_state;
            if (state == RECEIVE) begin
                bit_count <= bit_count + 1;
            end
            else begin
                bit_count <= 3'b0;
            end
        end
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 1'b0) begin // Start bit detected
                    next_state = RECEIVE;
                end
                else begin
                    next_state = IDLE;
                end
            end
            RECEIVE: begin
                if (bit_count == 3'b111) begin // All 8 data bits received
                    next_state = STOP;
                end
                else begin
                    next_state = RECEIVE;
                end
            end
            STOP: begin
                if (in == 1'b1) begin // Stop bit detected
                    next_state = IDLE;
                end
                else begin
                    next_state = STOP;
                end
            end
            default: begin
                next_state = IDLE;
            end
        endcase
    end

    // Output logic and datapath
    always @(posedge clk) begin
        if (state == RECEIVE) begin
            shift_reg <= {in, shift_reg[7:1]}; // Shift in the serial bit
        end
    end

    assign out_byte = (state == STOP && in == 1'b1) ? shift_reg : 8'bx;
    assign done = (state == STOP && in == 1'b1);

endmodule"
N/A,N/A,-0.1,87,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    localparam IDLE = 2'd0;
    localparam RECEIVE = 2'd1;
    localparam STOP = 2'd2;

    reg [1:0] state, next_state;
    reg [7:0] shift_reg;
    reg [2:0] bit_count;

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 3'd0;
        end
        else begin
            state <= next_state;
            if (state == RECEIVE) begin
                bit_count <= bit_count + 1;
            end
            else begin
                bit_count <= 3'd0;
            end
        end
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 1'b0) begin // Start bit detected
                    next_state = RECEIVE;
                end
                else begin
                    next_state = IDLE;
                end
            end
            RECEIVE: begin
                if (bit_count == 3'd7) begin
                    next_state = STOP;
                end
                else begin
                    next_state = RECEIVE;
                end
            end
            STOP: begin
                if (in == 1'b1) begin // Stop bit detected
                    next_state = IDLE;
                end
                else begin
                    next_state = STOP; // Wait for stop bit
                end
            end
            default: begin
                next_state = IDLE;
            end
        endcase
    end

    // Output logic
    always @(posedge clk) begin
        if (state == RECEIVE) begin
            shift_reg <= {in, shift_reg[7:1]};
        end
    end

    assign out_byte = shift_reg;
    assign done = (state == STOP && in == 1'b1);

endmodule"
N/A,N/A,-0.1,88,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    localparam IDLE = 2'b00;
    localparam RECEIVE = 2'b01;
    localparam STOP = 2'b10;

    reg [1:0] state, next_state;
    reg [7:0] shift_reg;
    reg [2:0] bit_count;

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 3'b0;
        end else begin
            state <= next_state;
            if (state == RECEIVE) begin
                shift_reg <= {in, shift_reg[7:1]};
                bit_count <= bit_count + 1;
            end else if (state == IDLE) begin
                bit_count <= 3'b0;
            end
        end
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 0) begin  // Start bit detected
                    next_state = RECEIVE;
                end else begin
                    next_state = IDLE;
                end
            end
            RECEIVE: begin
                if (bit_count == 3'b111) begin  // 8 bits received
                    next_state = STOP;
                end else begin
                    next_state = RECEIVE;
                end
            end
            STOP: begin
                if (in == 1) begin  // Stop bit detected
                    next_state = IDLE;
                end else begin
                    next_state = STOP;
                end
            end
            default: begin
                next_state = IDLE;
            end
        endcase
    end

    // Output logic
    assign done = (state == STOP) && (in == 1);
    assign out_byte = (done) ? shift_reg : 8'bx;

endmodule"
N/A,N/A,-0.1,89,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    localparam IDLE = 2'b00;
    localparam RECEIVE = 2'b01;
    localparam STOP = 2'b10;

    reg [1:0] state, next_state;
    reg [7:0] shift_reg;
    reg [2:0] bit_count;

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 3'b0;
        end else begin
            state <= next_state;
            if (state == RECEIVE) begin
                shift_reg <= {in, shift_reg[7:1]};
                bit_count <= bit_count + 1;
            end else if (state == IDLE) begin
                bit_count <= 3'b0;
            end
        end
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 0) begin  // Start bit detected
                    next_state = RECEIVE;
                end else begin
                    next_state = IDLE;
                end
            end
            RECEIVE: begin
                if (bit_count == 3'd7) begin  // All 8 data bits received
                    next_state = STOP;
                end else begin
                    next_state = RECEIVE;
                end
            end
            STOP: begin
                if (in == 1) begin  // Stop bit detected
                    next_state = IDLE;
                end else begin
                    next_state = STOP;  // Wait for stop bit
                end
            end
            default: next_state = IDLE;
        endcase
    end

    // Output logic
    assign done = (state == STOP && in == 1);
    assign out_byte = (done) ? shift_reg : 8'bx;

endmodule"
N/A,N/A,-0.1,90,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    localparam IDLE = 2'b00;
    localparam RECEIVE = 2'b01;
    localparam STOP = 2'b10;

    reg [1:0] state, next_state;
    reg [7:0] shift_reg;
    reg [2:0] bit_count;

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 3'b0;
        end else begin
            state <= next_state;
            if (state == RECEIVE) begin
                shift_reg <= {in, shift_reg[7:1]};
                bit_count <= bit_count + 1;
            end
        end
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 0) // Start bit detected
                    next_state = RECEIVE;
                else
                    next_state = IDLE;
            end
            RECEIVE: begin
                if (bit_count == 3'b111) // All 8 data bits received
                    next_state = STOP;
                else
                    next_state = RECEIVE;
            end
            STOP: begin
                if (in == 1) // Stop bit detected
                    next_state = IDLE;
                else
                    next_state = STOP; // Wait for stop bit
            end
            default: next_state = IDLE;
        endcase
    end

    // Output logic
    assign done = (state == STOP) && (in == 1);
    assign out_byte = shift_reg;

endmodule"
N/A,N/A,-0.1,91,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    localparam IDLE = 2'b00;
    localparam RECEIVE = 2'b01;
    localparam STOP = 2'b10;

    reg [1:0] state, next_state;
    reg [7:0] shift_reg;
    reg [2:0] bit_count;

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 3'b0;
        end
        else begin
            state <= next_state;
            if (state == RECEIVE) begin
                bit_count <= bit_count + 1;
            end
            else begin
                bit_count <= 3'b0;
            end
        end
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 0) // Start bit detected
                    next_state = RECEIVE;
                else
                    next_state = IDLE;
            end
            RECEIVE: begin
                if (bit_count == 3'b111) // 8 bits received
                    next_state = STOP;
                else
                    next_state = RECEIVE;
            end
            STOP: begin
                if (in == 1) // Stop bit detected
                    next_state = IDLE;
                else
                    next_state = STOP; // Wait for stop bit
            end
            default: next_state = IDLE;
        endcase
    end

    // Output logic
    always @(posedge clk) begin
        if (state == RECEIVE) begin
            shift_reg <= {in, shift_reg[7:1]}; // Shift in the serial input
        end
    end

    assign out_byte = shift_reg;
    assign done = (state == STOP) && (in == 1); // Valid output when in STOP state with correct stop bit

endmodule"
N/A,N/A,-0.1,92,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    localparam IDLE = 2'b00;
    localparam RECEIVE = 2'b01;
    localparam STOP = 2'b10;

    reg [1:0] state, next_state;
    reg [7:0] shift_reg;
    reg [2:0] bit_count;

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 3'b0;
        end
        else begin
            state <= next_state;
            if (state == RECEIVE) begin
                bit_count <= bit_count + 1;
            end
            else begin
                bit_count <= 3'b0;
            end
        end
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 0) // Start bit detected
                    next_state = RECEIVE;
                else
                    next_state = IDLE;
            end
            RECEIVE: begin
                if (bit_count == 3'b111) // 8 bits received
                    next_state = STOP;
                else
                    next_state = RECEIVE;
            end
            STOP: begin
                if (in == 1) // Stop bit detected
                    next_state = IDLE;
                else
                    next_state = STOP; // Wait for stop bit
            end
            default: next_state = IDLE;
        endcase
    end

    // Output logic
    always @(posedge clk) begin
        if (state == RECEIVE) begin
            shift_reg <= {in, shift_reg[7:1]}; // Shift in the serial input
        end
    end

    assign out_byte = shift_reg;
    assign done = (state == STOP) && (in == 1); // done is high when stop bit is correct

endmodule"
N/A,N/A,-0.1,93,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    localparam IDLE = 2'b00;
    localparam RECEIVE = 2'b01;
    localparam STOP = 2'b10;

    reg [1:0] state, next_state;
    reg [7:0] shift_reg;
    reg [2:0] bit_count;

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 3'b0;
        end else begin
            state <= next_state;
            if (state == RECEIVE) begin
                shift_reg <= {in, shift_reg[7:1]};
                bit_count <= bit_count + 1;
            end
        end
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 0) // Start bit detected
                    next_state = RECEIVE;
                else
                    next_state = IDLE;
            end
            RECEIVE: begin
                if (bit_count == 3'b111) // All 8 data bits received
                    next_state = STOP;
                else
                    next_state = RECEIVE;
            end
            STOP: begin
                if (in == 1) // Stop bit detected
                    next_state = IDLE;
                else
                    next_state = STOP; // Wait for stop bit
            end
            default: next_state = IDLE;
        endcase
    end

    // Output logic
    assign done = (state == STOP) && (in == 1);
    assign out_byte = shift_reg;

endmodule"
N/A,N/A,-0.1,94,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    localparam IDLE = 2'b00;
    localparam RECEIVE = 2'b01;
    localparam STOP = 2'b10;

    reg [1:0] state, next_state;
    reg [7:0] shift_reg;
    reg [2:0] bit_count;

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 3'b0;
        end
        else begin
            state <= next_state;
            if (state == RECEIVE) begin
                bit_count <= bit_count + 1;
            end
            else begin
                bit_count <= 3'b0;
            end
        end
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 1'b0) begin // Start bit detected
                    next_state = RECEIVE;
                end
                else begin
                    next_state = IDLE;
                end
            end
            RECEIVE: begin
                if (bit_count == 3'b111) begin // All 8 data bits received
                    next_state = STOP;
                end
                else begin
                    next_state = RECEIVE;
                end
            end
            STOP: begin
                if (in == 1'b1) begin // Stop bit detected
                    next_state = IDLE;
                end
                else begin
                    next_state = STOP; // Wait for stop bit
                end
            end
            default: next_state = IDLE;
        endcase
    end

    // Output logic and datapath
    always @(posedge clk) begin
        if (state == RECEIVE) begin
            shift_reg <= {in, shift_reg[7:1]}; // Shift in the serial bit
        end
    end

    assign out_byte = (state == STOP && in == 1'b1) ? shift_reg : 8'bx;
    assign done = (state == STOP && in == 1'b1);

endmodule"
N/A,N/A,-0.1,95,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    localparam IDLE = 2'b00;
    localparam RECEIVE = 2'b01;
    localparam STOP = 2'b10;

    reg [1:0] state, next_state;
    reg [7:0] shift_reg;
    reg [2:0] bit_count;

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 3'b0;
        end else begin
            state <= next_state;
            if (state == RECEIVE)
                bit_count <= bit_count + 1;
            else
                bit_count <= 3'b0;
        end
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 1'b0)  // Start bit detected
                    next_state = RECEIVE;
                else
                    next_state = IDLE;
            end
            RECEIVE: begin
                if (bit_count == 3'b111)  // 8 data bits received
                    next_state = STOP;
                else
                    next_state = RECEIVE;
            end
            STOP: begin
                if (in == 1'b1)  // Stop bit detected
                    next_state = IDLE;
                else
                    next_state = STOP;
            end
            default: next_state = IDLE;
        endcase
    end

    // Output logic
    always @(posedge clk) begin
        if (reset) begin
            shift_reg <= 8'b0;
        end else if (state == RECEIVE) begin
            shift_reg <= {in, shift_reg[7:1]};  // Shift in the incoming bit
        end
    end

    assign done = (state == STOP && in == 1'b1);
    assign out_byte = done ? shift_reg : 8'bx;

endmodule"
N/A,N/A,-0.1,96,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    localparam IDLE = 2'b00;
    localparam RECEIVE = 2'b01;
    localparam STOP = 2'b10;

    reg [1:0] state, next_state;
    reg [7:0] shift_reg;
    reg [2:0] bit_count;

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 3'b0;
        end else begin
            state <= next_state;
            if (state == RECEIVE) begin
                shift_reg <= {in, shift_reg[7:1]};
                bit_count <= bit_count + 1;
            end else if (state == IDLE) begin
                bit_count <= 3'b0;
            end
        end
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 0) begin  // Start bit detected
                    next_state = RECEIVE;
                end else begin
                    next_state = IDLE;
                end
            end
            RECEIVE: begin
                if (bit_count == 3'd7) begin  // All 8 data bits received
                    next_state = STOP;
                end else begin
                    next_state = RECEIVE;
                end
            end
            STOP: begin
                if (in == 1) begin  // Stop bit detected
                    next_state = IDLE;
                end else begin
                    next_state = STOP;  // Wait for stop bit
                end
            end
            default: next_state = IDLE;
        endcase
    end

    // Output logic
    assign done = (state == STOP && in == 1);
    assign out_byte = (done) ? shift_reg : 8'bx;

endmodule"
N/A,N/A,-0.1,97,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    localparam IDLE = 2'b00;
    localparam RECEIVE = 2'b01;
    localparam STOP = 2'b10;

    reg [1:0] state, next_state;
    reg [7:0] shift_reg;
    reg [2:0] bit_count;

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 3'b0;
        end else begin
            state <= next_state;
            if (state == RECEIVE) begin
                shift_reg <= {in, shift_reg[7:1]};
                bit_count <= bit_count + 1;
            end else if (state == IDLE) begin
                bit_count <= 3'b0;
            end
        end
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 0) begin  // Start bit detected
                    next_state = RECEIVE;
                end else begin
                    next_state = IDLE;
                end
            end
            RECEIVE: begin
                if (bit_count == 3'd7) begin  // All 8 data bits received
                    next_state = STOP;
                end else begin
                    next_state = RECEIVE;
                end
            end
            STOP: begin
                if (in == 1) begin  // Stop bit detected
                    next_state = IDLE;
                end else begin
                    next_state = STOP;  // Wait for stop bit
                end
            end
            default: next_state = IDLE;
        endcase
    end

    // Output logic
    assign done = (state == STOP && in == 1);
    assign out_byte = (done) ? shift_reg : 8'bx;

endmodule"
N/A,N/A,-0.1,98,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    localparam IDLE = 2'b00;
    localparam RECEIVE = 2'b01;
    localparam STOP = 2'b10;

    reg [1:0] state, next_state;
    reg [7:0] shift_reg;
    reg [2:0] bit_count;

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 3'b0;
        end
        else begin
            state <= next_state;
            if (state == RECEIVE) begin
                bit_count <= bit_count + 1;
            end
            else begin
                bit_count <= 3'b0;
            end
        end
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 1'b0) begin // Start bit detected
                    next_state = RECEIVE;
                end
                else begin
                    next_state = IDLE;
                end
            end
            RECEIVE: begin
                if (bit_count == 3'b111) begin // All 8 data bits received
                    next_state = STOP;
                end
                else begin
                    next_state = RECEIVE;
                end
            end
            STOP: begin
                if (in == 1'b1) begin // Stop bit detected
                    next_state = IDLE;
                end
                else begin
                    next_state = STOP;
                end
            end
            default: begin
                next_state = IDLE;
            end
        endcase
    end

    // Output logic and datapath
    always @(posedge clk) begin
        if (state == RECEIVE) begin
            shift_reg <= {in, shift_reg[7:1]}; // Shift in the serial data
        end
    end

    assign out_byte = (state == STOP && in == 1'b1) ? shift_reg : 8'bx;
    assign done = (state == STOP && in == 1'b1);

endmodule"
N/A,N/A,-0.1,99,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    localparam IDLE = 2'd0;
    localparam START = 2'd1;
    localparam DATA = 2'd2;
    localparam STOP = 2'd3;

    reg [1:0] state, next_state;
    reg [2:0] bit_count;
    reg [7:0] shift_reg;

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
        end else begin
            state <= next_state;
        end
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 0) // Start bit detected
                    next_state = START;
                else
                    next_state = IDLE;
            end
            START: begin
                next_state = DATA;
            end
            DATA: begin
                if (bit_count == 3'd7)
                    next_state = STOP;
                else
                    next_state = DATA;
            end
            STOP: begin
                if (in == 1) // Stop bit detected
                    next_state = IDLE;
                else
                    next_state = STOP; // Wait for stop bit
            end
            default: next_state = IDLE;
        endcase
    end

    // Datapath to shift in data bits
    always @(posedge clk) begin
        if (reset) begin
            bit_count <= 3'd0;
            shift_reg <= 8'd0;
        end else begin
            case (state)
                IDLE: begin
                    bit_count <= 3'd0;
                end
                START: begin
                    // No action needed, just transition to DATA
                end
                DATA: begin
                    shift_reg <= {in, shift_reg[7:1]}; // Shift in the LSB first
                    bit_count <= bit_count + 1;
                end
                STOP: begin
                    // No action needed, just wait for stop bit
                end
            endcase
        end
    end

    // Output logic
    assign out_byte = (state == STOP && in == 1) ? shift_reg : 8'd0;
    assign done = (state == STOP && in == 1);

endmodule"
