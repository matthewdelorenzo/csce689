Area,Delay,Score,Current Run,Episode,Verilog
N/A,N/A,-1,0,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum reg [2:0] {
        IDLE,
        START,
        DATA,
        PARITY,
        STOP
    } state_t;

    // State registers
    reg [2:0] state, next_state;
    reg [3:0] bit_count; // To count the number of bits received
    reg [7:0] data;      // To store the received data byte
    wire parity_odd;     // Parity check output

    // Instantiate the parity module
    parity parity_inst (
        .clk(clk),
        .reset(reset | (state == IDLE) | (state == START)), // Reset at IDLE and START
        .in(in),
        .odd(parity_odd)
    );

    // State transition logic
    always @(*) begin
        next_state = state;
        case (state)
            IDLE: begin
                if (in == 0) // Detect start bit
                    next_state = START;
            end
            START: begin
                if (bit_count == 4'd8) // After 8 bits of data
                    next_state = PARITY;
            end
            PARITY: begin
                next_state = STOP; // Move to stop bit check
            end
            STOP: begin
                if (in == 1) // Check stop bit
                    next_state = IDLE;
            end
        endcase
    end

    // State register update
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
        end else begin
            state <= next_state;
            if (state == START || state == DATA) begin
                bit_count <= bit_count + 1;
            end else if (state == STOP) begin
                bit_count <= 0;
            end
        end
    end

    // Output logic
    always @(posedge clk) begin
        if (state == DATA) begin
            data <= {in, data[7:1]}; // Shift in the data bits
        end
    end

    assign out_byte = data;
    assign done = (state == STOP) && (in == 1) && parity_odd; // Assert done when stop bit is correct and parity is odd

endmodule"
N/A,N/A,-1,1,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        DATA = 3'b010,
        PARITY = 3'b011,
        STOP = 3'b100,
        ERROR = 3'b101
    } state_t;
    
    state_t state, next_state;
    reg [3:0] bit_count;  // Count the number of bits received
    reg [7:0] data;       // Store the received data byte
    reg parity_bit;       // Store the received parity bit
    wire odd_parity;      // Output from the parity module
    reg parity_reset;     // Control signal to reset the parity module
    
    // Instantiate the parity module
    parity parity_inst (
        .clk(clk),
        .reset(parity_reset),
        .in(in),
        .odd(odd_parity)
    );
    
    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
            data <= 8'b0;
            parity_reset <= 1;
        end else begin
            state <= next_state;
            if (state == DATA) begin
                data <= {in, data[7:1]};  // Shift in the data bits
                bit_count <= bit_count + 1;
            end else if (state == PARITY) begin
                parity_bit <= in;
            end else if (state == STOP) begin
                parity_reset <= 1;  // Reset parity module for next byte
            end
        end
    end
    
    // Next state logic
    always @(*) begin
        next_state = state;
        parity_reset = 0;
        case (state)
            IDLE: begin
                if (in == 0)  // Detect start bit
                    next_state = START;
            end
            START: begin
                if (bit_count == 0)
                    next_state = DATA;
            end
            DATA: begin
                if (bit_count == 8)  // After 8 data bits
                    next_state = PARITY;
            end
            PARITY: begin
                next_state = STOP;
            end
            STOP: begin
                if (in == 1) begin  // Check stop bit
                    if (odd_parity == 1 && parity_bit == 1)  // Check for odd parity
                        next_state = IDLE;  // Successful reception
                    else
                        next_state = ERROR;  // Parity error
                end
            end
            ERROR: begin
                if (in == 1)  // Wait for stop bit to return to IDLE
                    next_state = IDLE;
            end
        endcase
    end
    
    // Output logic
    assign out_byte = data;
    assign done = (state == STOP && in == 1 && odd_parity == 1 && parity_bit == 1);

endmodule"
N/A,N/A,-1,2,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        DATA = 3'b010,
        PARITY = 3'b011,
        STOP = 3'b100
    } state_t;

    state_t state, next_state;
    reg [3:0] bit_count;  // Count the number of bits received
    reg [7:0] data_byte;  // Store the received byte
    reg parity_bit;       // Store the received parity bit
    reg [7:0] shift_reg;  // Shift register for serial data

    // Instantiate the parity module
    wire odd_parity;
    parity parity_checker (
        .clk(clk),
        .reset(reset | (state == START)),
        .in(in),
        .odd(odd_parity)
    );

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
        end else begin
            state <= next_state;
            if (state == DATA) begin
                shift_reg <= {in, shift_reg[7:1]};
                bit_count <= bit_count + 1;
            end else if (state == PARITY) begin
                parity_bit <= in;
            end else if (state == START) begin
                bit_count <= 0;
            end
        end
    end

    // Next state logic
    always @(*) begin
        next_state = state;
        case (state)
            IDLE: begin
                if (in == 0)  // Detect start bit
                    next_state = START;
            end
            START: begin
                if (bit_count == 8)
                    next_state = DATA;
            end
            DATA: begin
                if (bit_count == 7)
                    next_state = PARITY;
            end
            PARITY: begin
                next_state = STOP;
            end
            STOP: begin
                if (in == 1)  // Detect stop bit
                    next_state = IDLE;
            end
        endcase
    end

    // Output logic
    assign out_byte = shift_reg;
    assign done = (state == STOP) && (in == 1) && (odd_parity == 1) && (parity_bit == 1);

endmodule"
N/A,N/A,-0.1,3,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    parameter IDLE = 3'd0, START = 3'd1, DATA = 3'd2, PARITY = 3'd3, STOP = 3'd4, DONE = 3'd5;

    reg [2:0] state, next_state;
    reg [3:0] bit_count; // To count 9 bits (8 data + 1 parity)
    reg [7:0] data_byte;
    reg stop_bit;
    wire odd_parity;
    reg parity_reset;

    // Instantiate the parity module
    parity parity_checker (
        .clk(clk),
        .reset(parity_reset),
        .in(in),
        .odd(odd_parity)
    );

    // State transition
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
        end else begin
            state <= next_state;

            if (state == DATA) begin
                data_byte[bit_count] <= in;
                bit_count <= bit_count + 1;
            end
        end
    end

    // Next state logic
    always @(*) begin
        next_state = state; // Default to hold state
        parity_reset = 0;

        case (state)
            IDLE: begin
                if (in == 0) // Start bit detected
                    next_state = START;
            end

            START: begin
                next_state = DATA;
                bit_count = 0;
                parity_reset = 1; // Reset parity checker
            end

            DATA: begin
                if (bit_count == 8)
                    next_state = PARITY;
            end

            PARITY: begin
                if (odd_parity == 1)
                    next_state = STOP;
                else
                    next_state = IDLE; // Parity error, wait for next start bit
            end

            STOP: begin
                if (in == 1) // Stop bit detected
                    next_state = DONE;
                else
                    next_state = IDLE; // Stop bit error, wait for next start bit
            end

            DONE: begin
                next_state = IDLE;
            end
        endcase
    end

    // Output logic
    assign out_byte = data_byte;
    assign done = (state == DONE);

endmodule"
N/A,N/A,-1,4,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        DATA = 3'b010,
        PARITY = 3'b011,
        STOP = 3'b100,
        DONE = 3'b101
    } state_t;
    
    state_t state, next_state;
    reg [3:0] bit_count;  // Count the number of bits received
    reg [7:0] data;       // Store the received data byte
    reg parity_bit;       // Store the received parity bit
    wire odd_parity;      // Output from the parity module

    // Instantiate the parity module
    parity parity_inst (
        .clk(clk),
        .reset(reset | (state == IDLE) | (state == DONE)),
        .in(in),
        .odd(odd_parity)
    );

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
        end else begin
            state <= next_state;
        end
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 0)  // Start bit detected
                    next_state = START;
                else
                    next_state = IDLE;
            end
            START: begin
                if (bit_count == 4'd8)
                    next_state = DATA;
                else
                    next_state = START;
            end
            DATA: begin
                if (bit_count == 4'd8)
                    next_state = PARITY;
                else
                    next_state = DATA;
            end
            PARITY: begin
                next_state = STOP;
            end
            STOP: begin
                if (in == 1)  // Stop bit detected
                    next_state = DONE;
                else
                    next_state = IDLE;
            end
            DONE: begin
                next_state = IDLE;
            end
            default: next_state = IDLE;
        endcase
    end

    // Output logic and data path
    always @(posedge clk) begin
        if (reset) begin
            bit_count <= 0;
            data <= 8'b0;
            parity_bit <= 0;
        end else begin
            case (state)
                IDLE: begin
                    bit_count <= 0;
                end
                START: begin
                    if (bit_count < 4'd8) begin
                        data[bit_count] <= in;
                        bit_count <= bit_count + 1;
                    end
                end
                DATA: begin
                    if (bit_count < 4'd8) begin
                        data[bit_count] <= in;
                        bit_count <= bit_count + 1;
                    end
                end
                PARITY: begin
                    parity_bit <= in;
                end
                STOP: begin
                    // Nothing to do here
                end
                DONE: begin
                    // Nothing to do here
                end
            endcase
        end
    end

    // Done signal logic
    assign done = (state == DONE) && (parity_bit == odd_parity);

    // Output byte
    assign out_byte = data;

endmodule"
N/A,N/A,-1,5,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        RECEIVE = 3'b010,
        PARITY_CHECK = 3'b011,
        STOP = 3'b100
    } state_t;

    state_t state, next_state;
    reg [7:0] data_shift;
    reg [3:0] bit_count;
    wire parity_odd;
    reg parity_reset;
    reg [7:0] out_byte_reg;
    reg done_reg;

    // Instantiate the parity module
    parity parity_inst (
        .clk(clk),
        .reset(parity_reset),
        .in(in),
        .odd(parity_odd)
    );

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
            parity_reset <= 1;
            done_reg <= 0;
        end else begin
            state <= next_state;
            if (state == RECEIVE) begin
                data_shift <= {in, data_shift[7:1]};
                bit_count <= bit_count + 1;
            end
        end
    end

    // Next state logic
    always @(*) begin
        next_state = state;
        parity_reset = 0;
        done_reg = 0;
        case (state)
            IDLE: begin
                if (~in) begin
                    next_state = START;
                    parity_reset = 1; // Reset parity on start bit
                end
            end
            START: begin
                if (in) begin
                    next_state = RECEIVE;
                    bit_count = 0;
                end
            end
            RECEIVE: begin
                if (bit_count == 8) begin
                    next_state = PARITY_CHECK;
                end
            end
            PARITY_CHECK: begin
                if (parity_odd == in) begin
                    next_state = STOP;
                end else begin
                    next_state = IDLE; // Parity failed, return to IDLE
                end
            end
            STOP: begin
                if (in) begin
                    next_state = IDLE;
                    out_byte_reg = data_shift;
                    done_reg = 1;
                end
            end
        endcase
    end

    assign out_byte = out_byte_reg;
    assign done = done_reg;

endmodule"
N/A,N/A,-1,6,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        RECEIVE = 3'b010,
        PARITY_CHECK = 3'b011,
        STOP = 3'b100
    } state_t;

    state_t state, next_state;
    reg [7:0] data_shift;
    reg [3:0] bit_count;
    wire parity_odd;
    reg parity_reset;
    reg done_reg;

    // Instantiate the parity module
    parity parity_inst (
        .clk(clk),
        .reset(parity_reset),
        .in(in),
        .odd(parity_odd)
    );

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
            done_reg <= 0;
            parity_reset <= 1;
        end else begin
            state <= next_state;
            if (state == RECEIVE) bit_count <= bit_count + 1'b1;
            if (state == STOP) done_reg <= 0;
            if (state == IDLE || state == START) parity_reset <= 1;
            else parity_reset <= 0;
        end
    end

    // Next state logic
    always @(*) begin
        next_state = state;
        case (state)
            IDLE: begin
                if (!in) next_state = START;  // Detect start bit
            end
            START: begin
                next_state = RECEIVE;
            end
            RECEIVE: begin
                if (bit_count == 9) next_state = PARITY_CHECK;  // After 9 bits (8 data + 1 parity)
            end
            PARITY_CHECK: begin
                if (parity_odd) next_state = STOP;
                else next_state = IDLE;  // Parity error, wait for stop bit
            end
            STOP: begin
                if (in) next_state = IDLE;  // Stop bit detected
                else next_state = START;  // If no stop bit, assume it's a new start bit
            end
        endcase
    end

    // Output logic
    always @(posedge clk) begin
        if (reset) begin
            out_byte <= 8'b0;
        end else if (state == RECEIVE && bit_count < 8) begin
            data_shift <= {in, data_shift[7:1]};
        end else if (state == PARITY_CHECK && parity_odd) begin
            out_byte <= data_shift;
            done_reg <= 1;
        end
    end

    assign done = done_reg;

endmodule"
N/A,N/A,-1,7,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        RECEIVE = 3'b010,
        PARITY_CHECK = 3'b011,
        STOP = 3'b100
    } state_t;

    state_t state, next_state;
    reg [7:0] data_shift;
    reg [3:0] bit_count;
    wire parity_odd;
    reg parity_reset;
    reg [7:0] out_byte_reg;
    reg done_reg;

    // Instantiate the parity module
    parity parity_inst (
        .clk(clk),
        .reset(parity_reset),
        .in(in),
        .odd(parity_odd)
    );

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
            parity_reset <= 1;
            done_reg <= 0;
        end else begin
            state <= next_state;
            if (state == RECEIVE) begin
                data_shift <= {in, data_shift[7:1]};
                bit_count <= bit_count + 1;
            end
        end
    end

    // Next state logic
    always @(*) begin
        next_state = state;
        parity_reset = 0;
        done_reg = 0;
        case (state)
            IDLE: begin
                if (~in) begin
                    next_state = START;
                    parity_reset = 1; // Reset parity on start bit
                end
            end
            START: begin
                if (in) begin
                    next_state = RECEIVE;
                    bit_count = 0;
                end
            end
            RECEIVE: begin
                if (bit_count == 8) begin
                    next_state = PARITY_CHECK;
                end
            end
            PARITY_CHECK: begin
                if (parity_odd == in) begin
                    next_state = STOP;
                end else begin
                    next_state = IDLE; // Parity failed, return to IDLE
                end
            end
            STOP: begin
                if (in) begin
                    next_state = IDLE;
                    out_byte_reg = data_shift;
                    done_reg = 1;
                end else begin
                    next_state = IDLE; // Stop bit failed, return to IDLE
                end
            end
        endcase
    end

    // Output logic
    assign out_byte = out_byte_reg;
    assign done = done_reg;

endmodule"
N/A,N/A,-1,8,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        DATA = 3'b010,
        PARITY = 3'b011,
        STOP = 3'b100,
        ERROR = 3'b101
    } state_t;
    
    state_t state, next_state;
    reg [3:0] bit_count;  // Count the number of bits received
    reg [7:0] data;       // Store the received data byte
    reg parity_bit;       // Store the received parity bit
    wire odd_parity;      // Output from the parity module
    reg parity_reset;     // Control signal to reset the parity module
    
    // Instantiate the parity module
    parity parity_inst (
        .clk(clk),
        .reset(parity_reset),
        .in(in),
        .odd(odd_parity)
    );
    
    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
            parity_reset <= 1;
        end else begin
            state <= next_state;
            if (state == DATA) begin
                data <= {in, data[7:1]};  // Shift in data bits
                bit_count <= bit_count + 1;
            end
            if (state == PARITY) begin
                parity_bit <= in;  // Capture the parity bit
            end
            if (state == IDLE || state == STOP) begin
                bit_count <= 0;
            end
        end
    end
    
    // Next state logic
    always @(*) begin
        next_state = state;
        parity_reset = 0;
        case (state)
            IDLE: begin
                if (in == 0)  // Detect start bit
                    next_state = START;
            end
            START: begin
                next_state = DATA;
                parity_reset = 1;  // Reset parity calculation at the start of data reception
            end
            DATA: begin
                if (bit_count == 8)
                    next_state = PARITY;
            end
            PARITY: begin
                next_state = STOP;
            end
            STOP: begin
                if (in == 1 && odd_parity == 1'b1 && parity_bit == 1'b1)  // Check stop bit and parity
                    next_state = IDLE;
                else
                    next_state = ERROR;
            end
            ERROR: begin
                if (in == 1)  // Wait for stop bit
                    next_state = IDLE;
            end
        endcase
    end
    
    // Output logic
    assign out_byte = data;
    assign done = (state == STOP && in == 1 && odd_parity == 1'b1 && parity_bit == 1'b1);

endmodule"
N/A,N/A,-1,9,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        DATA = 3'b010,
        PARITY = 3'b011,
        STOP = 3'b100
    } state_t;
    
    state_t state, next_state;
    reg [7:0] data_shift;
    reg [3:0] bit_count;
    wire parity_odd;
    reg parity_reset;
    reg done_reg;

    // Instantiate the parity module
    parity parity_inst (
        .clk(clk),
        .reset(parity_reset),
        .in(in),
        .odd(parity_odd)
    );

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
            done_reg <= 0;
            parity_reset <= 1;
        end else begin
            state <= next_state;
            if (state == DATA) bit_count <= bit_count + 1'b1;
            if (state == STOP) done_reg <= 0;
            if (state == IDLE || state == START) parity_reset <= 1;
            else parity_reset <= 0;
        end
    end

    // Next state logic
    always @(*) begin
        next_state = state;
        case (state)
            IDLE: begin
                if (!in) next_state = START;  // Detect start bit
            end
            START: begin
                next_state = DATA;
            end
            DATA: begin
                if (bit_count == 8) next_state = PARITY;
            end
            PARITY: begin
                if (parity_odd) next_state = STOP;  // Check parity
                else next_state = IDLE;  // Parity error, go back to IDLE
            end
            STOP: begin
                if (in) begin
                    next_state = IDLE;
                    done_reg = 1;  // Successful reception
                end else begin
                    next_state = IDLE;  // Stop bit error, go back to IDLE
                end
            end
        endcase
    end

    // Output logic
    always @(posedge clk) begin
        if (state == DATA) begin
            data_shift <= {in, data_shift[7:1]};  // Shift in data bits
        end
    end

    assign out_byte = data_shift;
    assign done = done_reg;

endmodule"
N/A,N/A,-1,10,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        DATA = 3'b010,
        PARITY = 3'b011,
        STOP = 3'b100,
        ERROR = 3'b101
    } state_t;
    
    state_t state, next_state;
    reg [3:0] bit_count;  // Count the number of bits received
    reg [7:0] data;       // Store the received data byte
    reg parity_bit;       // Store the received parity bit
    wire parity_odd;      // Output from the parity module
    reg parity_reset;     // Control signal to reset the parity module
    
    // Instantiate the parity module
    parity parity_inst (
        .clk(clk),
        .reset(parity_reset),
        .in(in),
        .odd(parity_odd)
    );
    
    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
            parity_reset <= 1;
        end else begin
            state <= next_state;
            if (state == DATA) begin
                data <= {in, data[7:1]};  // Shift in data bits
                bit_count <= bit_count + 1;
            end else if (state == PARITY) begin
                parity_bit <= in;
            end
            if (state == IDLE || state == STOP) begin
                parity_reset <= 1;  // Reset parity calculation at the start and end
            end else begin
                parity_reset <= 0;
            end
        end
    end
    
    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (!in)  // Start bit detected (start bit is 0)
                    next_state = START;
                else
                    next_state = IDLE;
            end
            START: begin
                next_state = DATA;
                bit_count = 0;
            end
            DATA: begin
                if (bit_count == 8)
                    next_state = PARITY;
                else
                    next_state = DATA;
            end
            PARITY: begin
                next_state = STOP;
            end
            STOP: begin
                if (in) begin  // Stop bit detected (stop bit is 1)
                    if (parity_bit == parity_odd)  // Check if parity is odd
                        next_state = IDLE;
                    else
                        next_state = ERROR;
                end else begin
                    next_state = ERROR;  // Stop bit was not detected
                end
            end
            ERROR: begin
                if (in)  // Wait for stop bit to return to IDLE
                    next_state = IDLE;
                else
                    next_state = ERROR;
            end
            default: next_state = IDLE;
        endcase
    end
    
    // Output logic
    assign out_byte = (state == STOP && in && parity_bit == parity_odd) ? data : 8'b0;
    assign done = (state == STOP && in && parity_bit == parity_odd);
    
endmodule"
N/A,N/A,-1,11,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        DATA = 3'b010,
        PARITY = 3'b011,
        STOP = 3'b100,
        ERROR = 3'b101
    } state_t;
    
    reg [2:0] state, next_state;
    reg [3:0] bit_count;
    reg [7:0] data_byte;
    wire odd_parity;
    
    // Parity checker instance
    parity parity_checker (
        .clk(clk),
        .reset(reset | (state == START)),
        .in(in),
        .odd(odd_parity)
    );

    // State transition
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
        end else begin
            state <= next_state;
            if (state == DATA) begin
                data_byte[bit_count] <= in;
                bit_count <= bit_count + 1;
            end
        end
    end

    // Next state logic
    always @(*) begin
        next_state = state; // Default to hold state
        case (state)
            IDLE: begin
                if (!in) next_state = START; // Detect start bit
            end
            START: begin
                if (bit_count == 0) next_state = DATA;
            end
            DATA: begin
                if (bit_count == 8) next_state = PARITY;
            end
            PARITY: begin
                if (odd_parity == in) next_state = STOP;
                else next_state = ERROR;
            end
            STOP: begin
                if (in) next_state = IDLE; // Detect stop bit
                else next_state = ERROR;
            end
            ERROR: begin
                if (in) next_state = IDLE; // Wait for stop bit
            end
        endcase
    end

    // Output logic
    assign done = (state == STOP) && in;
    assign out_byte = data_byte;

endmodule"
N/A,N/A,-1,12,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        DATA = 3'b010,
        PARITY = 3'b011,
        STOP = 3'b100
    } state_t;
    
    state_t state, next_state;
    reg [7:0] data_shift;
    reg [3:0] bit_count;
    wire parity_odd;
    reg parity_reset;
    reg done_reg;

    // Instantiate the parity module
    parity parity_inst (
        .clk(clk),
        .reset(parity_reset),
        .in(in),
        .odd(parity_odd)
    );

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
            done_reg <= 0;
            parity_reset <= 1;
        end else begin
            state <= next_state;
            if (state == DATA) bit_count <= bit_count + 1'b1;
            if (state == STOP) done_reg <= 0;
            if (state == PARITY && parity_odd) done_reg <= 1;
            parity_reset <= (state == IDLE || state == START);
        end
    end

    // Next state logic
    always @(*) begin
        next_state = state;
        case (state)
            IDLE: if (~in) next_state = START;
            START: if (in) next_state = DATA;
            DATA: if (bit_count == 8) next_state = PARITY;
            PARITY: if (in) next_state = STOP;
            STOP: if (~in) next_state = IDLE;
            default: next_state = IDLE;
        endcase
    end

    // Output logic
    always @(posedge clk) begin
        if (state == DATA) data_shift <= {in, data_shift[7:1]};
    end

    assign out_byte = data_shift;
    assign done = done_reg;

endmodule"
N/A,N/A,-1,13,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        DATA = 3'b010,
        PARITY = 3'b011,
        STOP = 3'b100
    } state_t;

    state_t state, next_state;
    reg [3:0] bit_count;  // Count the number of bits received
    reg [7:0] data_byte;  // Store the received byte
    reg parity_bit;       // Store the received parity bit
    reg [7:0] shift_reg;  // Shift register for serial data

    // Parity checker instance
    wire odd_parity;
    parity parity_checker (
        .clk(clk),
        .reset(reset | (state == START)),
        .in(in),
        .odd(odd_parity)
    );

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
        end else begin
            state <= next_state;
            if (state == DATA || state == PARITY) begin
                bit_count <= bit_count + 1;
            end else begin
                bit_count <= 0;
            end
        end
    end

    // Next state logic
    always @(*) begin
        next_state = state;
        case (state)
            IDLE: begin
                if (~in) next_state = START;  // Detect start bit (0)
            end
            START: begin
                if (bit_count == 4'd8) next_state = DATA;  // Wait for start bit to pass
            end
            DATA: begin
                if (bit_count == 4'd8) next_state = PARITY;  // After 8 data bits, expect parity bit
            end
            PARITY: begin
                if (bit_count == 4'd9) next_state = STOP;  // After parity bit, expect stop bit
            end
            STOP: begin
                if (in) next_state = IDLE;  // Stop bit must be 1
                else next_state = IDLE;  // If stop bit is not 1, reset to IDLE
            end
        endcase
    end

    // Output logic and data shifting
    always @(posedge clk) begin
        if (state == DATA) begin
            data_byte <= {in, data_byte[7:1]};  // Shift in the data bits
        end
        if (state == PARITY) begin
            parity_bit <= in;  // Capture the parity bit
        end
    end

    // Assign outputs
    assign out_byte = data_byte;
    assign done = (state == STOP) && (in == 1) && (odd_parity == 1);  // Done is asserted if stop bit is 1 and parity is odd

endmodule"
N/A,N/A,-1,14,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        RECEIVE = 3'b010,
        PARITY_CHECK = 3'b011,
        STOP = 3'b100
    } state_t;

    state_t state, next_state;
    reg [7:0] data_shift;
    reg [3:0] bit_count;
    wire parity_odd;
    reg parity_reset;
    reg done_reg;

    // Instantiate the parity module
    parity parity_inst (
        .clk(clk),
        .reset(parity_reset),
        .in(in),
        .odd(parity_odd)
    );

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
            done_reg <= 0;
            parity_reset <= 1;
        end else begin
            state <= next_state;
            if (state == RECEIVE) bit_count <= bit_count + 1'b1;
            if (state == STOP) done_reg <= 0;
            if (state == IDLE || state == PARITY_CHECK) parity_reset <= 1;
            else parity_reset <= 0;
        end
    end

    // Next state logic
    always @(*) begin
        next_state = state;
        case (state)
            IDLE: begin
                if (in == 0) next_state = START;  // Detect start bit
            end
            START: begin
                next_state = RECEIVE;
            end
            RECEIVE: begin
                if (bit_count == 4'd8) next_state = PARITY_CHECK;
            end
            PARITY_CHECK: begin
                if (parity_odd) next_state = STOP;  // Check for odd parity
                else next_state = IDLE;             // Parity error, go back to IDLE
            end
            STOP: begin
                if (in == 1) begin
                    next_state = IDLE;  // Valid stop bit
                    done_reg = 1;
                end else begin
                    next_state = IDLE;  // Invalid stop bit, wait for next valid start
                end
            end
        endcase
    end

    // Output logic
    always @(posedge clk) begin
        if (state == RECEIVE) data_shift <= {in, data_shift[7:1]};
    end

    assign out_byte = data_shift;
    assign done = done_reg;

endmodule"
N/A,N/A,-1,15,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        RECEIVE = 3'b010,
        PARITY_CHECK = 3'b011,
        STOP = 3'b100
    } state_t;

    state_t state, next_state;
    reg [7:0] data_shift;
    reg [3:0] bit_count;
    wire parity_odd;
    reg parity_reset;
    reg done_reg;

    // Instantiate the parity module
    parity parity_inst (
        .clk(clk),
        .reset(parity_reset),
        .in(in),
        .odd(parity_odd)
    );

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
            done_reg <= 0;
            parity_reset <= 1;
        end else begin
            state <= next_state;
            if (state == RECEIVE) bit_count <= bit_count + 1'b1;
            if (state == STOP) done_reg <= 0;
            if (state == PARITY_CHECK && parity_odd) done_reg <= 1;
        end
    end

    // Next state logic
    always @(*) begin
        next_state = state;
        parity_reset = 0;
        case (state)
            IDLE: begin
                if (!in) next_state = START;  // Detect start bit
            end
            START: begin
                next_state = RECEIVE;
                bit_count = 0;
                parity_reset = 1;
            end
            RECEIVE: begin
                if (bit_count == 8) next_state = PARITY_CHECK;
            end
            PARITY_CHECK: begin
                if (parity_odd) next_state = STOP;
                else next_state = IDLE;  // Parity error, go back to idle
            end
            STOP: begin
                if (in) next_state = IDLE;  // Stop bit detected
                else next_state = START;  // If no stop bit, assume it's a new start bit
            end
        endcase
    end

    // Output logic
    always @(posedge clk) begin
        if (state == RECEIVE) begin
            data_shift <= {in, data_shift[7:1]};
        end
    end

    assign out_byte = data_shift;
    assign done = done_reg;

endmodule"
N/A,N/A,-1,16,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        RECEIVE = 3'b010,
        PARITY_CHECK = 3'b011,
        STOP = 3'b100
    } state_t;

    state_t state, next_state;
    reg [7:0] data_shift;
    reg [3:0] bit_count;
    wire parity_odd;
    reg parity_reset;
    reg done_reg;

    // Instantiate the parity module
    parity parity_inst (
        .clk(clk),
        .reset(parity_reset),
        .in(in),
        .odd(parity_odd)
    );

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
            parity_reset <= 1;
            done_reg <= 0;
        end else begin
            state <= next_state;
            if (state == RECEIVE) bit_count <= bit_count + 1;
            if (state == START) parity_reset <= 0;
            if (state == STOP && in) done_reg <= 1;
            else done_reg <= 0;
        end
    end

    // Next state logic
    always @(*) begin
        next_state = state;
        case (state)
            IDLE: begin
                if (~in) next_state = START;
            end
            START: begin
                if (in) next_state = RECEIVE;
            end
            RECEIVE: begin
                if (bit_count == 8) next_state = PARITY_CHECK;
            end
            PARITY_CHECK: begin
                if (parity_odd) next_state = STOP;
                else next_state = IDLE; // Parity error, reset
            end
            STOP: begin
                if (in) next_state = IDLE;
            end
        endcase
    end

    // Data shift register
    always @(posedge clk) begin
        if (state == RECEIVE) data_shift <= {in, data_shift[7:1]};
    end

    assign out_byte = data_shift;
    assign done = done_reg;

endmodule"
N/A,N/A,-1,17,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum reg [2:0] {
        IDLE,
        START,
        DATA,
        PARITY,
        STOP
    } state_t;

    // State registers
    reg [2:0] state, next_state;
    reg [3:0] bit_count; // To count bits received
    reg [7:0] data_reg;  // To store the received byte
    reg parity_reset;
    wire odd_parity;

    // Instantiate the parity module
    parity parity_checker (
        .clk(clk),
        .reset(parity_reset),
        .in(in),
        .odd(odd_parity)
    );

    // FSM state transition
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
            data_reg <= 8'b0;
            parity_reset <= 1;
        end else begin
            state <= next_state;
            if (state == DATA) begin
                data_reg <= {in, data_reg[7:1]}; // Shift in the received bit
                bit_count <= bit_count + 1;
            end
            if (state == PARITY) begin
                parity_reset <= 0; // Stop resetting parity checker during parity bit
            end else begin
                parity_reset <= 1;
            end
        end
    end

    // FSM next state logic
    always @(*) begin
        next_state = state;
        done = 0;
        case (state)
            IDLE: begin
                if (!in) // Detect start bit (0)
                    next_state = START;
            end
            START: begin
                if (in) // Wait for start bit to complete
                    next_state = DATA;
            end
            DATA: begin
                if (bit_count == 8) // After 8 data bits
                    next_state = PARITY;
            end
            PARITY: begin
                if (odd_parity == 1'b1) // Check for odd parity
                    next_state = STOP;
                else
                    next_state = IDLE; // Parity error, go back to IDLE
            end
            STOP: begin
                if (in) begin // Check for stop bit (1)
                    done = 1;
                    next_state = IDLE;
                end else begin
                    next_state = IDLE; // Stop bit error, go back to IDLE
                end
            end
        endcase
    end

    // Output the received byte
    assign out_byte = data_reg;

endmodule"
N/A,N/A,-1,18,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        DATA = 3'b010,
        PARITY = 3'b011,
        STOP = 3'b100
    } state_t;

    state_t state, next_state;
    reg [3:0] bit_count;  // Count the number of bits received
    reg [7:0] data_byte;  // Store the received byte
    reg parity_bit;       // Store the received parity bit
    reg [7:0] shift_reg;  // Shift register for serial data

    wire odd_parity;

    // Instantiate the parity module
    parity parity_inst (
        .clk(clk),
        .reset(reset | (state == START)),
        .in(in),
        .odd(odd_parity)
    );

    // State transition logic
    always @(posedge clk) begin
        if (reset)
            state <= IDLE;
        else
            state <= next_state;
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (!in)  // Detect start bit (0)
                    next_state = START;
                else
                    next_state = IDLE;
            end
            START: begin
                if (bit_count == 4'd8)
                    next_state = PARITY;
                else
                    next_state = DATA;
            end
            DATA: begin
                if (bit_count == 4'd8)
                    next_state = PARITY;
                else
                    next_state = DATA;
            end
            PARITY: begin
                next_state = STOP;
            end
            STOP: begin
                if (in)  // Detect stop bit (1)
                    next_state = IDLE;
                else
                    next_state = STOP;  // Wait for stop bit
            end
            default: next_state = IDLE;
        endcase
    end

    // Datapath logic
    always @(posedge clk) begin
        if (reset) begin
            bit_count <= 4'd0;
            shift_reg <= 8'd0;
            data_byte <= 8'd0;
            parity_bit <= 1'b0;
        end else begin
            case (state)
                START: begin
                    bit_count <= 4'd0;
                    shift_reg <= 8'd0;
                end
                DATA: begin
                    bit_count <= bit_count + 1'b1;
                    shift_reg <= {in, shift_reg[7:1]};
                end
                PARITY: begin
                    parity_bit <= in;
                    data_byte <= shift_reg;  // Capture the data byte
                end
                STOP: begin
                    // Nothing to do here
                end
            endcase
        end
    end

    // Output logic
    assign out_byte = data_byte;
    assign done = (state == STOP) && in && (odd_parity == parity_bit);

endmodule"
N/A,N/A,-1,19,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        RECEIVE = 3'b010,
        PARITY_CHECK = 3'b011,
        STOP = 3'b100
    } state_t;

    state_t state, next_state;
    reg [7:0] data_shift;
    reg [3:0] bit_count;
    wire parity_odd;
    reg parity_reset;
    reg [7:0] out_byte_reg;
    reg done_reg;

    // Instantiate the parity module
    parity parity_inst (
        .clk(clk),
        .reset(parity_reset),
        .in(in),
        .odd(parity_odd)
    );

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
            parity_reset <= 1;
            done_reg <= 0;
        end else begin
            state <= next_state;
            if (state == RECEIVE) begin
                data_shift <= {in, data_shift[7:1]};
                bit_count <= bit_count + 1;
            end
        end
    end

    // Next state logic
    always @(*) begin
        next_state = state;
        parity_reset = 0;
        done_reg = 0;

        case (state)
            IDLE: begin
                if (~in) begin
                    next_state = START;
                    parity_reset = 1; // Reset parity on start bit
                end
            end

            START: begin
                if (in) begin
                    next_state = RECEIVE;
                    bit_count = 0;
                end
            end

            RECEIVE: begin
                if (bit_count == 8) begin
                    next_state = PARITY_CHECK;
                end
            end

            PARITY_CHECK: begin
                if (parity_odd == in) begin
                    next_state = STOP;
                end else begin
                    next_state = IDLE; // Parity failed, return to IDLE
                end
            end

            STOP: begin
                if (in) begin
                    next_state = IDLE;
                    out_byte_reg = data_shift;
                    done_reg = 1;
                end
            end
        endcase
    end

    assign out_byte = out_byte_reg;
    assign done = done_reg;

endmodule"
N/A,N/A,-1,20,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        RECEIVE = 3'b010,
        PARITY_CHECK = 3'b011,
        STOP = 3'b100
    } state_t;

    state_t state, next_state;
    reg [7:0] data_shift;
    reg [3:0] bit_count;
    wire parity_odd;
    reg parity_reset;
    reg done_reg;

    // Instantiate the parity module
    parity parity_inst (
        .clk(clk),
        .reset(parity_reset),
        .in(in),
        .odd(parity_odd)
    );

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
            done_reg <= 0;
            parity_reset <= 1;
        end else begin
            state <= next_state;
            if (state == RECEIVE) bit_count <= bit_count + 1'b1;
            if (state == STOP) done_reg <= 0;
            if (state == START) parity_reset <= 0;
        end
    end

    // Next state logic
    always @(*) begin
        next_state = state;  // Default to hold state
        case (state)
            IDLE: begin
                if (in == 0)  // Detect start bit
                    next_state = START;
            end
            START: begin
                if (bit_count == 4'd0)  // Wait for the middle of the start bit
                    next_state = RECEIVE;
            end
            RECEIVE: begin
                if (bit_count == 4'd8)  // After 8 data bits
                    next_state = PARITY_CHECK;
            end
            PARITY_CHECK: begin
                if (bit_count == 4'd9) begin  // After parity bit
                    if (parity_odd)  // Check for odd parity
                        next_state = STOP;
                    else
                        next_state = IDLE; // Parity failed, go back to IDLE
                end
            end
            STOP: begin
                if (in == 1) begin  // Stop bit detected
                    done_reg = 1;
                    next_state = IDLE;
                end else begin
                    next_state = IDLE;  // Error in stop bit, return to IDLE
                end
            end
        endcase
    end

    // Output logic
    assign out_byte = data_shift;
    assign done = done_reg;

    // Data shift register
    always @(posedge clk) begin
        if (state == RECEIVE) begin
            data_shift <= {in, data_shift[7:1]};
        end
    end

endmodule"
N/A,N/A,-1,21,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum reg [2:0] {
        IDLE,
        START,
        DATA,
        PARITY,
        STOP
    } state_t;

    // State registers
    reg [2:0] state, next_state;
    reg [3:0] bit_count; // To count the number of bits received
    reg [7:0] data;      // To store the received data byte
    wire parity_odd;     // Parity check output

    // Instantiate the parity module
    parity parity_inst (
        .clk(clk),
        .reset(reset | (state == IDLE)), // Reset parity when in IDLE state
        .in(in),
        .odd(parity_odd)
    );

    // FSM state transition
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
        end else begin
            state <= next_state;
        end
    end

    // FSM next state logic
    always @(*) begin
        next_state = state; // Default to hold state
        case (state)
            IDLE: begin
                if (in == 0) // Detect start bit
                    next_state = START;
            end
            START: begin
                if (bit_count == 0) // Wait for the start bit to finish
                    next_state = DATA;
            end
            DATA: begin
                if (bit_count == 8) // After receiving 8 data bits
                    next_state = PARITY;
            end
            PARITY: begin
                next_state = STOP; // Move to stop bit check
            end
            STOP: begin
                if (in == 1) // Check for valid stop bit
                    next_state = IDLE;
            end
        endcase
    end

    // Bit counter logic
    always @(posedge clk) begin
        if (reset || state == IDLE || state == STOP) begin
            bit_count <= 0;
        end else if (state == START || state == DATA || state == PARITY) begin
            bit_count <= bit_count + 1;
        end
    end

    // Data capturing logic
    always @(posedge clk) begin
        if (state == DATA) begin
            data <= {in, data[7:1]}; // Shift in the received bits
        end
    end

    // Output logic
    assign out_byte = data;
    assign done = (state == STOP) && (in == 1) && parity_odd; // Assert done if stop bit is valid and parity is odd

endmodule"
N/A,N/A,-1,22,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum reg [2:0] {
        IDLE,
        START,
        DATA,
        PARITY,
        STOP
    } state_t;

    // State registers
    reg [2:0] state, next_state;
    reg [3:0] bit_count; // To count the number of bits received
    reg [7:0] data; // To store the received data byte
    reg parity_bit; // To store the received parity bit
    wire odd_parity; // Output from the parity module

    // Instantiate the parity module
    parity parity_checker (
        .clk(clk),
        .reset(reset | (state == IDLE)), // Reset parity checker at the start of a new byte
        .in(in),
        .odd(odd_parity)
    );

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
        end else begin
            state <= next_state;
        end
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 0) // Start bit detected
                    next_state = START;
                else
                    next_state = IDLE;
            end
            START: begin
                next_state = DATA;
            end
            DATA: begin
                if (bit_count == 8)
                    next_state = PARITY;
                else
                    next_state = DATA;
            end
            PARITY: begin
                next_state = STOP;
            end
            STOP: begin
                if (in == 1) // Stop bit detected
                    next_state = IDLE;
                else
                    next_state = STOP; // Wait for stop bit
            end
            default: next_state = IDLE;
        endcase
    end

    // Output logic and data path
    always @(posedge clk) begin
        if (reset) begin
            bit_count <= 0;
            data <= 8'b0;
            parity_bit <= 0;
        end else begin
            case (state)
                IDLE: begin
                    bit_count <= 0;
                end
                START: begin
                    bit_count <= 0;
                end
                DATA: begin
                    data[bit_count] <= in;
                    bit_count <= bit_count + 1;
                end
                PARITY: begin
                    parity_bit <= in;
                end
                STOP: begin
                    // No operation needed
                end
            endcase
        end
    end

    // Done signal logic
    assign done = (state == STOP) && (in == 1) && (odd_parity == 1) && (parity_bit == 1);

    // Output data byte
    assign out_byte = data;

endmodule"
N/A,N/A,-1,23,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        RECEIVE = 3'b010,
        PARITY_CHECK = 3'b011,
        STOP = 3'b100
    } state_t;

    state_t state, next_state;
    reg [7:0] data_shift;
    reg [3:0] bit_count;
    wire parity_odd;
    reg parity_reset;
    reg done_reg;

    // Instantiate the parity module
    parity parity_inst (
        .clk(clk),
        .reset(parity_reset),
        .in(in),
        .odd(parity_odd)
    );

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
            done_reg <= 0;
            parity_reset <= 1;
        end else begin
            state <= next_state;
            if (state == RECEIVE) bit_count <= bit_count + 1'b1;
            if (state == STOP) done_reg <= 0;
            if (state == PARITY_CHECK && parity_odd) done_reg <= 1;
        end
    end

    // Next state logic
    always @(*) begin
        next_state = state;
        parity_reset = 0;
        case (state)
            IDLE: begin
                if (!in) next_state = START;  // Detect start bit
            end
            START: begin
                next_state = RECEIVE;
                bit_count = 0;
                parity_reset = 1;
            end
            RECEIVE: begin
                if (bit_count == 8) next_state = PARITY_CHECK;
            end
            PARITY_CHECK: begin
                if (parity_odd) next_state = STOP;
                else next_state = IDLE;  // Parity error, go back to idle
            end
            STOP: begin
                if (in) next_state = IDLE;  // Stop bit detected
                else next_state = START;  // If no stop bit, assume it's a new start bit
            end
        endcase
    end

    // Output logic
    always @(posedge clk) begin
        if (state == RECEIVE) begin
            data_shift <= {in, data_shift[7:1]};
        end
    end

    assign out_byte = data_shift;
    assign done = done_reg;

endmodule"
N/A,N/A,-1,24,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        DATA = 3'b010,
        PARITY = 3'b011,
        STOP = 3'b100
    } state_t;

    state_t state, next_state;
    reg [3:0] bit_count;  // Count the number of bits received
    reg [7:0] data_byte;  // Store the received byte
    reg parity_bit;       // Store the received parity bit
    reg [7:0] shift_reg;  // Shift register for serial data

    wire odd_parity;

    // Instantiate the parity module
    parity parity_inst (
        .clk(clk),
        .reset(reset | (state == START)),
        .in(in),
        .odd(odd_parity)
    );

    // State transition logic
    always @(posedge clk) begin
        if (reset)
            state <= IDLE;
        else
            state <= next_state;
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (!in)  // Detect start bit (0)
                    next_state = START;
                else
                    next_state = IDLE;
            end
            START: begin
                if (bit_count == 4'd8)
                    next_state = PARITY;
                else
                    next_state = DATA;
            end
            DATA: begin
                if (bit_count == 4'd8)
                    next_state = PARITY;
                else
                    next_state = DATA;
            end
            PARITY: begin
                next_state = STOP;
            end
            STOP: begin
                if (in)  // Detect stop bit (1)
                    next_state = IDLE;
                else
                    next_state = STOP;  // Wait for stop bit
            end
            default: next_state = IDLE;
        endcase
    end

    // Datapath logic
    always @(posedge clk) begin
        if (reset) begin
            bit_count <= 4'd0;
            shift_reg <= 8'd0;
            done <= 1'b0;
        end else begin
            case (state)
                IDLE: begin
                    bit_count <= 4'd0;
                    done <= 1'b0;
                end
                START: begin
                    bit_count <= bit_count + 1'b1;
                end
                DATA: begin
                    shift_reg <= {in, shift_reg[7:1]};
                    bit_count <= bit_count + 1'b1;
                end
                PARITY: begin
                    parity_bit <= in;
                end
                STOP: begin
                    if (in) begin  // Check for stop bit
                        if (parity_bit == odd_parity) begin
                            out_byte <= shift_reg;
                            done <= 1'b1;
                        end else begin
                            done <= 1'b0;
                        end
                    end else begin
                        done <= 1'b0;
                    end
                end
            endcase
        end
    end

endmodule"
N/A,N/A,-1,25,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        RECEIVE = 3'b010,
        PARITY_CHECK = 3'b011,
        STOP = 3'b100
    } state_t;

    state_t state, next_state;
    reg [7:0] data_shift;
    reg [3:0] bit_count;
    wire parity_odd;
    reg parity_reset;
    reg done_reg;

    // Instantiate the parity module
    parity parity_inst (
        .clk(clk),
        .reset(parity_reset),
        .in(in),
        .odd(parity_odd)
    );

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
            done_reg <= 0;
            parity_reset <= 1;
        end else begin
            state <= next_state;
            if (state == RECEIVE) bit_count <= bit_count + 1'b1;
            if (state == START) parity_reset <= 0; // Start counting parity bits
            if (state == STOP) parity_reset <= 1;  // Reset parity counter
            if (state == STOP) done_reg <= 1;
            else done_reg <= 0;
        end
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (~in) next_state = START; // Start bit detected
                else next_state = IDLE;
            end
            START: begin
                if (in) next_state = RECEIVE; // Start bit confirmed
                else next_state = START;
            end
            RECEIVE: begin
                if (bit_count == 4'd8) next_state = PARITY_CHECK; // After 8 data bits
                else next_state = RECEIVE;
            end
            PARITY_CHECK: begin
                if (parity_odd == 1'b1) next_state = STOP; // Check for odd parity
                else next_state = IDLE; // Parity error, return to IDLE
            end
            STOP: begin
                if (in) next_state = IDLE; // Stop bit confirmed
                else next_state = STOP; // Wait for stop bit
            end
            default: next_state = IDLE;
        endcase
    end

    // Output logic
    always @(posedge clk) begin
        if (state == RECEIVE) begin
            data_shift <= {in, data_shift[7:1]};
        end
    end

    assign out_byte = data_shift;
    assign done = done_reg;

endmodule"
N/A,N/A,-1,26,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        RECEIVE = 3'b010,
        PARITY_CHECK = 3'b011,
        STOP = 3'b100
    } state_t;

    state_t state, next_state;
    reg [7:0] data_shift;
    reg [3:0] bit_count;
    wire parity_odd;
    reg parity_reset;
    reg done_reg;

    // Instantiate the parity module
    parity parity_inst (
        .clk(clk),
        .reset(parity_reset),
        .in(in),
        .odd(parity_odd)
    );

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
            done_reg <= 0;
            parity_reset <= 1;
        end else begin
            state <= next_state;
            if (state == RECEIVE) bit_count <= bit_count + 1'b1;
            if (state == STOP) done_reg <= 0;
            if (state == IDLE || state == START) parity_reset <= 1;
            else parity_reset <= 0;
        end
    end

    // Next state logic
    always @(*) begin
        next_state = state;
        case (state)
            IDLE: begin
                if (!in) next_state = START;  // Detect start bit
            end
            START: begin
                next_state = RECEIVE;
            end
            RECEIVE: begin
                if (bit_count == 9) next_state = PARITY_CHECK;  // After 9 bits (8 data + 1 parity)
            end
            PARITY_CHECK: begin
                if (parity_odd) next_state = STOP;  // Check parity, should be odd
                else next_state = IDLE;  // Parity check failed
            end
            STOP: begin
                if (in) next_state = IDLE;  // Check stop bit, should be 1
                else next_state = RECEIVE;  // If stop bit not 1, continue receiving
            end
        endcase
    end

    // Output logic
    always @(posedge clk) begin
        if (state == RECEIVE && bit_count < 8) begin
            data_shift <= {in, data_shift[7:1]};  // Shift in data bits
        end
        if (state == STOP && in) begin
            out_byte <= data_shift;
            done_reg <= 1;
        end
    end

    assign done = done_reg;

endmodule"
N/A,N/A,-1,27,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum reg [2:0] {
        IDLE,
        START,
        DATA,
        PARITY,
        STOP
    } state_t;

    // State registers
    reg [2:0] state, next_state;
    reg [3:0] bit_count; // To count the number of bits received
    reg [7:0] data;      // To store the received data byte
    wire parity_odd;     // Parity check output

    // Instantiate the parity module
    parity parity_inst (
        .clk(clk),
        .reset(reset | (state == IDLE) | (state == START)), // Reset at IDLE and START
        .in(in),
        .odd(parity_odd)
    );

    // State transition logic
    always @(*) begin
        next_state = state;
        case (state)
            IDLE: begin
                if (in == 0) // Detect start bit
                    next_state = START;
            end
            START: begin
                if (bit_count == 4'd8) // After 8 bits of data
                    next_state = PARITY;
            end
            PARITY: begin
                next_state = STOP; // Move to stop bit check
            end
            STOP: begin
                if (in == 1) // Check stop bit
                    next_state = IDLE;
            end
        endcase
    end

    // State register update
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
        end else begin
            state <= next_state;
            if (state == START || state == DATA) begin
                bit_count <= bit_count + 1;
            end else begin
                bit_count <= 0;
            end
        end
    end

    // Data capture
    always @(posedge clk) begin
        if (state == START && bit_count < 8) begin
            data[bit_count] <= in; // Capture data bits
        end
    end

    // Output logic
    assign out_byte = data;
    assign done = (state == STOP && in == 1 && parity_odd); // Check stop bit and parity

endmodule"
N/A,N/A,-1,28,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        DATA = 3'b010,
        PARITY = 3'b011,
        STOP = 3'b100
    } state_t;

    state_t state, next_state;
    reg [3:0] bit_count;  // Count the number of bits received
    reg [7:0] data_byte;  // Store the received byte
    reg parity_bit;       // Store the received parity bit
    reg [7:0] shift_reg;  // Shift register for serial data

    // Instantiate the parity module
    wire odd_parity;
    parity parity_inst (
        .clk(clk),
        .reset(reset | (state == START)),
        .in(in),
        .odd(odd_parity)
    );

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
        end else begin
            state <= next_state;
            if (state == DATA) begin
                shift_reg <= {in, shift_reg[7:1]};
                bit_count <= bit_count + 1;
            end else if (state == PARITY) begin
                parity_bit <= in;
            end else if (state == START) begin
                bit_count <= 0;
            end
        end
    end

    // Next state logic
    always @(*) begin
        next_state = state;
        case (state)
            IDLE: begin
                if (in == 0)  // Detect start bit
                    next_state = START;
            end
            START: begin
                if (bit_count == 8)
                    next_state = DATA;
            end
            DATA: begin
                if (bit_count == 8)
                    next_state = PARITY;
            end
            PARITY: begin
                next_state = STOP;
            end
            STOP: begin
                if (in == 1 && odd_parity)  // Check for stop bit and parity
                    next_state = IDLE;
                else
                    next_state = IDLE;  // Wait for the next start bit
            end
        endcase
    end

    // Output logic
    assign done = (state == STOP) && (in == 1) && odd_parity;
    assign out_byte = shift_reg;

endmodule"
N/A,N/A,-1,29,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        RECEIVE = 3'b010,
        PARITY_CHECK = 3'b011,
        STOP = 3'b100
    } state_t;

    state_t state, next_state;
    reg [7:0] data_shift;
    reg [3:0] bit_count;
    wire parity_odd;
    reg parity_reset;
    reg done_reg;

    // Instantiate the parity module
    parity parity_inst (
        .clk(clk),
        .reset(parity_reset),
        .in(in),
        .odd(parity_odd)
    );

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
            done_reg <= 0;
            parity_reset <= 1;
        end else begin
            state <= next_state;
            if (state == RECEIVE) bit_count <= bit_count + 1'b1;
            if (state == STOP) done_reg <= 0;
            if (state == PARITY_CHECK && parity_odd) done_reg <= 1;
        end
    end

    // Next state logic
    always @(*) begin
        next_state = state;
        parity_reset = 0;
        case (state)
            IDLE: begin
                if (!in) next_state = START;  // Detect start bit
            end
            START: begin
                next_state = RECEIVE;
                bit_count = 0;
                parity_reset = 1;
            end
            RECEIVE: begin
                if (bit_count == 8) next_state = PARITY_CHECK;
            end
            PARITY_CHECK: begin
                if (parity_odd) next_state = STOP;
                else next_state = IDLE;  // Parity error, wait for stop bit
            end
            STOP: begin
                if (in) next_state = IDLE;  // Stop bit detected
                else next_state = STOP;  // Wait for stop bit
            end
        endcase
    end

    // Data capturing
    always @(posedge clk) begin
        if (state == RECEIVE) begin
            data_shift <= {in, data_shift[7:1]};
        end
    end

    assign out_byte = data_shift;
    assign done = done_reg;

endmodule"
N/A,N/A,-1,30,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        RECEIVE = 3'b010,
        PARITY_CHECK = 3'b011,
        STOP = 3'b100,
        DONE = 3'b101
    } state_t;

    reg [2:0] state, next_state;
    reg [3:0] bit_count;
    reg [7:0] shift_reg;
    wire odd_parity;
    reg parity_reset;
    reg stop_bit_error;

    // Instantiate the parity module
    parity parity_inst (
        .clk(clk),
        .reset(parity_reset),
        .in(in),
        .odd(odd_parity)
    );

    // State transitions
    always @(posedge clk) begin
        if (reset)
            state <= IDLE;
        else
            state <= next_state;
    end

    // Next state logic
    always @(*) begin
        next_state = state;
        parity_reset = 0;
        stop_bit_error = 0;

        case (state)
            IDLE: begin
                if (!in) // Start bit detected
                    next_state = START;
            end
            START: begin
                if (bit_count == 4'd0) begin
                    next_state = RECEIVE;
                    parity_reset = 1;
                end
            end
            RECEIVE: begin
                if (bit_count == 4'd8)
                    next_state = PARITY_CHECK;
            end
            PARITY_CHECK: begin
                if (odd_parity == 1)
                    next_state = STOP;
                else
                    next_state = IDLE; // Parity error, reset to IDLE
            end
            STOP: begin
                if (in) // Stop bit detected
                    next_state = DONE;
                else
                    stop_bit_error = 1; // Wait for correct stop bit
            end
            DONE: begin
                next_state = IDLE; // Return to IDLE after successful reception
            end
        endcase
    end

    // Output logic
    assign done = (state == DONE);
    assign out_byte = shift_reg;

    // Bit counter and shift register
    always @(posedge clk) begin
        if (reset || state == IDLE || state == DONE) begin
            bit_count <= 0;
            shift_reg <= 0;
        end else if (state == START || state == RECEIVE) begin
            bit_count <= bit_count + 1;
            if (state == RECEIVE)
                shift_reg <= {in, shift_reg[7:1]};
        end
    end

endmodule"
N/A,N/A,-1,31,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        RECEIVE = 3'b010,
        PARITY_CHECK = 3'b011,
        STOP = 3'b100
    } state_t;

    state_t state, next_state;
    reg [7:0] data_shift;
    reg [3:0] bit_count;
    wire parity_odd;
    reg parity_reset;

    // Instantiate the parity module
    parity parity_inst (
        .clk(clk),
        .reset(parity_reset),
        .in(in),
        .odd(parity_odd)
    );

    // State transition
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
            data_shift <= 0;
            parity_reset <= 1;
        end else begin
            state <= next_state;
            if (state == RECEIVE) begin
                data_shift <= {in, data_shift[7:1]};
                bit_count <= bit_count + 1;
            end
            if (state == START) begin
                parity_reset <= 0; // Start counting parity
            end
            if (state == STOP) begin
                parity_reset <= 1; // Reset parity counter
            end
        end
    end

    // Next state logic
    always @(*) begin
        next_state = state; // Default: stay in current state
        case (state)
            IDLE: begin
                if (!in) // Detect start bit (0)
                    next_state = START;
            end
            START: begin
                next_state = RECEIVE;
            end
            RECEIVE: begin
                if (bit_count == 8)
                    next_state = PARITY_CHECK;
            end
            PARITY_CHECK: begin
                if (parity_odd) // Check for odd parity
                    next_state = STOP;
                else
                    next_state = IDLE; // Parity error, wait for next start bit
            end
            STOP: begin
                if (in) // Stop bit must be 1
                    next_state = IDLE;
                else
                    next_state = START; // Error, wait for next start bit
            end
        endcase
    end

    // Output logic
    assign out_byte = data_shift;
    assign done = (state == STOP) && in;

endmodule"
N/A,N/A,-1,32,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        RECEIVE = 3'b010,
        PARITY_CHECK = 3'b011,
        STOP = 3'b100
    } state_t;

    state_t state, next_state;
    reg [7:0] data_shift;
    reg [3:0] bit_count;
    wire parity_odd;
    reg parity_reset;
    reg done_reg;

    // Instantiate the parity module
    parity parity_inst (
        .clk(clk),
        .reset(parity_reset),
        .in(in),
        .odd(parity_odd)
    );

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            data_shift <= 8'd0;
            bit_count <= 4'd0;
            done_reg <= 1'b0;
            parity_reset <= 1'b1;
        end else begin
            state <= next_state;
            if (state == RECEIVE) begin
                data_shift <= {in, data_shift[7:1]};
                bit_count <= bit_count + 1;
            end
            if (state == PARITY_CHECK) begin
                done_reg <= (parity_odd == 1'b1);
            end
            if (state == IDLE) begin
                done_reg <= 1'b0;
            end
        end
    end

    // Next state logic
    always @(*) begin
        next_state = state;
        parity_reset = 1'b0;
        case (state)
            IDLE: begin
                if (in == 1'b0) begin  // Start bit detected
                    next_state = START;
                    parity_reset = 1'b1;
                end
            end
            START: begin
                next_state = RECEIVE;
            end
            RECEIVE: begin
                if (bit_count == 4'd8) begin
                    next_state = PARITY_CHECK;
                end
            end
            PARITY_CHECK: begin
                next_state = STOP;
            end
            STOP: begin
                if (in == 1'b1) begin  // Stop bit detected
                    next_state = IDLE;
                end else begin
                    next_state = IDLE;  // Wait for a valid stop bit
                end
            end
        endcase
    end

    assign out_byte = data_shift;
    assign done = done_reg;

endmodule"
N/A,N/A,-1,33,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        RECEIVE = 3'b010,
        PARITY_CHECK = 3'b011,
        STOP = 3'b100
    } state_t;

    state_t state, next_state;
    reg [7:0] data_shift;
    reg [3:0] bit_count;
    wire parity_odd;
    reg parity_reset;
    reg done_reg;

    // Instantiate the parity module
    parity parity_inst (
        .clk(clk),
        .reset(parity_reset),
        .in(in),
        .odd(parity_odd)
    );

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
            done_reg <= 0;
            parity_reset <= 1;
        end else begin
            state <= next_state;
            if (state == RECEIVE) bit_count <= bit_count + 1'b1;
            if (state == STOP) done_reg <= 0;
            if (state == PARITY_CHECK && parity_odd) done_reg <= 1;
        end
    end

    // Next state logic
    always @(*) begin
        next_state = state;
        parity_reset = 0;
        case (state)
            IDLE: begin
                if (!in) next_state = START;  // Detect start bit
            end
            START: begin
                next_state = RECEIVE;
                bit_count = 0;
                parity_reset = 1;
            end
            RECEIVE: begin
                if (bit_count == 8) next_state = PARITY_CHECK;
            end
            PARITY_CHECK: begin
                if (parity_odd == in) next_state = STOP;  // Check parity bit
                else next_state = IDLE;  // Parity error
            end
            STOP: begin
                if (in) next_state = IDLE;  // Stop bit detected
            end
        endcase
    end

    // Output logic
    always @(posedge clk) begin
        if (state == RECEIVE) begin
            data_shift <= {in, data_shift[7:1]};
        end
    end

    assign out_byte = data_shift;
    assign done = done_reg;

endmodule"
N/A,N/A,-1,34,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum reg [2:0] {
        IDLE,
        START,
        DATA,
        PARITY,
        STOP
    } state_t;

    // State registers
    reg [2:0] state, next_state;
    reg [3:0] bit_count; // To count bits received
    reg [7:0] data_reg;  // To store the received byte
    reg parity_reset;
    wire parity_odd;

    // Instantiate the parity module
    parity parity_inst (
        .clk(clk),
        .reset(parity_reset),
        .in(in),
        .odd(parity_odd)
    );

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
            parity_reset <= 1;
        end else begin
            state <= next_state;
            if (state == DATA) begin
                data_reg <= {in, data_reg[7:1]}; // Shift in the data bits
                bit_count <= bit_count + 1;
            end
        end
    end

    // Next state logic
    always @(*) begin
        next_state = state; // Default to hold state
        parity_reset = 0;
        done = 0;

        case (state)
            IDLE: begin
                if (!in) begin // Start bit detected
                    next_state = START;
                    parity_reset = 1; // Reset parity counter for new byte
                end
            end

            START: begin
                if (in) begin // False start bit, wait for a valid start bit
                    next_state = IDLE;
                end else begin
                    next_state = DATA;
                end
            end

            DATA: begin
                if (bit_count == 8) begin
                    next_state = PARITY;
                end
            end

            PARITY: begin
                if (parity_odd == in) begin // Check for odd parity
                    next_state = STOP;
                end else begin
                    next_state = IDLE; // Parity error, wait for next start bit
                end
            end

            STOP: begin
                if (in) begin // Valid stop bit
                    done = 1;
                    next_state = IDLE;
                end else begin
                    next_state = IDLE; // Stop bit error, wait for next start bit
                end
            end
        endcase
    end

    // Output logic
    assign out_byte = data_reg;

endmodule"
N/A,N/A,-1,35,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum reg [2:0] {
        IDLE,
        START,
        DATA,
        PARITY,
        STOP
    } state_t;

    // State registers
    reg [2:0] state, next_state;
    reg [3:0] bit_count; // To count bits received
    reg [7:0] data_reg;  // To store the received byte
    reg parity_bit;      // To store the received parity bit
    wire odd_parity;     // Output from the parity module

    // Instantiate the parity module
    parity parity_checker (
        .clk(clk),
        .reset(reset | (state == IDLE)), // Reset parity checker at the start of a new byte
        .in(in),
        .odd(odd_parity)
    );

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
        end else begin
            state <= next_state;
        end
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 0) // Start bit detected
                    next_state = START;
                else
                    next_state = IDLE;
            end
            START: begin
                next_state = DATA;
            end
            DATA: begin
                if (bit_count == 8)
                    next_state = PARITY;
                else
                    next_state = DATA;
            end
            PARITY: begin
                next_state = STOP;
            end
            STOP: begin
                if (in == 1) // Stop bit detected
                    next_state = IDLE;
                else
                    next_state = STOP; // Wait for stop bit
            end
            default: next_state = IDLE;
        endcase
    end

    // Output logic and data path
    always @(posedge clk) begin
        if (reset) begin
            bit_count <= 0;
            data_reg <= 8'b0;
            parity_bit <= 0;
        end else begin
            case (state)
                IDLE: begin
                    bit_count <= 0;
                end
                START: begin
                    bit_count <= 0;
                end
                DATA: begin
                    data_reg <= {in, data_reg[7:1]}; // Shift in the data bits
                    bit_count <= bit_count + 1;
                end
                PARITY: begin
                    parity_bit <= in; // Capture the parity bit
                end
                STOP: begin
                    // Nothing to do
                end
            endcase
        end
    end

    // Done signal logic
    assign done = (state == STOP) && (in == 1) && (parity_bit == odd_parity);
    assign out_byte = data_reg;

endmodule"
N/A,N/A,-1,36,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum reg [2:0] {
        IDLE,
        START,
        DATA,
        PARITY,
        STOP
    } state_t;

    // State registers
    reg [2:0] state, next_state;
    reg [3:0] bit_count; // To count the number of bits received
    reg [7:0] data;      // To store the received data byte
    wire parity_odd;     // Parity check output

    // Instantiate the parity module
    parity parity_inst (
        .clk(clk),
        .reset(reset | (state == IDLE) | (state == START)), // Reset at IDLE and START
        .in(in),
        .odd(parity_odd)
    );

    // State transition logic
    always @(*) begin
        next_state = state;
        case (state)
            IDLE: begin
                if (in == 0) // Detect start bit
                    next_state = START;
            end
            START: begin
                if (bit_count == 4'd8) // After 8 bits of data
                    next_state = DATA;
            end
            DATA: begin
                if (bit_count == 4'd0) // After 8 bits of data
                    next_state = PARITY;
            end
            PARITY: begin
                next_state = STOP; // Move to stop bit checking
            end
            STOP: begin
                if (in == 1) // Stop bit detected
                    next_state = IDLE;
                else
                    next_state = STOP; // Wait for stop bit
            end
        endcase
    end

    // State register update
    always @(posedge clk or posedge reset) begin
        if (reset)
            state <= IDLE;
        else
            state <= next_state;
    end

    // Bit count and data register update
    always @(posedge clk or posedge reset) begin
        if (reset) begin
            bit_count <= 4'd0;
            data <= 8'd0;
        end else if (state == START || state == DATA) begin
            if (bit_count == 4'd8)
                bit_count <= 4'd0;
            else
                bit_count <= bit_count + 1;
                
            if (state == DATA)
                data <= {in, data[7:1]}; // Shift in the data bits
        end
    end

    // Output logic
    assign out_byte = data;
    assign done = (state == STOP) && (parity_odd == 1) && (in == 1); // Assert done if parity is odd and stop bit is correct

endmodule"
N/A,N/A,-1,37,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        RECEIVE = 3'b010,
        PARITY_CHECK = 3'b011,
        STOP = 3'b100
    } state_t;

    state_t state, next_state;
    reg [7:0] data_shift;
    reg [3:0] bit_count;
    wire parity_odd;
    reg parity_reset;
    reg done_reg;

    // Instantiate the parity module
    parity parity_inst (
        .clk(clk),
        .reset(parity_reset),
        .in(in),
        .odd(parity_odd)
    );

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
            done_reg <= 0;
            parity_reset <= 1;
        end else begin
            state <= next_state;
            if (state == RECEIVE) bit_count <= bit_count + 1'b1;
            if (state == STOP) done_reg <= 0;
            if (state == IDLE || state == START) parity_reset <= 1;
            else parity_reset <= 0;
        end
    end

    // Next state logic
    always @(*) begin
        next_state = state;
        case (state)
            IDLE: begin
                if (!in) next_state = START;  // Detect start bit
            end
            START: begin
                next_state = RECEIVE;
            end
            RECEIVE: begin
                if (bit_count == 9) next_state = PARITY_CHECK;  // After 9 bits (8 data + 1 parity)
            end
            PARITY_CHECK: begin
                if (parity_odd) next_state = STOP;  // Check parity
                else next_state = IDLE;  // Parity error, wait for next start bit
            end
            STOP: begin
                if (in) begin  // Check stop bit
                    next_state = IDLE;
                    done_reg = 1;
                end else begin
                    next_state = IDLE;  // Stop bit error, reset
                end
            end
        endcase
    end

    // Output logic
    assign out_byte = data_shift;
    assign done = done_reg;

    // Data shift register
    always @(posedge clk) begin
        if (state == RECEIVE) begin
            data_shift <= {in, data_shift[7:1]};  // Shift in the data bits
        end
    end

endmodule"
N/A,N/A,-1,38,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum reg [2:0] {
        IDLE,
        START,
        DATA,
        PARITY,
        STOP
    } state_t;

    // State registers
    reg [2:0] state, next_state;
    reg [3:0] bit_count; // To count the number of bits received
    reg [7:0] data;      // To store the received data byte
    wire parity_odd;     // Parity check output

    // Instantiate the parity module
    parity parity_inst (
        .clk(clk),
        .reset(reset | (state == IDLE) | (state == START)), // Reset at IDLE and START
        .in(in),
        .odd(parity_odd)
    );

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
        end else begin
            state <= next_state;
        end
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (~in) // Start bit detected (0)
                    next_state = START;
                else
                    next_state = IDLE;
            end
            START: begin
                next_state = DATA;
            end
            DATA: begin
                if (bit_count == 8)
                    next_state = PARITY;
                else
                    next_state = DATA;
            end
            PARITY: begin
                next_state = STOP;
            end
            STOP: begin
                if (in) // Stop bit detected (1)
                    next_state = IDLE;
                else
                    next_state = STOP; // Wait for stop bit
            end
            default: next_state = IDLE;
        endcase
    end

    // Output logic and data path
    always @(posedge clk) begin
        if (reset) begin
            bit_count <= 0;
            data <= 0;
        end else begin
            case (state)
                START: begin
                    bit_count <= 0;
                    data <= 0;
                end
                DATA: begin
                    data <= {in, data[7:1]}; // Shift in the data bits
                    bit_count <= bit_count + 1;
                end
                PARITY: begin
                    // No action needed, just checking parity
                end
                STOP: begin
                    // No action needed
                end
            endcase
        end
    end

    // Done signal logic
    assign done = (state == STOP) && in && parity_odd;

    // Output the received byte
    assign out_byte = data;

endmodule"
N/A,N/A,-1,39,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        DATA = 3'b010,
        PARITY = 3'b011,
        STOP = 3'b100
    } state_t;
    
    state_t state, next_state;
    reg [7:0] data_shift;
    reg [3:0] bit_count;
    wire parity_odd;
    reg parity_reset;
    reg done_reg;

    // Instantiate the parity module
    parity parity_inst (
        .clk(clk),
        .reset(parity_reset),
        .in(in),
        .odd(parity_odd)
    );

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
            done_reg <= 0;
            parity_reset <= 1;
        end else begin
            state <= next_state;
            if (state == DATA) bit_count <= bit_count + 1'b1;
            if (state == STOP) done_reg <= 0;
            if (state == START) parity_reset <= 0;
        end
    end

    // Next state logic
    always @(*) begin
        next_state = state;  // Default to hold state
        case (state)
            IDLE: begin
                if (!in) next_state = START;  // Detect start bit (0)
            end
            START: begin
                next_state = DATA;  // Move to data state
            end
            DATA: begin
                if (bit_count == 8) next_state = PARITY;  // After 8 bits, check parity
            end
            PARITY: begin
                if (parity_odd) next_state = STOP;  // If odd parity, expect stop bit
                else next_state = IDLE;  // If parity fails, go to IDLE
            end
            STOP: begin
                if (in) begin
                    next_state = IDLE;
                    done_reg = 1;  // Assert done if stop bit is correct
                end
            end
        endcase
    end

    // Output logic
    always @(posedge clk) begin
        if (state == DATA) begin
            data_shift <= {in, data_shift[7:1]};  // Shift in data bits
        end
    end

    assign out_byte = data_shift;
    assign done = done_reg;

endmodule"
N/A,N/A,-1,40,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        DATA = 3'b010,
        PARITY = 3'b011,
        STOP = 3'b100,
        ERROR = 3'b101
    } state_t;
    
    state_t state, next_state;
    reg [3:0] bit_count;  // Count the number of bits received
    reg [7:0] data;       // Store the received data byte
    reg parity_bit;       // Store the received parity bit
    wire odd_parity;      // Output from the parity module
    reg parity_reset;     // Control signal to reset the parity module
    reg stop_bit;         // Store the received stop bit

    // Instantiate the parity module
    parity parity_inst (
        .clk(clk),
        .reset(parity_reset),
        .in(in),
        .odd(odd_parity)
    );

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
            parity_reset <= 1;
        end else begin
            state <= next_state;
            if (state == DATA) begin
                data[bit_count] <= in;
                bit_count <= bit_count + 1;
            end
            if (state == PARITY) begin
                parity_bit <= in;
            end
            if (state == STOP) begin
                stop_bit <= in;
            end
            if (state == IDLE || state == ERROR) begin
                bit_count <= 0;
                parity_reset <= 1; // Reset parity check at the start or after error
            end else begin
                parity_reset <= 0;
            end
        end
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 0) // Start bit detected
                    next_state = START;
                else
                    next_state = IDLE;
            end
            START: begin
                if (bit_count == 0)
                    next_state = DATA;
                else
                    next_state = START;
            end
            DATA: begin
                if (bit_count == 8)
                    next_state = PARITY;
                else
                    next_state = DATA;
            end
            PARITY: begin
                next_state = STOP;
            end
            STOP: begin
                if (in == 1) begin // Stop bit should be 1
                    if (odd_parity == 1 && parity_bit == 1) // Check for odd parity
                        next_state = IDLE;
                    else
                        next_state = ERROR;
                end else
                    next_state = STOP;
            end
            ERROR: begin
                if (in == 1) // Wait for stop bit to recover
                    next_state = IDLE;
                else
                    next_state = ERROR;
            end
            default: next_state = IDLE;
        endcase
    end

    // Output logic
    assign out_byte = data;
    assign done = (state == STOP) && (in == 1) && (odd_parity == 1) && (parity_bit == 1);

endmodule"
N/A,N/A,-1,41,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        RECEIVE = 3'b010,
        PARITY_CHECK = 3'b011,
        STOP = 3'b100
    } state_t;

    // State registers
    reg [2:0] state, next_state;
    reg [3:0] bit_count;  // To count bits received
    reg [7:0] data_byte;  // To store received data byte
    reg parity_bit;       // To store received parity bit
    wire parity_odd;      // Output from the parity module

    // Instantiate the parity module
    parity parity_inst (
        .clk(clk),
        .reset(reset || (state == IDLE) || (state == START)),
        .in(in),
        .odd(parity_odd)
    );

    // State transition logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (~in)  // Start bit detected
                    next_state = START;
                else
                    next_state = IDLE;
            end
            START: begin
                next_state = RECEIVE;
            end
            RECEIVE: begin
                if (bit_count == 8)
                    next_state = PARITY_CHECK;
                else
                    next_state = RECEIVE;
            end
            PARITY_CHECK: begin
                next_state = STOP;
            end
            STOP: begin
                if (in)  // Stop bit detected
                    next_state = IDLE;
                else
                    next_state = STOP;
            end
            default: next_state = IDLE;
        endcase
    end

    // State update logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
            data_byte <= 8'b0;
            parity_bit <= 1'b0;
        end else begin
            state <= next_state;

            case (state)
                START: begin
                    bit_count <= 0;
                    data_byte <= 8'b0;
                end
                RECEIVE: begin
                    data_byte <= {in, data_byte[7:1]};
                    bit_count <= bit_count + 1;
                end
                PARITY_CHECK: begin
                    parity_bit <= in;
                end
                STOP: begin
                    // No action needed
                end
                default: begin
                    // No action needed
                end
            endcase
        end
    end

    // Output logic
    assign out_byte = data_byte;
    assign done = (state == STOP) && (in) && (parity_odd == parity_bit);

endmodule"
N/A,N/A,-1,42,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        RECEIVE = 3'b010,
        PARITY_CHECK = 3'b011,
        STOP = 3'b100
    } state_t;

    // State variables
    reg [2:0] state, next_state;
    reg [3:0] bit_count; // Count 9 bits (8 data + 1 parity)
    reg [7:0] data_reg;
    reg parity_bit;
    wire odd_parity;

    // Instantiate the parity module
    parity parity_checker (
        .clk(clk),
        .reset(reset | (state == IDLE) | (state == START)),
        .in(in),
        .odd(odd_parity)
    );

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
        end else begin
            state <= next_state;
        end
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (!in) // Detect start bit (0)
                    next_state = START;
                else
                    next_state = IDLE;
            end
            START: begin
                next_state = RECEIVE;
            end
            RECEIVE: begin
                if (bit_count == 4'd8) // After 8 data bits
                    next_state = PARITY_CHECK;
                else
                    next_state = RECEIVE;
            end
            PARITY_CHECK: begin
                next_state = STOP;
            end
            STOP: begin
                if (in) // Stop bit should be 1
                    next_state = IDLE;
                else
                    next_state = STOP; // Wait for stop bit
            end
            default: next_state = IDLE;
        endcase
    end

    // Output and data path logic
    always @(posedge clk) begin
        if (reset) begin
            bit_count <= 0;
            data_reg <= 8'b0;
            parity_bit <= 0;
        end else begin
            case (state)
                IDLE: begin
                    bit_count <= 0;
                end
                START: begin
                    bit_count <= 0;
                end
                RECEIVE: begin
                    bit_count <= bit_count + 1;
                    data_reg <= {in, data_reg[7:1]}; // Shift in data bits (LSB first)
                end
                PARITY_CHECK: begin
                    parity_bit <= in; // Capture parity bit
                end
                STOP: begin
                    // Do nothing
                end
            endcase
        end
    end

    // Done signal logic
    assign done = (state == STOP) && in && (odd_parity == 1'b1) && (parity_bit == odd_parity);

    // Output byte
    assign out_byte = data_reg;

endmodule"
N/A,N/A,-1,43,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        RECEIVE = 3'b010,
        PARITY_CHECK = 3'b011,
        STOP = 3'b100
    } state_t;

    // State variables
    reg [2:0] state, next_state;
    reg [3:0] bit_count; // Count 9 bits (8 data + 1 parity)
    reg [7:0] data_reg;
    reg parity_bit;
    wire odd_parity;

    // Instantiate the parity module
    parity parity_checker (
        .clk(clk),
        .reset(reset | (state == IDLE) | (state == START)),
        .in(in),
        .odd(odd_parity)
    );

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
        end else begin
            state <= next_state;
        end
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (!in) // Detect start bit (0)
                    next_state = START;
                else
                    next_state = IDLE;
            end
            START: begin
                next_state = RECEIVE;
            end
            RECEIVE: begin
                if (bit_count == 4'd8) // After 8 data bits
                    next_state = PARITY_CHECK;
                else
                    next_state = RECEIVE;
            end
            PARITY_CHECK: begin
                next_state = STOP;
            end
            STOP: begin
                if (in) // Stop bit should be 1
                    next_state = IDLE;
                else
                    next_state = STOP; // Wait for stop bit
            end
            default: next_state = IDLE;
        endcase
    end

    // Output and data path logic
    always @(posedge clk) begin
        if (reset) begin
            bit_count <= 0;
            data_reg <= 8'b0;
            parity_bit <= 0;
        end else begin
            case (state)
                IDLE: begin
                    bit_count <= 0;
                end
                START: begin
                    bit_count <= 0;
                end
                RECEIVE: begin
                    bit_count <= bit_count + 1;
                    data_reg <= {in, data_reg[7:1]}; // Shift in data bits (LSB first)
                end
                PARITY_CHECK: begin
                    parity_bit <= in; // Capture parity bit
                end
                STOP: begin
                    // Do nothing
                end
            endcase
        end
    end

    // Done signal logic
    assign done = (state == STOP) && in && (parity_bit == odd_parity);

    // Output data
    assign out_byte = data_reg;

endmodule"
N/A,N/A,-1,44,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        DATA = 3'b010,
        PARITY = 3'b011,
        STOP = 3'b100
    } state_t;

    state_t state, next_state;
    reg [3:0] bit_count;  // Count the number of bits received
    reg [7:0] data_byte;  // Store the received data byte
    reg parity_bit;       // Store the received parity bit
    wire odd;             // Output of the parity checker

    // Instantiate the parity module
    parity parity_checker (
        .clk(clk),
        .reset(reset || (state == IDLE)),
        .in(in),
        .odd(odd)
    );

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
            data_byte <= 8'b0;
            parity_bit <= 0;
        end else begin
            state <= next_state;
        end
    end

    // Next state logic
    always @(*) begin
        next_state = state;  // Default: stay in the current state
        case (state)
            IDLE: begin
                if (in == 0)  // Detect start bit (0)
                    next_state = START;
            end
            START: begin
                if (bit_count == 4'd8)  // Wait for 8 data bits
                    next_state = DATA;
            end
            DATA: begin
                if (bit_count == 4'd9)  // After 8 data bits, wait for parity bit
                    next_state = PARITY;
            end
            PARITY: begin
                if (bit_count == 4'd10)  // After parity bit, wait for stop bit
                    next_state = STOP;
            end
            STOP: begin
                if (in == 1) begin  // Check for stop bit (1)
                    if (odd) begin  // Check if odd parity is satisfied
                        next_state = IDLE;
                    end
                end else begin
                    next_state = IDLE;  // If stop bit is incorrect, reset
                end
            end
        endcase
    end

    // Output logic and data processing
    always @(posedge clk) begin
        if (reset) begin
            bit_count <= 0;
            data_byte <= 8'b0;
            parity_bit <= 0;
        end else begin
            case (state)
                IDLE: begin
                    bit_count <= 0;
                end
                START: begin
                    bit_count <= bit_count + 1;
                end
                DATA: begin
                    if (bit_count < 8) begin
                        data_byte[bit_count] <= in;  // Shift in the data bits
                    end
                    bit_count <= bit_count + 1;
                end
                PARITY: begin
                    parity_bit <= in;  // Capture the parity bit
                    bit_count <= bit_count + 1;
                end
                STOP: begin
                    if (in == 1 && odd) begin
                        done <= 1;  // Assert done if stop bit is correct and parity is odd
                    end else begin
                        done <= 0;
                    end
                end
            endcase
        end
    end

    assign out_byte = data_byte;

endmodule"
N/A,N/A,-1,45,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        DATA = 3'b010,
        PARITY = 3'b011,
        STOP = 3'b100,
        ERROR = 3'b101
    } state_t;
    
    reg [2:0] state, next_state;
    reg [3:0] bit_count;
    reg [7:0] data_byte;
    wire odd_parity;
    
    // Parity checker instance
    parity parity_checker (
        .clk(clk),
        .reset(reset | (state == START)),
        .in(in),
        .odd(odd_parity)
    );

    // State transition
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
        end else begin
            state <= next_state;
            if (state == DATA) begin
                data_byte[bit_count] <= in;
                bit_count <= bit_count + 1;
            end
        end
    end

    // Next state logic
    always @(*) begin
        next_state = state; // Default to hold state
        case (state)
            IDLE: begin
                if (!in) next_state = START; // Detect start bit
            end
            START: begin
                if (bit_count == 0) next_state = DATA;
            end
            DATA: begin
                if (bit_count == 8) next_state = PARITY;
            end
            PARITY: begin
                if (odd_parity == in) next_state = STOP;
                else next_state = ERROR;
            end
            STOP: begin
                if (in) next_state = IDLE; // Stop bit detected
                else next_state = ERROR;
            end
            ERROR: begin
                if (in) next_state = IDLE; // Wait for stop bit
            end
        endcase
    end

    // Output logic
    assign done = (state == STOP) && in;
    assign out_byte = data_byte;

endmodule"
N/A,N/A,-1,46,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        DATA = 3'b010,
        PARITY = 3'b011,
        STOP = 3'b100
    } state_t;

    state_t state, next_state;
    reg [3:0] bit_count;  // Count the number of bits received
    reg [7:0] data_byte;  // Store the received byte
    reg parity_bit;       // Store the received parity bit
    reg [7:0] shift_reg;  // Shift register for serial data

    // Instantiate the parity module
    wire odd_parity;
    parity parity_inst (
        .clk(clk),
        .reset(reset | (state == START)),
        .in(in),
        .odd(odd_parity)
    );

    // State transition logic
    always @(posedge clk) begin
        if (reset)
            state <= IDLE;
        else
            state <= next_state;
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (!in)  // Detect start bit (0)
                    next_state = START;
                else
                    next_state = IDLE;
            end
            START: begin
                if (bit_count == 4'd8)
                    next_state = PARITY;
                else
                    next_state = DATA;
            end
            DATA: begin
                if (bit_count == 4'd8)
                    next_state = PARITY;
                else
                    next_state = DATA;
            end
            PARITY: begin
                next_state = STOP;
            end
            STOP: begin
                if (in)  // Detect stop bit (1)
                    next_state = IDLE;
                else
                    next_state = STOP;  // Wait for stop bit
            end
            default: next_state = IDLE;
        endcase
    end

    // Datapath logic
    always @(posedge clk) begin
        if (reset) begin
            bit_count <= 4'd0;
            data_byte <= 8'd0;
            parity_bit <= 1'b0;
        end
        else begin
            case (state)
                START: begin
                    bit_count <= 4'd0;
                    data_byte <= 8'd0;
                    parity_bit <= 1'b0;
                end
                DATA: begin
                    shift_reg <= {in, shift_reg[7:1]};
                    bit_count <= bit_count + 1;
                    if (bit_count < 4'd8)
                        data_byte <= {in, data_byte[7:1]};
                end
                PARITY: begin
                    parity_bit <= in;
                end
                STOP: begin
                    // No action needed, just wait for stop bit
                end
            endcase
        end
    end

    // Output logic
    assign out_byte = data_byte;
    assign done = (state == STOP) && in && (odd_parity == 1'b1);

endmodule"
N/A,N/A,-1,47,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        RECEIVE = 3'b010,
        PARITY_CHECK = 3'b011,
        STOP = 3'b100
    } state_t;

    state_t state, next_state;
    reg [7:0] data_shift;
    reg [3:0] bit_count;
    wire parity_odd;
    reg parity_reset;
    reg [7:0] out_byte_reg;
    reg done_reg;

    // Instantiate the parity module
    parity parity_inst (
        .clk(clk),
        .reset(parity_reset),
        .in(in),
        .odd(parity_odd)
    );

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
            data_shift <= 8'b0;
            parity_reset <= 1;
            done_reg <= 0;
        end else begin
            state <= next_state;
            if (state == RECEIVE) begin
                data_shift <= {in, data_shift[7:1]};
                bit_count <= bit_count + 1;
            end
            if (state == PARITY_CHECK) begin
                out_byte_reg <= data_shift;
                done_reg <= 0;
            end
            if (state == STOP) begin
                if (in == 1 && parity_odd) begin
                    done_reg <= 1;
                end else begin
                    done_reg <= 0;
                end
            end
        end
    end

    // Next state logic
    always @(*) begin
        next_state = state;
        parity_reset = 0;
        case (state)
            IDLE: begin
                done_reg = 0;
                if (in == 0) begin
                    next_state = START;
                    parity_reset = 1;
                end
            end
            START: begin
                if (in == 0) begin
                    next_state = RECEIVE;
                    bit_count = 0;
                end
            end
            RECEIVE: begin
                if (bit_count == 8) begin
                    next_state = PARITY_CHECK;
                end
            end
            PARITY_CHECK: begin
                next_state = STOP;
            end
            STOP: begin
                if (in == 1) begin
                    next_state = IDLE;
                end else begin
                    next_state = IDLE; // Wait for stop bit
                end
            end
        endcase
    end

    assign out_byte = out_byte_reg;
    assign done = done_reg;

endmodule"
N/A,N/A,-1,48,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum reg [2:0] {
        IDLE,
        START,
        DATA,
        PARITY,
        STOP
    } state_t;

    // State registers
    reg [2:0] state, next_state;
    reg [3:0] bit_count; // To count bits received
    reg [7:0] data_reg;  // To store the received byte
    reg parity_reset;
    wire parity_odd;

    // Instantiate the parity module
    parity parity_inst (
        .clk(clk),
        .reset(parity_reset),
        .in(in),
        .odd(parity_odd)
    );

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
            parity_reset <= 1;
        end else begin
            state <= next_state;
            if (state == DATA) begin
                data_reg <= {in, data_reg[7:1]}; // Shift in the data bits
                bit_count <= bit_count + 1;
            end
        end
    end

    // Next state logic
    always @(*) begin
        next_state = state; // Default to hold state
        parity_reset = 0;   // Default to not reset parity

        case (state)
            IDLE: begin
                if (in == 0) begin // Start bit detected
                    next_state = START;
                    parity_reset = 1; // Reset parity on start bit
                end
            end
            START: begin
                next_state = DATA;
            end
            DATA: begin
                if (bit_count == 8) begin
                    next_state = PARITY;
                end
            end
            PARITY: begin
                if (parity_odd) begin // Check for odd parity
                    next_state = STOP;
                end else begin
                    next_state = IDLE; // Parity check failed, reset
                end
            end
            STOP: begin
                if (in == 1) begin // Valid stop bit
                    next_state = IDLE;
                end else begin
                    next_state = STOP; // Wait for stop bit
                end
            end
        endcase
    end

    // Output logic
    assign out_byte = data_reg;
    assign done = (state == STOP) && (in == 1) && parity_odd;

endmodule"
N/A,N/A,-1,49,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        RECEIVE = 3'b010,
        PARITY_CHECK = 3'b011,
        STOP = 3'b100
    } state_t;

    state_t state, next_state;
    reg [7:0] data_shift;
    reg [3:0] bit_count;
    wire parity_odd;
    reg parity_reset;
    reg [7:0] out_byte_reg;
    reg done_reg;

    // Instantiate the parity module
    parity parity_inst (
        .clk(clk),
        .reset(parity_reset),
        .in(in),
        .odd(parity_odd)
    );

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
            parity_reset <= 1;
            done_reg <= 0;
        end else begin
            state <= next_state;
            if (state == RECEIVE) begin
                data_shift <= {in, data_shift[7:1]};
                bit_count <= bit_count + 1;
            end
        end
    end

    // Next state logic
    always @(*) begin
        next_state = state;
        parity_reset = 0;
        done_reg = 0;
        case (state)
            IDLE: begin
                if (~in) begin
                    next_state = START;
                    parity_reset = 1; // Reset parity on start bit
                end
            end
            START: begin
                if (in) begin
                    next_state = RECEIVE;
                    bit_count = 0;
                end
            end
            RECEIVE: begin
                if (bit_count == 8) begin
                    next_state = PARITY_CHECK;
                end
            end
            PARITY_CHECK: begin
                if (parity_odd) begin
                    next_state = STOP;
                end else begin
                    next_state = IDLE; // Parity check failed, go back to IDLE
                end
            end
            STOP: begin
                if (in) begin
                    next_state = IDLE;
                    out_byte_reg = data_shift;
                    done_reg = 1;
                end
            end
        endcase
    end

    assign out_byte = out_byte_reg;
    assign done = done_reg;

endmodule"
N/A,N/A,-1,50,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        RECEIVE = 3'b010,
        PARITY_CHECK = 3'b011,
        STOP = 3'b100
    } state_t;

    state_t state, next_state;
    reg [7:0] data_shift;
    reg [3:0] bit_count;
    wire parity_odd;
    reg parity_reset;
    reg [7:0] out_byte_reg;
    reg done_reg;

    // Instantiate the parity module
    parity parity_inst (
        .clk(clk),
        .reset(parity_reset),
        .in(in),
        .odd(parity_odd)
    );

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
            parity_reset <= 1;
            done_reg <= 0;
        end else begin
            state <= next_state;
            if (state == RECEIVE) begin
                data_shift <= {in, data_shift[7:1]};
                bit_count <= bit_count + 1;
            end
        end
    end

    // Next state logic
    always @(*) begin
        next_state = state;
        parity_reset = 0;
        done_reg = 0;

        case (state)
            IDLE: begin
                if (~in) begin
                    next_state = START;
                    parity_reset = 1; // Reset parity on start bit
                end
            end

            START: begin
                if (in) begin
                    next_state = RECEIVE;
                    bit_count = 0;
                end
            end

            RECEIVE: begin
                if (bit_count == 8) begin
                    next_state = PARITY_CHECK;
                end
            end

            PARITY_CHECK: begin
                if (parity_odd == in) begin
                    next_state = STOP;
                end else begin
                    next_state = IDLE; // Parity failed, return to IDLE
                end
            end

            STOP: begin
                if (in) begin
                    next_state = IDLE;
                    out_byte_reg = data_shift;
                    done_reg = 1;
                end
            end
        endcase
    end

    assign out_byte = out_byte_reg;
    assign done = done_reg;

endmodule"
N/A,N/A,-1,51,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        DATA = 3'b010,
        PARITY = 3'b011,
        STOP = 3'b100
    } state_t;

    state_t state, next_state;
    reg [3:0] bit_count;  // Count the number of bits received
    reg [7:0] data_byte;  // Store the received byte
    reg parity_bit;       // Store the received parity bit
    reg [7:0] shift_reg;  // Shift register for serial data

    // Parity checker instance
    wire odd_parity;
    parity parity_checker (
        .clk(clk),
        .reset(reset | (state == START)),
        .in(in),
        .odd(odd_parity)
    );

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
        end else begin
            state <= next_state;
            if (state == DATA) begin
                shift_reg <= {in, shift_reg[7:1]};
                bit_count <= bit_count + 1;
            end else if (state == PARITY) begin
                parity_bit <= in;
            end else if (state == IDLE || state == STOP) begin
                bit_count <= 0;
            end
        end
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (~in) // Start bit detected (active low)
                    next_state = START;
                else
                    next_state = IDLE;
            end
            START: begin
                next_state = DATA;
            end
            DATA: begin
                if (bit_count == 8)
                    next_state = PARITY;
                else
                    next_state = DATA;
            end
            PARITY: begin
                next_state = STOP;
            end
            STOP: begin
                if (in) // Stop bit detected (active high)
                    next_state = IDLE;
                else
                    next_state = STOP; // Wait for stop bit
            end
            default: next_state = IDLE;
        endcase
    end

    // Output logic
    assign out_byte = shift_reg;
    assign done = (state == STOP) && in && (odd_parity == 1'b1) && (parity_bit == odd_parity);

endmodule"
N/A,N/A,-1,52,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        DATA = 3'b010,
        PARITY = 3'b011,
        STOP = 3'b100
    } state_t;

    state_t state, next_state;
    reg [3:0] bit_count;  // Count the number of bits received
    reg [7:0] data_byte;  // Store the received byte
    reg parity_bit;       // Store the received parity bit
    reg [7:0] shift_reg;  // Shift register for serial data

    // Parity checker instance
    wire odd_parity;
    parity parity_checker (
        .clk(clk),
        .reset(reset | (state == START)),
        .in(in),
        .odd(odd_parity)
    );

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
        end else begin
            state <= next_state;
            if (state == DATA) begin
                shift_reg <= {in, shift_reg[7:1]};
                bit_count <= bit_count + 1;
            end else if (state == PARITY) begin
                parity_bit <= in;
            end else if (state == STOP) begin
                bit_count <= 0;
            end
        end
    end

    // Next state logic
    always @(*) begin
        next_state = state;
        case (state)
            IDLE: begin
                if (in == 0)  // Detect start bit
                    next_state = START;
            end
            START: begin
                next_state = DATA;
            end
            DATA: begin
                if (bit_count == 8)
                    next_state = PARITY;
            end
            PARITY: begin
                next_state = STOP;
            end
            STOP: begin
                if (in == 1) begin  // Detect stop bit
                    if (parity_bit == odd_parity) 
                        next_state = IDLE;
                    else
                        next_state = IDLE;  // Parity error, reset to IDLE
                end else begin
                    next_state = IDLE;  // Wait for stop bit
                end
            end
        endcase
    end

    // Output logic
    assign done = (state == STOP) && (in == 1) && (parity_bit == odd_parity);
    assign out_byte = shift_reg;

endmodule"
N/A,N/A,-1,53,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        DATA = 3'b010,
        PARITY = 3'b011,
        STOP = 3'b100
    } state_t;

    state_t state, next_state;
    reg [3:0] bit_count;  // Count the number of bits received
    reg [7:0] data_reg;   // Store the received data byte
    reg parity_bit;       // Store the received parity bit
    wire odd;             // Output of the parity checker

    // Instantiate the parity module
    parity parity_checker (
        .clk(clk),
        .reset(reset | (state == IDLE)),
        .in(in),
        .odd(odd)
    );

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
            data_reg <= 8'b0;
            parity_bit <= 0;
        end else begin
            state <= next_state;
            if (state == DATA && bit_count < 8) begin
                data_reg <= {in, data_reg[7:1]};
                bit_count <= bit_count + 1;
            end else if (state == PARITY) begin
                parity_bit <= in;
            end else if (state == STOP) begin
                bit_count <= 0;
            end
        end
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (!in) next_state = START;  // Detect start bit (0)
                else next_state = IDLE;
            end
            START: begin
                next_state = DATA;
            end
            DATA: begin
                if (bit_count == 8) next_state = PARITY;
                else next_state = DATA;
            end
            PARITY: begin
                next_state = STOP;
            end
            STOP: begin
                if (in) next_state = IDLE;  // Detect stop bit (1)
                else next_state = START;    // If stop bit is not correct, search for new start
            end
            default: next_state = IDLE;
        endcase
    end

    // Output logic
    assign out_byte = data_reg;
    assign done = (state == STOP) && in && (odd == parity_bit);

endmodule"
N/A,N/A,-1,54,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        RECEIVE = 3'b010,
        PARITY_CHECK = 3'b011,
        STOP = 3'b100
    } state_t;

    state_t state, next_state;
    reg [7:0] data_shift;
    reg [3:0] bit_count;
    wire parity_odd;
    reg parity_reset;
    reg done_reg;

    // Instantiate the parity module
    parity parity_inst (
        .clk(clk),
        .reset(parity_reset),
        .in(in),
        .odd(parity_odd)
    );

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
            done_reg <= 0;
            parity_reset <= 1;
        end else begin
            state <= next_state;
            if (state == RECEIVE) bit_count <= bit_count + 1'b1;
            if (state == STOP) done_reg <= 0;
            if (state == IDLE || state == PARITY_CHECK) parity_reset <= 1;
            else parity_reset <= 0;
        end
    end

    // Next state logic
    always @(*) begin
        next_state = state;
        case (state)
            IDLE: begin
                if (in == 0) next_state = START; // Detect start bit (0)
            end
            START: begin
                if (bit_count == 4'd8) next_state = RECEIVE; // Move to RECEIVE after 1 bit
            end
            RECEIVE: begin
                if (bit_count == 4'd8) next_state = PARITY_CHECK; // After 8 data bits, check parity
            end
            PARITY_CHECK: begin
                if (parity_odd == 1) next_state = STOP; // If parity is odd, check stop bit
                else next_state = IDLE; // Parity failed, return to IDLE
            end
            STOP: begin
                if (in == 1) next_state = IDLE; // Check for stop bit (1), then return to IDLE
            end
        endcase
    end

    // Output logic
    always @(posedge clk) begin
        if (state == RECEIVE) begin
            data_shift <= {in, data_shift[7:1]};
        end
        if (state == STOP && in == 1 && parity_odd == 1) begin
            done_reg <= 1;
        end
    end

    assign out_byte = data_shift;
    assign done = done_reg;

endmodule"
N/A,N/A,-1,55,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        DATA = 3'b010,
        PARITY = 3'b011,
        STOP = 3'b100
    } state_t;

    state_t state, next_state;
    reg [3:0] bit_count;  // Count the number of bits received
    reg [7:0] data_byte;  // Store the received byte
    reg parity_bit;       // Store the received parity bit
    reg [7:0] shift_reg;  // Shift register for serial data

    wire odd_parity;

    // Instantiate the parity module
    parity parity_inst (
        .clk(clk),
        .reset(reset | (state == START)),
        .in(in),
        .odd(odd_parity)
    );

    // State transition logic
    always @(posedge clk) begin
        if (reset)
            state <= IDLE;
        else
            state <= next_state;
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (!in)  // Detect start bit (0)
                    next_state = START;
                else
                    next_state = IDLE;
            end
            START: begin
                if (bit_count == 4'd8)
                    next_state = PARITY;
                else
                    next_state = DATA;
            end
            DATA: begin
                if (bit_count == 4'd8)
                    next_state = PARITY;
                else
                    next_state = DATA;
            end
            PARITY: begin
                next_state = STOP;
            end
            STOP: begin
                if (in)  // Detect stop bit (1)
                    next_state = IDLE;
                else
                    next_state = STOP;  // Wait for stop bit
            end
            default: next_state = IDLE;
        endcase
    end

    // Datapath logic
    always @(posedge clk) begin
        if (reset) begin
            bit_count <= 4'd0;
            data_byte <= 8'd0;
            parity_bit <= 1'b0;
        end
        else begin
            case (state)
                START: begin
                    bit_count <= 4'd0;
                    data_byte <= 8'd0;
                    parity_bit <= 1'b0;
                end
                DATA: begin
                    shift_reg <= {in, shift_reg[7:1]};
                    bit_count <= bit_count + 1;
                    if (bit_count < 4'd8)
                        data_byte <= {in, data_byte[7:1]};
                end
                PARITY: begin
                    parity_bit <= in;
                end
                STOP: begin
                    // No action needed, just wait for stop bit
                end
            endcase
        end
    end

    // Output logic
    assign out_byte = data_byte;
    assign done = (state == STOP) && in && (odd_parity == 1'b1);

endmodule"
N/A,N/A,-1,56,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum reg [2:0] {
        IDLE,
        START,
        DATA,
        PARITY,
        STOP
    } state_t;

    reg [2:0] state, next_state;
    reg [3:0] bit_count; // Counts bits from 0 to 9 (8 data + 1 parity)
    reg [7:0] data_reg;
    reg parity_bit;
    wire odd_parity;

    // Instantiate the parity module
    parity parity_inst (
        .clk(clk),
        .reset(reset || (state == IDLE && next_state == START)), // Reset parity at the start of each byte
        .in(in),
        .odd(odd_parity)
    );

    // State transition logic
    always @(posedge clk) begin
        if (reset)
            state <= IDLE;
        else
            state <= next_state;
    end

    // Next state logic
    always @(*) begin
        next_state = state;
        case (state)
            IDLE: begin
                if (in == 0) // Detect start bit
                    next_state = START;
            end
            START: begin
                if (bit_count == 9)
                    next_state = PARITY;
                else
                    next_state = DATA;
            end
            DATA: begin
                if (bit_count == 9)
                    next_state = PARITY;
            end
            PARITY: begin
                next_state = STOP;
            end
            STOP: begin
                if (in == 1) // Detect stop bit
                    next_state = IDLE;
                else
                    next_state = STOP; // Wait for stop bit
            end
        endcase
    end

    // Output logic
    always @(posedge clk) begin
        if (reset) begin
            bit_count <= 0;
            data_reg <= 0;
            parity_bit <= 0;
        end else begin
            case (state)
                IDLE: begin
                    bit_count <= 0;
                end
                START: begin
                    bit_count <= bit_count + 1;
                end
                DATA: begin
                    data_reg <= {in, data_reg[7:1]}; // Shift in the incoming data bit
                    bit_count <= bit_count + 1;
                end
                PARITY: begin
                    parity_bit <= in;
                end
                STOP: begin
                    if (in == 1 && odd_parity) // Check stop bit and parity
                        done <= 1;
                    else
                        done <= 0;
                end
            endcase
        end
    end

    assign out_byte = data_reg;
endmodule"
N/A,N/A,-1,57,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum reg [2:0] {
        IDLE,
        START,
        DATA,
        PARITY,
        STOP
    } state_t;

    // State registers
    reg [2:0] state, next_state;
    reg [3:0] bit_count; // To count bits received
    reg [7:0] data_reg;  // To store the received byte
    reg parity_bit;      // To store the received parity bit
    wire odd_parity;     // Output from parity module

    // Instantiate the parity module
    parity parity_inst (
        .clk(clk),
        .reset(reset | (state == START)), // Reset on FSM reset or new start bit
        .in(in),
        .odd(odd_parity)
    );

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
        end else begin
            state <= next_state;
            if (state == DATA) begin
                data_reg <= {in, data_reg[7:1]}; // Shift in data bits
                bit_count <= bit_count + 1;
            end else if (state == PARITY) begin
                parity_bit <= in; // Capture the parity bit
            end else if (state == STOP) begin
                bit_count <= 0; // Reset bit counter
            end
        end
    end

    // Next state logic
    always @(*) begin
        next_state = state;
        case (state)
            IDLE: begin
                if (in == 0) // Start bit detected
                    next_state = START;
            end
            START: begin
                if (in == 0) // Confirm start bit is still low
                    next_state = DATA;
            end
            DATA: begin
                if (bit_count == 8)
                    next_state = PARITY;
            end
            PARITY: begin
                next_state = STOP;
            end
            STOP: begin
                if (in == 1) // Stop bit should be high
                    next_state = IDLE;
                else
                    next_state = IDLE; // Wait for stop bit
            end
        endcase
    end

    // Output logic
    assign out_byte = data_reg;
    assign done = (state == STOP) && (in == 1) && (odd_parity == 1'b1) && (parity_bit == odd_parity);

endmodule"
N/A,N/A,-1,58,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        RECEIVE = 3'b010,
        PARITY_CHECK = 3'b011,
        STOP = 3'b100
    } state_t;

    state_t state, next_state;
    reg [7:0] data_shift;
    reg [3:0] bit_count;
    wire parity_odd;
    reg parity_reset;
    reg [7:0] out_byte_reg;
    reg done_reg;

    // Instantiate the parity module
    parity parity_inst (
        .clk(clk),
        .reset(parity_reset),
        .in(in),
        .odd(parity_odd)
    );

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
            parity_reset <= 1;
            done_reg <= 0;
        end else begin
            state <= next_state;
            if (state == RECEIVE) begin
                data_shift <= {in, data_shift[7:1]};
                bit_count <= bit_count + 1;
            end
        end
    end

    // Next state logic
    always @(*) begin
        next_state = state;
        parity_reset = 0;
        done_reg = 0;

        case (state)
            IDLE: begin
                if (~in) begin
                    next_state = START;
                    parity_reset = 1; // Reset parity on start bit
                end
            end

            START: begin
                if (in) begin
                    next_state = RECEIVE;
                    bit_count = 0;
                end
            end

            RECEIVE: begin
                if (bit_count == 8) begin
                    next_state = PARITY_CHECK;
                end
            end

            PARITY_CHECK: begin
                if (parity_odd == in) begin
                    next_state = STOP;
                end else begin
                    next_state = IDLE; // Parity error, return to IDLE
                end
            end

            STOP: begin
                if (in) begin
                    next_state = IDLE;
                    out_byte_reg = data_shift;
                    done_reg = 1;
                end
            end
        endcase
    end

    assign out_byte = out_byte_reg;
    assign done = done_reg;

endmodule"
N/A,N/A,-1,59,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum reg [2:0] {
        IDLE,
        START,
        DATA,
        PARITY,
        STOP
    } state_t;

    // State registers
    reg [2:0] state, next_state;
    reg [3:0] bit_count; // To count bits received
    reg [7:0] data_reg;  // To store the received byte
    reg parity_bit;
    wire odd_parity;

    // Instantiate the parity module
    parity parity_checker (
        .clk(clk),
        .reset(reset | (state == START)), // Reset parity checker at start of new byte
        .in(in),
        .odd(odd_parity)
    );

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
        end else begin
            state <= next_state;

            // Count bits received in DATA and PARITY states
            if (state == DATA || state == PARITY) begin
                bit_count <= bit_count + 1;
            end else begin
                bit_count <= 0;
            end
        end
    end

    // Next state logic
    always @(*) begin
        next_state = state;
        case (state)
            IDLE: begin
                if (~in) // Start bit detected
                    next_state = START;
            end
            START: begin
                next_state = DATA;
            end
            DATA: begin
                if (bit_count == 8)
                    next_state = PARITY;
            end
            PARITY: begin
                if (bit_count == 9)
                    next_state = STOP;
            end
            STOP: begin
                if (in) // Stop bit detected
                    next_state = IDLE;
            end
        endcase
    end

    // Output and data register logic
    always @(posedge clk) begin
        if (state == DATA) begin
            data_reg <= {in, data_reg[7:1]}; // Shift in data bits
        end else if (state == PARITY && bit_count == 8) begin
            parity_bit <= in; // Capture parity bit
        end
    end

    // Done signal logic
    assign done = (state == STOP && in && odd_parity); // Valid stop bit and correct parity

    // Output the received byte
    assign out_byte = data_reg;

endmodule"
N/A,N/A,-1,60,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        RECEIVE = 3'b010,
        PARITY_CHECK = 3'b011,
        STOP = 3'b100
    } state_t;

    state_t state, next_state;
    reg [7:0] data_shift;
    reg [3:0] bit_count;
    wire parity_odd;
    reg parity_reset;
    reg done_reg;

    // Instantiate the parity module
    parity parity_inst (
        .clk(clk),
        .reset(parity_reset),
        .in(in),
        .odd(parity_odd)
    );

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
            done_reg <= 0;
            parity_reset <= 1;
        end else begin
            state <= next_state;
            if (state == RECEIVE) bit_count <= bit_count + 1'b1;
            if (state == STOP) done_reg <= 0;
            if (state == PARITY_CHECK && parity_odd) done_reg <= 1;
        end
    end

    // Next state logic
    always @(*) begin
        next_state = state;
        parity_reset = 0;
        case (state)
            IDLE: begin
                if (!in) next_state = START;  // Detect start bit
            end
            START: begin
                next_state = RECEIVE;
                bit_count = 0;
                parity_reset = 1;
            end
            RECEIVE: begin
                if (bit_count == 8) next_state = PARITY_CHECK;
            end
            PARITY_CHECK: begin
                if (parity_odd) next_state = STOP;
                else next_state = IDLE;  // Parity error, go back to IDLE
            end
            STOP: begin
                if (in) next_state = IDLE;  // Detect stop bit
                else next_state = START;  // If stop bit not detected, look for start bit again
            end
        endcase
    end

    // Output logic
    always @(posedge clk) begin
        if (state == RECEIVE && bit_count < 8) begin
            data_shift <= {in, data_shift[7:1]};
        end
    end

    assign out_byte = data_shift;
    assign done = done_reg;

endmodule"
N/A,N/A,-1,61,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        RECEIVE = 3'b010,
        PARITY_CHECK = 3'b011,
        STOP = 3'b100
    } state_t;

    state_t state, next_state;
    reg [7:0] data_shift;
    reg [3:0] bit_count;
    wire parity_odd;
    reg parity_reset;
    reg done_reg;

    // Instantiate the parity module
    parity parity_inst (
        .clk(clk),
        .reset(parity_reset),
        .in(in),
        .odd(parity_odd)
    );

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
            done_reg <= 0;
            parity_reset <= 1;
        end else begin
            state <= next_state;
            if (state == RECEIVE) bit_count <= bit_count + 1'b1;
            if (state == START) parity_reset <= 0; // Start counting parity
            if (state == STOP) parity_reset <= 1;  // Reset parity counter
        end
    end

    // Next state logic
    always @(*) begin
        next_state = state;
        done_reg = 0;

        case (state)
            IDLE: begin
                if (in == 0) // Detect start bit
                    next_state = START;
            end
            START: begin
                next_state = RECEIVE;
            end
            RECEIVE: begin
                if (bit_count < 8) begin
                    data_shift = {in, data_shift[7:1]};
                end else begin
                    next_state = PARITY_CHECK;
                end
            end
            PARITY_CHECK: begin
                if (parity_odd == 1'b1) begin
                    next_state = STOP;
                end else begin
                    next_state = IDLE; // Parity error, reset to IDLE
                end
            end
            STOP: begin
                if (in == 1) begin // Check stop bit
                    done_reg = 1;
                    next_state = IDLE;
                end else begin
                    next_state = IDLE; // Stop bit error, reset to IDLE
                end
            end
        endcase
    end

    // Output logic
    assign out_byte = data_shift;
    assign done = done_reg;

endmodule"
N/A,N/A,-1,62,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        DATA = 3'b010,
        PARITY = 3'b011,
        STOP = 3'b100,
        ERROR = 3'b101
    } state_t;
    
    state_t state, next_state;
    reg [3:0] bit_count;  // Count the number of bits received
    reg [7:0] data;       // Store the received data byte
    reg parity_bit;       // Store the received parity bit
    wire odd_parity;      // Output from the parity module
    reg parity_reset;     // Control signal to reset the parity module
    
    // Instantiate the parity module
    parity parity_inst (
        .clk(clk),
        .reset(parity_reset),
        .in(in),
        .odd(odd_parity)
    );
    
    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
            data <= 8'b0;
            parity_reset <= 1;
        end else begin
            state <= next_state;
        end
    end
    
    // Next state logic
    always @(*) begin
        next_state = state;
        parity_reset = 0;
        
        case (state)
            IDLE: begin
                if (in == 0)  // Detect start bit
                    next_state = START;
            end
            
            START: begin
                if (bit_count == 4'd8) begin
                    next_state = DATA;
                    bit_count = 0;
                    parity_reset = 1;  // Reset parity counter for new byte
                end
            end
            
            DATA: begin
                if (bit_count < 4'd8) begin
                    data[bit_count] = in;
                    bit_count = bit_count + 1;
                end else begin
                    next_state = PARITY;
                    parity_bit = in;
                    bit_count = 0;
                end
            end
            
            PARITY: begin
                if (parity_bit == odd_parity) begin
                    next_state = STOP;
                end else begin
                    next_state = ERROR;
                end
            end
            
            STOP: begin
                if (in == 1) begin  // Stop bit must be 1
                    next_state = IDLE;
                end else begin
                    next_state = ERROR;
                end
            end
            
            ERROR: begin
                if (in == 1) begin  // Wait for a correct stop bit
                    next_state = IDLE;
                end
            end
        endcase
    end
    
    // Output logic
    assign out_byte = data;
    assign done = (state == STOP) && (in == 1);
    
endmodule"
N/A,N/A,-1,63,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum reg [2:0] {
        IDLE,
        START,
        DATA,
        PARITY,
        STOP
    } state_t;

    // State registers
    reg [2:0] state, next_state;
    reg [3:0] bit_count; // To count the number of bits received
    reg [7:0] data; // To store the received data
    reg parity_error; // To indicate a parity error
    reg stop_error; // To indicate a stop bit error

    // Parity checker instance
    wire odd_parity;
    parity parity_checker (
        .clk(clk),
        .reset(reset | (state == IDLE)),
        .in(in),
        .odd(odd_parity)
    );

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
            data <= 0;
            parity_error <= 0;
            stop_error <= 0;
        end else begin
            state <= next_state;
            if (state == DATA) begin
                data <= {in, data[7:1]};
                bit_count <= bit_count + 1;
            end else if (state == PARITY) begin
                parity_error <= ~odd_parity;
            end else if (state == STOP) begin
                stop_error <= ~in; // Expecting stop bit to be 1
            end
        end
    end

    // Next state logic
    always @(*) begin
        next_state = state;
        case (state)
            IDLE: begin
                if (in == 0) // Detect start bit
                    next_state = START;
            end
            START: begin
                next_state = DATA;
                bit_count = 0;
            end
            DATA: begin
                if (bit_count == 8)
                    next_state = PARITY;
            end
            PARITY: begin
                next_state = STOP;
            end
            STOP: begin
                if (in == 1) // Valid stop bit
                    next_state = IDLE;
                else
                    next_state = IDLE; // Wait for next valid start bit
            end
        endcase
    end

    // Output logic
    assign out_byte = data;
    assign done = (state == STOP) && (in == 1) && ~parity_error && ~stop_error;

endmodule"
N/A,N/A,-1,64,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum reg [2:0] {
        IDLE,
        START,
        DATA,
        PARITY,
        STOP
    } state_t;

    // State registers
    reg [2:0] state, next_state;
    reg [3:0] bit_count; // To count the number of bits received
    reg [7:0] data; // To store the received byte
    wire odd_parity;
    reg parity_reset;
    
    // Instantiate the parity module
    parity parity_checker (
        .clk(clk),
        .reset(parity_reset),
        .in(in),
        .odd(odd_parity)
    );

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
            data <= 0;
            parity_reset <= 1;
        end else begin
            state <= next_state;
            if (state == DATA) begin
                data <= {in, data[7:1]}; // Shift in the received bit
                bit_count <= bit_count + 1;
            end
            if (state == PARITY) begin
                parity_reset <= 1; // Reset parity checker for next byte
            end else begin
                parity_reset <= 0;
            end
        end
    end

    // Next state logic
    always @(*) begin
        next_state = state;
        case (state)
            IDLE: begin
                if (in == 0) // Start bit detected
                    next_state = START;
            end
            START: begin
                if (in == 0) // Still in start bit
                    next_state = DATA;
            end
            DATA: begin
                if (bit_count == 8)
                    next_state = PARITY;
            end
            PARITY: begin
                if (odd_parity == 1)
                    next_state = STOP;
                else
                    next_state = IDLE; // Parity error, go to IDLE
            end
            STOP: begin
                if (in == 1) // Stop bit must be high
                    next_state = IDLE;
                else
                    next_state = IDLE; // Error, go to IDLE
            end
        endcase
    end

    // Output logic
    assign out_byte = data;
    assign done = (state == STOP) && (in == 1) && (odd_parity == 1);

endmodule"
N/A,N/A,-1,65,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        RECEIVE = 3'b010,
        PARITY_CHECK = 3'b011,
        STOP = 3'b100
    } state_t;

    state_t state, next_state;
    reg [7:0] data_shift;
    reg [3:0] bit_count;
    wire parity_odd;
    reg parity_reset;
    reg [7:0] out_byte_reg;
    reg done_reg;

    // Instantiate the parity module
    parity parity_inst (
        .clk(clk),
        .reset(parity_reset),
        .in(in),
        .odd(parity_odd)
    );

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
            data_shift <= 8'b0;
            parity_reset <= 1;
            done_reg <= 0;
        end else begin
            state <= next_state;
            if (state == RECEIVE) begin
                data_shift <= {in, data_shift[7:1]};
                bit_count <= bit_count + 1;
            end
            if (state == STOP) begin
                out_byte_reg <= data_shift;
                done_reg <= 1;
            end else begin
                done_reg <= 0;
            end
        end
    end

    // Next state logic
    always @(*) begin
        next_state = state; // Default to hold state
        parity_reset = 0; // Default parity_reset
        case (state)
            IDLE: begin
                if (!in) next_state = START; // Detect start bit
            end
            START: begin
                if (in) next_state = RECEIVE; // Start receiving bits
                parity_reset = 1; // Reset parity at start
            end
            RECEIVE: begin
                if (bit_count == 8) next_state = PARITY_CHECK; // 8 data bits received
            end
            PARITY_CHECK: begin
                if (parity_odd == in) next_state = STOP; // Parity check passes
                else next_state = IDLE; // Parity check fails, wait for start bit again
            end
            STOP: begin
                if (in) next_state = IDLE; // Correct stop bit detected
                else next_state = START; // Incorrect stop bit, wait for next start bit
            end
        endcase
    end

    assign out_byte = out_byte_reg;
    assign done = done_reg;

endmodule"
N/A,N/A,-1,66,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        DATA = 3'b010,
        PARITY = 3'b011,
        STOP = 3'b100,
        ERROR = 3'b101
    } state_t;
    
    state_t state, next_state;
    reg [3:0] bit_count;  // Count the number of bits received
    reg [7:0] data;       // Store the received data byte
    reg parity_bit;       // Store the received parity bit
    wire odd_parity;      // Output from the parity module
    reg parity_reset;     // Control signal to reset the parity module
    reg stop_bit;         // Store the received stop bit

    // Instantiate the parity module
    parity parity_inst (
        .clk(clk),
        .reset(parity_reset),
        .in(in),
        .odd(odd_parity)
    );

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
            parity_reset <= 1;
        end else begin
            state <= next_state;
            if (state == DATA) begin
                data[bit_count] <= in;
                bit_count <= bit_count + 1;
            end
            if (state == PARITY) begin
                parity_bit <= in;
            end
            if (state == STOP) begin
                stop_bit <= in;
            end
            if (state == IDLE || state == ERROR) begin
                bit_count <= 0;
                parity_reset <= 1; // Reset parity check at the start or on error
            end else begin
                parity_reset <= 0;
            end
        end
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 0) // Start bit detected
                    next_state = START;
                else
                    next_state = IDLE;
            end
            START: begin
                if (bit_count == 0)
                    next_state = DATA;
                else
                    next_state = START;
            end
            DATA: begin
                if (bit_count == 8)
                    next_state = PARITY;
                else
                    next_state = DATA;
            end
            PARITY: begin
                next_state = STOP;
            end
            STOP: begin
                if (in == 1) begin // Stop bit should be 1
                    if (odd_parity == 1 && parity_bit == 1) // Odd parity check
                        next_state = IDLE;
                    else
                        next_state = ERROR; // Parity error
                end else begin
                    next_state = ERROR; // Stop bit error
                end
            end
            ERROR: begin
                if (in == 1) // Wait for a stop bit to reset
                    next_state = IDLE;
                else
                    next_state = ERROR;
            end
            default: next_state = IDLE;
        endcase
    end

    // Output logic
    assign out_byte = data;
    assign done = (state == STOP) && (in == 1) && (odd_parity == 1) && (parity_bit == 1);

endmodule"
N/A,N/A,-1,67,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        DATA = 3'b010,
        PARITY = 3'b011,
        STOP = 3'b100
    } state_t;

    state_t state, next_state;
    reg [3:0] bit_count;  // Count the number of bits received
    reg [7:0] data_reg;   // Store the received data byte
    reg parity_bit;       // Store the received parity bit
    wire odd;             // Output of the parity checker

    // Instantiate the parity module
    parity parity_checker (
        .clk(clk),
        .reset(reset | (state == IDLE)),
        .in(in),
        .odd(odd)
    );

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
            data_reg <= 8'b0;
            parity_bit <= 0;
        end else begin
            state <= next_state;
            if (state == DATA && bit_count < 8) begin
                data_reg <= {in, data_reg[7:1]};
                bit_count <= bit_count + 1;
            end else if (state == PARITY) begin
                parity_bit <= in;
            end else if (state == STOP) begin
                bit_count <= 0;
            end
        end
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (!in) next_state = START;  // Detect start bit (0)
                else next_state = IDLE;
            end
            START: begin
                next_state = DATA;
            end
            DATA: begin
                if (bit_count == 8) next_state = PARITY;
                else next_state = DATA;
            end
            PARITY: begin
                next_state = STOP;
            end
            STOP: begin
                if (in) next_state = IDLE;  // Detect stop bit (1)
                else next_state = STOP;
            end
            default: next_state = IDLE;
        endcase
    end

    // Output logic
    assign out_byte = data_reg;
    assign done = (state == STOP) && in && (odd == 1'b1) && (parity_bit == odd);

endmodule"
N/A,N/A,-1,68,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        RECEIVE = 3'b010,
        PARITY_CHECK = 3'b011,
        STOP = 3'b100
    } state_t;

    state_t state, next_state;
    reg [3:0] bit_count;
    reg [7:0] data;
    reg parity_bit;
    wire parity_odd;

    // Instantiate the parity module
    parity parity_checker (
        .clk(clk),
        .reset(reset | (state == IDLE)),
        .in(in),
        .odd(parity_odd)
    );

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
        end else begin
            state <= next_state;
        end
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 0)  // Start bit detected
                    next_state = START;
                else
                    next_state = IDLE;
            end
            START: begin
                next_state = RECEIVE;
            end
            RECEIVE: begin
                if (bit_count == 8)
                    next_state = PARITY_CHECK;
                else
                    next_state = RECEIVE;
            end
            PARITY_CHECK: begin
                next_state = STOP;
            end
            STOP: begin
                if (in == 1)  // Stop bit detected
                    next_state = IDLE;
                else
                    next_state = STOP;  // Wait for stop bit
            end
            default: next_state = IDLE;
        endcase
    end

    // Output logic and bit counting
    always @(posedge clk) begin
        if (reset) begin
            bit_count <= 0;
            data <= 8'b0;
            parity_bit <= 0;
        end else begin
            case (state)
                IDLE: begin
                    bit_count <= 0;
                    data <= 8'b0;
                    parity_bit <= 0;
                end
                START: begin
                    bit_count <= 0;
                end
                RECEIVE: begin
                    data[bit_count] <= in;
                    bit_count <= bit_count + 1;
                end
                PARITY_CHECK: begin
                    parity_bit <= in;
                end
                STOP: begin
                    // Nothing to do
                end
            endcase
        end
    end

    // Done signal logic
    assign done = (state == STOP) && (in == 1) && (parity_bit == parity_odd);

    // Output byte logic
    assign out_byte = data;

endmodule"
N/A,N/A,-1,69,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        DATA = 3'b010,
        PARITY = 3'b011,
        STOP = 3'b100,
        ERROR = 3'b101
    } state_t;
    
    state_t state, next_state;
    reg [3:0] bit_count;  // Count the number of bits received
    reg [7:0] data;       // Store the received data byte
    reg parity_bit;       // Store the received parity bit
    wire odd_parity;      // Output from the parity module
    reg parity_reset;     // Control signal to reset the parity module
    
    // Instantiate the parity module
    parity parity_inst (
        .clk(clk),
        .reset(parity_reset),
        .in(in),
        .odd(odd_parity)
    );
    
    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
            parity_reset <= 1;
        end else begin
            state <= next_state;
            if (state == DATA) begin
                data <= {in, data[7:1]};  // Shift in data bits
                bit_count <= bit_count + 1;
            end
            if (state == PARITY) begin
                parity_bit <= in;  // Capture the parity bit
            end
            if (state == IDLE || state == STOP) begin
                parity_reset <= 1;  // Reset parity calculation
            end else begin
                parity_reset <= 0;
            end
        end
    end
    
    // Next state logic
    always @(*) begin
        next_state = state;
        case (state)
            IDLE: begin
                if (in == 0)  // Start bit detected
                    next_state = START;
            end
            START: begin
                next_state = DATA;  // Move to data reception
            end
            DATA: begin
                if (bit_count == 8)
                    next_state = PARITY;  // Move to parity bit
            end
            PARITY: begin
                next_state = STOP;  // Move to stop bit
            end
            STOP: begin
                if (in == 1) begin  // Stop bit detected
                    if (odd_parity && parity_bit == 1)  // Check odd parity
                        next_state = IDLE;  // Correct reception
                    else
                        next_state = ERROR;  // Parity error
                end else begin
                    next_state = ERROR;  // Missing stop bit
                end
            end
            ERROR: begin
                if (in == 1)  // Wait for the stop bit
                    next_state = IDLE;
            end
        endcase
    end
    
    // Output logic
    assign out_byte = data;
    assign done = (state == STOP && in == 1 && odd_parity && parity_bit == 1);

endmodule"
N/A,N/A,-1,70,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum reg [2:0] {
        IDLE,
        START,
        DATA,
        PARITY,
        STOP
    } state_t;

    reg [2:0] state, next_state;
    reg [3:0] bit_count; // Counts bits from 0 to 9 (8 data + 1 parity)
    reg [7:0] data_reg;
    reg parity_bit;
    wire odd_parity;

    // Instantiate the parity module
    parity u_parity (
        .clk(clk),
        .reset(reset | (state == IDLE) | (state == START)),
        .in(in),
        .odd(odd_parity)
    );

    // State transition logic
    always @(posedge clk) begin
        if (reset)
            state <= IDLE;
        else
            state <= next_state;
    end

    // Next state logic
    always @(*) begin
        next_state = state;
        case (state)
            IDLE: begin
                if (~in) // Start bit detected (0)
                    next_state = START;
            end
            START: begin
                if (bit_count == 4'd8)
                    next_state = DATA;
            end
            DATA: begin
                if (bit_count == 4'd8)
                    next_state = PARITY;
            end
            PARITY: begin
                if (bit_count == 4'd9)
                    next_state = STOP;
            end
            STOP: begin
                if (in) // Stop bit detected (1)
                    next_state = IDLE;
            end
        endcase
    end

    // Output logic and bit counting
    always @(posedge clk) begin
        if (reset) begin
            bit_count <= 0;
            data_reg <= 8'd0;
            parity_bit <= 1'b0;
        end else begin
            case (state)
                IDLE: begin
                    bit_count <= 0;
                end
                START: begin
                    bit_count <= bit_count + 1;
                end
                DATA: begin
                    if (bit_count < 4'd8) begin
                        data_reg[bit_count] <= in;
                        bit_count <= bit_count + 1;
                    end
                end
                PARITY: begin
                    parity_bit <= in;
                    bit_count <= bit_count + 1;
                end
                STOP: begin
                    if (in && odd_parity) begin
                        done <= (parity_bit == odd_parity);
                        out_byte <= data_reg;
                    end else begin
                        done <= 0;
                    end
                end
            endcase
        end
    end

    // Ensure done signal is de-asserted in non-STOP states
    always @(posedge clk) begin
        if (reset | (state != STOP)) begin
            done <= 0;
        end
    end

endmodule"
N/A,N/A,-1,71,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        RECEIVE = 3'b010,
        PARITY_CHECK = 3'b011,
        STOP = 3'b100
    } state_t;

    state_t state, next_state;
    reg [3:0] bit_count;
    reg [7:0] data;
    reg parity_bit;
    wire parity_odd;

    // Instantiate the parity module
    parity parity_checker (
        .clk(clk),
        .reset(reset | (state == IDLE)),
        .in(in),
        .odd(parity_odd)
    );

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
        end else begin
            state <= next_state;
        end
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 0)  // Start bit detected
                    next_state = START;
                else
                    next_state = IDLE;
            end
            START: begin
                next_state = RECEIVE;
            end
            RECEIVE: begin
                if (bit_count == 8)
                    next_state = PARITY_CHECK;
                else
                    next_state = RECEIVE;
            end
            PARITY_CHECK: begin
                next_state = STOP;
            end
            STOP: begin
                if (in == 1)  // Stop bit detected
                    next_state = IDLE;
                else
                    next_state = STOP;  // Wait for stop bit
            end
            default: next_state = IDLE;
        endcase
    end

    // Output logic and data handling
    always @(posedge clk) begin
        if (reset) begin
            bit_count <= 0;
            data <= 8'b0;
            parity_bit <= 0;
        end else begin
            case (state)
                IDLE: begin
                    bit_count <= 0;
                    data <= 8'b0;
                end
                START: begin
                    // Start bit detected, reset bit_count
                    bit_count <= 0;
                end
                RECEIVE: begin
                    data <= {in, data[7:1]};  // Shift in the data bits
                    bit_count <= bit_count + 1;
                end
                PARITY_CHECK: begin
                    parity_bit <= in;  // Capture the parity bit
                end
                STOP: begin
                    // Check parity and stop bit
                    if ((parity_odd == 1) && (parity_bit == 1)) begin
                        done <= 1;
                        out_byte <= data;
                    end else begin
                        done <= 0;
                    end
                end
            endcase
        end
    end

endmodule"
N/A,N/A,-1,72,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        RECEIVE = 3'b010,
        PARITY_CHECK = 3'b011,
        STOP = 3'b100
    } state_t;

    state_t state, next_state;
    reg [7:0] data_shift;
    reg [3:0] bit_count;
    wire parity_odd;
    reg parity_reset;
    reg done_reg;

    // Instantiate the parity module
    parity parity_inst (
        .clk(clk),
        .reset(parity_reset),
        .in(in),
        .odd(parity_odd)
    );

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
            done_reg <= 0;
            parity_reset <= 1;
        end else begin
            state <= next_state;
            if (state == RECEIVE) bit_count <= bit_count + 1'b1;
            if (state == STOP) done_reg <= 0;
            if (state == PARITY_CHECK && parity_odd) done_reg <= 1;
        end
    end

    // Next state logic
    always @(*) begin
        next_state = state;
        parity_reset = 0;
        case (state)
            IDLE: begin
                if (!in) next_state = START;  // Detect start bit
            end
            START: begin
                next_state = RECEIVE;
                bit_count = 0;
                parity_reset = 1;
            end
            RECEIVE: begin
                if (bit_count == 8) next_state = PARITY_CHECK;
            end
            PARITY_CHECK: begin
                if (parity_odd) next_state = STOP;
                else next_state = IDLE;  // Parity error, go back to IDLE
            end
            STOP: begin
                if (in) next_state = IDLE;  // Detect stop bit
                else next_state = START;  // If stop bit not detected, look for start bit again
            end
        endcase
    end

    // Output logic
    always @(posedge clk) begin
        if (state == RECEIVE && bit_count < 8) begin
            data_shift <= {in, data_shift[7:1]};
        end
    end

    assign out_byte = data_shift;
    assign done = done_reg;

endmodule"
N/A,N/A,-1,73,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        DATA = 3'b010,
        PARITY = 3'b011,
        STOP = 3'b100
    } state_t;
    
    state_t state, next_state;
    reg [7:0] data_shift;
    reg [3:0] bit_count;
    wire parity_odd;
    reg parity_reset;
    reg done_reg;

    // Instantiate the parity module
    parity parity_inst (
        .clk(clk),
        .reset(parity_reset),
        .in(in),
        .odd(parity_odd)
    );

    // State transition
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
            data_shift <= 0;
            done_reg <= 0;
            parity_reset <= 1;
        end else begin
            state <= next_state;
            if (state == DATA) begin
                data_shift <= {in, data_shift[7:1]};
                bit_count <= bit_count + 1;
            end
            if (state == PARITY) begin
                parity_reset <= 1;
            end else begin
                parity_reset <= 0;
            end
            if (state == STOP) begin
                done_reg <= (in && parity_odd);
            end else begin
                done_reg <= 0;
            end
        end
    end

    // Next state logic
    always @(*) begin
        next_state = state;
        case (state)
            IDLE: begin
                if (!in) begin // Detect start bit
                    next_state = START;
                end
            end
            START: begin
                next_state = DATA;
            end
            DATA: begin
                if (bit_count == 8) begin
                    next_state = PARITY;
                end
            end
            PARITY: begin
                next_state = STOP;
            end
            STOP: begin
                if (in) begin // Detect stop bit
                    next_state = IDLE;
                end
            end
        endcase
    end

    // Output logic
    assign out_byte = data_shift;
    assign done = done_reg;

endmodule"
N/A,N/A,-1,74,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        DATA = 3'b010,
        PARITY = 3'b011,
        STOP = 3'b100,
        ERROR = 3'b101
    } state_t;
    
    state_t state, next_state;
    reg [3:0] bit_count;  // Count the number of bits received
    reg [7:0] data;       // Store the received data byte
    reg parity_bit;       // Store the received parity bit
    wire odd_parity;      // Output from the parity module
    reg parity_reset;     // Control signal to reset the parity module
    
    // Instantiate the parity module
    parity parity_inst (
        .clk(clk),
        .reset(parity_reset),
        .in(in),
        .odd(odd_parity)
    );
    
    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
            parity_reset <= 1;
        end else begin
            state <= next_state;
            if (state == DATA) begin
                data <= {in, data[7:1]};  // Shift in data bits
                bit_count <= bit_count + 1;
            end else if (state == PARITY) begin
                parity_bit <= in;
            end
            if (state == IDLE || state == STOP) begin
                parity_reset <= 1;  // Reset parity calculation at the start and end
            end else begin
                parity_reset <= 0;
            end
        end
    end
    
    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (!in)  // Start bit detected (start bit is 0)
                    next_state = START;
                else
                    next_state = IDLE;
            end
            START: begin
                next_state = DATA;
                bit_count = 0;
            end
            DATA: begin
                if (bit_count == 8)
                    next_state = PARITY;
                else
                    next_state = DATA;
            end
            PARITY: begin
                next_state = STOP;
            end
            STOP: begin
                if (in)  // Stop bit detected (stop bit is 1)
                    next_state = IDLE;
                else
                    next_state = ERROR;
            end
            ERROR: begin
                if (in)  // Wait for a stop bit to reset
                    next_state = IDLE;
                else
                    next_state = ERROR;
            end
            default: next_state = IDLE;
        endcase
    end
    
    // Output logic
    assign out_byte = data;
    assign done = (state == STOP) && (parity_bit == odd_parity);
    
endmodule"
N/A,N/A,-1,75,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        RECEIVE = 3'b010,
        PARITY_CHECK = 3'b011,
        STOP = 3'b100
    } state_t;

    state_t state, next_state;
    reg [7:0] data_shift;
    reg [3:0] bit_count;
    wire parity_odd;
    reg parity_reset;

    // Instantiate the parity module
    parity parity_inst (
        .clk(clk),
        .reset(parity_reset),
        .in(in),
        .odd(parity_odd)
    );

    // State transition
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
            data_shift <= 0;
        end else begin
            state <= next_state;
            if (state == RECEIVE) begin
                data_shift <= {in, data_shift[7:1]};
                bit_count <= bit_count + 1;
            end
        end
    end

    // Next state logic
    always @(*) begin
        next_state = state; // Default to hold state
        parity_reset = 0;
        done = 0;
        case (state)
            IDLE: begin
                if (~in) // Start bit detected
                    next_state = START;
            end
            START: begin
                next_state = RECEIVE;
                bit_count = 0;
                parity_reset = 1; // Reset parity for new byte
            end
            RECEIVE: begin
                if (bit_count == 8)
                    next_state = PARITY_CHECK;
            end
            PARITY_CHECK: begin
                if (parity_odd == in) // Check if parity is correct
                    next_state = STOP;
                else
                    next_state = IDLE; // Parity error, reset
            end
            STOP: begin
                if (in) begin // Stop bit detected
                    done = 1;
                    next_state = IDLE;
                end else
                    next_state = IDLE; // Error, wait for stop bit
            end
        endcase
    end

    // Output logic
    assign out_byte = data_shift;

endmodule"
N/A,N/A,-1,76,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        RECEIVE = 3'b010,
        PARITY_CHECK = 3'b011,
        STOP = 3'b100
    } state_t;

    state_t state, next_state;
    reg [7:0] data_shift;
    reg [3:0] bit_count;
    wire parity_odd;
    reg parity_reset;
    reg done_reg;

    // Instantiate the parity module
    parity parity_inst (
        .clk(clk),
        .reset(parity_reset),
        .in(in),
        .odd(parity_odd)
    );

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
            done_reg <= 0;
            parity_reset <= 1;
        end else begin
            state <= next_state;
            if (state == RECEIVE) bit_count <= bit_count + 1'b1;
            if (state == START) parity_reset <= 0; // Start counting parity
            if (state == STOP) done_reg <= (in == 1'b1) && (parity_odd == 1'b1);
        end
    end

    // Next state logic
    always @(*) begin
        next_state = state;
        case (state)
            IDLE: begin
                if (in == 1'b0) next_state = START; // Start bit detected
            end
            START: begin
                next_state = RECEIVE;
                bit_count = 0;
            end
            RECEIVE: begin
                if (bit_count == 8) next_state = PARITY_CHECK;
            end
            PARITY_CHECK: begin
                next_state = STOP;
            end
            STOP: begin
                if (in == 1'b1) next_state = IDLE; // Stop bit detected
            end
        endcase
    end

    // Output logic
    always @(posedge clk) begin
        if (state == RECEIVE) begin
            data_shift <= {in, data_shift[7:1]};
        end
    end

    assign out_byte = data_shift;
    assign done = done_reg;

endmodule"
N/A,N/A,-1,77,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        RECEIVE = 3'b010,
        PARITY_CHECK = 3'b011,
        STOP = 3'b100
    } state_t;

    // State registers
    reg [2:0] state, next_state;
    reg [3:0] bit_count; // Count 9 bits (8 data + 1 parity)
    reg [7:0] data_reg;
    reg parity_bit;
    wire odd_parity;

    // Instantiate the parity module
    parity parity_checker (
        .clk(clk),
        .reset(reset | (state == IDLE) | (state == START)),
        .in(in),
        .odd(odd_parity)
    );

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
            data_reg <= 8'b0;
            parity_bit <= 0;
        end else begin
            state <= next_state;
            if (state == RECEIVE) begin
                bit_count <= bit_count + 1;
                if (bit_count < 8)
                    data_reg <= {in, data_reg[7:1]};
                else
                    parity_bit <= in;
            end else if (state == IDLE || state == START) begin
                bit_count <= 0;
            end
        end
    end

    // Next state logic
    always @(*) begin
        next_state = state;
        case (state)
            IDLE: begin
                if (!in) next_state = START; // Detect start bit
            end
            START: begin
                if (in) next_state = RECEIVE; // Move to receiving bits
            end
            RECEIVE: begin
                if (bit_count == 8) next_state = PARITY_CHECK;
            end
            PARITY_CHECK: begin
                if (parity_bit == odd_parity) next_state = STOP;
                else next_state = IDLE; // Parity error, wait for next start bit
            end
            STOP: begin
                if (in) next_state = IDLE; // Valid stop bit, go to IDLE
                else next_state = IDLE; // Invalid stop bit, reset
            end
        endcase
    end

    // Output logic
    assign done = (state == STOP) && in;
    assign out_byte = data_reg;

endmodule"
N/A,N/A,-1,78,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        DATA = 3'b010,
        PARITY = 3'b011,
        STOP = 3'b100,
        ERROR = 3'b101
    } state_t;
    
    reg [2:0] state, next_state;
    reg [3:0] bit_count;
    reg [7:0] data_byte;
    wire odd_parity;
    
    // Parity checker instance
    parity parity_checker (
        .clk(clk),
        .reset(reset | (state == START)),
        .in(in),
        .odd(odd_parity)
    );

    // State transition
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
        end else begin
            state <= next_state;
            if (state == DATA) begin
                data_byte[bit_count] <= in;
                bit_count <= bit_count + 1;
            end
        end
    end

    // Next state logic
    always @(*) begin
        next_state = state; // Default to hold state
        case (state)
            IDLE: begin
                if (!in) next_state = START; // Detect start bit
            end
            START: begin
                if (bit_count == 0) next_state = DATA;
            end
            DATA: begin
                if (bit_count == 8) next_state = PARITY;
            end
            PARITY: begin
                if (odd_parity == in) next_state = STOP;
                else next_state = ERROR;
            end
            STOP: begin
                if (in) next_state = IDLE; // Detect stop bit
                else next_state = ERROR;
            end
            ERROR: begin
                if (in) next_state = IDLE; // Wait for stop bit
            end
        endcase
    end

    // Output logic
    assign done = (state == STOP) && in;
    assign out_byte = data_byte;

endmodule"
N/A,N/A,-1,79,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        RECEIVE = 3'b010,
        PARITY_CHECK = 3'b011,
        STOP = 3'b100,
        DONE = 3'b101
    } state_t;

    reg [2:0] state, next_state;
    reg [3:0] bit_count;
    reg [7:0] shift_reg;
    wire odd_parity;
    reg parity_reset;
    reg stop_bit_error;

    // Instantiate the parity module
    parity parity_inst (
        .clk(clk),
        .reset(parity_reset),
        .in(in),
        .odd(odd_parity)
    );

    // State transitions
    always @(posedge clk) begin
        if (reset)
            state <= IDLE;
        else
            state <= next_state;
    end

    // Next state logic
    always @(*) begin
        next_state = state; // Default to hold state
        parity_reset = 0;
        stop_bit_error = 0;

        case (state)
            IDLE: begin
                if (!in) // Start bit detected (active low)
                    next_state = START;
            end
            START: begin
                next_state = RECEIVE;
                parity_reset = 1; // Reset parity checker at start of new byte
            end
            RECEIVE: begin
                if (bit_count == 8)
                    next_state = PARITY_CHECK;
            end
            PARITY_CHECK: begin
                if (odd_parity == in) // Parity bit should match odd parity
                    next_state = STOP;
                else
                    next_state = IDLE; // Parity error, reset
            end
            STOP: begin
                if (in) // Stop bit should be high
                    next_state = DONE;
                else
                    stop_bit_error = 1;
            end
            DONE: begin
                next_state = IDLE;
            end
        endcase
    end

    // Output and bit counter logic
    always @(posedge clk) begin
        if (reset) begin
            bit_count <= 0;
            shift_reg <= 0;
        end
        else begin
            case (state)
                START: begin
                    bit_count <= 0;
                end
                RECEIVE: begin
                    shift_reg <= {in, shift_reg[7:1]};
                    bit_count <= bit_count + 1;
                end
                DONE: begin
                    out_byte <= shift_reg;
                end
            endcase
        end
    end

    // Done signal logic
    assign done = (state == DONE) && !stop_bit_error;

endmodule"
N/A,N/A,-1,80,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        DATA = 3'b010,
        PARITY = 3'b011,
        STOP = 3'b100,
        ERROR = 3'b101
    } state_t;
    
    state_t state, next_state;
    reg [3:0] bit_count;  // Count the number of bits received
    reg [7:0] data;       // Store the received data byte
    reg parity_bit;       // Store the received parity bit
    wire odd_parity;      // Output from the parity module
    reg parity_reset;     // Control signal to reset the parity module
    
    // Instantiate the parity module
    parity parity_inst (
        .clk(clk),
        .reset(parity_reset),
        .in(in),
        .odd(odd_parity)
    );
    
    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
            parity_reset <= 1;
        end else begin
            state <= next_state;
            if (state == DATA) begin
                data <= {in, data[7:1]};  // Shift in data bits
                bit_count <= bit_count + 1;
            end
            if (state == PARITY) begin
                parity_bit <= in;  // Capture the parity bit
            end
            if (state == IDLE || state == STOP) begin
                bit_count <= 0;
                parity_reset <= 1;  // Reset the parity calculation
            end else begin
                parity_reset <= 0;  // Continue parity calculation
            end
        end
    end
    
    // Next state logic
    always @(*) begin
        next_state = state;
        case (state)
            IDLE: begin
                if (!in) next_state = START;  // Start bit detected
            end
            START: begin
                next_state = DATA;
            end
            DATA: begin
                if (bit_count == 8) next_state = PARITY;
            end
            PARITY: begin
                next_state = STOP;
            end
            STOP: begin
                if (in) begin  // Stop bit detected
                    if (parity_bit == odd_parity) begin
                        next_state = IDLE;
                    end else begin
                        next_state = ERROR;
                    end
                end
            end
            ERROR: begin
                if (in) next_state = IDLE;  // Wait for stop bit to reset
            end
        endcase
    end
    
    // Output logic
    assign out_byte = data;
    assign done = (state == STOP) && (in) && (parity_bit == odd_parity);
    
endmodule"
N/A,N/A,-1,81,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        RECEIVE = 3'b010,
        PARITY_CHECK = 3'b011,
        STOP = 3'b100
    } state_t;

    state_t state, next_state;
    reg [3:0] bit_count;
    reg [7:0] data;
    reg parity_bit;
    wire parity_odd;

    // Instantiate the parity module
    parity parity_checker (
        .clk(clk),
        .reset(reset | (state == IDLE)),
        .in(in),
        .odd(parity_odd)
    );

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
        end else begin
            state <= next_state;
        end
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 0)  // Start bit detected
                    next_state = START;
                else
                    next_state = IDLE;
            end
            START: begin
                next_state = RECEIVE;
            end
            RECEIVE: begin
                if (bit_count == 8)
                    next_state = PARITY_CHECK;
                else
                    next_state = RECEIVE;
            end
            PARITY_CHECK: begin
                next_state = STOP;
            end
            STOP: begin
                if (in == 1)  // Stop bit detected
                    next_state = IDLE;
                else
                    next_state = STOP;  // Wait for stop bit
            end
            default: next_state = IDLE;
        endcase
    end

    // Output logic and data handling
    always @(posedge clk) begin
        if (reset) begin
            bit_count <= 0;
            data <= 8'b0;
            parity_bit <= 0;
        end else begin
            case (state)
                IDLE: begin
                    bit_count <= 0;
                    data <= 8'b0;
                    parity_bit <= 0;
                end
                START: begin
                    bit_count <= 0;
                end
                RECEIVE: begin
                    data[bit_count] <= in;
                    bit_count <= bit_count + 1;
                end
                PARITY_CHECK: begin
                    parity_bit <= in;
                end
                STOP: begin
                    // Nothing to do
                end
            endcase
        end
    end

    // Done signal logic
    assign done = (state == STOP) && (in == 1) && (parity_bit == parity_odd);

    // Output byte logic
    assign out_byte = data;

endmodule"
N/A,N/A,-1,82,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum reg [2:0] {
        IDLE,
        START,
        DATA,
        PARITY,
        STOP
    } state_t;

    // State registers
    reg [2:0] state, next_state;
    reg [3:0] bit_count; // To count bits received
    reg [7:0] data_reg;  // To store the received byte
    reg parity_bit;      // To store the received parity bit
    wire odd_parity;     // Output from parity module

    // Instantiate the parity module
    parity parity_inst (
        .clk(clk),
        .reset(reset | (state == START)), // Reset on FSM reset or new start bit
        .in(in),
        .odd(odd_parity)
    );

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
            data_reg <= 8'b0;
            parity_bit <= 0;
        end else begin
            state <= next_state;
            if (state == DATA) begin
                data_reg[bit_count] <= in;
                bit_count <= bit_count + 1;
            end else if (state == PARITY) begin
                parity_bit <= in;
            end else if (state == STOP) begin
                bit_count <= 0;
            end
        end
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (~in) // Detect start bit
                    next_state = START;
                else
                    next_state = IDLE;
            end
            START: begin
                next_state = DATA;
            end
            DATA: begin
                if (bit_count == 8)
                    next_state = PARITY;
                else
                    next_state = DATA;
            end
            PARITY: begin
                next_state = STOP;
            end
            STOP: begin
                if (in) // Detect stop bit
                    next_state = IDLE;
                else
                    next_state = STOP;
            end
            default: next_state = IDLE;
        endcase
    end

    // Output logic
    assign out_byte = data_reg;
    assign done = (state == STOP) && in && (odd_parity != parity_bit);

endmodule"
N/A,N/A,-1,83,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        DATA = 3'b010,
        PARITY = 3'b011,
        STOP = 3'b100,
        ERROR = 3'b101
    } state_t;
    
    state_t state, next_state;
    reg [3:0] bit_count;  // Count the number of bits received
    reg [7:0] data;       // Store the received data byte
    reg parity_bit;       // Store the received parity bit
    wire odd_parity;      // Output from the parity module
    reg parity_reset;     // Control signal to reset the parity module
    reg stop_error;       // Flag for stop bit error

    // Instantiate the parity module
    parity parity_inst (
        .clk(clk),
        .reset(parity_reset),
        .in(in),
        .odd(odd_parity)
    );

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
            parity_reset <= 1;
            stop_error <= 0;
        end else begin
            state <= next_state;
        end
    end

    // Next state logic and outputs
    always @(*) begin
        // Default values
        next_state = state;
        parity_reset = 0;
        done = 0;

        case (state)
            IDLE: begin
                if (in == 0) begin // Start bit detected
                    next_state = START;
                    parity_reset = 1;
                end
            end

            START: begin
                if (bit_count == 0) begin
                    next_state = DATA;
                end
            end

            DATA: begin
                if (bit_count < 8) begin
                    data[bit_count] = in;
                    bit_count = bit_count + 1;
                end else begin
                    next_state = PARITY;
                    bit_count = 0;
                end
            end

            PARITY: begin
                parity_bit = in;
                if (parity_bit == odd_parity) begin
                    next_state = STOP;
                end else begin
                    next_state = ERROR;
                end
            end

            STOP: begin
                if (in == 1) begin // Stop bit detected
                    done = 1;
                    out_byte = data;
                    next_state = IDLE;
                end else begin
                    stop_error = 1;
                    next_state = ERROR;
                end
            end

            ERROR: begin
                if (in == 1) begin // Wait for stop bit
                    next_state = IDLE;
                end
            end
        endcase
    end

    // Update the bit count
    always @(posedge clk) begin
        if (reset || state == IDLE || state == STOP || state == ERROR) begin
            bit_count <= 0;
        end else if (state == DATA || state == START) begin
            bit_count <= bit_count + 1;
        end
    end

endmodule"
N/A,N/A,-1,84,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum reg [2:0] {
        IDLE,
        START,
        DATA,
        PARITY,
        STOP
    } state_t;

    // State registers
    reg [2:0] state, next_state;
    reg [3:0] bit_count; // To count the number of bits received
    reg [7:0] data;      // To store the received data byte
    wire odd_parity;     // Parity check output

    // Instantiate the parity module
    parity parity_checker (
        .clk(clk),
        .reset(reset | (state == IDLE) | (state == START)),
        .in(in),
        .odd(odd_parity)
    );

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
        end else begin
            state <= next_state;
            if (state == DATA || state == PARITY) begin
                bit_count <= bit_count + 1;
            end else begin
                bit_count <= 0;
            end
        end
    end

    // Next state logic
    always @(*) begin
        next_state = state;
        case (state)
            IDLE: begin
                if (~in) // Detect start bit (0)
                    next_state = START;
            end
            START: begin
                if (bit_count == 0)
                    next_state = DATA;
            end
            DATA: begin
                if (bit_count == 8) // After 8 data bits
                    next_state = PARITY;
            end
            PARITY: begin
                if (bit_count == 9) // After parity bit
                    next_state = STOP;
            end
            STOP: begin
                if (in) // Stop bit (1) expected
                    next_state = IDLE;
            end
        endcase
    end

    // Output logic
    assign done = (state == STOP) && in && odd_parity;
    assign out_byte = data;

    // Data capturing logic
    always @(posedge clk) begin
        if (state == DATA && bit_count < 8) begin
            data <= {in, data[7:1]}; // Shift in the bits
        end
    end

endmodule"
N/A,N/A,-1,85,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum reg [2:0] {
        IDLE,
        START,
        DATA,
        PARITY,
        STOP
    } state_t;

    // State registers
    reg [2:0] state, next_state;
    reg [3:0] bit_count; // To count the number of bits received
    reg [7:0] data; // To store the received byte
    reg parity_error; // To indicate a parity error
    reg stop_error; // To indicate a stop bit error

    // Parity checker instance
    wire odd_parity;
    parity parity_checker (
        .clk(clk),
        .reset(reset | (state == IDLE)),
        .in(in),
        .odd(odd_parity)
    );

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
            data <= 0;
            parity_error <= 0;
            stop_error <= 0;
        end else begin
            state <= next_state;
            if (state == DATA) begin
                data <= {in, data[7:1]};
                bit_count <= bit_count + 1;
            end else if (state == PARITY) begin
                parity_error <= ~odd_parity;
            end else if (state == STOP) begin
                stop_error <= ~in; // Expecting stop bit to be 1
            end
        end
    end

    // Next state logic
    always @(*) begin
        next_state = state;
        case (state)
            IDLE: begin
                if (in == 0) // Detect start bit
                    next_state = START;
            end
            START: begin
                next_state = DATA;
                bit_count = 0;
            end
            DATA: begin
                if (bit_count == 8)
                    next_state = PARITY;
            end
            PARITY: begin
                next_state = STOP;
            end
            STOP: begin
                if (in == 1) // Valid stop bit
                    next_state = IDLE;
                else
                    next_state = IDLE; // Wait for next valid start bit
            end
        endcase
    end

    // Output logic
    assign out_byte = data;
    assign done = (state == STOP) && ~parity_error && ~stop_error;

endmodule"
N/A,N/A,-1,86,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        RECEIVE = 3'b010,
        PARITY_CHECK = 3'b011,
        STOP = 3'b100,
        DONE = 3'b101
    } state_t;

    reg [2:0] state, next_state;
    reg [3:0] bit_count;
    reg [7:0] shift_reg;
    wire odd_parity;
    reg parity_reset;
    reg stop_bit_error;

    // Instantiate the parity module
    parity parity_inst (
        .clk(clk),
        .reset(parity_reset),
        .in(in),
        .odd(odd_parity)
    );

    // State transitions
    always @(posedge clk) begin
        if (reset)
            state <= IDLE;
        else
            state <= next_state;
    end

    // Next state logic
    always @(*) begin
        next_state = state;
        parity_reset = 0;
        stop_bit_error = 0;

        case (state)
            IDLE: begin
                if (!in) // Start bit detected
                    next_state = START;
            end
            START: begin
                if (in) // False start bit
                    next_state = IDLE;
                else
                    next_state = RECEIVE;
            end
            RECEIVE: begin
                if (bit_count == 8)
                    next_state = PARITY_CHECK;
            end
            PARITY_CHECK: begin
                if (odd_parity == in)
                    next_state = STOP;
                else
                    next_state = IDLE; // Parity error
            end
            STOP: begin
                if (in) // Stop bit correct
                    next_state = DONE;
                else
                    stop_bit_error = 1;
            end
            DONE: begin
                next_state = IDLE;
            end
        endcase
    end

    // Output logic and bit counting
    always @(posedge clk) begin
        if (reset) begin
            bit_count <= 0;
            shift_reg <= 0;
            parity_reset <= 1;
        end
        else begin
            case (state)
                START: begin
                    bit_count <= 0;
                    parity_reset <= 1;
                end
                RECEIVE: begin
                    bit_count <= bit_count + 1;
                    shift_reg <= {in, shift_reg[7:1]};
                end
                PARITY_CHECK: begin
                    parity_reset <= 1;
                end
                DONE: begin
                    if (!stop_bit_error)
                        out_byte <= shift_reg;
                end
            endcase
        end
    end

    // Done signal logic
    assign done = (state == DONE) && !stop_bit_error;

endmodule"
N/A,N/A,-1,87,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        DATA = 3'b010,
        PARITY = 3'b011,
        STOP = 3'b100,
        ERROR = 3'b101
    } state_t;
    
    state_t state, next_state;
    reg [3:0] bit_count;  // Count the number of bits received
    reg [7:0] data;       // Store the received data byte
    reg parity_bit;       // Store the received parity bit
    wire parity_odd;      // Output from the parity module

    // Instantiate the parity module
    parity parity_inst (
        .clk(clk),
        .reset(reset | (state == IDLE) | (state == START)),
        .in(in),
        .odd(parity_odd)
    );

    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
        end else begin
            state <= next_state;
            if (state == DATA) begin
                data <= {in, data[7:1]};
                bit_count <= bit_count + 1;
            end else if (state == PARITY) begin
                parity_bit <= in;
            end else if (state == STOP) begin
                bit_count <= 0;
            end
        end
    end

    always @(*) begin
        next_state = state;
        case (state)
            IDLE: begin
                if (in == 0) // Detect start bit
                    next_state = START;
            end
            START: begin
                next_state = DATA;
            end
            DATA: begin
                if (bit_count == 8)
                    next_state = PARITY;
            end
            PARITY: begin
                next_state = STOP;
            end
            STOP: begin
                if (in == 1) begin // Stop bit must be 1
                    if (parity_odd == 1) // Check for odd parity
                        next_state = IDLE;
                    else
                        next_state = ERROR;
                end
            end
            ERROR: begin
                if (in == 1) // Wait for stop bit to return to IDLE
                    next_state = IDLE;
            end
        endcase
    end

    assign done = (state == STOP) && (in == 1) && (parity_odd == 1);
    assign out_byte = data;

endmodule"
N/A,N/A,-1,88,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum reg [2:0] {
        IDLE,
        START,
        DATA,
        PARITY,
        STOP
    } state_t;

    // State registers
    reg [2:0] state, next_state;
    reg [3:0] bit_count; // To count bits received
    reg [7:0] data_reg;  // To store the received byte
    reg parity_reset;
    wire odd_parity;

    // Instantiate the parity module
    parity parity_inst (
        .clk(clk),
        .reset(parity_reset),
        .in(in),
        .odd(odd_parity)
    );

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
            data_reg <= 8'b0;
        end else begin
            state <= next_state;
            if (state == DATA) begin
                data_reg <= {in, data_reg[7:1]}; // Shift in the received bits
                bit_count <= bit_count + 1;
            end else if (state == START) begin
                bit_count <= 0; // Reset bit counter at the start of a new byte
            end
        end
    end

    // Next state logic
    always @(*) begin
        next_state = state;
        parity_reset = 0;
        case (state)
            IDLE: begin
                if (in == 0) // Detect start bit (0)
                    next_state = START;
            end
            START: begin
                if (in == 0) // Ensure start bit is still low
                    next_state = DATA;
                else
                    next_state = IDLE; // False start, go back to IDLE
            end
            DATA: begin
                if (bit_count == 8)
                    next_state = PARITY;
            end
            PARITY: begin
                if (odd_parity == 1'b1)
                    next_state = STOP;
                else
                    next_state = IDLE; // Parity error, go back to IDLE
            end
            STOP: begin
                if (in == 1) // Check for stop bit (1)
                    next_state = IDLE;
                else
                    next_state = IDLE; // Stop bit error, go back to IDLE
            end
        endcase
    end

    // Output logic
    assign out_byte = data_reg;
    assign done = (state == STOP) && (in == 1);

endmodule"
N/A,N/A,-1,89,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        RECEIVE = 3'b010,
        PARITY_CHECK = 3'b011,
        STOP = 3'b100,
        DONE = 3'b101
    } state_t;

    reg [2:0] state, next_state;
    reg [3:0] bit_count;
    reg [7:0] data_byte;
    reg parity_bit;
    wire odd_parity;
    reg parity_reset;

    // Instantiate the parity module
    parity parity_checker (
        .clk(clk),
        .reset(parity_reset),
        .in(in),
        .odd(odd_parity)
    );

    // State transition logic
    always @(posedge clk) begin
        if (reset)
            state <= IDLE;
        else
            state <= next_state;
    end

    // Next state logic and datapath operations
    always @(*) begin
        next_state = state;
        parity_reset = 0;
        done = 0;

        case (state)
            IDLE: begin
                if (in == 0) // Start bit detected
                    next_state = START;
            end

            START: begin
                if (in == 0) begin // Confirm start bit
                    bit_count = 0;
                    parity_reset = 1; // Reset parity checker
                    next_state = RECEIVE;
                end else begin
                    next_state = IDLE; // False start bit
                end
            end

            RECEIVE: begin
                if (bit_count < 8) begin
                    data_byte[bit_count] = in;
                    bit_count = bit_count + 1;
                end else begin
                    parity_bit = in;
                    next_state = PARITY_CHECK;
                end
            end

            PARITY_CHECK: begin
                if (odd_parity == parity_bit) begin
                    next_state = STOP;
                end else begin
                    next_state = IDLE; // Parity error, go back to IDLE
                end
            end

            STOP: begin
                if (in == 1) begin // Stop bit detected
                    out_byte = data_byte;
                    done = 1;
                    next_state = DONE;
                end else begin
                    next_state = IDLE; // No stop bit, go back to IDLE
                end
            end

            DONE: begin
                next_state = IDLE; // Return to IDLE after done
            end

            default: begin
                next_state = IDLE;
            end
        endcase
    end
endmodule"
N/A,N/A,-1,90,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum reg [2:0] {
        IDLE,
        START,
        DATA,
        PARITY,
        STOP
    } state_t;

    // State registers
    reg [2:0] state, next_state;
    reg [3:0] bit_count; // To count the number of bits received
    reg [7:0] data; // To store the received data byte
    reg parity_bit; // To store the received parity bit
    wire odd_parity; // Output from the parity module

    // Instantiate the parity module
    parity parity_checker (
        .clk(clk),
        .reset(reset | (state == IDLE)), // Reset parity checker at the start of a new byte
        .in(in),
        .odd(odd_parity)
    );

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
        end else begin
            state <= next_state;
        end
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 0) // Start bit detected
                    next_state = START;
                else
                    next_state = IDLE;
            end
            START: begin
                next_state = DATA;
            end
            DATA: begin
                if (bit_count == 8)
                    next_state = PARITY;
                else
                    next_state = DATA;
            end
            PARITY: begin
                next_state = STOP;
            end
            STOP: begin
                if (in == 1) // Stop bit detected
                    next_state = IDLE;
                else
                    next_state = STOP; // Wait for stop bit
            end
            default: next_state = IDLE;
        endcase
    end

    // Output logic and data capture
    always @(posedge clk) begin
        if (reset) begin
            bit_count <= 0;
            data <= 8'b0;
            parity_bit <= 0;
        end else begin
            case (state)
                IDLE: begin
                    bit_count <= 0;
                end
                START: begin
                    bit_count <= 0;
                end
                DATA: begin
                    data[bit_count] <= in;
                    bit_count <= bit_count + 1;
                end
                PARITY: begin
                    parity_bit <= in;
                end
                STOP: begin
                    // No operation
                end
            endcase
        end
    end

    // Done signal logic
    assign done = (state == STOP) && (in == 1) && (parity_bit == odd_parity);

    // Output the received byte
    assign out_byte = data;

endmodule"
N/A,N/A,-1,91,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        DATA = 3'b010,
        PARITY = 3'b011,
        STOP = 3'b100
    } state_t;

    state_t state, next_state;
    reg [3:0] bit_count;  // Count the number of bits received
    reg [7:0] data_byte;  // Store the received data byte
    reg parity_bit;       // Store the received parity bit
    wire odd;             // Output of the parity checker

    // Instantiate the parity module
    parity parity_checker (
        .clk(clk),
        .reset(reset | (state == IDLE)),
        .in(in),
        .odd(odd)
    );

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
            data_byte <= 8'b0;
            parity_bit <= 0;
        end else begin
            state <= next_state;
        end
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 0) // Start bit detected
                    next_state = START;
                else
                    next_state = IDLE;
            end
            START: begin
                if (bit_count == 0)
                    next_state = DATA;
                else
                    next_state = START;
            end
            DATA: begin
                if (bit_count == 8)
                    next_state = PARITY;
                else
                    next_state = DATA;
            end
            PARITY: begin
                next_state = STOP;
            end
            STOP: begin
                if (in == 1) // Stop bit detected
                    next_state = IDLE;
                else
                    next_state = STOP;
            end
            default: next_state = IDLE;
        endcase
    end

    // Output logic and data path
    always @(posedge clk) begin
        if (reset) begin
            bit_count <= 0;
            data_byte <= 8'b0;
            parity_bit <= 0;
        end else begin
            case (state)
                START: begin
                    if (bit_count == 0) bit_count <= bit_count + 1;
                end
                DATA: begin
                    data_byte[bit_count] <= in;
                    bit_count <= bit_count + 1;
                end
                PARITY: begin
                    parity_bit <= in;
                end
                STOP: begin
                    if (in == 1 && odd == 1 && parity_bit == 1) begin
                        out_byte <= data_byte;
                        done <= 1;
                    end else begin
                        done <= 0;
                    end
                end
            endcase
        end
    end
endmodule"
N/A,N/A,-1,92,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        RECEIVE = 3'b010,
        PARITY_CHECK = 3'b011,
        STOP = 3'b100
    } state_t;

    state_t state, next_state;
    reg [3:0] bit_count;
    reg [7:0] data;
    reg parity_bit;
    wire parity_odd;

    // Instantiate the parity module
    parity parity_checker (
        .clk(clk),
        .reset(reset | (state == IDLE)),
        .in(in),
        .odd(parity_odd)
    );

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
        end else begin
            state <= next_state;
        end
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 0)  // Start bit detected
                    next_state = START;
                else
                    next_state = IDLE;
            end
            START: begin
                next_state = RECEIVE;
            end
            RECEIVE: begin
                if (bit_count == 8)
                    next_state = PARITY_CHECK;
                else
                    next_state = RECEIVE;
            end
            PARITY_CHECK: begin
                next_state = STOP;
            end
            STOP: begin
                if (in == 1)  // Stop bit detected
                    next_state = IDLE;
                else
                    next_state = STOP;  // Wait for stop bit
            end
            default: next_state = IDLE;
        endcase
    end

    // Output logic and bit count
    always @(posedge clk) begin
        if (reset) begin
            bit_count <= 0;
            data <= 8'b0;
            parity_bit <= 0;
            done <= 0;
        end else begin
            case (state)
                IDLE: begin
                    bit_count <= 0;
                    done <= 0;
                end
                START: begin
                    bit_count <= 0;
                end
                RECEIVE: begin
                    data[bit_count] <= in;
                    bit_count <= bit_count + 1;
                end
                PARITY_CHECK: begin
                    parity_bit <= in;
                end
                STOP: begin
                    if (in == 1 && parity_odd) begin
                        out_byte <= data;
                        done <= 1;
                    end else begin
                        done <= 0;
                    end
                end
            endcase
        end
    end

endmodule"
N/A,N/A,-1,93,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        RECEIVE = 3'b010,
        PARITY_CHECK = 3'b011,
        STOP = 3'b100,
        DONE = 3'b101
    } state_t;

    reg [2:0] state, next_state;
    reg [3:0] bit_count;
    reg [7:0] shift_reg;
    wire odd_parity;
    reg parity_reset;

    // Instantiate the parity checker
    parity parity_checker (
        .clk(clk),
        .reset(parity_reset),
        .in(in),
        .odd(odd_parity)
    );

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
            shift_reg <= 0;
            parity_reset <= 1;
        end else begin
            state <= next_state;
            if (state == RECEIVE) begin
                shift_reg <= {in, shift_reg[7:1]};
                bit_count <= bit_count + 1;
            end
        end
    end

    // Next state logic
    always @(*) begin
        next_state = state;
        parity_reset = 0;
        case (state)
            IDLE: begin
                if (in == 0) begin  // Detect start bit
                    next_state = START;
                    parity_reset = 1;
                end
            end
            START: begin
                next_state = RECEIVE;
            end
            RECEIVE: begin
                if (bit_count == 8) begin
                    next_state = PARITY_CHECK;
                end
            end
            PARITY_CHECK: begin
                if (odd_parity == in) begin  // Check parity bit
                    next_state = STOP;
                end else begin
                    next_state = IDLE;  // Parity error, wait for next start bit
                end
            end
            STOP: begin
                if (in == 1) begin  // Check stop bit
                    next_state = DONE;
                end else begin
                    next_state = IDLE;  // Stop bit error, wait for next start bit
                end
            end
            DONE: begin
                next_state = IDLE;
            end
        endcase
    end

    // Output logic
    assign done = (state == DONE);
    assign out_byte = shift_reg;

endmodule"
N/A,N/A,-1,94,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        RECEIVE = 3'b010,
        PARITY_CHECK = 3'b011,
        STOP = 3'b100
    } state_t;

    state_t state, next_state;
    reg [7:0] data_shift;
    reg [3:0] bit_count;
    wire parity_odd;
    reg parity_reset;

    // Instantiate the parity module
    parity parity_inst (
        .clk(clk),
        .reset(parity_reset),
        .in(in),
        .odd(parity_odd)
    );

    // State transition
    always @(posedge clk) begin
        if (reset)
            state <= IDLE;
        else
            state <= next_state;
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 0) // Start bit detected
                    next_state = START;
                else
                    next_state = IDLE;
            end
            START: begin
                if (bit_count == 4'd8)
                    next_state = PARITY_CHECK;
                else
                    next_state = RECEIVE;
            end
            RECEIVE: begin
                next_state = START;
            end
            PARITY_CHECK: begin
                if (parity_odd) // Check for odd parity
                    next_state = STOP;
                else
                    next_state = IDLE;
            end
            STOP: begin
                if (in == 1) // Stop bit detected
                    next_state = IDLE;
                else
                    next_state = STOP;
            end
            default: next_state = IDLE;
        endcase
    end

    // Output and counter logic
    always @(posedge clk) begin
        if (reset) begin
            bit_count <= 0;
            data_shift <= 0;
            parity_reset <= 1;
        end else begin
            case (state)
                IDLE: begin
                    bit_count <= 0;
                    parity_reset <= 1;
                end
                START: begin
                    parity_reset <= 0;
                    data_shift <= {in, data_shift[7:1]};
                    bit_count <= bit_count + 1;
                end
                RECEIVE: begin
                    data_shift <= {in, data_shift[7:1]};
                    bit_count <= bit_count + 1;
                end
                PARITY_CHECK: begin
                    // Do nothing, just wait for the stop bit
                end
                STOP: begin
                    if (in == 1) // Stop bit is valid
                        bit_count <= 0;
                end
            endcase
        end
    end

    // Output assignments
    assign out_byte = data_shift;
    assign done = (state == STOP && in == 1);

endmodule"
N/A,N/A,-1,95,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum reg [2:0] {
        IDLE,
        START,
        DATA,
        PARITY,
        STOP
    } state_t;

    // State registers
    reg [2:0] state, next_state;
    reg [3:0] bit_count; // To count the number of bits received
    reg [7:0] data;      // To store the received data byte
    wire odd_parity;     // Parity check output

    // Instantiate the parity module
    parity parity_checker (
        .clk(clk),
        .reset(reset | (state == IDLE) | (state == START)), // Reset at IDLE and START
        .in(in),
        .odd(odd_parity)
    );

    // State transition logic
    always @(*) begin
        next_state = state;
        case (state)
            IDLE: begin
                if (in == 0) // Detect start bit
                    next_state = START;
            end
            START: begin
                if (bit_count == 4'd8) // After 8 bits, move to PARITY
                    next_state = PARITY;
                else
                    next_state = DATA;
            end
            DATA: begin
                if (bit_count == 4'd8) // After 8 data bits
                    next_state = PARITY;
            end
            PARITY: begin
                if (odd_parity == 1) // Check for odd parity
                    next_state = STOP;
                else
                    next_state = IDLE; // Parity error, go back to IDLE
            end
            STOP: begin
                if (in == 1) // Detect stop bit
                    next_state = IDLE;
                else
                    next_state = STOP; // Wait for stop bit
            end
        endcase
    end

    // State register update
    always @(posedge clk) begin
        if (reset)
            state <= IDLE;
        else
            state <= next_state;
    end

    // Bit counter and data register update
    always @(posedge clk) begin
        if (reset || state == IDLE) begin
            bit_count <= 4'd0;
            data <= 8'd0;
        end
        else if (state == START || state == DATA) begin
            bit_count <= bit_count + 1;
            if (state == DATA)
                data <= {in, data[7:1]}; // Shift in the serial data
        end
    end

    // Output logic
    assign out_byte = data;
    assign done = (state == STOP && in == 1 && odd_parity == 1);

endmodule"
N/A,N/A,-1,96,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        DATA = 3'b010,
        PARITY = 3'b011,
        STOP = 3'b100,
        ERROR = 3'b101
    } state_t;
    
    state_t state, next_state;
    reg [3:0] bit_count;  // Count the number of bits received
    reg [7:0] data;       // Store the received data byte
    reg parity_bit;       // Store the received parity bit
    wire parity_odd;      // Output from the parity module
    reg parity_reset;     // Control signal to reset the parity module
    reg stop_bit;         // Store the received stop bit

    // Instantiate the parity module
    parity parity_inst (
        .clk(clk),
        .reset(parity_reset),
        .in(in),
        .odd(parity_odd)
    );

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
            parity_reset <= 1;
        end else begin
            state <= next_state;
            if (state == DATA) begin
                data[bit_count] <= in;
                bit_count <= bit_count + 1;
            end
            if (state == PARITY) begin
                parity_bit <= in;
            end
            if (state == STOP) begin
                stop_bit <= in;
            end
            if (state == IDLE || state == ERROR) begin
                bit_count <= 0;
                parity_reset <= 1; // Reset parity check at the start or after error
            end else begin
                parity_reset <= 0;
            end
        end
    end

    // Next state logic
    always @(*) begin
        next_state = state;
        case (state)
            IDLE: begin
                if (in == 0) // Detect start bit
                    next_state = START;
            end
            START: begin
                next_state = DATA;
            end
            DATA: begin
                if (bit_count == 8)
                    next_state = PARITY;
            end
            PARITY: begin
                next_state = STOP;
            end
            STOP: begin
                if (stop_bit == 1 && (parity_odd ^ parity_bit) == 1) // Check stop bit and odd parity
                    next_state = IDLE;
                else
                    next_state = ERROR;
            end
            ERROR: begin
                if (in == 1) // Wait for stop bit to return to IDLE
                    next_state = IDLE;
            end
        endcase
    end

    // Output logic
    assign out_byte = data;
    assign done = (state == STOP && stop_bit == 1 && (parity_odd ^ parity_bit) == 1);

endmodule"
N/A,N/A,-1,97,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum reg [2:0] {
        IDLE,
        START,
        DATA,
        PARITY,
        STOP
    } state_t;

    // State registers
    reg [2:0] state, next_state;
    reg [3:0] bit_count; // To count bits received
    reg [7:0] data_reg;  // To store the received byte
    reg parity_bit;      // To store the received parity bit
    wire odd_parity;     // Output from parity module

    // Instantiate the parity module
    parity parity_inst (
        .clk(clk),
        .reset(reset | (state == START)), // Reset on FSM reset or new start bit
        .in(in),
        .odd(odd_parity)
    );

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
        end else begin
            state <= next_state;
            if (state == DATA) begin
                data_reg <= {in, data_reg[7:1]}; // Shift in data bits
                bit_count <= bit_count + 1;
            end else if (state == PARITY) begin
                parity_bit <= in; // Capture the parity bit
            end else if (state == STOP) begin
                bit_count <= 0; // Reset bit counter
            end
        end
    end

    // Next state logic
    always @(*) begin
        next_state = state;
        case (state)
            IDLE: begin
                if (in == 0) // Start bit detected
                    next_state = START;
            end
            START: begin
                if (in == 0) // Confirm start bit is still low
                    next_state = DATA;
            end
            DATA: begin
                if (bit_count == 8)
                    next_state = PARITY;
            end
            PARITY: begin
                next_state = STOP;
            end
            STOP: begin
                if (in == 1) // Stop bit should be high
                    next_state = IDLE;
                else
                    next_state = IDLE; // Wait for stop bit
            end
        endcase
    end

    // Output logic
    assign out_byte = data_reg;
    assign done = (state == STOP) && (in == 1) && (odd_parity == 1'b1) && (parity_bit == odd_parity);

endmodule"
N/A,N/A,-1,98,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum reg [2:0] {
        IDLE,
        START,
        DATA,
        PARITY,
        STOP
    } state_t;

    // State registers
    reg [2:0] state, next_state;
    reg [3:0] bit_count; // To count bits received
    reg [7:0] data_reg;  // To store the received byte
    reg parity_reset;
    wire parity_odd;

    // Instantiate the parity module
    parity parity_inst (
        .clk(clk),
        .reset(parity_reset),
        .in(in),
        .odd(parity_odd)
    );

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
            data_reg <= 8'b0;
        end else begin
            state <= next_state;
            if (state == DATA) begin
                data_reg <= {in, data_reg[7:1]}; // Shift in the received bits
                bit_count <= bit_count + 1;
            end else if (state == START) begin
                bit_count <= 0;
            end
        end
    end

    // Next state logic
    always @(*) begin
        next_state = state;
        parity_reset = 0;
        case (state)
            IDLE: begin
                if (!in) // Start bit detected (0)
                    next_state = START;
            end
            START: begin
                if (in) // Invalid start bit, stay in IDLE
                    next_state = IDLE;
                else
                    next_state = DATA;
            end
            DATA: begin
                if (bit_count == 8)
                    next_state = PARITY;
            end
            PARITY: begin
                parity_reset = 1; // Reset parity for next byte
                if (parity_odd == in) // Check parity bit
                    next_state = STOP;
                else
                    next_state = IDLE; // Parity error, go back to IDLE
            end
            STOP: begin
                if (in) // Valid stop bit
                    next_state = IDLE;
                else
                    next_state = IDLE; // Invalid stop bit, go back to IDLE
            end
        endcase
    end

    // Output logic
    assign out_byte = data_reg;
    assign done = (state == STOP) && in; // Done when stop bit is valid

endmodule"
N/A,N/A,-1,99,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum reg [2:0] {
        IDLE,
        START,
        DATA,
        PARITY,
        STOP
    } state_t;

    // State registers
    reg [2:0] state, next_state;
    reg [3:0] bit_count; // To count the number of bits received
    reg [7:0] data;      // To store the received data byte
    wire odd_parity;     // Parity check output

    // Instantiate the parity module
    parity parity_checker (
        .clk(clk),
        .reset(reset | (state == IDLE)), // Reset on reset signal or when returning to IDLE
        .in(in),
        .odd(odd_parity)
    );

    // State transitions
    always @(posedge clk) begin
        if (reset)
            state <= IDLE;
        else
            state <= next_state;
    end

    // Next state logic
    always @(*) begin
        next_state = state; // Default to hold state
        case (state)
            IDLE: begin
                if (in == 0) // Start bit detected
                    next_state = START;
            end
            START: begin
                next_state = DATA;
            end
            DATA: begin
                if (bit_count == 8)
                    next_state = PARITY;
            end
            PARITY: begin
                next_state = STOP;
            end
            STOP: begin
                if (in == 1) // Stop bit detected
                    next_state = IDLE;
            end
        endcase
    end

    // Bit counting and data capturing
    always @(posedge clk) begin
        if (reset || state == IDLE) begin
            bit_count <= 0;
            data <= 8'b0;
        end else if (state == DATA) begin
            data <= {in, data[7:1]}; // Shift in the data bits
            bit_count <= bit_count + 1;
        end else if (state == PARITY) begin
            bit_count <= 0; // Reset bit count after data bits
        end
    end

    // Output logic
    assign out_byte = data;
    assign done = (state == STOP && in == 1 && odd_parity); // Assert done if stop bit is correct and parity is odd

endmodule"
