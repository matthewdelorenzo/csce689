Area,Delay,Score,Current Run,Episode,Verilog
N/A,N/A,-1,0,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

verilog
    // State encoding
    typedef enum reg [2:0] {
        IDLE,
        START,
        DATA,
        PARITY,
        STOP
    } state_t;

    // State registers
    reg [2:0] state, next_state;
    reg [3:0] bit_count; // To count bits received
    reg [7:0] data_reg;  // To store the received byte
    reg parity_bit;
    wire odd_parity;

    // Instantiate the parity module
    parity parity_checker (
        .clk(clk),
        .reset(reset | (state == START)), // Reset parity checker at start of new byte
        .in(in),
        .odd(odd_parity)
    );

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
        end else begin
            state <= next_state;

            // Count bits received in DATA and PARITY states
            if (state == DATA || state == PARITY) begin
                bit_count <= bit_count + 1;
            end else begin
                bit_count <= 0;
            end
        end
    end

    // Next state logic
    always @(*) begin
        next_state = state;
        case (state)
            IDLE: begin
                if (~in) // Start bit detected
                    next_state = START;
            end
            START: begin
                next_state = DATA;
            end
            DATA: begin
                if (bit_count == 8)
                    next_state = PARITY;
            end
            PARITY: begin
                if (bit_count == 9)
                    next_state = STOP;
            end
            STOP: begin
                if (in) // Stop bit detected
                    next_state = IDLE;
            end
        endcase
    end

    // Output and data register logic
    always @(posedge clk) begin
        if (state == DATA) begin
            data_reg <= {in, data_reg[7:1]}; // Shift in data bits
        end else if (state == PARITY && bit_count == 8) begin
            parity_bit <= in; // Capture parity bit
        end
    end

    // Done signal logic
    assign done = (state == STOP && in && odd_parity); // Valid stop bit and correct parity

    // Output the received byte
    assign out_byte = data_reg;

endmodule"
N/A,N/A,-1,1,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

verilog
    // State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        RECEIVE = 3'b010,
        PARITY_CHECK = 3'b011,
        STOP = 3'b100
    } state_t;

    state_t state, next_state;
    reg [7:0] data_shift;
    reg [3:0] bit_count;
    wire parity_odd;
    reg parity_reset;
    reg [7:0] out_byte_reg;
    reg done_reg;

    // Instantiate the parity module
    parity parity_inst (
        .clk(clk),
        .reset(parity_reset),
        .in(in),
        .odd(parity_odd)
    );

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
            parity_reset <= 1;
            done_reg <= 0;
        end else begin
            state <= next_state;
            if (state == RECEIVE) begin
                data_shift <= {in, data_shift[7:1]};
                bit_count <= bit_count + 1;
            end
        end
    end

    // Next state logic
    always @(*) begin
        next_state = state;
        parity_reset = 0;
        done_reg = 0;

        case (state)
            IDLE: begin
                if (~in) begin
                    next_state = START;
                    parity_reset = 1; // Reset parity on start bit
                end
            end

            START: begin
                if (in) begin
                    next_state = RECEIVE;
                    bit_count = 0;
                end
            end

            RECEIVE: begin
                if (bit_count == 8) begin
                    next_state = PARITY_CHECK;
                end
            end

            PARITY_CHECK: begin
                if (parity_odd == in) begin
                    next_state = STOP;
                end else begin
                    next_state = IDLE; // Parity failed, return to IDLE
                end
            end

            STOP: begin
                if (in) begin
                    next_state = IDLE;
                    out_byte_reg = data_shift;
                    done_reg = 1;
                end
            end
        endcase
    end

    assign out_byte = out_byte_reg;
    assign done = done_reg;

endmodule"
N/A,N/A,-1,2,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

verilog
    // State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        DATA = 3'b010,
        PARITY = 3'b011,
        STOP = 3'b100,
        ERROR = 3'b101
    } state_t;
    
    state_t state, next_state;
    reg [3:0] bit_count;  // Count the number of bits received
    reg [7:0] data;       // Store the received data byte
    reg parity_bit;       // Store the received parity bit
    wire odd_parity;      // Output from the parity module

    // Instantiate the parity module
    parity parity_inst (
        .clk(clk),
        .reset(reset | (state == IDLE) | (state == START)),
        .in(in),
        .odd(odd_parity)
    );

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
        end else begin
            state <= next_state;
        end
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 0) // Look for start bit
                    next_state = START;
                else
                    next_state = IDLE;
            end
            START: begin
                if (bit_count == 4'd8)
                    next_state = DATA;
                else
                    next_state = START;
            end
            DATA: begin
                if (bit_count == 4'd8)
                    next_state = PARITY;
                else
                    next_state = DATA;
            end
            PARITY: begin
                next_state = STOP;
            end
            STOP: begin
                if (in == 1) // Stop bit must be 1
                    next_state = IDLE;
                else
                    next_state = ERROR;
            end
            ERROR: begin
                if (in == 1) // Wait for stop bit to be high
                    next_state = IDLE;
                else
                    next_state = ERROR;
            end
            default: next_state = IDLE;
        endcase
    end

    // Output logic and data path
    always @(posedge clk) begin
        if (reset) begin
            bit_count <= 0;
            data <= 8'b0;
            parity_bit <= 0;
        end else begin
            case (state)
                START: begin
                    bit_count <= bit_count + 1;
                end
                DATA: begin
                    data <= {in, data[7:1]}; // Shift in the data bits
                    bit_count <= bit_count + 1;
                end
                PARITY: begin
                    parity_bit <= in;
                end
                STOP: begin
                    if (parity_bit == odd_parity) begin
                        done <= 1;
                        out_byte <= data;
                    end else begin
                        done <= 0;
                    end
                end
                ERROR: begin
                    done <= 0;
                end
            endcase
        end
    end

    // Reset done signal at the beginning of each new byte reception
    always @(posedge clk) begin
        if (reset || state == IDLE) begin
            done <= 0;
        end
    end

endmodule"
N/A,N/A,-1,3,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

verilog
    // State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        DATA = 3'b010,
        PARITY = 3'b011,
        STOP = 3'b100
    } state_t;

    state_t state, next_state;
    reg [3:0] bit_count;  // Count the number of bits received
    reg [7:0] data_byte;  // Store the received data byte
    reg parity_bit;       // Store the received parity bit
    wire odd;             // Output of the parity checker

    // Instantiate the parity module
    parity parity_checker (
        .clk(clk),
        .reset(reset | (state == IDLE)),
        .in(in),
        .odd(odd)
    );

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
            data_byte <= 8'b0;
            parity_bit <= 0;
        end else begin
            state <= next_state;
        end
    end

    // Next state logic
    always @(*) begin
        next_state = state;  // Default to hold state
        case (state)
            IDLE: begin
                if (in == 0)  // Detect start bit (0)
                    next_state = START;
            end
            START: begin
                if (bit_count == 4'd8)  // After 8 bits, move to DATA
                    next_state = DATA;
            end
            DATA: begin
                if (bit_count == 4'd8)  // After 8 bits, move to PARITY
                    next_state = PARITY;
            end
            PARITY: begin
                if (bit_count == 4'd9)  // After parity bit, move to STOP
                    next_state = STOP;
            end
            STOP: begin
                if (in == 1)  // Detect stop bit (1)
                    next_state = IDLE;
            end
        endcase
    end

    // Output and data path logic
    always @(posedge clk) begin
        if (reset) begin
            bit_count <= 0;
            data_byte <= 8'b0;
            parity_bit <= 0;
        end else begin
            case (state)
                START: begin
                    if (bit_count < 4'd8) begin
                        data_byte[bit_count] <= in;  // Shift in data bits
                        bit_count <= bit_count + 1;
                    end
                end
                DATA: begin
                    if (bit_count < 4'd8) begin
                        data_byte[bit_count] <= in;  // Shift in data bits
                        bit_count <= bit_count + 1;
                    end
                end
                PARITY: begin
                    if (bit_count == 4'd8) begin
                        parity_bit <= in;  // Capture the parity bit
                        bit_count <= bit_count + 1;
                    end
                end
                STOP: begin
                    if (in == 1) begin
                        if (odd && (parity_bit == 1)) begin
                            out_byte <= data_byte;  // Capture the valid byte
                            done <= 1;  // Assert done if parity is correct
                        end else begin
                            done <= 0;  // Deassert done if parity is incorrect
                        end
                        bit_count <= 0;  // Reset bit count
                    end
                end
            endcase
        end
    end

endmodule"
N/A,N/A,-1,4,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

verilog
    // State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        DATA = 3'b010,
        PARITY = 3'b011,
        STOP = 3'b100
    } state_t;

    state_t state, next_state;
    reg [3:0] bit_count;  // Count the number of bits received
    reg [7:0] data_byte;  // Store the received data byte
    reg parity_bit;       // Store the received parity bit
    wire odd;             // Output of the parity checker

    // Instantiate the parity module
    parity parity_checker (
        .clk(clk),
        .reset(reset | (state == IDLE)),
        .in(in),
        .odd(odd)
    );

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
            data_byte <= 8'b0;
            parity_bit <= 0;
        end else begin
            state <= next_state;
            if (state == DATA && bit_count < 8) begin
                data_byte <= {in, data_byte[7:1]};
                bit_count <= bit_count + 1;
            end else if (state == PARITY) begin
                parity_bit <= in;
            end else if (state == STOP) begin
                bit_count <= 0;
            end
        end
    end

    // Next state logic
    always @(*) begin
        next_state = state;
        case (state)
            IDLE: begin
                if (in == 0)  // Start bit detected
                    next_state = START;
            end
            START: begin
                next_state = DATA;
            end
            DATA: begin
                if (bit_count == 8)
                    next_state = PARITY;
            end
            PARITY: begin
                next_state = STOP;
            end
            STOP: begin
                if (in == 1)  // Stop bit detected
                    next_state = IDLE;
            end
        endcase
    end

    // Output logic
    assign out_byte = data_byte;
    assign done = (state == STOP) && (in == 1) && (parity_bit == odd);

endmodule"
N/A,N/A,-1,5,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

verilog
    // State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        DATA = 3'b010,
        PARITY = 3'b011,
        STOP = 3'b100
    } state_t;
    
    state_t state, next_state;
    reg [7:0] data_shift;
    reg [3:0] bit_count;
    wire parity_odd;
    reg parity_reset;
    reg done_reg;

    // Instantiate the parity module
    parity parity_inst (
        .clk(clk),
        .reset(parity_reset),
        .in(in),
        .odd(parity_odd)
    );

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
            done_reg <= 0;
            parity_reset <= 1;
        end else begin
            state <= next_state;
            if (state == DATA) bit_count <= bit_count + 1'b1;
            if (state == STOP) done_reg <= 0;
            if (state == PARITY && parity_odd) done_reg <= 1;
            parity_reset <= (state == IDLE || state == STOP);
        end
    end

    // Next state logic
    always @(*) begin
        next_state = state;
        case (state)
            IDLE: if (~in) next_state = START;
            START: if (in) next_state = DATA;
            DATA: if (bit_count == 8) next_state = PARITY;
            PARITY: if (in) next_state = STOP;
            STOP: if (~in) next_state = IDLE;
            default: next_state = IDLE;
        endcase
    end

    // Output logic
    always @(posedge clk) begin
        if (state == DATA) data_shift <= {in, data_shift[7:1]};
    end

    assign out_byte = data_shift;
    assign done = done_reg;

endmodule"
N/A,N/A,-1,6,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

verilog
    // State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        RECEIVE = 3'b010,
        PARITY_CHECK = 3'b011,
        STOP = 3'b100
    } state_t;

    state_t state, next_state;
    reg [7:0] data_shift;
    reg [3:0] bit_count;
    wire parity_odd;
    reg parity_reset;
    reg [7:0] out_byte_reg;
    reg done_reg;

    // Instantiate the parity module
    parity parity_inst (
        .clk(clk),
        .reset(parity_reset),
        .in(in),
        .odd(parity_odd)
    );

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
            parity_reset <= 1;
            done_reg <= 0;
        end else begin
            state <= next_state;
            if (state == RECEIVE) begin
                data_shift <= {in, data_shift[7:1]};
                bit_count <= bit_count + 1;
            end
        end
    end

    // Next state logic
    always @(*) begin
        next_state = state;
        parity_reset = 0;
        done_reg = 0;
        case (state)
            IDLE: begin
                if (~in) begin
                    next_state = START;
                    parity_reset = 1; // Reset parity on start bit
                end
            end
            START: begin
                if (in) begin
                    next_state = RECEIVE;
                    bit_count = 0;
                end
            end
            RECEIVE: begin
                if (bit_count == 8) begin
                    next_state = PARITY_CHECK;
                end
            end
            PARITY_CHECK: begin
                if (parity_odd == in) begin
                    next_state = STOP;
                end else begin
                    next_state = IDLE; // Parity failed, return to IDLE
                end
            end
            STOP: begin
                if (in) begin
                    next_state = IDLE;
                    out_byte_reg = data_shift;
                    done_reg = 1;
                end
            end
        endcase
    end

    assign out_byte = out_byte_reg;
    assign done = done_reg;

endmodule"
N/A,N/A,-1,7,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

verilog
    // State encoding
    typedef enum reg [2:0] {
        IDLE,
        START,
        DATA,
        PARITY,
        STOP
    } state_t;

    // State registers
    reg [2:0] state, next_state;
    reg [3:0] bit_count; // To count bits received
    reg [7:0] data_reg;  // To store the received byte
    reg parity_bit;
    wire odd_parity;

    // Instantiate the parity module
    parity parity_checker (
        .clk(clk),
        .reset(reset | (state == IDLE)),
        .in(in),
        .odd(odd_parity)
    );

    // State transition logic
    always @(posedge clk) begin
        if (reset)
            state <= IDLE;
        else
            state <= next_state;
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (~in) // Start bit detected
                    next_state = START;
                else
                    next_state = IDLE;
            end
            START: begin
                if (bit_count == 0)
                    next_state = DATA;
                else
                    next_state = START;
            end
            DATA: begin
                if (bit_count == 8)
                    next_state = PARITY;
                else
                    next_state = DATA;
            end
            PARITY: begin
                next_state = STOP;
            end
            STOP: begin
                if (in) // Stop bit detected
                    next_state = IDLE;
                else
                    next_state = STOP;
            end
            default: next_state = IDLE;
        endcase
    end

    // Output logic and data capturing
    always @(posedge clk) begin
        if (reset) begin
            bit_count <= 0;
            data_reg <= 8'b0;
            parity_bit <= 0;
        end
        else begin
            case (state)
                IDLE: begin
                    bit_count <= 0;
                end
                START: begin
                    // Wait for the start bit to finish
                    bit_count <= bit_count + 1;
                end
                DATA: begin
                    data_reg <= {in, data_reg[7:1]};
                    bit_count <= bit_count + 1;
                end
                PARITY: begin
                    parity_bit <= in;
                end
                STOP: begin
                    // Nothing to do, just wait for the stop bit
                end
            endcase
        end
    end

    // Done signal logic
    assign done = (state == STOP) && in && (odd_parity == 1'b1) && (parity_bit == odd_parity);
    assign out_byte = data_reg;

endmodule"
N/A,N/A,-1,8,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

verilog
    // State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        RECEIVE = 3'b010,
        PARITY_CHECK = 3'b011,
        STOP = 3'b100,
        DONE = 3'b101
    } state_t;

    reg [2:0] state, next_state;
    reg [3:0] bit_count;
    reg [7:0] shift_reg;
    wire odd_parity;
    reg parity_reset;
    reg stop_bit_error;

    // Instantiate the parity module
    parity parity_inst (
        .clk(clk),
        .reset(parity_reset),
        .in(in),
        .odd(odd_parity)
    );

    // State transitions
    always @(posedge clk) begin
        if (reset)
            state <= IDLE;
        else
            state <= next_state;
    end

    // Next state logic
    always @(*) begin
        next_state = state; // Default to hold state
        parity_reset = 0;
        stop_bit_error = 0;

        case (state)
            IDLE: begin
                if (!in) // Start bit detected (active low)
                    next_state = START;
            end
            START: begin
                next_state = RECEIVE;
                bit_count = 0;
                parity_reset = 1; // Reset parity counter for new byte
            end
            RECEIVE: begin
                if (bit_count < 8) begin
                    next_state = RECEIVE;
                end else begin
                    next_state = PARITY_CHECK;
                end
            end
            PARITY_CHECK: begin
                if (odd_parity == in) // Check if parity bit matches
                    next_state = STOP;
                else
                    next_state = IDLE; // Parity error, go back to IDLE
            end
            STOP: begin
                if (in) // Stop bit should be high
                    next_state = DONE;
                else
                    stop_bit_error = 1; // Stop bit error detected
            end
            DONE: begin
                next_state = IDLE;
            end
        endcase
    end

    // Output logic
    assign done = (state == DONE) && !stop_bit_error;
    assign out_byte = shift_reg;

    // Shift register and bit count logic
    always @(posedge clk) begin
        if (reset) begin
            shift_reg <= 0;
            bit_count <= 0;
        end else if (state == RECEIVE) begin
            shift_reg <= {in, shift_reg[7:1]};
            bit_count <= bit_count + 1;
        end
    end

endmodule"
N/A,N/A,-1,9,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

verilog
    // State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        RECEIVE = 3'b010,
        PARITY_CHECK = 3'b011,
        STOP = 3'b100
    } state_t;

    state_t state, next_state;
    reg [7:0] data_shift;
    reg [3:0] bit_count;
    wire parity_odd;
    reg parity_reset;
    reg [7:0] out_byte_reg;
    reg done_reg;

    // Instantiate the parity module
    parity parity_inst (
        .clk(clk),
        .reset(parity_reset),
        .in(in),
        .odd(parity_odd)
    );

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
            parity_reset <= 1;
            done_reg <= 0;
        end else begin
            state <= next_state;
            if (state == RECEIVE) begin
                data_shift <= {in, data_shift[7:1]};
                bit_count <= bit_count + 1;
            end
        end
    end

    // Next state logic
    always @(*) begin
        next_state = state;
        parity_reset = 0;
        done_reg = 0;

        case (state)
            IDLE: begin
                if (~in) begin
                    next_state = START;
                    parity_reset = 1; // Reset parity on start bit
                end
            end

            START: begin
                if (in) begin
                    next_state = RECEIVE;
                    bit_count = 0;
                end
            end

            RECEIVE: begin
                if (bit_count == 8) begin
                    next_state = PARITY_CHECK;
                end
            end

            PARITY_CHECK: begin
                if (parity_odd == in) begin
                    next_state = STOP;
                end else begin
                    next_state = IDLE; // Parity failed, return to IDLE
                end
            end

            STOP: begin
                if (in) begin
                    next_state = IDLE;
                    out_byte_reg = data_shift;
                    done_reg = 1;
                end
            end
        endcase
    end

    assign out_byte = out_byte_reg;
    assign done = done_reg;

endmodule"
N/A,N/A,-1,10,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

verilog
    // State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        RECEIVE = 3'b010,
        PARITY_CHECK = 3'b011,
        STOP = 3'b100
    } state_t;

    state_t state, next_state;
    reg [7:0] data_shift;
    reg [3:0] bit_count;
    wire parity_odd;
    reg parity_reset;
    reg [7:0] out_byte_reg;
    reg done_reg;

    // Instantiate the parity module
    parity parity_inst (
        .clk(clk),
        .reset(parity_reset),
        .in(in),
        .odd(parity_odd)
    );

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
            parity_reset <= 1;
            done_reg <= 0;
        end else begin
            state <= next_state;
            if (state == RECEIVE) begin
                data_shift <= {in, data_shift[7:1]};
                bit_count <= bit_count + 1;
            end
        end
    end

    // Next state logic
    always @(*) begin
        next_state = state;
        parity_reset = 0;
        done_reg = 0;
        case (state)
            IDLE: begin
                if (~in) begin
                    next_state = START;
                    parity_reset = 1; // Reset parity on start bit
                end
            end
            START: begin
                if (in) begin
                    next_state = RECEIVE;
                    bit_count = 0;
                end
            end
            RECEIVE: begin
                if (bit_count == 8) begin
                    next_state = PARITY_CHECK;
                end
            end
            PARITY_CHECK: begin
                if (parity_odd == in) begin
                    next_state = STOP;
                end else begin
                    next_state = IDLE; // Parity failed, return to IDLE
                end
            end
            STOP: begin
                if (in) begin
                    next_state = IDLE;
                    out_byte_reg = data_shift;
                    done_reg = 1;
                end
            end
        endcase
    end

    assign out_byte = out_byte_reg;
    assign done = done_reg;

endmodule"
N/A,N/A,-1,11,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

verilog
    // State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        DATA = 3'b010,
        PARITY = 3'b011,
        STOP = 3'b100
    } state_t;
    
    state_t state, next_state;
    reg [3:0] bit_count;
    reg [7:0] data_reg;
    wire parity_odd;
    reg parity_reset;
    reg done_reg;

    // Instantiate the parity module
    parity parity_inst (
        .clk(clk),
        .reset(parity_reset),
        .in(in),
        .odd(parity_odd)
    );

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
            done_reg <= 0;
            parity_reset <= 1;
        end else begin
            state <= next_state;
            if (state == DATA) bit_count <= bit_count + 1'b1;
            if (state == STOP) done_reg <= 0;
            if (state == IDLE || state == START) parity_reset <= 1;
            else parity_reset <= 0;
        end
    end

    // Next state logic
    always @(*) begin
        next_state = state;
        case (state)
            IDLE: begin
                if (!in) next_state = START;  // Detect start bit
            end
            START: begin
                next_state = DATA;
            end
            DATA: begin
                if (bit_count == 8) next_state = PARITY;
            end
            PARITY: begin
                if (parity_odd) next_state = STOP;  // Check parity
                else next_state = IDLE;  // Parity error, go back to IDLE
            end
            STOP: begin
                if (in) begin
                    next_state = IDLE;
                    done_reg = 1;  // Successful reception
                end else begin
                    next_state = IDLE;  // Stop bit error, go back to IDLE
                end
            end
        endcase
    end

    // Output logic
    always @(posedge clk) begin
        if (state == DATA) begin
            data_reg[bit_count] <= in;
        end
        if (done_reg) begin
            out_byte <= data_reg;
        end
    end

    assign done = done_reg;

endmodule"
N/A,N/A,-1,12,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

verilog
    // State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        RECEIVE = 3'b010,
        PARITY_CHECK = 3'b011,
        STOP = 3'b100
    } state_t;

    state_t state, next_state;
    reg [7:0] data_shift;
    reg [3:0] bit_count;
    wire parity_odd;
    reg parity_reset;
    reg done_reg;

    // Instantiate the parity module
    parity parity_inst (
        .clk(clk),
        .reset(parity_reset),
        .in(in),
        .odd(parity_odd)
    );

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
            done_reg <= 0;
            parity_reset <= 1;
        end else begin
            state <= next_state;
            if (state == RECEIVE) bit_count <= bit_count + 1'b1;
            if (state == STOP) done_reg <= 0;
            if (state == PARITY_CHECK && parity_odd) done_reg <= 1;
        end
    end

    // Next state logic
    always @(*) begin
        next_state = state;
        parity_reset = 0;
        case (state)
            IDLE: begin
                if (!in) next_state = START;  // Detect start bit
            end
            START: begin
                next_state = RECEIVE;
                bit_count = 0;
                parity_reset = 1;
            end
            RECEIVE: begin
                if (bit_count == 8) next_state = PARITY_CHECK;
            end
            PARITY_CHECK: begin
                if (parity_odd == in) next_state = STOP;  // Check parity bit
                else next_state = IDLE;  // Parity error
            end
            STOP: begin
                if (in) next_state = IDLE;  // Stop bit detected
            end
        endcase
    end

    // Output logic
    always @(posedge clk) begin
        if (state == RECEIVE) begin
            data_shift <= {in, data_shift[7:1]};
        end
    end

    assign out_byte = data_shift;
    assign done = done_reg;

endmodule"
N/A,N/A,-1,13,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

verilog
    // State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        RECEIVE = 3'b010,
        PARITY_CHECK = 3'b011,
        STOP = 3'b100
    } state_t;

    // State registers
    reg [2:0] state, next_state;
    reg [3:0] bit_count; // Count 9 bits (8 data + 1 parity)
    reg [7:0] data_reg;
    reg parity_bit;
    wire odd_parity;

    // Instantiate the parity module
    parity parity_checker (
        .clk(clk),
        .reset(reset | (state == IDLE) | (state == START)),
        .in(in),
        .odd(odd_parity)
    );

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
        end else begin
            state <= next_state;
        end
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (!in) // Detect start bit (0)
                    next_state = START;
                else
                    next_state = IDLE;
            end
            START: begin
                next_state = RECEIVE;
            end
            RECEIVE: begin
                if (bit_count == 4'd8) // After 8 data bits
                    next_state = PARITY_CHECK;
                else
                    next_state = RECEIVE;
            end
            PARITY_CHECK: begin
                next_state = STOP;
            end
            STOP: begin
                if (in) // Stop bit should be 1
                    next_state = IDLE;
                else
                    next_state = STOP; // Wait for stop bit
            end
            default: next_state = IDLE;
        endcase
    end

    // Output and data path logic
    always @(posedge clk) begin
        if (reset) begin
            bit_count <= 0;
            data_reg <= 8'b0;
            parity_bit <= 0;
        end else begin
            case (state)
                IDLE: begin
                    bit_count <= 0;
                end
                START: begin
                    bit_count <= 0;
                end
                RECEIVE: begin
                    bit_count <= bit_count + 1;
                    data_reg <= {in, data_reg[7:1]}; // Shift in data bits (LSB first)
                end
                PARITY_CHECK: begin
                    parity_bit <= in; // Capture parity bit
                end
                STOP: begin
                    // Do nothing
                end
            endcase
        end
    end

    // Done signal logic
    assign done = (state == STOP) && in && (odd_parity == 1'b1) && (parity_bit == odd_parity);

    // Output byte
    assign out_byte = data_reg;

endmodule"
N/A,N/A,-1,14,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

verilog
    // State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        DATA = 3'b010,
        PARITY = 3'b011,
        STOP = 3'b100
    } state_t;
    
    state_t state, next_state;
    reg [7:0] data_shift;
    reg [3:0] bit_count;
    wire parity_odd;
    reg parity_reset;
    reg done_reg;

    // Instantiate the parity module
    parity parity_inst (
        .clk(clk),
        .reset(parity_reset),
        .in(in),
        .odd(parity_odd)
    );

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
            done_reg <= 0;
            parity_reset <= 1;
        end else begin
            state <= next_state;
            if (state == DATA) bit_count <= bit_count + 1'b1;
            if (state == STOP) done_reg <= 0;
            if (state == START) parity_reset <= 0;
        end
    end

    // Next state logic
    always @(*) begin
        next_state = state;  // Default to hold state
        case (state)
            IDLE: begin
                if (!in) next_state = START;  // Detect start bit (0)
            end
            START: begin
                if (in) next_state = DATA;  // Move to data state on next clock
            end
            DATA: begin
                if (bit_count == 8) next_state = PARITY;  // 8 data bits received
            end
            PARITY: begin
                if (parity_odd == 1'b1) next_state = STOP;  // Check for odd parity
                else next_state = IDLE;  // Parity error, go back to idle
            end
            STOP: begin
                if (in) begin  // Check for stop bit (1)
                    next_state = IDLE;
                    done_reg = 1'b1;
                end else begin
                    next_state = IDLE;  // Stop bit error, go back to idle
                end
            end
        endcase
    end

    // Output logic
    always @(posedge clk) begin
        if (state == DATA) begin
            data_shift <= {in, data_shift[7:1]};  // Shift in the data bits
        end
    end

    assign out_byte = data_shift;
    assign done = done_reg;

endmodule"
N/A,N/A,-1,15,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

verilog
    // State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        RECEIVE = 3'b010,
        PARITY_CHECK = 3'b011,
        STOP = 3'b100
    } state_t;

    state_t state, next_state;
    reg [7:0] data_shift;
    reg [3:0] bit_count;
    wire parity_odd;
    reg parity_reset;
    reg [7:0] out_byte_reg;
    reg done_reg;

    // Instantiate the parity module
    parity parity_inst (
        .clk(clk),
        .reset(parity_reset),
        .in(in),
        .odd(parity_odd)
    );

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
            parity_reset <= 1;
            done_reg <= 0;
        end else begin
            state <= next_state;
            if (state == RECEIVE) begin
                data_shift <= {in, data_shift[7:1]};
                bit_count <= bit_count + 1;
            end
        end
    end

    // Next state logic
    always @(*) begin
        next_state = state;
        parity_reset = 0;
        done_reg = 0;
        case (state)
            IDLE: begin
                if (~in) begin
                    next_state = START;
                    parity_reset = 1; // Reset parity on start bit
                end
            end
            START: begin
                if (in) begin
                    next_state = RECEIVE;
                end
            end
            RECEIVE: begin
                if (bit_count == 8) begin
                    next_state = PARITY_CHECK;
                end
            end
            PARITY_CHECK: begin
                if (parity_odd == in) begin
                    next_state = STOP;
                end else begin
                    next_state = IDLE; // Parity failed, go back to IDLE
                end
            end
            STOP: begin
                if (in) begin
                    next_state = IDLE;
                    out_byte_reg = data_shift;
                    done_reg = 1;
                end
            end
        endcase
    end

    // Output assignments
    assign out_byte = out_byte_reg;
    assign done = done_reg;

endmodule"
N/A,N/A,-1,16,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

verilog
    // State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        RECEIVE = 3'b010,
        PARITY_CHECK = 3'b011,
        STOP = 3'b100
    } state_t;

    state_t state, next_state;
    reg [7:0] data_shift;
    reg [3:0] bit_count;
    wire parity_odd;
    reg parity_reset;
    reg done_reg;

    // Instantiate the parity module
    parity parity_inst (
        .clk(clk),
        .reset(parity_reset),
        .in(in),
        .odd(parity_odd)
    );

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
            done_reg <= 0;
            parity_reset <= 1;
        end else begin
            state <= next_state;
            if (state == RECEIVE) bit_count <= bit_count + 1'b1;
            if (state == STOP) done_reg <= 0;
            if (state == PARITY_CHECK && parity_odd) done_reg <= 1;
        end
    end

    // Next state logic
    always @(*) begin
        next_state = state;
        parity_reset = 0;
        case (state)
            IDLE: begin
                if (!in) next_state = START;  // Detect start bit
            end
            START: begin
                next_state = RECEIVE;
                bit_count = 0;
                parity_reset = 1;
            end
            RECEIVE: begin
                if (bit_count == 8) next_state = PARITY_CHECK;
            end
            PARITY_CHECK: begin
                if (parity_odd) next_state = STOP;
                else next_state = IDLE;  // Parity error, go back to idle
            end
            STOP: begin
                if (in) next_state = IDLE;  // Stop bit detected
                else next_state = START;  // If no stop bit, assume it's a new start bit
            end
        endcase
    end

    // Output logic
    always @(posedge clk) begin
        if (state == RECEIVE) begin
            data_shift <= {in, data_shift[7:1]};
        end
    end

    assign out_byte = data_shift;
    assign done = done_reg;

endmodule"
N/A,N/A,-1,17,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

verilog
    // State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        DATA = 3'b010,
        PARITY = 3'b011,
        STOP = 3'b100,
        ERROR = 3'b101
    } state_t;
    
    state_t state, next_state;
    reg [3:0] bit_count;  // To count 9 bits (8 data + 1 parity)
    reg [7:0] data_byte;  // To store the received byte
    wire odd_parity;
    
    // Instantiate parity module
    parity parity_inst (
        .clk(clk),
        .reset(reset | (state == START)),
        .in(in),
        .odd(odd_parity)
    );
    
    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
        end else begin
            state <= next_state;
        end
    end
    
    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 0) // Start bit detected
                    next_state = START;
                else
                    next_state = IDLE;
            end
            START: begin
                if (bit_count == 4'd8) // All data bits received
                    next_state = PARITY;
                else
                    next_state = DATA;
            end
            DATA: begin
                next_state = (bit_count == 4'd8) ? PARITY : DATA;
            end
            PARITY: begin
                if (odd_parity == 1) // Parity check passed
                    next_state = STOP;
                else
                    next_state = ERROR;
            end
            STOP: begin
                if (in == 1) // Stop bit detected
                    next_state = IDLE;
                else
                    next_state = ERROR;
            end
            ERROR: begin
                if (in == 1) // Wait for stop bit to return to IDLE
                    next_state = IDLE;
                else
                    next_state = ERROR;
            end
            default: next_state = IDLE;
        endcase
    end
    
    // Output logic and data path
    always @(posedge clk) begin
        if (reset) begin
            bit_count <= 0;
            data_byte <= 8'b0;
        end else begin
            case (state)
                START: begin
                    bit_count <= 0;
                end
                DATA: begin
                    data_byte[bit_count] <= in;
                    bit_count <= bit_count + 1;
                end
                PARITY: begin
                    // Do nothing, just checking parity
                end
                STOP: begin
                    if (in == 1) begin // Stop bit is correct
                        out_byte <= data_byte;
                    end
                end
                ERROR: begin
                    // Reset data and bit count
                    bit_count <= 0;
                    data_byte <= 8'b0;
                end
            endcase
        end
    end
    
    assign done = (state == STOP) && (in == 1);
    
endmodule"
N/A,N/A,-1,18,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

verilog
    // State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        RECEIVE = 3'b010,
        PARITY_CHECK = 3'b011,
        STOP = 3'b100
    } state_t;

    state_t state, next_state;
    reg [7:0] data_shift;
    reg [3:0] bit_count;
    wire parity_odd;
    reg parity_reset;
    reg done_reg;

    // Instantiate the parity module
    parity parity_inst (
        .clk(clk),
        .reset(parity_reset),
        .in(in),
        .odd(parity_odd)
    );

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            data_shift <= 8'd0;
            bit_count <= 4'd0;
            done_reg <= 1'b0;
        end else begin
            state <= next_state;
            if (state == RECEIVE) begin
                data_shift <= {in, data_shift[7:1]};
                bit_count <= bit_count + 1;
            end
            if (state == PARITY_CHECK) begin
                done_reg <= (parity_odd == 1'b1);
            end else begin
                done_reg <= 1'b0;
            end
        end
    end

    // Next state logic
    always @(*) begin
        next_state = state;
        parity_reset = 1'b0;
        case (state)
            IDLE: begin
                if (in == 1'b0) begin // Start bit detected
                    next_state = START;
                    parity_reset = 1'b1;
                end
            end
            START: begin
                next_state = RECEIVE;
            end
            RECEIVE: begin
                if (bit_count == 4'd8) begin
                    next_state = PARITY_CHECK;
                end
            end
            PARITY_CHECK: begin
                if (bit_count == 4'd9) begin
                    next_state = STOP;
                end
            end
            STOP: begin
                if (in == 1'b1) begin // Stop bit detected
                    next_state = IDLE;
                end else begin
                    next_state = IDLE; // Wait for stop bit
                end
            end
        endcase
    end

    assign out_byte = data_shift;
    assign done = done_reg;

endmodule"
N/A,N/A,-1,19,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

verilog
    // State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        DATA = 3'b010,
        PARITY = 3'b011,
        STOP = 3'b100
    } state_t;

    state_t state, next_state;
    reg [3:0] bit_count;  // Count the number of bits received
    reg [7:0] data_reg;   // Store the received data byte
    reg parity_bit;       // Store the received parity bit
    wire odd;             // Output of the parity checker

    // Instantiate the parity module
    parity parity_checker (
        .clk(clk),
        .reset(reset | (state == IDLE)),
        .in(in),
        .odd(odd)
    );

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
            data_reg <= 8'b0;
            parity_bit <= 0;
        end else begin
            state <= next_state;
            if (state == DATA && bit_count < 8) begin
                data_reg <= {in, data_reg[7:1]};
                bit_count <= bit_count + 1;
            end else if (state == PARITY) begin
                parity_bit <= in;
            end else if (state == STOP) begin
                bit_count <= 0;
            end
        end
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (!in) next_state = START;  // Detect start bit (0)
                else next_state = IDLE;
            end
            START: begin
                next_state = DATA;
            end
            DATA: begin
                if (bit_count == 8) next_state = PARITY;
                else next_state = DATA;
            end
            PARITY: begin
                next_state = STOP;
            end
            STOP: begin
                if (in) next_state = IDLE;  // Detect stop bit (1)
                else next_state = START;    // If stop bit is not correct, restart
            end
            default: next_state = IDLE;
        endcase
    end

    // Output logic
    assign out_byte = data_reg;
    assign done = (state == STOP) && in && (odd != parity_bit);  // Check stop bit and parity

endmodule"
N/A,N/A,-1,20,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

verilog
    // State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        DATA = 3'b010,
        PARITY = 3'b011,
        STOP = 3'b100,
        ERROR = 3'b101
    } state_t;
    
    state_t state, next_state;
    reg [3:0] bit_count;  // Count the number of bits received
    reg [7:0] data;       // Store the received data byte
    reg parity_bit;       // Store the received parity bit
    wire odd_parity;      // Output from the parity module
    reg parity_reset;     // Control signal to reset the parity module
    
    // Instantiate the parity module
    parity parity_inst (
        .clk(clk),
        .reset(parity_reset),
        .in(in),
        .odd(odd_parity)
    );
    
    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
            parity_reset <= 1;
        end else begin
            state <= next_state;
            if (state == DATA) begin
                data <= {in, data[7:1]};  // Shift in data bits
                bit_count <= bit_count + 1;
            end else if (state == PARITY) begin
                parity_bit <= in;
            end
            if (state == IDLE || state == STOP) begin
                parity_reset <= 1;  // Reset parity calculation at the start and end
            end else begin
                parity_reset <= 0;
            end
        end
    end
    
    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (!in) next_state = START;  // Detect start bit (0)
                else next_state = IDLE;
            end
            START: begin
                if (bit_count == 9) next_state = PARITY;  // After 8 data bits
                else next_state = DATA;
            end
            DATA: begin
                if (bit_count == 8) next_state = PARITY;  // Move to parity bit
                else next_state = DATA;
            end
            PARITY: begin
                next_state = STOP;
            end
            STOP: begin
                if (in) begin  // Expect stop bit (1)
                    if (parity_bit == odd_parity) next_state = IDLE;  // Check parity
                    else next_state = ERROR;  // Parity error
                end else begin
                    next_state = ERROR;  // Stop bit error
                end
            end
            ERROR: begin
                if (in) next_state = IDLE;  // Wait for a new start bit
                else next_state = ERROR;
            end
            default: next_state = IDLE;
        endcase
    end

    // Output logic
    assign out_byte = data;
    assign done = (state == STOP && in && parity_bit == odd_parity);

endmodule"
N/A,N/A,-1,21,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

verilog
    // State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        RECEIVE = 3'b010,
        PARITY_CHECK = 3'b011,
        STOP = 3'b100
    } state_t;

    state_t state, next_state;
    reg [7:0] data_shift;
    reg [3:0] bit_count;
    wire parity_odd;
    reg parity_reset;
    reg done_reg;

    // Instantiate the parity module
    parity parity_inst (
        .clk(clk),
        .reset(parity_reset),
        .in(in),
        .odd(parity_odd)
    );

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
            done_reg <= 0;
            parity_reset <= 1;
        end else begin
            state <= next_state;
            if (state == RECEIVE) bit_count <= bit_count + 1'b1;
            if (state == STOP) done_reg <= 0;
            if (state == IDLE || state == START) parity_reset <= 1;
            else parity_reset <= 0;
        end
    end

    // Next state logic
    always @(*) begin
        next_state = state;
        case (state)
            IDLE: begin
                if (!in) next_state = START;  // Detect start bit
            end
            START: begin
                next_state = RECEIVE;
            end
            RECEIVE: begin
                if (bit_count == 9) next_state = PARITY_CHECK;  // After 9 bits (8 data + 1 parity)
            end
            PARITY_CHECK: begin
                if (parity_odd) next_state = STOP;
                else next_state = IDLE;  // Parity error, wait for stop bit
            end
            STOP: begin
                if (in) next_state = IDLE;  // Stop bit detected
                else next_state = STOP;  // Wait for stop bit
            end
        endcase
    end

    // Output logic
    always @(posedge clk) begin
        if (state == RECEIVE && bit_count < 8) begin
            data_shift <= {in, data_shift[7:1]};
        end else if (state == STOP && in && parity_odd) begin
            done_reg <= 1;
        end
    end

    assign out_byte = data_shift;
    assign done = done_reg;

endmodule"
N/A,N/A,-1,22,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

verilog
    // State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        DATA = 3'b010,
        PARITY = 3'b011,
        STOP = 3'b100,
        ERROR = 3'b101
    } state_t;
    
    state_t state, next_state;
    reg [3:0] bit_count;  // Count the number of bits received
    reg [7:0] data;       // Store the received data byte
    reg parity_bit;       // Store the received parity bit
    wire parity_odd;      // Output from the parity module
    reg parity_reset;     // Control signal to reset the parity module
    reg stop_bit;         // Store the received stop bit

    // Instantiate the parity module
    parity parity_inst (
        .clk(clk),
        .reset(parity_reset),
        .in(in),
        .odd(parity_odd)
    );

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
            parity_reset <= 1;
        end else begin
            state <= next_state;
            if (state == DATA) begin
                data[bit_count] <= in;
                bit_count <= bit_count + 1;
            end
            if (state == PARITY) begin
                parity_bit <= in;
            end
            if (state == STOP) begin
                stop_bit <= in;
            end
            if (state == IDLE || state == ERROR) begin
                bit_count <= 0;
                parity_reset <= 1; // Reset parity check at the start or after error
            end else begin
                parity_reset <= 0;
            end
        end
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 0) // Start bit detected
                    next_state = START;
                else
                    next_state = IDLE;
            end
            START: begin
                if (bit_count == 0)
                    next_state = DATA;
                else
                    next_state = START;
            end
            DATA: begin
                if (bit_count == 8)
                    next_state = PARITY;
                else
                    next_state = DATA;
            end
            PARITY: begin
                next_state = STOP;
            end
            STOP: begin
                if (in == 1) begin // Stop bit should be 1
                    if (parity_odd == 1 && parity_bit == 1) // Odd parity check
                        next_state = IDLE;
                    else
                        next_state = ERROR;
                end else
                    next_state = STOP;
            end
            ERROR: begin
                if (in == 1) // Wait for stop bit to return to IDLE
                    next_state = IDLE;
                else
                    next_state = ERROR;
            end
            default: next_state = IDLE;
        endcase
    end

    // Output logic
    assign out_byte = data;
    assign done = (state == STOP && in == 1 && parity_odd == 1 && parity_bit == 1);

endmodule"
N/A,N/A,-1,23,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

verilog
    // State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        RECEIVE = 3'b010,
        PARITY_CHECK = 3'b011,
        STOP = 3'b100
    } state_t;

    state_t state, next_state;
    reg [7:0] data_shift;
    reg [3:0] bit_count;
    wire parity_odd;
    reg parity_reset;
    reg [7:0] out_byte_reg;
    reg done_reg;

    // Instantiate the parity module
    parity parity_inst (
        .clk(clk),
        .reset(parity_reset),
        .in(in),
        .odd(parity_odd)
    );

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
            parity_reset <= 1;
            done_reg <= 0;
        end else begin
            state <= next_state;
            if (state == RECEIVE) begin
                data_shift <= {in, data_shift[7:1]};
                bit_count <= bit_count + 1;
            end
        end
    end

    // Next state logic
    always @(*) begin
        next_state = state;
        parity_reset = 0;
        done_reg = 0;

        case (state)
            IDLE: begin
                if (~in) begin
                    next_state = START;
                    parity_reset = 1; // Reset parity on start bit
                end
            end

            START: begin
                if (in) begin
                    next_state = RECEIVE;
                    bit_count = 0;
                end
            end

            RECEIVE: begin
                if (bit_count == 8) begin
                    next_state = PARITY_CHECK;
                end
            end

            PARITY_CHECK: begin
                if (parity_odd == in) begin
                    next_state = STOP;
                end else begin
                    next_state = IDLE; // Parity failed, return to IDLE
                end
            end

            STOP: begin
                if (in) begin
                    next_state = IDLE;
                    out_byte_reg = data_shift;
                    done_reg = 1;
                end
            end
        endcase
    end

    assign out_byte = out_byte_reg;
    assign done = done_reg;

endmodule"
N/A,N/A,-1,24,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

verilog
    // State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        DATA = 3'b010,
        PARITY = 3'b011,
        STOP = 3'b100,
        ERROR = 3'b101
    } state_t;
    
    state_t state, next_state;
    reg [3:0] bit_count;  // Count the number of bits received
    reg [7:0] data;       // Store the received data byte
    reg parity_bit;       // Store the received parity bit
    wire odd_parity;      // Output from the parity module
    reg parity_reset;     // Control signal to reset the parity module
    
    // Instantiate the parity module
    parity parity_inst (
        .clk(clk),
        .reset(parity_reset),
        .in(in),
        .odd(odd_parity)
    );
    
    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
            parity_reset <= 1;
        end else begin
            state <= next_state;
            if (state == DATA) begin
                data <= {in, data[7:1]};  // Shift in data bits
                bit_count <= bit_count + 1;
            end
            if (state == PARITY) begin
                parity_bit <= in;  // Capture the parity bit
            end
            if (state == IDLE || state == STOP) begin
                parity_reset <= 1;  // Reset parity calculation
            end else begin
                parity_reset <= 0;
            end
        end
    end
    
    // Next state logic
    always @(*) begin
        next_state = state;
        case (state)
            IDLE: begin
                if (in == 0)  // Start bit detected
                    next_state = START;
            end
            START: begin
                next_state = DATA;  // Move to data reception
            end
            DATA: begin
                if (bit_count == 8)
                    next_state = PARITY;  // Move to parity bit
            end
            PARITY: begin
                next_state = STOP;  // Move to stop bit
            end
            STOP: begin
                if (in == 1) begin  // Stop bit detected
                    if (odd_parity && parity_bit == 1)  // Check odd parity
                        next_state = IDLE;  // Correct reception
                    else
                        next_state = ERROR;  // Parity error
                end
            end
            ERROR: begin
                if (in == 1)  // Wait for stop bit
                    next_state = IDLE;
            end
        endcase
    end
    
    // Output logic
    assign out_byte = data;
    assign done = (state == STOP && in == 1 && odd_parity && parity_bit == 1);

endmodule"
N/A,N/A,-1,25,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

verilog
    // State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        RECEIVE = 3'b010,
        PARITY_CHECK = 3'b011,
        STOP = 3'b100
    } state_t;

    // State variables
    reg [2:0] state, next_state;
    reg [3:0] bit_count;  // To count 9 bits (8 data + 1 parity)
    reg [7:0] data_reg;
    reg parity_bit;
    wire odd_parity;

    // Instantiate the parity module
    parity parity_inst (
        .clk(clk),
        .reset(reset || (state == IDLE) || (state == START)),
        .in(in),
        .odd(odd_parity)
    );

    // State transition
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
        end else begin
            state <= next_state;
        end
    end

    // Next state logic
    always @(*) begin
        next_state = state; // Default to stay in current state
        case (state)
            IDLE: begin
                if (!in) // Detect start bit (0)
                    next_state = START;
            end
            START: begin
                if (in) // Start bit must be 0, wait for next bit
                    next_state = IDLE;
                else
                    next_state = RECEIVE;
            end
            RECEIVE: begin
                if (bit_count == 4'd8) // After receiving 8 data bits
                    next_state = PARITY_CHECK;
            end
            PARITY_CHECK: begin
                next_state = STOP;
            end
            STOP: begin
                if (in) // Stop bit should be 1
                    next_state = IDLE;
                else
                    next_state = START; // If stop bit is incorrect, look for a new start bit
            end
        endcase
    end

    // Output logic and data path
    always @(posedge clk) begin
        if (reset) begin
            bit_count <= 0;
            data_reg <= 0;
            parity_bit <= 0;
        end else begin
            case (state)
                IDLE: begin
                    bit_count <= 0;
                end
                START: begin
                    bit_count <= 0;
                end
                RECEIVE: begin
                    data_reg <= {in, data_reg[7:1]}; // Shift in the received bit
                    bit_count <= bit_count + 1;
                end
                PARITY_CHECK: begin
                    parity_bit <= in; // Capture the parity bit
                end
                STOP: begin
                    // Do nothing
                end
            endcase
        end
    end

    // Done signal logic
    assign done = (state == STOP) && in && (odd_parity == 1'b1) && (parity_bit == 1'b1);

    // Output byte
    assign out_byte = data_reg;

endmodule"
N/A,N/A,-1,26,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

verilog
    // State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        DATA = 3'b010,
        PARITY = 3'b011,
        STOP = 3'b100
    } state_t;

    state_t state, next_state;
    reg [3:0] bit_count;  // Count the bits received (0-8 for data, 9 for parity)
    reg [7:0] data;       // Store the received data byte
    reg parity_bit;       // Store the received parity bit
    wire parity_odd;      // Output from the parity module

    // Instantiate the parity module
    parity parity_inst (
        .clk(clk),
        .reset(reset | (state == IDLE) | (state == START)),
        .in(in),
        .odd(parity_odd)
    );

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
        end else begin
            state <= next_state;
        end
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 0)  // Detect start bit
                    next_state = START;
                else
                    next_state = IDLE;
            end
            START: begin
                if (bit_count == 4'd8)
                    next_state = DATA;
                else
                    next_state = START;
            end
            DATA: begin
                if (bit_count == 4'd8)
                    next_state = PARITY;
                else
                    next_state = DATA;
            end
            PARITY: begin
                next_state = STOP;
            end
            STOP: begin
                if (in == 1)  // Stop bit should be 1
                    next_state = IDLE;
                else
                    next_state = STOP;  // Wait for stop bit
            end
            default: next_state = IDLE;
        endcase
    end

    // Output logic and bit counting
    always @(posedge clk) begin
        if (reset) begin
            bit_count <= 0;
            data <= 0;
            parity_bit <= 0;
        end else begin
            case (state)
                IDLE: begin
                    bit_count <= 0;
                    data <= 0;
                    parity_bit <= 0;
                end
                START: begin
                    if (bit_count < 4'd8) begin
                        data[bit_count] <= in;
                    end else begin
                        parity_bit <= in;
                    end
                    bit_count <= bit_count + 1;
                end
                DATA: begin
                    if (bit_count < 4'd8) begin
                        data[bit_count] <= in;
                        bit_count <= bit_count + 1;
                    end
                end
                PARITY: begin
                    parity_bit <= in;
                end
                STOP: begin
                    // Do nothing, just wait for the stop bit
                end
            endcase
        end
    end

    // Done signal logic
    assign done = (state == STOP) && (in == 1) && (parity_odd == 1) && (parity_bit == 1);
    assign out_byte = data;

endmodule"
N/A,N/A,-1,27,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

verilog
    // State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        RECEIVE = 3'b010,
        PARITY_CHECK = 3'b011,
        STOP = 3'b100
    } state_t;

    state_t state, next_state;
    reg [7:0] data_shift;
    reg [3:0] bit_count;
    wire parity_odd;
    reg parity_reset;

    // Instantiate the parity module
    parity parity_inst (
        .clk(clk),
        .reset(parity_reset),
        .in(in),
        .odd(parity_odd)
    );

    // State transition
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
            data_shift <= 0;
        end else begin
            state <= next_state;
            if (state == RECEIVE) begin
                data_shift <= {in, data_shift[7:1]};
                bit_count <= bit_count + 1;
            end
        end
    end

    // Next state logic
    always @(*) begin
        next_state = state; // Default to hold state
        parity_reset = 0;
        done = 0;
        case (state)
            IDLE: begin
                if (~in) begin // Detect start bit (0)
                    next_state = START;
                    parity_reset = 1; // Reset parity counter
                end
            end
            START: begin
                if (in) begin // Detect end of start bit
                    next_state = RECEIVE;
                    bit_count = 0;
                end
            end
            RECEIVE: begin
                if (bit_count == 8) begin
                    next_state = PARITY_CHECK;
                end
            end
            PARITY_CHECK: begin
                if (parity_odd == in) begin // Check for odd parity
                    next_state = STOP;
                end else begin
                    next_state = IDLE; // Parity error, go to IDLE
                end
            end
            STOP: begin
                if (in) begin // Stop bit should be 1
                    done = 1;
                    next_state = IDLE;
                end else begin
                    next_state = IDLE; // Error, wait for stop bit
                end
            end
        endcase
    end

    // Output logic
    assign out_byte = data_shift;

endmodule"
N/A,N/A,-1,28,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

verilog
    // State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        RECEIVE = 3'b010,
        PARITY_CHECK = 3'b011,
        STOP = 3'b100
    } state_t;

    state_t state, next_state;
    reg [3:0] bit_count;
    reg [7:0] shift_reg;
    wire parity_odd;
    reg parity_reset;

    // Instantiate the parity module
    parity parity_inst (
        .clk(clk),
        .reset(parity_reset),
        .in(in),
        .odd(parity_odd)
    );

    // State transition
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
            shift_reg <= 0;
            parity_reset <= 1;
        end else begin
            state <= next_state;
            if (state == RECEIVE) begin
                shift_reg <= {in, shift_reg[7:1]};
                bit_count <= bit_count + 1;
            end
            if (state == START) begin
                parity_reset <= 0; // Start counting parity
            end
            if (state == STOP) begin
                parity_reset <= 1; // Reset parity counter
            end
        end
    end

    // Next state logic
    always @(*) begin
        next_state = state; // Default: stay in current state
        case (state)
            IDLE: begin
                if (!in) // Detect start bit (0)
                    next_state = START;
            end
            START: begin
                next_state = RECEIVE;
            end
            RECEIVE: begin
                if (bit_count == 8)
                    next_state = PARITY_CHECK;
            end
            PARITY_CHECK: begin
                if (parity_odd == in) // Check if parity matches
                    next_state = STOP;
                else
                    next_state = IDLE; // Parity error, go back to IDLE
            end
            STOP: begin
                if (in) // Check stop bit (1)
                    next_state = IDLE;
            end
        endcase
    end

    // Output logic
    assign out_byte = shift_reg;
    assign done = (state == STOP) && in; // Assert done if stop bit is correct

endmodule"
N/A,N/A,-1,29,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

verilog
    // State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        RECEIVE = 3'b010,
        PARITY_CHECK = 3'b011,
        STOP = 3'b100
    } state_t;

    // State registers
    reg [2:0] state, next_state;
    reg [3:0] bit_count;  // To count bits received
    reg [7:0] data_byte;  // To store received data byte
    reg parity_bit;       // To store received parity bit
    wire parity_odd;      // Output from the parity module

    // Instantiate the parity module
    parity parity_inst (
        .clk(clk),
        .reset(reset || (state == IDLE) || (state == START)),
        .in(in),
        .odd(parity_odd)
    );

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
        end else begin
            state <= next_state;
        end
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 0) // Look for start bit
                    next_state = START;
                else
                    next_state = IDLE;
            end
            START: begin
                if (bit_count == 4'd8) // 8 data bits received
                    next_state = PARITY_CHECK;
                else
                    next_state = RECEIVE;
            end
            RECEIVE: begin
                next_state = (bit_count == 4'd8) ? PARITY_CHECK : RECEIVE;
            end
            PARITY_CHECK: begin
                next_state = STOP;
            end
            STOP: begin
                if (in == 1) // Stop bit should be high
                    next_state = IDLE;
                else
                    next_state = STOP;
            end
            default: next_state = IDLE;
        endcase
    end

    // Output and data path logic
    always @(posedge clk) begin
        if (reset) begin
            bit_count <= 4'd0;
            data_byte <= 8'd0;
            parity_bit <= 1'b0;
        end else begin
            case (state)
                IDLE: begin
                    bit_count <= 4'd0;
                end
                START: begin
                    if (bit_count < 4'd8) begin
                        data_byte[bit_count] <= in;
                        bit_count <= bit_count + 1'b1;
                    end
                end
                RECEIVE: begin
                    if (bit_count < 4'd8) begin
                        data_byte[bit_count] <= in;
                        bit_count <= bit_count + 1'b1;
                    end else begin
                        parity_bit <= in; // Capture the parity bit
                    end
                end
                PARITY_CHECK: begin
                    // Nothing to do here, just transition to STOP
                end
                STOP: begin
                    // Nothing to do here, just wait for the stop bit
                end
            endcase
        end
    end

    // Assign outputs
    assign out_byte = data_byte;
    assign done = (state == STOP) && (in == 1) && (parity_odd == 1);

endmodule"
N/A,N/A,-1,30,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

verilog
    // State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        RECEIVE = 3'b010,
        PARITY_CHECK = 3'b011,
        STOP = 3'b100
    } state_t;

    state_t state, next_state;
    reg [7:0] data_shift;
    reg [3:0] bit_count;
    wire parity_odd;
    reg parity_reset;
    reg [7:0] out_byte_reg;
    reg done_reg;

    // Instantiate the parity module
    parity parity_inst (
        .clk(clk),
        .reset(parity_reset),
        .in(in),
        .odd(parity_odd)
    );

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
            parity_reset <= 1;
            done_reg <= 0;
        end else begin
            state <= next_state;
            if (state == RECEIVE) begin
                data_shift <= {in, data_shift[7:1]};
                bit_count <= bit_count + 1;
            end
        end
    end

    // Next state logic
    always @(*) begin
        next_state = state;
        parity_reset = 0;
        done_reg = 0;

        case (state)
            IDLE: begin
                if (~in) begin
                    next_state = START;
                end
            end
            START: begin
                if (bit_count == 4'd0) begin
                    next_state = RECEIVE;
                end
            end
            RECEIVE: begin
                if (bit_count == 4'd8) begin
                    next_state = PARITY_CHECK;
                end
            end
            PARITY_CHECK: begin
                if (parity_odd == in) begin
                    next_state = STOP;
                end else begin
                    next_state = IDLE;
                end
            end
            STOP: begin
                if (in) begin
                    out_byte_reg = data_shift;
                    done_reg = 1;
                    next_state = IDLE;
                end
            end
        endcase
    end

    // Output logic
    assign out_byte = out_byte_reg;
    assign done = done_reg;

    // Reset the parity checker at the start of a new byte
    always @(posedge clk) begin
        if (reset || state == IDLE) begin
            parity_reset <= 1;
        end else begin
            parity_reset <= 0;
        end
    end

endmodule"
N/A,N/A,-1,31,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

verilog
    // State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        DATA = 3'b010,
        PARITY = 3'b011,
        STOP = 3'b100,
        ERROR = 3'b101
    } state_t;
    
    state_t state, next_state;
    reg [3:0] bit_count;  // Count the number of bits received
    reg [7:0] data;       // Store the received data byte
    reg parity_bit;       // Store the received parity bit
    wire odd_parity;      // Output from the parity module
    reg parity_reset;     // Control signal to reset the parity module
    
    // Instantiate the parity module
    parity parity_inst (
        .clk(clk),
        .reset(parity_reset),
        .in(in),
        .odd(odd_parity)
    );
    
    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
            parity_reset <= 1;
        end else begin
            state <= next_state;
            if (state == DATA) begin
                data <= {in, data[7:1]};  // Shift in data bits
                bit_count <= bit_count + 1;
            end
            if (state == PARITY) begin
                parity_bit <= in;  // Capture the parity bit
            end
            if (state == IDLE || state == STOP) begin
                parity_reset <= 1;  // Reset parity calculation
            end else begin
                parity_reset <= 0;
            end
        end
    end
    
    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (!in) next_state = START;  // Detect start bit (0)
                else next_state = IDLE;
            end
            START: begin
                next_state = DATA;  // Move to data reception
            end
            DATA: begin
                if (bit_count == 8) next_state = PARITY;  // After 8 bits, check parity
                else next_state = DATA;
            end
            PARITY: begin
                next_state = STOP;  // Move to stop bit checking
            end
            STOP: begin
                if (in && (odd_parity == 1'b1) && (parity_bit == 1'b1)) next_state = IDLE;  // Correct stop bit and odd parity
                else if (!in) next_state = ERROR;  // Incorrect stop bit
                else next_state = IDLE;  // Reset for next byte
            end
            ERROR: begin
                if (in) next_state = IDLE;  // Wait for line to go idle
                else next_state = ERROR;
            end
            default: next_state = IDLE;
        endcase
    end
    
    // Output logic
    assign done = (state == STOP) && (in) && (odd_parity == 1'b1) && (parity_bit == 1'b1);
    assign out_byte = data;
    
endmodule"
N/A,N/A,-1,32,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

verilog
    // State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        DATA = 3'b010,
        PARITY = 3'b011,
        STOP = 3'b100
    } state_t;

    state_t state, next_state;
    reg [3:0] bit_count;  // Count the number of bits received
    reg [7:0] data_byte;  // Store the received data byte
    reg parity_bit;       // Store the received parity bit
    wire odd;             // Output of the parity checker

    // Instantiate the parity module
    parity parity_checker (
        .clk(clk),
        .reset(reset | (state == IDLE)),
        .in(in),
        .odd(odd)
    );

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
            data_byte <= 8'b0;
            parity_bit <= 0;
        end else begin
            state <= next_state;
            if (state == DATA && bit_count < 8) begin
                data_byte <= {in, data_byte[7:1]};
                bit_count <= bit_count + 1;
            end else if (state == PARITY) begin
                parity_bit <= in;
            end else if (state == STOP) begin
                bit_count <= 0;
            end
        end
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (!in) next_state = START;  // Detect start bit (0)
                else next_state = IDLE;
            end
            START: begin
                if (in) next_state = DATA;  // Move to data state when start bit is done
                else next_state = START;
            end
            DATA: begin
                if (bit_count == 8) next_state = PARITY;  // After 8 data bits, check parity
                else next_state = DATA;
            end
            PARITY: begin
                next_state = STOP;  // Move to stop state after parity bit
            end
            STOP: begin
                if (in) next_state = IDLE;  // Stop bit detected, go back to IDLE
                else next_state = STOP;
            end
            default: next_state = IDLE;
        endcase
    end

    // Output logic
    assign done = (state == STOP) && in && (odd == 1'b1) && (parity_bit == 1'b0);
    assign out_byte = data_byte;

endmodule"
N/A,N/A,-1,33,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

verilog
    // State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        RECEIVE = 3'b010,
        PARITY_CHECK = 3'b011,
        STOP = 3'b100
    } state_t;

    state_t state, next_state;
    reg [7:0] data_shift;
    reg [3:0] bit_count;
    wire parity_odd;
    reg parity_reset;
    reg done_reg;

    // Instantiate the parity module
    parity parity_inst (
        .clk(clk),
        .reset(parity_reset),
        .in(in),
        .odd(parity_odd)
    );

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
            done_reg <= 0;
            parity_reset <= 1;
        end else begin
            state <= next_state;
            if (state == RECEIVE) bit_count <= bit_count + 1'b1;
            if (state == STOP) done_reg <= 0;
            if (state == PARITY_CHECK && parity_odd) done_reg <= 1;
        end
    end

    // Next state logic
    always @(*) begin
        next_state = state;
        parity_reset = 0;
        case (state)
            IDLE: begin
                if (!in) next_state = START;  // Detect start bit
            end
            START: begin
                next_state = RECEIVE;
                bit_count = 0;
                parity_reset = 1;
            end
            RECEIVE: begin
                if (bit_count == 8) next_state = PARITY_CHECK;
            end
            PARITY_CHECK: begin
                if (parity_odd) next_state = STOP;
                else next_state = IDLE;  // Parity error, go back to idle
            end
            STOP: begin
                if (in) next_state = IDLE;  // Stop bit detected
                else next_state = START;  // If no stop bit, assume it's a new start bit
            end
        endcase
    end

    // Output logic
    always @(posedge clk) begin
        if (state == RECEIVE) begin
            data_shift <= {in, data_shift[7:1]};
        end
    end

    assign out_byte = data_shift;
    assign done = done_reg;

endmodule"
N/A,N/A,-1,34,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

verilog
    // State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        DATA = 3'b010,
        PARITY = 3'b011,
        STOP = 3'b100,
        DONE = 3'b101
    } state_t;
    
    state_t state, next_state;
    reg [3:0] bit_count;  // Count the number of bits received
    reg [7:0] data;       // Store the received data byte
    reg parity_bit;       // Store the received parity bit
    wire odd_parity;      // Output from the parity module

    // Instantiate the parity module
    parity parity_inst (
        .clk(clk),
        .reset(reset || state == START),
        .in(in),
        .odd(odd_parity)
    );

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
            data <= 0;
            parity_bit <= 0;
        end else begin
            state <= next_state;
            if (state == DATA) begin
                data <= {in, data[7:1]};  // Shift in the data bits
            end
            if (state == PARITY) begin
                parity_bit <= in;  // Capture the parity bit
            end
            if (state == DATA || state == PARITY) begin
                bit_count <= bit_count + 1;
            end else begin
                bit_count <= 0;
            end
        end
    end

    // Next state logic
    always @(*) begin
        next_state = state;
        case (state)
            IDLE: begin
                if (in == 0)  // Detect start bit
                    next_state = START;
            end
            START: begin
                next_state = DATA;
            end
            DATA: begin
                if (bit_count == 8)
                    next_state = PARITY;
            end
            PARITY: begin
                if (bit_count == 9)
                    next_state = STOP;
            end
            STOP: begin
                if (in == 1)  // Stop bit must be high
                    next_state = DONE;
                else
                    next_state = IDLE;  // If stop bit is not high, go back to IDLE
            end
            DONE: begin
                next_state = IDLE;  // Return to IDLE after done
            end
        endcase
    end

    // Output logic
    assign out_byte = data;
    assign done = (state == DONE) && (parity_bit == odd_parity);

endmodule"
N/A,N/A,-1,35,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

verilog
    // State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        RECEIVE = 3'b010,
        PARITY_CHECK = 3'b011,
        STOP = 3'b100
    } state_t;

    state_t state, next_state;
    reg [7:0] data_shift;
    reg [3:0] bit_count;
    wire parity_odd;
    reg parity_reset;
    reg done_reg;

    // Instantiate the parity module
    parity parity_inst (
        .clk(clk),
        .reset(parity_reset),
        .in(in),
        .odd(parity_odd)
    );

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
            done_reg <= 0;
            parity_reset <= 1;
        end else begin
            state <= next_state;
            if (state == RECEIVE) bit_count <= bit_count + 1'b1;
            if (state == STOP) done_reg <= 0;
            if (state == PARITY_CHECK && parity_odd) done_reg <= 1;
        end
    end

    // Next state logic
    always @(*) begin
        next_state = state;
        parity_reset = 0;
        case (state)
            IDLE: begin
                if (!in) next_state = START;  // Detect start bit
            end
            START: begin
                next_state = RECEIVE;
                bit_count = 0;
                parity_reset = 1;
            end
            RECEIVE: begin
                if (bit_count == 8) next_state = PARITY_CHECK;
            end
            PARITY_CHECK: begin
                if (in) next_state = STOP;  // Stop bit expected
                else next_state = IDLE;  // Error, wait for stop bit
            end
            STOP: begin
                if (in) next_state = IDLE;  // Go back to IDLE after stop bit
            end
        endcase
    end

    // Output logic
    always @(posedge clk) begin
        if (state == RECEIVE) data_shift <= {in, data_shift[7:1]};
    end

    assign out_byte = data_shift;
    assign done = done_reg;

endmodule"
N/A,N/A,-1,36,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

verilog
    // State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        DATA = 3'b010,
        PARITY = 3'b011,
        STOP = 3'b100,
        ERROR = 3'b101
    } state_t;
    
    state_t state, next_state;
    reg [3:0] bit_count;  // Count the number of bits received
    reg [7:0] data;       // Store the received data byte
    reg parity_bit;       // Store the received parity bit
    wire parity_odd;      // Output from the parity module
    reg parity_reset;     // Control signal to reset the parity module
    reg stop_bit;         // Store the received stop bit

    // Instantiate the parity module
    parity parity_inst (
        .clk(clk),
        .reset(parity_reset),
        .in(in),
        .odd(parity_odd)
    );

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
            parity_reset <= 1;
        end else begin
            state <= next_state;
            if (state == DATA) begin
                data[bit_count] <= in;
                bit_count <= bit_count + 1;
            end
            else if (state == PARITY) begin
                parity_bit <= in;
            end
            else if (state == STOP) begin
                stop_bit <= in;
            end
        end
    end

    // Next state logic
    always @(*) begin
        next_state = state;  // Default to staying in the same state
        parity_reset = 0;    // Default to not resetting the parity
        
        case(state)
            IDLE: begin
                if (in == 0)  // Start bit detected
                    next_state = START;
            end
            START: begin
                if (in == 0)  // Confirm start bit is still low
                    next_state = DATA;
                else
                    next_state = IDLE;  // False start bit
            end
            DATA: begin
                if (bit_count == 8)
                    next_state = PARITY;
            end
            PARITY: begin
                next_state = STOP;
            end
            STOP: begin
                if (in == 1) begin  // Valid stop bit
                    if (parity_bit == parity_odd)  // Check odd parity
                        next_state = IDLE;
                    else
                        next_state = ERROR;  // Parity error
                end else
                    next_state = ERROR;  // Stop bit error
            end
            ERROR: begin
                if (in == 1)  // Wait for stop bit to reset
                    next_state = IDLE;
            end
        endcase
    end

    // Output logic
    assign out_byte = data;
    assign done = (state == STOP) && (in == 1) && (parity_bit == parity_odd);

endmodule"
N/A,N/A,-1,37,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

verilog
    // State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        DATA = 3'b010,
        PARITY = 3'b011,
        STOP = 3'b100,
        ERROR = 3'b101
    } state_t;
    
    state_t state, next_state;
    reg [3:0] bit_count;  // Count the number of bits received
    reg [7:0] data;       // Store the received data byte
    reg parity_bit;       // Store the received parity bit
    wire odd_parity;      // Output from the parity module
    reg parity_reset;     // Control signal to reset the parity module
    reg stop_error;       // Flag for stop bit error

    // Instantiate the parity module
    parity parity_inst (
        .clk(clk),
        .reset(parity_reset),
        .in(in),
        .odd(odd_parity)
    );

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
            parity_reset <= 1;
            stop_error <= 0;
        end else begin
            state <= next_state;
        end
    end

    // Next state logic
    always @(*) begin
        next_state = state; // Default to stay in the same state
        parity_reset = 0;   // Default is not to reset parity
        stop_error = 0;     // Default no stop error

        case (state)
            IDLE: begin
                if (~in) begin // Start bit detected
                    next_state = START;
                    parity_reset = 1; // Reset parity at the start
                end
            end
            START: begin
                next_state = DATA;
            end
            DATA: begin
                if (bit_count == 8) begin
                    next_state = PARITY;
                end
            end
            PARITY: begin
                parity_bit = in;
                if (odd_parity == parity_bit) begin
                    next_state = STOP;
                end else begin
                    next_state = ERROR;
                end
            end
            STOP: begin
                if (in) begin // Stop bit is correct (should be high)
                    next_state = IDLE;
                end else begin
                    stop_error = 1;
                    next_state = ERROR;
                end
            end
            ERROR: begin
                if (in) begin // Wait for a stop bit to return to IDLE
                    next_state = IDLE;
                end
            end
        endcase
    end

    // Output logic
    always @(posedge clk) begin
        if (reset) begin
            bit_count <= 0;
            data <= 0;
        end else begin
            case (state)
                START: begin
                    bit_count <= 0;
                end
                DATA: begin
                    data <= {in, data[7:1]}; // Shift in data bits
                    bit_count <= bit_count + 1;
                end
            endcase
        end
    end

    assign out_byte = data;
    assign done = (state == STOP) && (in) && (odd_parity == parity_bit) && ~stop_error;

endmodule"
N/A,N/A,-1,38,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

verilog
    // State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        RECEIVE = 3'b010,
        PARITY_CHECK = 3'b011,
        STOP = 3'b100
    } state_t;

    state_t state, next_state;
    reg [7:0] data_shift;
    reg [3:0] bit_count;
    wire parity_odd;
    reg parity_reset;
    reg done_reg;

    // Instantiate the parity module
    parity parity_inst (
        .clk(clk),
        .reset(parity_reset),
        .in(in),
        .odd(parity_odd)
    );

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
            done_reg <= 0;
            parity_reset <= 1;
        end else begin
            state <= next_state;
            if (state == RECEIVE) bit_count <= bit_count + 1'b1;
            if (state == STOP) done_reg <= 0;
            if (state == PARITY_CHECK && parity_odd) done_reg <= 1;
        end
    end

    // Next state logic
    always @(*) begin
        next_state = state;
        parity_reset = 0;
        case (state)
            IDLE: begin
                if (!in) next_state = START;  // Detect start bit
            end
            START: begin
                next_state = RECEIVE;
                parity_reset = 1;
            end
            RECEIVE: begin
                if (bit_count == 8) next_state = PARITY_CHECK;
            end
            PARITY_CHECK: begin
                if (parity_odd) next_state = STOP;
                else next_state = IDLE;  // Parity error, restart
            end
            STOP: begin
                if (in) next_state = IDLE;  // Stop bit detected, go to idle
            end
        endcase
    end

    // Output logic
    always @(posedge clk) begin
        if (state == RECEIVE) begin
            data_shift <= {in, data_shift[7:1]};  // Shift in data bits
        end
    end

    assign out_byte = data_shift;
    assign done = done_reg;

endmodule"
N/A,N/A,-1,39,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

verilog
    // State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        DATA = 3'b010,
        PARITY = 3'b011,
        STOP = 3'b100,
        ERROR = 3'b101
    } state_t;
    
    reg [2:0] state, next_state;
    reg [3:0] bit_count;
    reg [7:0] data_byte;
    wire odd_parity;
    reg parity_reset;
    reg done_reg;
    
    // Instantiate the parity module
    parity parity_inst (
        .clk(clk),
        .reset(parity_reset),
        .in(in),
        .odd(odd_parity)
    );
    
    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
            data_byte <= 0;
            parity_reset <= 1;
            done_reg <= 0;
        end else begin
            state <= next_state;
            if (state == DATA) begin
                data_byte <= {in, data_byte[7:1]};
                bit_count <= bit_count + 1;
            end else if (state == START) begin
                bit_count <= 0;
            end
        end
    end
    
    // Next state logic
    always @(*) begin
        next_state = state;
        done_reg = 0;
        parity_reset = 0;
        
        case (state)
            IDLE: begin
                if (!in) begin // Start bit detected
                    next_state = START;
                    parity_reset = 1;
                end
            end
            
            START: begin
                if (bit_count == 4'd0) begin
                    next_state = DATA;
                end
            end
            
            DATA: begin
                if (bit_count == 4'd8) begin
                    next_state = PARITY;
                end
            end
            
            PARITY: begin
                if (odd_parity == in) begin // Check for odd parity
                    next_state = STOP;
                end else begin
                    next_state = ERROR;
                end
            end
            
            STOP: begin
                if (in) begin // Stop bit detected
                    done_reg = 1;
                    next_state = IDLE;
                end else begin
                    next_state = ERROR;
                end
            end
            
            ERROR: begin
                if (in) begin // Wait for stop bit to return to IDLE
                    next_state = IDLE;
                end
            end
        endcase
    end
    
    // Output logic
    assign out_byte = data_byte;
    assign done = done_reg;

endmodule"
N/A,N/A,-1,40,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

verilog
    // State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        RECEIVE = 3'b010,
        PARITY_CHECK = 3'b011,
        STOP = 3'b100
    } state_t;

    state_t state, next_state;
    reg [7:0] data_shift;
    reg [3:0] bit_count;
    wire parity_odd;
    reg parity_reset;
    reg done_reg;

    // Instantiate the parity module
    parity parity_inst (
        .clk(clk),
        .reset(parity_reset),
        .in(in),
        .odd(parity_odd)
    );

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            data_shift <= 8'd0;
            bit_count <= 4'd0;
            done_reg <= 1'b0;
            parity_reset <= 1'b1;
        end else begin
            state <= next_state;
            if (state == RECEIVE) begin
                data_shift <= {in, data_shift[7:1]};
                bit_count <= bit_count + 1;
            end
            if (state == PARITY_CHECK) begin
                done_reg <= (parity_odd);
            end
            if (state == STOP) begin
                done_reg <= 1'b0;
            end
        end
    end

    // Next state logic
    always @(*) begin
        next_state = state;
        parity_reset = 1'b0;
        case (state)
            IDLE: begin
                if (in == 0) begin
                    next_state = START;
                    parity_reset = 1'b1;
                end
            end
            START: begin
                if (in == 1) begin
                    next_state = RECEIVE;
                    bit_count = 4'd0;
                end
            end
            RECEIVE: begin
                if (bit_count == 4'd8) begin
                    next_state = PARITY_CHECK;
                end
            end
            PARITY_CHECK: begin
                if (in == 1) begin
                    next_state = STOP;
                end else begin
                    next_state = IDLE; // Error, go back to IDLE
                end
            end
            STOP: begin
                if (in == 1) begin
                    next_state = IDLE;
                end
            end
        endcase
    end

    assign out_byte = data_shift;
    assign done = done_reg;

endmodule"
N/A,N/A,-1,41,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

verilog
    // State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        DATA = 3'b010,
        PARITY = 3'b011,
        STOP = 3'b100
    } state_t;

    state_t state, next_state;
    reg [3:0] bit_count;  // Count the number of bits received
    reg [7:0] data_byte;  // Store the received data byte
    reg parity_bit;       // Store the received parity bit
    wire odd;             // Output of the parity checker

    // Instantiate the parity module
    parity parity_checker (
        .clk(clk),
        .reset(reset | (state == IDLE)),
        .in(in),
        .odd(odd)
    );

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
            data_byte <= 8'b0;
            parity_bit <= 0;
        end else begin
            state <= next_state;
            if (state == DATA && bit_count < 8) begin
                data_byte <= {in, data_byte[7:1]};
                bit_count <= bit_count + 1;
            end else if (state == PARITY) begin
                parity_bit <= in;
            end else if (state == STOP) begin
                bit_count <= 0;
            end
        end
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (!in) next_state = START;  // Detect start bit (0)
                else next_state = IDLE;
            end
            START: begin
                if (in) next_state = DATA;  // Move to data state when start bit is done
                else next_state = START;
            end
            DATA: begin
                if (bit_count == 8) next_state = PARITY;  // After 8 data bits, check parity
                else next_state = DATA;
            end
            PARITY: begin
                next_state = STOP;  // Move to stop state after parity bit
            end
            STOP: begin
                if (in) next_state = IDLE;  // Stop bit detected, go to IDLE
                else next_state = STOP;  // Wait for stop bit
            end
            default: next_state = IDLE;
        endcase
    end

    // Output logic
    assign out_byte = data_byte;
    assign done = (state == STOP) && in && (odd == parity_bit);  // Assert done if stop bit is correct and parity matches

endmodule"
N/A,N/A,-1,42,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

verilog
    // State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        DATA = 3'b010,
        PARITY = 3'b011,
        STOP = 3'b100
    } state_t;

    state_t state, next_state;
    reg [3:0] bit_count;  // Count the number of bits received
    reg [7:0] data_byte;  // Store the received data byte
    reg parity_bit;       // Store the received parity bit
    wire odd;             // Output of the parity checker

    // Instantiate the parity module
    parity parity_checker (
        .clk(clk),
        .reset(reset | (state == IDLE)),
        .in(in),
        .odd(odd)
    );

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
            data_byte <= 8'b0;
            parity_bit <= 0;
        end else begin
            state <= next_state;
            if (state == DATA && bit_count < 8) begin
                data_byte <= {in, data_byte[7:1]};
                bit_count <= bit_count + 1;
            end else if (state == PARITY) begin
                parity_bit <= in;
            end else if (state == STOP) begin
                bit_count <= 0;
            end
        end
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (!in) next_state = START;  // Detect start bit (0)
                else next_state = IDLE;
            end
            START: begin
                next_state = DATA;
            end
            DATA: begin
                if (bit_count == 8) next_state = PARITY;
                else next_state = DATA;
            end
            PARITY: begin
                next_state = STOP;
            end
            STOP: begin
                if (in) next_state = IDLE;  // Detect stop bit (1)
                else next_state = STOP;
            end
            default: next_state = IDLE;
        endcase
    end

    // Output logic
    assign out_byte = data_byte;
    assign done = (state == STOP) && in && (parity_bit == odd);  // Check stop bit and parity

endmodule"
N/A,N/A,-1,43,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

verilog
    // State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        DATA = 3'b010,
        PARITY = 3'b011,
        STOP = 3'b100,
        ERROR = 3'b101
    } state_t;
    
    state_t state, next_state;
    reg [3:0] bit_count;  // Count the number of bits received
    reg [7:0] data;       // Store the received data byte
    reg parity_bit;       // Store the received parity bit
    wire parity_odd;      // Output from the parity module
    reg parity_reset;     // Control signal to reset the parity module
    reg stop_bit;         // Store the received stop bit

    // Instantiate the parity module
    parity parity_inst (
        .clk(clk),
        .reset(parity_reset),
        .in(in),
        .odd(parity_odd)
    );

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
            parity_reset <= 1;
        end else begin
            state <= next_state;
            if (state == DATA) begin
                data[bit_count] <= in;
                bit_count <= bit_count + 1;
            end
            if (state == PARITY) begin
                parity_bit <= in;
            end
            if (state == STOP) begin
                stop_bit <= in;
            end
            if (state == IDLE || state == ERROR) begin
                bit_count <= 0;
                parity_reset <= 1; // Reset parity check at the start or after error
            end else begin
                parity_reset <= 0;
            end
        end
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 0) // Start bit detected
                    next_state = START;
                else
                    next_state = IDLE;
            end
            START: begin
                if (bit_count == 0)
                    next_state = DATA;
                else
                    next_state = START;
            end
            DATA: begin
                if (bit_count == 8)
                    next_state = PARITY;
                else
                    next_state = DATA;
            end
            PARITY: begin
                next_state = STOP;
            end
            STOP: begin
                if (in == 1) begin // Stop bit should be 1
                    if (parity_odd == 1 && parity_bit == 0 || parity_odd == 0 && parity_bit == 1) // Odd parity check
                        next_state = IDLE;
                    else
                        next_state = ERROR; // Parity error
                end else
                    next_state = STOP;
            end
            ERROR: begin
                if (in == 1) // Wait for stop bit to return to IDLE
                    next_state = IDLE;
                else
                    next_state = ERROR;
            end
            default: next_state = IDLE;
        endcase
    end

    // Output logic
    assign done = (state == STOP) && (in == 1) && ((parity_odd == 1 && parity_bit == 0) || (parity_odd == 0 && parity_bit == 1));
    assign out_byte = data;

endmodule"
N/A,N/A,-1,44,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

verilog
    // State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        DATA = 3'b010,
        PARITY = 3'b011,
        STOP = 3'b100
    } state_t;

    state_t state, next_state;
    reg [3:0] bit_count;  // Count the number of bits received
    reg [7:0] data_reg;   // Store the received data byte
    reg parity_bit;       // Store the received parity bit
    wire odd;             // Output of the parity checker

    // Instantiate the parity module
    parity parity_checker (
        .clk(clk),
        .reset(reset | (state == IDLE)),
        .in(in),
        .odd(odd)
    );

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
            data_reg <= 8'b0;
            parity_bit <= 0;
        end else begin
            state <= next_state;
            if (state == DATA && bit_count < 8) begin
                data_reg <= {in, data_reg[7:1]};
                bit_count <= bit_count + 1;
            end else if (state == PARITY) begin
                parity_bit <= in;
            end else if (state == STOP) begin
                bit_count <= 0;
            end
        end
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (!in) next_state = START;  // Detect start bit (0)
                else next_state = IDLE;
            end
            START: begin
                if (in) next_state = DATA;  // Move to data state when start bit is done
                else next_state = START;
            end
            DATA: begin
                if (bit_count == 8) next_state = PARITY;  // After 8 data bits, check parity
                else next_state = DATA;
            end
            PARITY: begin
                next_state = STOP;  // Move to stop state after parity bit
            end
            STOP: begin
                if (in) next_state = IDLE;  // Stop bit detected, go to IDLE
                else next_state = STOP;  // Wait for stop bit
            end
            default: next_state = IDLE;
        endcase
    end

    // Output logic
    assign out_byte = data_reg;
    assign done = (state == STOP) && in && (odd == parity_bit);  // Assert done if stop bit is correct and parity matches

endmodule"
N/A,N/A,-1,45,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

verilog
    // State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        RECEIVE = 3'b010,
        PARITY_CHECK = 3'b011,
        STOP = 3'b100
    } state_t;

    state_t state, next_state;
    reg [7:0] data_shift;
    reg [3:0] bit_count;
    wire parity_odd;
    reg parity_reset;
    reg done_reg;

    // Instantiate the parity module
    parity parity_inst (
        .clk(clk),
        .reset(parity_reset),
        .in(in),
        .odd(parity_odd)
    );

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            data_shift <= 8'd0;
            bit_count <= 4'd0;
            done_reg <= 1'b0;
        end else begin
            state <= next_state;
            if (state == RECEIVE) begin
                data_shift <= {in, data_shift[7:1]};
                bit_count <= bit_count + 1'b1;
            end
            if (state == STOP) begin
                done_reg <= 1'b1;
            end else begin
                done_reg <= 1'b0;
            end
        end
    end

    // Next state logic
    always @(*) begin
        next_state = state;
        parity_reset = 1'b0;
        case (state)
            IDLE: begin
                if (in == 1'b0) begin
                    next_state = START;
                end
            end
            START: begin
                next_state = RECEIVE;
                parity_reset = 1'b1; // Reset parity at the start of receiving
            end
            RECEIVE: begin
                if (bit_count == 4'd8) begin
                    next_state = PARITY_CHECK;
                end
            end
            PARITY_CHECK: begin
                if (parity_odd) begin
                    next_state = STOP;
                end else begin
                    next_state = IDLE; // Parity failed, go back to IDLE
                end
            end
            STOP: begin
                if (in == 1'b1) begin
                    next_state = IDLE; // Stop bit detected, go back to IDLE
                end else begin
                    next_state = START; // No stop bit, look for new start bit
                end
            end
        endcase
    end

    assign out_byte = data_shift;
    assign done = done_reg;

endmodule"
N/A,N/A,-1,46,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

verilog
    // State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        RECEIVE = 3'b010,
        PARITY_CHECK = 3'b011,
        STOP = 3'b100
    } state_t;

    state_t state, next_state;
    reg [7:0] data_shift;
    reg [3:0] bit_count;
    wire parity_odd;
    reg parity_reset;
    reg done_reg;

    // Instantiate the parity module
    parity parity_inst (
        .clk(clk),
        .reset(parity_reset),
        .in(in),
        .odd(parity_odd)
    );

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
            done_reg <= 0;
            parity_reset <= 1;
        end else begin
            state <= next_state;
            if (state == RECEIVE) bit_count <= bit_count + 1'b1;
            if (state == START) parity_reset <= 0;
            if (state == STOP) done_reg <= 0;
        end
    end

    // Next state logic
    always @(*) begin
        next_state = state;  // Default to hold state
        case (state)
            IDLE: begin
                if (in == 0)  // Detect start bit
                    next_state = START;
            end
            START: begin
                if (in == 0)  // Confirm start bit
                    next_state = RECEIVE;
            end
            RECEIVE: begin
                if (bit_count == 8)  // After receiving 8 data bits
                    next_state = PARITY_CHECK;
            end
            PARITY_CHECK: begin
                if (parity_odd == 1 && in == 1)  // Check parity and stop bit
                    next_state = STOP;
                else
                    next_state = IDLE;  // Parity failed, reset
            end
            STOP: begin
                if (in == 1) begin  // Detect stop bit
                    next_state = IDLE;
                    done_reg = 1;
                end
            end
        endcase
    end

    // Output logic
    always @(posedge clk) begin
        if (state == RECEIVE && bit_count < 8)
            data_shift <= {in, data_shift[7:1]};  // Shift in bits
    end

    assign out_byte = data_shift;
    assign done = done_reg;

endmodule"
N/A,N/A,-1,47,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

verilog
    // State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        DATA = 3'b010,
        PARITY = 3'b011,
        STOP = 3'b100,
        ERROR = 3'b101
    } state_t;
    
    reg [2:0] state, next_state;
    reg [3:0] bit_count;
    reg [7:0] data_byte;
    wire odd_parity;
    
    // Parity checker instance
    parity parity_checker (
        .clk(clk),
        .reset(reset | (state == START)),
        .in(in),
        .odd(odd_parity)
    );

    // State transition
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
        end else begin
            state <= next_state;
            if (state == DATA) begin
                data_byte[bit_count] <= in;
                bit_count <= bit_count + 1;
            end
        end
    end

    // Next state logic
    always @(*) begin
        next_state = state; // Default to hold state
        case (state)
            IDLE: begin
                if (!in) next_state = START; // Detect start bit
            end
            START: begin
                if (bit_count == 0) next_state = DATA;
            end
            DATA: begin
                if (bit_count == 8) next_state = PARITY;
            end
            PARITY: begin
                if (odd_parity == in) next_state = STOP;
                else next_state = ERROR;
            end
            STOP: begin
                if (in) next_state = IDLE; // Detect stop bit
                else next_state = ERROR;
            end
            ERROR: begin
                if (in) next_state = IDLE; // Wait for stop bit
            end
        endcase
    end

    // Output logic
    assign done = (state == STOP) && in;
    assign out_byte = data_byte;

endmodule"
N/A,N/A,-1,48,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

verilog
    // State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        RECEIVE = 3'b010,
        PARITY_CHECK = 3'b011,
        STOP = 3'b100
    } state_t;

    // State registers
    reg [2:0] state, next_state;
    reg [3:0] bit_count; // Count 9 bits (8 data + 1 parity)
    reg [7:0] data_reg;
    reg parity_bit;
    wire odd_parity;

    // Instantiate the parity module
    parity parity_checker (
        .clk(clk),
        .reset(reset | (state == IDLE) | (state == START)),
        .in(in),
        .odd(odd_parity)
    );

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
        end else begin
            state <= next_state;
            if (state == RECEIVE) begin
                bit_count <= bit_count + 1;
            end else if (state == IDLE) begin
                bit_count <= 0;
            end
        end
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (!in) // Detect start bit (0)
                    next_state = START;
                else
                    next_state = IDLE;
            end
            START: begin
                next_state = RECEIVE;
            end
            RECEIVE: begin
                if (bit_count == 8)
                    next_state = PARITY_CHECK;
                else
                    next_state = RECEIVE;
            end
            PARITY_CHECK: begin
                parity_bit = in;
                if (odd_parity == parity_bit)
                    next_state = STOP;
                else
                    next_state = IDLE; // Parity error, reset
            end
            STOP: begin
                if (in) // Stop bit should be 1
                    next_state = IDLE;
                else
                    next_state = STOP; // Wait for stop bit to be 1
            end
            default: next_state = IDLE;
        endcase
    end

    // Output logic
    always @(posedge clk) begin
        if (state == RECEIVE && bit_count < 8) begin
            data_reg <= {in, data_reg[7:1]}; // Shift in the bits
        end
    end

    assign out_byte = data_reg;
    assign done = (state == STOP) && in; // Assert done when stop bit is valid

endmodule"
N/A,N/A,-1,49,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

verilog
    // State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        DATA = 3'b010,
        PARITY = 3'b011,
        STOP = 3'b100
    } state_t;

    state_t state, next_state;
    reg [3:0] bit_count;  // Count the number of bits received
    reg [7:0] data_byte;  // Store the received byte
    reg parity_bit;       // Store the received parity bit
    reg [7:0] shift_reg;  // Shift register for serial data

    wire odd_parity;

    // Instantiate the parity checker module
    parity parity_inst (
        .clk(clk),
        .reset(reset),
        .in(in),
        .odd(odd_parity)
    );

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
            data_byte <= 8'b0;
            parity_bit <= 0;
        end else begin
            state <= next_state;
            if (state == DATA) begin
                shift_reg <= {in, shift_reg[7:1]};
                bit_count <= bit_count + 1;
            end
            if (state == PARITY) begin
                parity_bit <= in;
            end
        end
    end

    // Next state logic
    always @(*) begin
        next_state = state; // Default to hold state
        case (state)
            IDLE: begin
                if (!in) // Detect start bit (low)
                    next_state = START;
            end
            START: begin
                if (bit_count == 0)
                    next_state = DATA;
            end
            DATA: begin
                if (bit_count == 8)
                    next_state = PARITY;
            end
            PARITY: begin
                next_state = STOP;
            end
            STOP: begin
                if (in) begin // Check for stop bit (high)
                    if (parity_bit == odd_parity)
                        next_state = IDLE; // Parity check passed
                end else begin
                    next_state = IDLE; // Stop bit not detected, reset
                end
            end
        endcase
    end

    // Output logic
    assign done = (state == STOP) && in && (parity_bit == odd_parity);
    assign out_byte = shift_reg;

endmodule"
N/A,N/A,-1,50,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

verilog
    // State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        RECEIVE = 3'b010,
        PARITY_CHECK = 3'b011,
        STOP = 3'b100
    } state_t;

    // State registers
    reg [2:0] state, next_state;
    reg [3:0] bit_count;  // To count bits received
    reg [7:0] data_byte;  // To store received data byte
    reg parity_bit;       // To store received parity bit
    wire parity_odd;      // Output from the parity module

    // Instantiate the parity module
    parity parity_inst (
        .clk(clk),
        .reset(reset || (state == IDLE) || (state == START)),
        .in(in),
        .odd(parity_odd)
    );

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
        end else begin
            state <= next_state;
        end
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 0)  // Start bit detected
                    next_state = START;
                else
                    next_state = IDLE;
            end
            START: begin
                if (bit_count == 4'd8)  // Received 8 data bits
                    next_state = PARITY_CHECK;
                else
                    next_state = RECEIVE;
            end
            RECEIVE: begin
                if (bit_count == 4'd8)  // Received 8 data bits
                    next_state = PARITY_CHECK;
                else
                    next_state = RECEIVE;
            end
            PARITY_CHECK: begin
                next_state = STOP;
            end
            STOP: begin
                if (in == 1)  // Stop bit detected
                    next_state = IDLE;
                else
                    next_state = STOP;
            end
            default: next_state = IDLE;
        endcase
    end

    // Output and data logic
    always @(posedge clk) begin
        if (reset) begin
            bit_count <= 0;
            data_byte <= 8'b0;
            parity_bit <= 0;
        end else begin
            case (state)
                IDLE: begin
                    bit_count <= 0;
                    data_byte <= 8'b0;
                    parity_bit <= 0;
                end
                START: begin
                    bit_count <= 0;
                    data_byte <= 8'b0;
                    parity_bit <= 0;
                end
                RECEIVE: begin
                    data_byte[bit_count] <= in;
                    bit_count <= bit_count + 1;
                end
                PARITY_CHECK: begin
                    parity_bit <= in;
                end
                STOP: begin
                    // No action needed
                end
            endcase
        end
    end

    // Done signal logic
    assign done = (state == STOP) && (in == 1) && (parity_odd == 1);

    // Output the received byte
    assign out_byte = data_byte;

endmodule"
N/A,N/A,-1,51,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

verilog
    // State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        DATA = 3'b010,
        PARITY = 3'b011,
        STOP = 3'b100,
        ERROR = 3'b101
    } state_t;
    
    state_t state, next_state;
    reg [3:0] bit_count;  // Count the number of bits received
    reg [7:0] data;       // Store the received data byte
    reg parity_bit;       // Store the received parity bit
    wire odd_parity;      // Output from the parity module
    reg parity_reset;     // Reset signal for the parity module

    // Instantiate the parity module
    parity parity_inst(
        .clk(clk),
        .reset(parity_reset),
        .in(in),
        .odd(odd_parity)
    );

    // State transition logic
    always @(*) begin
        next_state = state;
        case (state)
            IDLE: begin
                if (in == 0) // Start bit detected
                    next_state = START;
            end

            START: begin
                if (bit_count == 4'd8)
                    next_state = DATA;
            end

            DATA: begin
                if (bit_count == 4'd7)
                    next_state = PARITY;
            end

            PARITY: begin
                next_state = STOP;
            end

            STOP: begin
                if (in == 1 && odd_parity) // Stop bit must be 1 and parity must be odd
                    next_state = IDLE;
                else
                    next_state = ERROR;
            end

            ERROR: begin
                if (in == 1) // Wait for a stop bit
                    next_state = IDLE;
            end
        endcase
    end

    // State flip-flops
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
            data <= 0;
            parity_bit <= 0;
            parity_reset <= 1;
        end else begin
            state <= next_state;

            case (state)
                IDLE: begin
                    bit_count <= 0;
                    parity_reset <= 1;
                end

                START: begin
                    bit_count <= bit_count + 1;
                    parity_reset <= 0;
                end

                DATA: begin
                    data <= {in, data[7:1]};
                    bit_count <= bit_count + 1;
                end

                PARITY: begin
                    parity_bit <= in;
                end

                STOP: begin
                    // Do nothing
                end

                ERROR: begin
                    // Do nothing
                end
            endcase
        end
    end

    // Output logic
    assign out_byte = data;
    assign done = (state == STOP && in == 1 && odd_parity);

endmodule"
N/A,N/A,-1,52,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

verilog
    // State encoding
    typedef enum reg [2:0] {
        IDLE,
        START,
        DATA,
        PARITY,
        STOP
    } state_t;

    // State registers
    reg [2:0] state, next_state;
    reg [3:0] bit_count; // To count the number of bits received
    reg [7:0] data;      // To store the received data byte
    wire parity_odd;     // Parity check output

    // Instantiate the parity module
    parity parity_inst (
        .clk(clk),
        .reset(reset | (state == IDLE) | (state == START)),
        .in(in),
        .odd(parity_odd)
    );

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
            data <= 0;
        end else begin
            state <= next_state;
            if (state == DATA) begin
                data <= {in, data[7:1]}; // Shift in the received bit
                bit_count <= bit_count + 1;
            end else if (state == START) begin
                bit_count <= 0;
            end
        end
    end

    // Next state logic
    always @(*) begin
        next_state = state;
        case (state)
            IDLE: begin
                if (in == 0) // Detect start bit
                    next_state = START;
            end
            START: begin
                if (in == 0) // Confirm start bit
                    next_state = DATA;
            end
            DATA: begin
                if (bit_count == 8)
                    next_state = PARITY;
            end
            PARITY: begin
                if (parity_odd == 1)
                    next_state = STOP;
                else
                    next_state = IDLE; // Parity error
            end
            STOP: begin
                if (in == 1) // Stop bit must be 1
                    next_state = IDLE;
                else
                    next_state = IDLE; // Stop bit error, wait for next start
            end
        endcase
    end

    // Output logic
    assign out_byte = data;
    assign done = (state == STOP) && (in == 1);
endmodule"
N/A,N/A,-1,53,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

verilog
    // State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        RECEIVE = 3'b010,
        PARITY_CHECK = 3'b011,
        STOP = 3'b100
    } state_t;

    state_t state, next_state;
    reg [7:0] data_shift;
    reg [3:0] bit_count;
    wire parity_odd;
    reg parity_reset;
    reg done_reg;

    // Instantiate the parity module
    parity parity_inst (
        .clk(clk),
        .reset(parity_reset),
        .in(in),
        .odd(parity_odd)
    );

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
            done_reg <= 0;
            parity_reset <= 1;
        end else begin
            state <= next_state;
            if (state == RECEIVE) bit_count <= bit_count + 1'b1;
            if (state == STOP) done_reg <= 0;
            if (state == IDLE || state == START) parity_reset <= 1;
            else parity_reset <= 0;
        end
    end

    // Next state logic
    always @(*) begin
        next_state = state;
        case (state)
            IDLE: begin
                if (!in) next_state = START;  // Detect start bit
            end
            START: begin
                next_state = RECEIVE;
            end
            RECEIVE: begin
                if (bit_count == 9) next_state = PARITY_CHECK;  // After 9 bits (8 data + 1 parity)
            end
            PARITY_CHECK: begin
                if (parity_odd) next_state = STOP;  // Check parity, should be odd
                else next_state = IDLE;  // Parity check failed
            end
            STOP: begin
                if (in) next_state = IDLE;  // Check stop bit, should be 1
                else next_state = START;  // If stop bit not 1, look for new start bit
            end
        endcase
    end

    // Output logic
    always @(posedge clk) begin
        if (state == RECEIVE && bit_count < 8) begin
            data_shift <= {in, data_shift[7:1]};
        end
        if (state == PARITY_CHECK && parity_odd) begin
            out_byte <= data_shift;
        end
        if (state == STOP && in) begin
            done_reg <= 1;
        end
    end

    assign done = done_reg;

endmodule"
N/A,N/A,-1,54,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

verilog
    // State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        DATA = 3'b010,
        PARITY = 3'b011,
        STOP = 3'b100
    } state_t;
    
    state_t state, next_state;
    reg [7:0] data_shift;
    reg [3:0] bit_count;
    wire parity_odd;
    reg parity_reset;
    reg done_reg;

    // Instantiate the parity module
    parity parity_inst (
        .clk(clk),
        .reset(parity_reset),
        .in(in),
        .odd(parity_odd)
    );

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
            done_reg <= 0;
            parity_reset <= 1;
        end else begin
            state <= next_state;
            if (state == DATA) bit_count <= bit_count + 1'b1;
            if (state == STOP) done_reg <= 0;
            if (state == PARITY && parity_odd) done_reg <= 1;
            parity_reset <= (state == IDLE || state == STOP);
        end
    end

    // Next state logic
    always @(*) begin
        next_state = state;
        case (state)
            IDLE: if (~in) next_state = START;
            START: if (in) next_state = DATA;
            DATA: if (bit_count == 8) next_state = PARITY;
            PARITY: if (in) next_state = STOP;
            STOP: if (~in) next_state = IDLE;
            default: next_state = IDLE;
        endcase
    end

    // Output logic
    always @(posedge clk) begin
        if (state == DATA) data_shift <= {in, data_shift[7:1]};
    end

    assign out_byte = data_shift;
    assign done = done_reg;

endmodule"
N/A,N/A,-1,55,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

verilog
    // State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        DATA = 3'b010,
        PARITY = 3'b011,
        STOP = 3'b100,
        ERROR = 3'b101
    } state_t;
    
    state_t state, next_state;
    reg [3:0] bit_count;  // Count the number of bits received
    reg [7:0] data;       // Store the received data byte
    reg parity_bit;       // Store the received parity bit
    wire odd_parity;      // Output from the parity module
    reg parity_reset;     // Control signal to reset the parity module
    
    // Instantiate the parity module
    parity parity_inst (
        .clk(clk),
        .reset(parity_reset),
        .in(in),
        .odd(odd_parity)
    );
    
    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
            data <= 8'b0;
            parity_reset <= 1;
        end else begin
            state <= next_state;
        end
    end
    
    // Next state logic
    always @(*) begin
        next_state = state;
        parity_reset = 0;
        
        case (state)
            IDLE: begin
                if (in == 0)  // Detect start bit
                    next_state = START;
            end
            
            START: begin
                if (bit_count == 4'd0) begin
                    next_state = DATA;
                    parity_reset = 1;  // Reset parity at the start of data
                end
            end
            
            DATA: begin
                if (bit_count < 4'd8) begin
                    data[bit_count] = in;  // Shift in data bits
                end else begin
                    next_state = PARITY;
                end
            end
            
            PARITY: begin
                parity_bit = in;
                next_state = STOP;
            end
            
            STOP: begin
                if (in == 1) begin  // Check for valid stop bit
                    if (odd_parity && parity_bit == 1) begin
                        next_state = IDLE;
                    end else begin
                        next_state = ERROR;
                    end
                end else begin
                    next_state = ERROR;
                end
            end
            
            ERROR: begin
                if (in == 1)  // Wait for a valid stop bit to recover
                    next_state = IDLE;
            end
        endcase
    end
    
    // Output logic
    assign out_byte = data;
    assign done = (state == STOP) && (odd_parity && parity_bit == 1);
    
    // Bit counter logic
    always @(posedge clk) begin
        if (reset || state == IDLE || state == START) begin
            bit_count <= 0;
        end else if (state == DATA || state == PARITY) begin
            bit_count <= bit_count + 1;
        end
    end

endmodule"
N/A,N/A,-1,56,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

verilog
    // State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        DATA = 3'b010,
        PARITY = 3'b011,
        STOP = 3'b100,
        ERROR = 3'b101
    } state_t;
    
    state_t state, next_state;
    reg [3:0] bit_count;  // Count the number of bits received
    reg [7:0] data;       // Store the received data byte
    reg parity_bit;       // Store the received parity bit
    wire parity_odd;      // Output from the parity module
    reg parity_reset;     // Control signal to reset the parity module
    
    // Instantiate the parity module
    parity parity_inst (
        .clk(clk),
        .reset(parity_reset),
        .in(in),
        .odd(parity_odd)
    );
    
    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
            parity_reset <= 1;
        end else begin
            state <= next_state;
            if (state == DATA) begin
                data <= {in, data[7:1]};  // Shift in data bits
                bit_count <= bit_count + 1;
            end else if (state == PARITY) begin
                parity_bit <= in;
            end
            if (state == IDLE || state == STOP) begin
                parity_reset <= 1;  // Reset parity calculation at the start and end
            end else begin
                parity_reset <= 0;
            end
        end
    end
    
    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (!in)  // Detect start bit (0)
                    next_state = START;
                else
                    next_state = IDLE;
            end
            START: begin
                next_state = DATA;  // Move to data reception
            end
            DATA: begin
                if (bit_count == 8)
                    next_state = PARITY;  // Move to parity bit after 8 data bits
                else
                    next_state = DATA;
            end
            PARITY: begin
                next_state = STOP;  // Move to stop bit
            end
            STOP: begin
                if (in) begin  // Check for stop bit (1)
                    if (parity_odd)  // Check if odd parity is maintained
                        next_state = IDLE;  // Successfully received byte
                    else
                        next_state = ERROR;  // Parity error
                end else begin
                    next_state = STOP;  // Wait for stop bit
                end
            end
            ERROR: begin
                if (in)  // Wait for stop bit before returning to IDLE
                    next_state = IDLE;
                else
                    next_state = ERROR;
            end
            default: next_state = IDLE;
        endcase
    end
    
    // Output logic
    assign out_byte = data;
    assign done = (state == STOP && in && parity_odd);  // Assert done if stop bit is correct and parity is odd

endmodule"
N/A,N/A,-1,57,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

verilog
    // State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        DATA = 3'b010,
        PARITY = 3'b011,
        STOP = 3'b100,
        ERROR = 3'b101
    } state_t;
    
    state_t state, next_state;
    reg [3:0] bit_count;  // Count the number of bits received
    reg [7:0] data;       // Store the received data byte
    reg parity_bit;       // Store the received parity bit
    wire odd_parity;      // Output from the parity module
    reg parity_reset;     // Control signal to reset the parity module
    reg stop_error;       // Flag for stop bit error

    // Instantiate the parity module
    parity parity_inst (
        .clk(clk),
        .reset(parity_reset),
        .in(in),
        .odd(odd_parity)
    );

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
            parity_reset <= 1;
            stop_error <= 0;
        end else begin
            state <= next_state;
        end
    end

    // Next state logic and outputs
    always @(*) begin
        // Default values
        next_state = state;
        parity_reset = 0;
        done = 0;

        case (state)
            IDLE: begin
                if (in == 0) begin // Start bit detected
                    next_state = START;
                    parity_reset = 1;
                end
            end

            START: begin
                if (bit_count == 0) begin
                    next_state = DATA;
                end
            end

            DATA: begin
                if (bit_count < 8) begin
                    data[bit_count] = in;
                    bit_count = bit_count + 1;
                end else begin
                    next_state = PARITY;
                    bit_count = 0;
                end
            end

            PARITY: begin
                parity_bit = in;
                next_state = STOP;
            end

            STOP: begin
                if (in == 1) begin // Correct stop bit
                    if (odd_parity == 1 && parity_bit == 1) begin
                        done = 1;
                        out_byte = data;
                    end
                    next_state = IDLE;
                end else begin
                    stop_error = 1;
                    next_state = ERROR;
                end
            end

            ERROR: begin
                if (in == 1) begin // Wait for stop bit
                    stop_error = 0;
                    next_state = IDLE;
                end
            end

            default: begin
                next_state = IDLE;
            end
        endcase
    end

    // Output logic
    always @(posedge clk) begin
        if (reset) begin
            out_byte <= 8'b0;
        end else if (done) begin
            out_byte <= data;
        end
    end

endmodule"
N/A,N/A,-1,58,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

verilog
    // State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        DATA = 3'b010,
        PARITY = 3'b011,
        STOP = 3'b100,
        ERROR = 3'b101
    } state_t;
    
    state_t state, next_state;
    reg [3:0] bit_count;  // Count the number of bits received
    reg [7:0] data;       // Store the received data byte
    reg parity_bit;       // Store the received parity bit
    wire odd_parity;      // Output from the parity module
    reg parity_reset;     // Control signal to reset the parity module
    reg stop_error;       // Flag for stop bit error

    // Instantiate the parity module
    parity parity_inst (
        .clk(clk),
        .reset(parity_reset),
        .in(in),
        .odd(odd_parity)
    );

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
            parity_reset <= 1;
            stop_error <= 0;
        end else begin
            state <= next_state;
        end
    end

    // Next state logic and outputs
    always @(*) begin
        // Default values
        next_state = state;
        parity_reset = 0;
        done = 0;

        case (state)
            IDLE: begin
                if (in == 0) begin // Start bit detected
                    next_state = START;
                    parity_reset = 1;
                end
            end

            START: begin
                if (bit_count == 0) begin
                    next_state = DATA;
                end
            end

            DATA: begin
                if (bit_count < 8) begin
                    data[bit_count] = in;
                    bit_count = bit_count + 1;
                end else begin
                    next_state = PARITY;
                    bit_count = 0;
                end
            end

            PARITY: begin
                parity_bit = in;
                if (parity_bit == odd_parity) begin
                    next_state = STOP;
                end else begin
                    next_state = ERROR;
                end
            end

            STOP: begin
                if (in == 1) begin // Stop bit detected
                    done = 1;
                    out_byte = data;
                    next_state = IDLE;
                end else begin
                    stop_error = 1;
                    next_state = ERROR;
                end
            end

            ERROR: begin
                if (in == 1) begin // Wait for stop bit
                    next_state = IDLE;
                end
            end
        endcase
    end

    // Update the bit count
    always @(posedge clk) begin
        if (reset || state == IDLE || state == STOP || state == ERROR) begin
            bit_count <= 0;
        end else if (state == DATA || state == START) begin
            bit_count <= bit_count + 1;
        end
    end

endmodule"
N/A,N/A,-1,59,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

verilog
    // State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        RECEIVE = 3'b010,
        PARITY_CHECK = 3'b011,
        STOP = 3'b100
    } state_t;

    state_t state, next_state;
    reg [7:0] data_shift;
    reg [3:0] bit_count;
    wire parity_odd;
    reg parity_reset;
    reg done_reg;

    // Instantiate the parity module
    parity parity_inst (
        .clk(clk),
        .reset(parity_reset),
        .in(in),
        .odd(parity_odd)
    );

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
            done_reg <= 0;
            parity_reset <= 1;
        end else begin
            state <= next_state;
            if (state == RECEIVE) bit_count <= bit_count + 1'b1;
            if (state == STOP) done_reg <= 0;
            if (state == IDLE || state == START) parity_reset <= 1;
            else parity_reset <= 0;
        end
    end

    // Next state logic
    always @(*) begin
        next_state = state;
        case (state)
            IDLE: begin
                if (!in) next_state = START;  // Detect start bit
            end
            START: begin
                next_state = RECEIVE;
            end
            RECEIVE: begin
                if (bit_count == 9) next_state = PARITY_CHECK;  // After 9 bits (8 data + 1 parity)
            end
            PARITY_CHECK: begin
                if (parity_odd) next_state = STOP;
                else next_state = IDLE;  // Parity error, wait for stop bit
            end
            STOP: begin
                if (in) next_state = IDLE;  // Stop bit detected
                else next_state = STOP;  // Wait for stop bit
            end
        endcase
    end

    // Output logic
    always @(posedge clk) begin
        if (state == RECEIVE && bit_count < 8) begin
            data_shift <= {in, data_shift[7:1]};
        end else if (state == STOP && in) begin
            done_reg <= 1;
        end
    end

    assign out_byte = data_shift;
    assign done = done_reg;

endmodule"
N/A,N/A,-1,60,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

verilog
    // State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        DATA = 3'b010,
        PARITY = 3'b011,
        STOP = 3'b100,
        ERROR = 3'b101
    } state_t;
    
    state_t state, next_state;
    reg [3:0] bit_count;  // Count the number of bits received
    reg [7:0] data;       // Store the received data byte
    reg parity_bit;       // Store the received parity bit
    wire odd_parity;      // Output from the parity module
    reg parity_reset;     // Control signal to reset the parity module
    
    // Instantiate the parity module
    parity parity_inst (
        .clk(clk),
        .reset(parity_reset),
        .in(in),
        .odd(odd_parity)
    );
    
    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
            parity_reset <= 1;
        end else begin
            state <= next_state;
            if (state == DATA) begin
                data <= {in, data[7:1]};  // Shift in data bits
                bit_count <= bit_count + 1;
            end
            if (state == PARITY) begin
                parity_bit <= in;  // Capture the parity bit
            end
            if (state == IDLE || state == STOP) begin
                parity_reset <= 1;  // Reset parity calculation
            end else begin
                parity_reset <= 0;
            end
        end
    end
    
    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (!in) next_state = START;  // Detect start bit (0)
                else next_state = IDLE;
            end
            START: begin
                next_state = DATA;  // Move to data reception
            end
            DATA: begin
                if (bit_count == 8) next_state = PARITY;  // After 8 bits, check parity
                else next_state = DATA;
            end
            PARITY: begin
                next_state = STOP;  // Move to stop bit checking
            end
            STOP: begin
                if (in && (odd_parity == parity_bit)) next_state = IDLE;  // Check for stop bit and parity
                else if (!in) next_state = ERROR;  // If stop bit is not correct, go to error
                else next_state = STOP;
            end
            ERROR: begin
                if (in) next_state = IDLE;  // Wait for a stop bit to return to IDLE
                else next_state = ERROR;
            end
            default: next_state = IDLE;
        endcase
    end
    
    // Output logic
    assign out_byte = data;
    assign done = (state == STOP) && in && (odd_parity == parity_bit);

endmodule"
N/A,N/A,-1,61,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

verilog
    // State encoding
    typedef enum reg [2:0] {
        IDLE,
        START,
        DATA,
        PARITY,
        STOP
    } state_t;

    // State registers
    reg [2:0] state, next_state;
    reg [3:0] bit_count; // To count the number of bits received
    reg [7:0] data;      // To store the received data byte
    wire parity_odd;     // Parity check output

    // Instantiate the parity module
    parity parity_inst (
        .clk(clk),
        .reset(reset | (state == IDLE) | (state == START)), // Reset at IDLE and START
        .in(in),
        .odd(parity_odd)
    );

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
        end else begin
            state <= next_state;
        end
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (~in) // Start bit detected (0)
                    next_state = START;
                else
                    next_state = IDLE;
            end
            START: begin
                next_state = DATA;
            end
            DATA: begin
                if (bit_count == 8)
                    next_state = PARITY;
                else
                    next_state = DATA;
            end
            PARITY: begin
                if (parity_odd) // Check if parity is odd
                    next_state = STOP;
                else
                    next_state = IDLE; // Invalid parity, reset FSM
            end
            STOP: begin
                if (in) // Stop bit detected (1)
                    next_state = IDLE;
                else
                    next_state = STOP; // Wait for stop bit
            end
            default: next_state = IDLE;
        endcase
    end

    // Output logic and data capture
    always @(posedge clk) begin
        if (reset) begin
            bit_count <= 0;
            data <= 8'b0;
        end else if (state == DATA) begin
            data <= {in, data[7:1]}; // Shift in the data bits
            bit_count <= bit_count + 1;
        end else if (state == PARITY || state == IDLE) begin
            bit_count <= 0;
        end
    end

    // Assign outputs
    assign out_byte = data;
    assign done = (state == STOP) && in; // Assert done when stop bit is detected

endmodule"
N/A,N/A,-1,62,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

verilog
    // State encoding
    parameter IDLE = 3'b000;
    parameter START = 3'b001;
    parameter DATA = 3'b010;
    parameter PARITY = 3'b011;
    parameter STOP = 3'b100;

    reg [2:0] state, next_state;
    reg [3:0] bit_counter;
    reg [7:0] data_reg;
    reg parity_bit;

    wire odd_parity;
    reg parity_reset;

    // Instantiate the parity module
    parity parity_checker (
        .clk(clk),
        .reset(parity_reset),
        .in(in),
        .odd(odd_parity)
    );

    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_counter <= 0;
            data_reg <= 0;
            parity_bit <= 0;
            parity_reset <= 1;
        end else begin
            state <= next_state;
            if (state == DATA) begin
                data_reg <= {in, data_reg[7:1]};
                bit_counter <= bit_counter + 1;
            end
            if (state == PARITY) begin
                parity_bit <= in;
            end
            if (state == STOP && in) begin
                parity_reset <= 1;
            end else begin
                parity_reset <= 0;
            end
        end
    end

    always @(*) begin
        next_state = state;
        case (state)
            IDLE: begin
                if (in == 0) begin // Detect start bit
                    next_state = START;
                end
            end
            START: begin
                next_state = DATA;
            end
            DATA: begin
                if (bit_counter == 8) begin
                    next_state = PARITY;
                end
            end
            PARITY: begin
                next_state = STOP;
            end
            STOP: begin
                if (in == 1 && odd_parity == 1 && parity_bit == odd_parity) begin // Check stop bit and parity
                    next_state = IDLE;
                end else if (in == 1) begin // Wait for stop bit
                    next_state = IDLE;
                end else begin
                    next_state = STOP;
                end
            end
        endcase
    end

    assign out_byte = data_reg;
    assign done = (state == STOP && in == 1 && odd_parity == 1 && parity_bit == odd_parity);

endmodule"
N/A,N/A,-1,63,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

verilog
    // State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        RECEIVE = 3'b010,
        PARITY_CHECK = 3'b011,
        STOP = 3'b100
    } state_t;

    state_t state, next_state;
    reg [7:0] data_shift;
    reg [3:0] bit_count;
    wire parity_odd;
    reg parity_reset;
    reg [7:0] out_byte_reg;
    reg done_reg;

    // Instantiate the parity module
    parity parity_inst (
        .clk(clk),
        .reset(parity_reset),
        .in(in),
        .odd(parity_odd)
    );

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
            data_shift <= 8'b0;
            parity_reset <= 1;
            done_reg <= 0;
        end else begin
            state <= next_state;
            if (state == RECEIVE) begin
                data_shift <= {in, data_shift[7:1]};
                bit_count <= bit_count + 1;
            end
            if (state == PARITY_CHECK) begin
                out_byte_reg <= data_shift;
                done_reg <= 0;
            end
            if (state == STOP) begin
                if (in == 1 && parity_odd) begin
                    done_reg <= 1;
                end else begin
                    done_reg <= 0;
                end
            end
        end
    end

    // Next state logic
    always @(*) begin
        next_state = state;
        parity_reset = 0;
        case (state)
            IDLE: begin
                done_reg = 0;
                if (in == 0) begin
                    next_state = START;
                    parity_reset = 1;
                end
            end
            START: begin
                if (in == 0) begin
                    next_state = RECEIVE;
                    bit_count = 0;
                end
            end
            RECEIVE: begin
                if (bit_count == 8) begin
                    next_state = PARITY_CHECK;
                end
            end
            PARITY_CHECK: begin
                next_state = STOP;
            end
            STOP: begin
                if (in == 1) begin
                    next_state = IDLE;
                end else begin
                    next_state = IDLE; // Wait for stop bit
                end
            end
        endcase
    end

    assign out_byte = out_byte_reg;
    assign done = done_reg;

endmodule"
N/A,N/A,-1,64,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

verilog
    // State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        DATA = 3'b010,
        PARITY = 3'b011,
        STOP = 3'b100
    } state_t;
    
    state_t state, next_state;
    reg [7:0] data_shift;
    reg [3:0] bit_count;
    wire parity_odd;
    reg parity_reset;
    reg done_reg;

    // Instantiate the parity module
    parity parity_inst (
        .clk(clk),
        .reset(parity_reset),
        .in(in),
        .odd(parity_odd)
    );

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
            done_reg <= 0;
            parity_reset <= 1;
        end else begin
            state <= next_state;
            if (state == DATA) bit_count <= bit_count + 1'b1;
            if (state == STOP) done_reg <= 0;
            if (state == PARITY && parity_odd) done_reg <= 1;
            parity_reset <= (state == IDLE || state == START);
        end
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: next_state = (in == 0) ? START : IDLE;
            START: next_state = (in == 0) ? DATA : IDLE;
            DATA: next_state = (bit_count == 8) ? PARITY : DATA;
            PARITY: next_state = STOP;
            STOP: next_state = (in == 1) ? IDLE : STOP;
            default: next_state = IDLE;
        endcase
    end

    // Output logic
    always @(posedge clk) begin
        if (state == DATA) data_shift <= {in, data_shift[7:1]};
    end

    assign out_byte = data_shift;
    assign done = done_reg;

endmodule"
N/A,N/A,-1,65,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

verilog
    // State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        RECEIVE = 3'b010,
        PARITY_CHECK = 3'b011,
        STOP = 3'b100
    } state_t;

    // State variables
    reg [2:0] state, next_state;
    reg [3:0] bit_count; // Count 9 bits (8 data + 1 parity)
    reg [7:0] data_reg;
    reg parity_bit;
    wire odd_parity;

    // Instantiate the parity module
    parity parity_checker (
        .clk(clk),
        .reset(reset | (state == IDLE) | (state == START)),
        .in(in),
        .odd(odd_parity)
    );

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
        end else begin
            state <= next_state;
        end
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (!in) // Detect start bit (0)
                    next_state = START;
                else
                    next_state = IDLE;
            end
            START: begin
                next_state = RECEIVE;
            end
            RECEIVE: begin
                if (bit_count == 4'd8) // After 8 data bits
                    next_state = PARITY_CHECK;
                else
                    next_state = RECEIVE;
            end
            PARITY_CHECK: begin
                next_state = STOP;
            end
            STOP: begin
                if (in) // Stop bit should be 1
                    next_state = IDLE;
                else
                    next_state = STOP; // Wait for stop bit
            end
            default: next_state = IDLE;
        endcase
    end

    // Output and data path logic
    always @(posedge clk) begin
        if (reset) begin
            bit_count <= 0;
            data_reg <= 8'b0;
            parity_bit <= 0;
        end else begin
            case (state)
                IDLE: begin
                    bit_count <= 0;
                end
                START: begin
                    bit_count <= 0;
                end
                RECEIVE: begin
                    bit_count <= bit_count + 1;
                    data_reg <= {in, data_reg[7:1]}; // Shift in data bits (LSB first)
                end
                PARITY_CHECK: begin
                    parity_bit <= in; // Capture parity bit
                end
                STOP: begin
                    // Do nothing
                end
            endcase
        end
    end

    // Done signal logic
    assign done = (state == STOP) && in && (odd_parity == 1'b1) && (parity_bit == odd_parity);

    // Output byte
    assign out_byte = data_reg;

endmodule"
N/A,N/A,-1,66,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

verilog
    // State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        RECEIVE = 3'b010,
        PARITY_CHECK = 3'b011,
        STOP = 3'b100
    } state_t;

    state_t state, next_state;
    reg [7:0] data_shift;
    reg [3:0] bit_count;
    wire parity_odd;
    reg parity_reset;
    reg done_reg;

    // Instantiate the parity module
    parity parity_inst (
        .clk(clk),
        .reset(parity_reset),
        .in(in),
        .odd(parity_odd)
    );

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
            done_reg <= 0;
            parity_reset <= 1;
        end else begin
            state <= next_state;
            if (state == RECEIVE) bit_count <= bit_count + 1'b1;
            if (state == STOP) done_reg <= 0;
            if (state == PARITY_CHECK && parity_odd) done_reg <= 1;
        end
    end

    // Next state logic
    always @(*) begin
        next_state = state;
        parity_reset = 0;
        case (state)
            IDLE: begin
                if (!in) next_state = START;  // Detect start bit
            end
            START: begin
                next_state = RECEIVE;
                parity_reset = 1;
            end
            RECEIVE: begin
                if (bit_count == 8) next_state = PARITY_CHECK;
            end
            PARITY_CHECK: begin
                if (parity_odd) next_state = STOP;
                else next_state = IDLE;  // Parity error, restart
            end
            STOP: begin
                if (in) next_state = IDLE;  // Stop bit detected, ready for next byte
                else next_state = IDLE;  // Stop bit error, restart
            end
        endcase
    end

    // Data shift register
    always @(posedge clk) begin
        if (state == RECEIVE) begin
            data_shift <= {in, data_shift[7:1]};
        end
    end

    // Output assignments
    assign out_byte = data_shift;
    assign done = done_reg;

endmodule"
N/A,N/A,-1,67,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

verilog
    // State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        DATA = 3'b010,
        PARITY = 3'b011,
        STOP = 3'b100,
        ERROR = 3'b101
    } state_t;
    
    state_t state, next_state;
    reg [3:0] bit_count;  // Count the number of bits received
    reg [7:0] data;       // Store the received data byte
    reg parity_bit;       // Store the received parity bit
    wire odd_parity;      // Output from the parity module
    reg parity_reset;     // Control signal to reset the parity module
    
    // Instantiate the parity module
    parity parity_inst (
        .clk(clk),
        .reset(parity_reset),
        .in(in),
        .odd(odd_parity)
    );
    
    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
            parity_reset <= 1;
        end else begin
            state <= next_state;
            if (state == DATA) begin
                data <= {in, data[7:1]};  // Shift in data bits
                bit_count <= bit_count + 1;
            end
            if (state == PARITY) begin
                parity_bit <= in;  // Capture the parity bit
            end
            if (state == IDLE || state == STOP) begin
                parity_reset <= 1;  // Reset parity calculation
            end else begin
                parity_reset <= 0;
            end
        end
    end
    
    // Next state logic
    always @(*) begin
        next_state = state;
        case (state)
            IDLE: begin
                if (in == 0)  // Start bit detected
                    next_state = START;
            end
            START: begin
                next_state = DATA;  // Move to data reception
            end
            DATA: begin
                if (bit_count == 8)
                    next_state = PARITY;  // Move to parity bit
            end
            PARITY: begin
                next_state = STOP;  // Move to stop bit
            end
            STOP: begin
                if (in == 1) begin  // Stop bit detected
                    if (odd_parity && parity_bit == 1)  // Check odd parity
                        next_state = IDLE;  // Correct reception
                    else
                        next_state = ERROR;  // Parity error
                end else begin
                    next_state = ERROR;  // Missing stop bit
                end
            end
            ERROR: begin
                if (in == 1)  // Wait for the stop bit
                    next_state = IDLE;
            end
        endcase
    end
    
    // Output logic
    assign out_byte = data;
    assign done = (state == STOP && in == 1 && odd_parity && parity_bit == 1);

endmodule"
N/A,N/A,-1,68,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

verilog
    // State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        RECEIVE = 3'b010,
        PARITY_CHECK = 3'b011,
        STOP = 3'b100
    } state_t;

    state_t state, next_state;
    reg [7:0] data_shift;
    reg [3:0] bit_count;
    wire parity_odd;
    reg parity_reset;
    reg [7:0] out_byte_reg;
    reg done_reg;

    // Instantiate the parity module
    parity parity_inst (
        .clk(clk),
        .reset(parity_reset),
        .in(in),
        .odd(parity_odd)
    );

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
            parity_reset <= 1;
            done_reg <= 0;
        end else begin
            state <= next_state;
            if (state == RECEIVE) begin
                data_shift <= {in, data_shift[7:1]};
                bit_count <= bit_count + 1;
            end
        end
    end

    // Next state logic
    always @(*) begin
        next_state = state;
        parity_reset = 0;
        done_reg = 0;
        case (state)
            IDLE: begin
                if (~in) begin
                    next_state = START;
                    parity_reset = 1; // Reset parity on start bit
                end
            end
            START: begin
                if (in) begin
                    next_state = RECEIVE;
                    bit_count = 0;
                end
            end
            RECEIVE: begin
                if (bit_count == 8) begin
                    next_state = PARITY_CHECK;
                end
            end
            PARITY_CHECK: begin
                if (parity_odd == in) begin
                    next_state = STOP;
                end else begin
                    next_state = IDLE; // Parity error, return to IDLE
                end
            end
            STOP: begin
                if (in) begin
                    next_state = IDLE;
                    out_byte_reg = data_shift;
                    done_reg = 1;
                end
            end
        endcase
    end

    assign out_byte = out_byte_reg;
    assign done = done_reg;

endmodule"
N/A,N/A,-1,69,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

verilog
    // State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        RECEIVE = 3'b010,
        PARITY_CHECK = 3'b011,
        STOP = 3'b100,
        DONE = 3'b101
    } state_t;

    reg [2:0] state, next_state;
    reg [3:0] bit_count;
    reg [7:0] data_byte;
    wire odd_parity;
    reg parity_reset;

    // Instantiate the parity checker
    parity parity_checker (
        .clk(clk),
        .reset(parity_reset),
        .in(in),
        .odd(odd_parity)
    );

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            parity_reset <= 1;
        end else begin
            state <= next_state;
        end
    end

    // Next state logic
    always @(*) begin
        next_state = state;
        case (state)
            IDLE: begin
                if (~in) begin // Detect start bit (0)
                    next_state = START;
                end
            end
            START: begin
                if (bit_count == 4'd8) begin
                    next_state = PARITY_CHECK;
                end else begin
                    next_state = RECEIVE;
                end
            end
            RECEIVE: begin
                next_state = (bit_count == 4'd7) ? PARITY_CHECK : RECEIVE;
            end
            PARITY_CHECK: begin
                next_state = STOP;
            end
            STOP: begin
                if (in) begin // Detect stop bit (1)
                    next_state = DONE;
                end else begin
                    next_state = IDLE; // Wait for stop bit
                end
            end
            DONE: begin
                next_state = IDLE;
            end
            default: begin
                next_state = IDLE;
            end
        endcase
    end

    // Output and bit_count logic
    always @(posedge clk) begin
        if (reset) begin
            bit_count <= 0;
            data_byte <= 0;
        end else begin
            case (state)
                IDLE: begin
                    bit_count <= 0;
                    parity_reset <= 1;
                end
                START: begin
                    bit_count <= 0;
                    parity_reset <= 0; // Start counting parity
                end
                RECEIVE: begin
                    data_byte[bit_count] <= in;
                    bit_count <= bit_count + 1;
                end
                PARITY_CHECK: begin
                    // No additional logic needed here
                end
                STOP: begin
                    // No additional logic needed here
                end
                DONE: begin
                    // No additional logic needed here
                end
                default: begin
                    // No additional logic needed here
                end
            endcase
        end
    end

    // Done signal logic
    assign done = (state == DONE) && odd_parity;

    // Output the received byte
    assign out_byte = data_byte;

endmodule"
N/A,N/A,-1,70,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

verilog
    // State encoding
    typedef enum reg [2:0] {
        IDLE,
        START,
        DATA,
        PARITY,
        STOP
    } state_t;

    // State registers
    reg [2:0] state, next_state;
    reg [3:0] bit_count; // To count bits received
    reg [7:0] data_reg;  // To store the received byte
    reg parity_reset;
    wire odd_parity;

    // Instantiate the parity module
    parity parity_checker (
        .clk(clk),
        .reset(parity_reset),
        .in(in),
        .odd(odd_parity)
    );

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
            data_reg <= 8'b0;
        end else begin
            state <= next_state;
            if (state == DATA) begin
                data_reg <= {in, data_reg[7:1]}; // Shift in the received bits
                bit_count <= bit_count + 1;
            end else if (state == START) begin
                bit_count <= 0; // Reset bit counter at the start of a new byte
            end
        end
    end

    // Next state logic
    always @(*) begin
        next_state = state;
        parity_reset = 0;
        case (state)
            IDLE: begin
                if (in == 0) // Detect start bit (0)
                    next_state = START;
            end
            START: begin
                if (in == 0) // Ensure start bit is still low
                    next_state = DATA;
                else
                    next_state = IDLE; // False start, go back to IDLE
            end
            DATA: begin
                if (bit_count == 8)
                    next_state = PARITY;
            end
            PARITY: begin
                if (odd_parity == 1'b1)
                    next_state = STOP;
                else
                    next_state = IDLE; // Parity error, go back to IDLE
            end
            STOP: begin
                if (in == 1) // Check for stop bit (1)
                    next_state = IDLE;
                else
                    next_state = IDLE; // Stop bit error, go back to IDLE
            end
        endcase
    end

    // Output logic
    assign out_byte = data_reg;
    assign done = (state == STOP) && (in == 1);

endmodule"
N/A,N/A,-1,71,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

verilog
    // State encoding
    typedef enum reg [2:0] {
        IDLE,
        START,
        DATA,
        PARITY,
        STOP
    } state_t;

    // State registers
    reg [2:0] state, next_state;
    reg [3:0] bit_count; // To count bits received
    reg [7:0] data_reg;  // To store the received byte
    reg parity_bit;
    wire odd_parity;

    // Instantiate the parity module
    parity parity_checker (
        .clk(clk),
        .reset(reset | (state == START)), // Reset parity checker at start of new byte
        .in(in),
        .odd(odd_parity)
    );

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
        end else begin
            state <= next_state;

            // Count bits received in DATA and PARITY states
            if (state == DATA || state == PARITY) begin
                bit_count <= bit_count + 1;
            end else begin
                bit_count <= 0;
            end
        end
    end

    // Next state logic
    always @(*) begin
        next_state = state;
        case (state)
            IDLE: begin
                if (~in) // Start bit detected
                    next_state = START;
            end
            START: begin
                next_state = DATA;
            end
            DATA: begin
                if (bit_count == 8)
                    next_state = PARITY;
            end
            PARITY: begin
                if (bit_count == 9)
                    next_state = STOP;
            end
            STOP: begin
                if (in) // Stop bit detected
                    next_state = IDLE;
            end
        endcase
    end

    // Output and data register logic
    always @(posedge clk) begin
        if (state == DATA) begin
            data_reg <= {in, data_reg[7:1]}; // Shift in data bits
        end else if (state == PARITY && bit_count == 8) begin
            parity_bit <= in; // Capture parity bit
        end
    end

    // Done signal logic
    assign done = (state == STOP && in && odd_parity); // Valid stop bit and correct parity

    // Output the received byte
    assign out_byte = data_reg;

endmodule"
N/A,N/A,-1,72,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

verilog
    // State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        RECEIVE = 3'b010,
        PARITY_CHECK = 3'b011,
        STOP = 3'b100
    } state_t;

    state_t state, next_state;
    reg [7:0] data_shift;
    reg [3:0] bit_count;
    wire parity_odd;
    reg parity_reset;
    reg done_reg;

    // Instantiate the parity module
    parity parity_inst (
        .clk(clk),
        .reset(parity_reset),
        .in(in),
        .odd(parity_odd)
    );

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
            done_reg <= 0;
            parity_reset <= 1;
        end else begin
            state <= next_state;
            if (state == RECEIVE) bit_count <= bit_count + 1'b1;
            if (state == STOP) done_reg <= 0;
            if (state == IDLE || state == START) parity_reset <= 1;
            else parity_reset <= 0;
        end
    end

    // Next state logic
    always @(*) begin
        next_state = state;
        case (state)
            IDLE: begin
                if (!in) next_state = START;  // Detect start bit
            end
            START: begin
                next_state = RECEIVE;
            end
            RECEIVE: begin
                if (bit_count == 9) next_state = PARITY_CHECK;  // After 9 bits (8 data + 1 parity)
            end
            PARITY_CHECK: begin
                if (parity_odd) next_state = STOP;  // Check parity
                else next_state = IDLE;  // Parity error, wait for next start bit
            end
            STOP: begin
                if (in) next_state = IDLE;  // Stop bit detected, go back to idle
                else next_state = START;  // Stop bit not detected, find next start
            end
        endcase
    end

    // Output logic
    always @(posedge clk) begin
        if (state == RECEIVE && bit_count < 8) begin
            data_shift <= {in, data_shift[7:1]};  // Shift in data bits
        end
        if (state == STOP && in) begin
            done_reg <= 1;  // Assert done if stop bit is correct
            out_byte <= data_shift;  // Capture the received byte
        end
    end

    assign done = done_reg;

endmodule"
N/A,N/A,-1,73,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

verilog
    // State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        RECEIVE = 3'b010,
        PARITY_CHECK = 3'b011,
        STOP = 3'b100,
        DONE = 3'b101
    } state_t;

    state_t state, next_state;
    reg [3:0] bit_count;  // Count the number of bits received
    reg [7:0] data;       // Store the received data byte
    reg parity_bit;       // Store the received parity bit
    wire odd_parity;      // Output from the parity module

    // Instantiate the parity module
    parity parity_inst (
        .clk(clk),
        .reset(reset | (state == IDLE) | (state == START)),
        .in(in),
        .odd(odd_parity)
    );

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
        end else begin
            state <= next_state;
        end
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 0) // Look for start bit
                    next_state = START;
                else
                    next_state = IDLE;
            end
            START: begin
                if (bit_count == 1)
                    next_state = RECEIVE;
                else
                    next_state = START;
            end
            RECEIVE: begin
                if (bit_count == 9) // 8 data bits + 1 parity bit
                    next_state = PARITY_CHECK;
                else
                    next_state = RECEIVE;
            end
            PARITY_CHECK: begin
                if (odd_parity == 1) // Check for odd parity
                    next_state = STOP;
                else
                    next_state = IDLE; // Parity error, go back to IDLE
            end
            STOP: begin
                if (in == 1) // Check for stop bit
                    next_state = DONE;
                else
                    next_state = IDLE; // Stop bit error, go back to IDLE
            end
            DONE: begin
                next_state = IDLE; // After done, go back to IDLE
            end
            default: next_state = IDLE;
        endcase
    end

    // Output logic and bit counting
    always @(posedge clk) begin
        if (reset) begin
            bit_count <= 0;
            data <= 8'b0;
            parity_bit <= 0;
        end else begin
            case (state)
                IDLE: begin
                    bit_count <= 0;
                end
                START: begin
                    bit_count <= bit_count + 1;
                end
                RECEIVE: begin
                    bit_count <= bit_count + 1;
                    if (bit_count < 8) begin
                        data <= {in, data[7:1]}; // Shift in the data bits
                    end else begin
                        parity_bit <= in; // Capture the parity bit
                    end
                end
                PARITY_CHECK: begin
                    // No operations needed here
                end
                STOP: begin
                    // No operations needed here
                end
                DONE: begin
                    // No operations needed here
                end
            endcase
        end
    end

    // Assign outputs
    assign out_byte = data;
    assign done = (state == DONE);

endmodule"
N/A,N/A,-1,74,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

verilog
    // State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        DATA = 3'b010,
        PARITY = 3'b011,
        STOP = 3'b100,
        ERROR = 3'b101
    } state_t;
    
    state_t state, next_state;
    reg [3:0] bit_count;  // Count the number of bits received
    reg [7:0] data;       // Store the received data byte
    reg parity_bit;       // Store the received parity bit
    wire parity_odd;      // Output from the parity module
    reg parity_reset;     // Control signal to reset the parity module
    reg stop_bit;         // Store the received stop bit

    // Instantiate the parity module
    parity parity_inst (
        .clk(clk),
        .reset(parity_reset),
        .in(in),
        .odd(parity_odd)
    );

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
            parity_reset <= 1;
        end else begin
            state <= next_state;
            if (state == DATA) begin
                data[bit_count] <= in;
                bit_count <= bit_count + 1;
            end
            if (state == PARITY) begin
                parity_bit <= in;
            end
            if (state == STOP) begin
                stop_bit <= in;
            end
            if (state == IDLE || state == ERROR) begin
                bit_count <= 0;
                parity_reset <= 1; // Reset parity check at the start or after error
            end else begin
                parity_reset <= 0;
            end
        end
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 0) // Start bit detected
                    next_state = START;
                else
                    next_state = IDLE;
            end
            START: begin
                if (bit_count == 0) // Move to data state after recognizing start bit
                    next_state = DATA;
                else
                    next_state = START;
            end
            DATA: begin
                if (bit_count == 8) // All data bits received
                    next_state = PARITY;
                else
                    next_state = DATA;
            end
            PARITY: begin
                next_state = STOP; // Move to stop bit checking
            end
            STOP: begin
                if (stop_bit == 1 && parity_odd == ~parity_bit) // Valid stop bit and parity check
                    next_state = IDLE;
                else
                    next_state = ERROR;
            end
            ERROR: begin
                if (in == 1) // Wait for stop bit to recover
                    next_state = IDLE;
                else
                    next_state = ERROR;
            end
            default: next_state = IDLE;
        endcase
    end

    // Output logic
    assign out_byte = data;
    assign done = (state == STOP) && (stop_bit == 1) && (parity_odd == ~parity_bit);

endmodule"
N/A,N/A,-1,75,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

verilog
    // State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        RECEIVE = 3'b010,
        PARITY_CHECK = 3'b011,
        STOP = 3'b100
    } state_t;

    state_t state, next_state;
    reg [7:0] data_shift;
    reg [3:0] bit_count;
    wire parity_odd;
    reg parity_reset;
    reg [7:0] out_byte_reg;
    reg done_reg;

    // Instantiate the parity module
    parity parity_inst (
        .clk(clk),
        .reset(parity_reset),
        .in(in),
        .odd(parity_odd)
    );

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
            parity_reset <= 1;
            done_reg <= 0;
        end else begin
            state <= next_state;
            if (state == RECEIVE) begin
                data_shift <= {in, data_shift[7:1]};
                bit_count <= bit_count + 1;
            end
        end
    end

    // Next state logic
    always @(*) begin
        next_state = state;
        parity_reset = 0;
        done_reg = 0;

        case (state)
            IDLE: begin
                if (~in) begin
                    next_state = START;
                    parity_reset = 1; // Reset parity on start bit
                end
            end

            START: begin
                if (in) begin
                    next_state = RECEIVE;
                    bit_count = 0;
                end
            end

            RECEIVE: begin
                if (bit_count == 8) begin
                    next_state = PARITY_CHECK;
                end
            end

            PARITY_CHECK: begin
                if (parity_odd == in) begin
                    next_state = STOP;
                end else begin
                    next_state = IDLE; // Parity failed, return to IDLE
                end
            end

            STOP: begin
                if (in) begin
                    next_state = IDLE;
                    out_byte_reg = data_shift;
                    done_reg = 1;
                end
            end
        endcase
    end

    assign out_byte = out_byte_reg;
    assign done = done_reg;

endmodule"
N/A,N/A,-1,76,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

verilog
    // State encoding
    typedef enum reg [2:0] {
        IDLE,
        START,
        DATA,
        PARITY,
        STOP
    } state_t;

    // State registers
    reg [2:0] state, next_state;
    reg [3:0] bit_count; // To count bits received
    reg [7:0] data_reg;  // To store the received byte
    reg parity_bit;      // To store the received parity bit
    wire odd_parity;     // Output from parity module

    // Instantiate the parity module
    parity parity_inst (
        .clk(clk),
        .reset(reset | (state == START)), // Reset on FSM reset or new start bit
        .in(in),
        .odd(odd_parity)
    );

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
            data_reg <= 8'b0;
            parity_bit <= 0;
        end else begin
            state <= next_state;
            if (state == DATA) begin
                data_reg[bit_count] <= in;
                bit_count <= bit_count + 1;
            end else if (state == PARITY) begin
                parity_bit <= in;
            end
        end
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 0) // Detect start bit
                    next_state = START;
                else
                    next_state = IDLE;
            end
            START: begin
                next_state = DATA;
            end
            DATA: begin
                if (bit_count == 8)
                    next_state = PARITY;
                else
                    next_state = DATA;
            end
            PARITY: begin
                next_state = STOP;
            end
            STOP: begin
                if (in == 1 && (odd_parity == 1'b1)) // Check stop bit and parity
                    next_state = IDLE;
                else if (in == 1) // Stop bit is correct but parity failed
                    next_state = IDLE;
                else
                    next_state = STOP; // Wait for stop bit
            end
            default: next_state = IDLE;
        endcase
    end

    // Output logic
    assign done = (state == STOP) && (in == 1) && (odd_parity == 1'b1);
    assign out_byte = data_reg;

endmodule"
N/A,N/A,-1,77,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

verilog
    // State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        DATA = 3'b010,
        PARITY = 3'b011,
        STOP = 3'b100,
        ERROR = 3'b101
    } state_t;
    
    reg [2:0] state, next_state;
    reg [3:0] bit_count;
    reg [7:0] data_byte;
    wire odd_parity;
    
    // Parity checker instance
    parity parity_checker (
        .clk(clk),
        .reset(reset | (state == START)),
        .in(in),
        .odd(odd_parity)
    );

    // State transition
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
        end else begin
            state <= next_state;
            if (state == DATA) begin
                data_byte[bit_count] <= in;
                bit_count <= bit_count + 1;
            end
        end
    end

    // Next state logic
    always @(*) begin
        next_state = state; // Default to hold state
        case (state)
            IDLE: begin
                if (!in) next_state = START; // Detect start bit
            end
            START: begin
                if (bit_count == 0) next_state = DATA;
            end
            DATA: begin
                if (bit_count == 8) next_state = PARITY;
            end
            PARITY: begin
                if (odd_parity == in) next_state = STOP;
                else next_state = ERROR;
            end
            STOP: begin
                if (in) next_state = IDLE; // Detect stop bit
                else next_state = ERROR;
            end
            ERROR: begin
                if (in) next_state = IDLE; // Wait for stop bit
            end
        endcase
    end

    // Output logic
    assign done = (state == STOP) && in;
    assign out_byte = data_byte;

endmodule"
N/A,N/A,-1,78,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

verilog
    // State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        RECEIVE = 3'b010,
        PARITY_CHECK = 3'b011,
        STOP = 3'b100
    } state_t;

    state_t state, next_state;
    reg [7:0] data_shift;
    reg [3:0] bit_count;
    wire parity_odd;
    reg parity_reset;
    reg done_reg;

    // Instantiate the parity module
    parity parity_inst (
        .clk(clk),
        .reset(parity_reset),
        .in(in),
        .odd(parity_odd)
    );

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
            done_reg <= 0;
            parity_reset <= 1;
        end else begin
            state <= next_state;
            if (state == RECEIVE) bit_count <= bit_count + 1'b1;
            if (state == STOP) done_reg <= 0;
            if (state == PARITY_CHECK && parity_odd) done_reg <= 1;
        end
    end

    // Next state logic
    always @(*) begin
        next_state = state;
        parity_reset = 0;
        case (state)
            IDLE: begin
                if (!in) next_state = START;  // Detect start bit
            end
            START: begin
                next_state = RECEIVE;
                bit_count = 0;
                parity_reset = 1;
            end
            RECEIVE: begin
                if (bit_count == 8) next_state = PARITY_CHECK;
            end
            PARITY_CHECK: begin
                if (parity_odd) next_state = STOP;
                else next_state = IDLE;  // Parity error, wait for next start bit
            end
            STOP: begin
                if (in) next_state = IDLE;  // Detect stop bit
                else next_state = START;  // If stop bit is not detected, wait for next start bit
            end
        endcase
    end

    // Output logic
    always @(posedge clk) begin
        if (state == RECEIVE) begin
            data_shift <= {in, data_shift[7:1]};  // Shift data in
        end
    end

    assign out_byte = data_shift;
    assign done = done_reg;

endmodule"
N/A,N/A,-1,79,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

verilog
    // State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        RECEIVE = 3'b010,
        PARITY_CHECK = 3'b011,
        STOP = 3'b100
    } state_t;

    state_t state, next_state;
    reg [7:0] data_shift;
    reg [3:0] bit_count;
    wire parity_odd;
    reg parity_reset;
    reg done_reg;

    // Instantiate the parity module
    parity parity_inst (
        .clk(clk),
        .reset(parity_reset),
        .in(in),
        .odd(parity_odd)
    );

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
            done_reg <= 0;
            parity_reset <= 1;
        end else begin
            state <= next_state;
            if (state == RECEIVE) bit_count <= bit_count + 1'b1;
            if (state == STOP) done_reg <= 0;
            if (state == IDLE || state == START) parity_reset <= 1;
            else parity_reset <= 0;
        end
    end

    // Next state logic
    always @(*) begin
        next_state = state;
        case (state)
            IDLE: begin
                if (!in) next_state = START;  // Detect start bit
            end
            START: begin
                next_state = RECEIVE;
            end
            RECEIVE: begin
                if (bit_count == 9) next_state = PARITY_CHECK;  // After 9 bits (8 data + 1 parity)
            end
            PARITY_CHECK: begin
                if (parity_odd) next_state = STOP;  // Check parity
                else next_state = IDLE;  // Parity error, wait for next start bit
            end
            STOP: begin
                if (in) next_state = IDLE;  // Stop bit detected, go back to idle
                else next_state = START;  // If stop bit not detected, look for new start bit
            end
        endcase
    end

    // Output logic
    always @(posedge clk) begin
        if (state == RECEIVE && bit_count < 8) begin
            data_shift <= {in, data_shift[7:1]};
        end
        if (state == STOP && in) begin
            done_reg <= 1;
        end
    end

    assign out_byte = data_shift;
    assign done = done_reg;

endmodule"
N/A,N/A,-1,80,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

verilog
    // State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        RECEIVE = 3'b010,
        PARITY_CHECK = 3'b011,
        STOP = 3'b100
    } state_t;

    state_t state, next_state;
    reg [7:0] data_shift;
    reg [3:0] bit_count;
    wire parity_odd;
    reg parity_reset;
    reg [7:0] out_byte_reg;
    reg done_reg;

    // Instantiate the parity module
    parity parity_inst (
        .clk(clk),
        .reset(parity_reset),
        .in(in),
        .odd(parity_odd)
    );

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
            parity_reset <= 1;
            done_reg <= 0;
        end else begin
            state <= next_state;
            if (state == RECEIVE) begin
                data_shift <= {in, data_shift[7:1]};
                bit_count <= bit_count + 1;
            end
        end
    end

    // Next state logic
    always @(*) begin
        next_state = state;
        parity_reset = 0;
        done_reg = 0;
        case (state)
            IDLE: begin
                if (~in) begin
                    next_state = START;
                    parity_reset = 1; // Reset parity on start bit
                end
            end
            START: begin
                if (in) begin
                    next_state = RECEIVE;
                    bit_count = 0;
                end
            end
            RECEIVE: begin
                if (bit_count == 8) begin
                    next_state = PARITY_CHECK;
                end
            end
            PARITY_CHECK: begin
                if (parity_odd == in) begin
                    next_state = STOP;
                end else begin
                    next_state = IDLE; // Parity failed, return to IDLE
                end
            end
            STOP: begin
                if (in) begin
                    next_state = IDLE;
                    out_byte_reg = data_shift;
                    done_reg = 1;
                end
            end
        endcase
    end

    assign out_byte = out_byte_reg;
    assign done = done_reg;

endmodule"
N/A,N/A,-1,81,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

verilog
    // State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        DATA = 3'b010,
        PARITY = 3'b011,
        STOP = 3'b100
    } state_t;

    state_t state, next_state;
    reg [3:0] bit_count;  // Count the number of bits received
    reg [7:0] data_byte;  // Store the received data byte
    reg parity_bit;       // Store the received parity bit
    wire odd;             // Output of the parity checker

    // Instantiate the parity module
    parity parity_checker (
        .clk(clk),
        .reset(reset | (state == IDLE)),
        .in(in),
        .odd(odd)
    );

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
            data_byte <= 8'b0;
            parity_bit <= 0;
        end else begin
            state <= next_state;
            if (state == DATA && bit_count < 8) begin
                data_byte <= {in, data_byte[7:1]};
                bit_count <= bit_count + 1;
            end else if (state == PARITY) begin
                parity_bit <= in;
            end else if (state == STOP) begin
                bit_count <= 0;
            end
        end
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (!in) next_state = START;  // Detect start bit (0)
                else next_state = IDLE;
            end
            START: begin
                if (in) next_state = DATA;  // Move to data state when start bit is done
                else next_state = START;
            end
            DATA: begin
                if (bit_count == 8) next_state = PARITY;  // After 8 data bits, check parity
                else next_state = DATA;
            end
            PARITY: begin
                next_state = STOP;  // Move to stop state after parity bit
            end
            STOP: begin
                if (in) next_state = IDLE;  // Stop bit detected, go back to IDLE
                else next_state = STOP;
            end
            default: next_state = IDLE;
        endcase
    end

    // Output logic
    assign done = (state == STOP) && in && (odd == 1'b1) && (parity_bit == 1'b0);
    assign out_byte = data_byte;

endmodule"
N/A,N/A,-1,82,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

verilog
    // State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        RECEIVE = 3'b010,
        PARITY_CHECK = 3'b011,
        STOP = 3'b100
    } state_t;

    state_t state, next_state;
    reg [7:0] data_shift;
    reg [3:0] bit_count;
    wire parity_odd;
    reg parity_reset;
    reg [7:0] out_byte_reg;
    reg done_reg;

    // Instantiate the parity module
    parity parity_inst (
        .clk(clk),
        .reset(parity_reset),
        .in(in),
        .odd(parity_odd)
    );

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
            data_shift <= 8'b0;
            parity_reset <= 1;
            done_reg <= 0;
        end else begin
            state <= next_state;
            if (state == RECEIVE) begin
                data_shift <= {in, data_shift[7:1]};
                bit_count <= bit_count + 1;
            end
            if (state == STOP) begin
                out_byte_reg <= data_shift;
                done_reg <= 1;
            end else begin
                done_reg <= 0;
            end
        end
    end

    // Next state logic
    always @(*) begin
        next_state = state; // Default to hold state
        parity_reset = 0; // Default parity reset
        case (state)
            IDLE: begin
                if (~in) next_state = START; // Detect start bit (0)
                parity_reset = 1; // Reset parity checker
            end
            START: begin
                next_state = RECEIVE; // Move to receive data bits
            end
            RECEIVE: begin
                if (bit_count == 8) next_state = PARITY_CHECK; // After 8 bits, check parity
            end
            PARITY_CHECK: begin
                if (parity_odd == in) next_state = STOP; // Check if parity is odd
                else next_state = IDLE; // Parity failed, go back to IDLE
            end
            STOP: begin
                if (in) next_state = IDLE; // Stop bit should be 1
                else next_state = IDLE; // If stop bit is not 1, go back to IDLE
            end
        endcase
    end

    // Output logic
    assign out_byte = out_byte_reg;
    assign done = done_reg;

endmodule"
N/A,N/A,-1,83,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

verilog
    // State encoding
    typedef enum reg [2:0] {
        IDLE,
        START,
        DATA,
        PARITY,
        STOP
    } state_t;

    // State registers
    reg [2:0] state, next_state;
    reg [3:0] bit_count; // To count the number of bits received
    reg [7:0] data;      // To store the received data byte
    wire parity_odd;     // Parity check output

    // Instantiate the parity module
    parity parity_inst (
        .clk(clk),
        .reset(reset | (state == IDLE) | (state == START)), // Reset at IDLE and START
        .in(in),
        .odd(parity_odd)
    );

    // State transition logic
    always @(*) begin
        next_state = state;
        case (state)
            IDLE: begin
                if (in == 0) // Detect start bit
                    next_state = START;
            end
            START: begin
                if (bit_count == 4'd8) // After 8 bits of data
                    next_state = PARITY;
            end
            PARITY: begin
                next_state = STOP; // Move to stop bit check
            end
            STOP: begin
                if (in == 1) // Check stop bit
                    next_state = IDLE;
            end
        endcase
    end

    // State register update
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
        end else begin
            state <= next_state;
            if (state == START || state == DATA) begin
                bit_count <= bit_count + 1;
            end else if (state == STOP) begin
                bit_count <= 0;
            end
        end
    end

    // Output logic
    always @(posedge clk) begin
        if (state == DATA) begin
            data <= {in, data[7:1]}; // Shift in the data bits
        end
    end

    assign out_byte = data;
    assign done = (state == STOP) && (in == 1) && parity_odd; // Assert done if stop bit is correct and parity is odd

endmodule"
N/A,N/A,-1,84,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

verilog
    // State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        RECEIVE = 3'b010,
        PARITY_CHECK = 3'b011,
        STOP = 3'b100
    } state_t;

    state_t state, next_state;
    reg [7:0] data_shift;
    reg [3:0] bit_count;
    wire parity_odd;
    reg parity_reset;
    reg done_reg;

    // Instantiate the parity module
    parity parity_inst (
        .clk(clk),
        .reset(parity_reset),
        .in(in),
        .odd(parity_odd)
    );

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            data_shift <= 8'd0;
            bit_count <= 4'd0;
            done_reg <= 1'b0;
            parity_reset <= 1'b1;
        end else begin
            state <= next_state;
            if (state == RECEIVE) begin
                data_shift <= {in, data_shift[7:1]};
                bit_count <= bit_count + 1;
            end
            if (state == PARITY_CHECK) begin
                done_reg <= (parity_odd);
            end
            if (state == STOP) begin
                done_reg <= 1'b0; // Reset done signal
            end
        end
    end

    // Next state logic
    always @(*) begin
        next_state = state;
        parity_reset = 1'b0;
        case (state)
            IDLE: begin
                if (!in) begin // Start bit detected
                    next_state = START;
                end
                parity_reset = 1'b1; // Reset parity for the new byte
            end
            START: begin
                next_state = RECEIVE;
            end
            RECEIVE: begin
                if (bit_count == 4'd8) begin
                    next_state = PARITY_CHECK;
                end
            end
            PARITY_CHECK: begin
                next_state = STOP;
            end
            STOP: begin
                if (in) begin // Stop bit detected
                    next_state = IDLE;
                end
            end
        endcase
    end

    // Output logic
    assign out_byte = data_shift;
    assign done = done_reg;

endmodule"
N/A,N/A,-1,85,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

verilog
    // State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        RECEIVE = 3'b010,
        PARITY_CHECK = 3'b011,
        STOP = 3'b100
    } state_t;

    state_t state, next_state;
    reg [7:0] data_shift;
    reg [3:0] bit_count;
    wire parity_odd;
    reg parity_reset;
    reg [7:0] out_byte_reg;
    reg done_reg;

    // Instantiate the parity module
    parity parity_inst (
        .clk(clk),
        .reset(parity_reset),
        .in(in),
        .odd(parity_odd)
    );

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
            parity_reset <= 1;
            done_reg <= 0;
        end else begin
            state <= next_state;
            if (state == RECEIVE) begin
                data_shift <= {in, data_shift[7:1]};
                bit_count <= bit_count + 1;
            end
        end
    end

    // Next state logic
    always @(*) begin
        next_state = state;
        parity_reset = 0;
        done_reg = 0;

        case (state)
            IDLE: begin
                if (~in) begin
                    next_state = START;
                    parity_reset = 1; // Reset parity on start bit
                end
            end

            START: begin
                if (in) begin
                    next_state = RECEIVE;
                    bit_count = 0;
                end
            end

            RECEIVE: begin
                if (bit_count == 8) begin
                    next_state = PARITY_CHECK;
                end
            end

            PARITY_CHECK: begin
                if (parity_odd) begin
                    next_state = STOP;
                end else begin
                    next_state = IDLE; // Parity check failed, go back to IDLE
                end
            end

            STOP: begin
                if (in) begin
                    next_state = IDLE;
                    out_byte_reg = data_shift;
                    done_reg = 1;
                end
            end
        endcase
    end

    assign out_byte = out_byte_reg;
    assign done = done_reg;

endmodule"
N/A,N/A,-1,86,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

verilog
    // State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        RECEIVE = 3'b010,
        PARITY_CHECK = 3'b011,
        STOP = 3'b100
    } state_t;

    state_t state, next_state;
    reg [7:0] data_shift;
    reg [3:0] bit_count;
    wire parity_odd;
    reg parity_reset;
    reg [7:0] out_byte_reg;
    reg done_reg;

    // Instantiate the parity module
    parity parity_inst (
        .clk(clk),
        .reset(parity_reset),
        .in(in),
        .odd(parity_odd)
    );

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
            parity_reset <= 1;
            done_reg <= 0;
        end else begin
            state <= next_state;
            if (state == RECEIVE) begin
                data_shift <= {in, data_shift[7:1]};
                bit_count <= bit_count + 1;
            end
        end
    end

    // Next state logic
    always @(*) begin
        next_state = state;
        parity_reset = 0;
        done_reg = 0;

        case (state)
            IDLE: begin
                if (~in) begin
                    next_state = START;
                    parity_reset = 1; // Reset parity on start bit
                end
            end

            START: begin
                if (in) begin
                    next_state = RECEIVE;
                    bit_count = 0;
                end
            end

            RECEIVE: begin
                if (bit_count == 8) begin
                    next_state = PARITY_CHECK;
                end
            end

            PARITY_CHECK: begin
                if (parity_odd == in) begin
                    next_state = STOP;
                end else begin
                    next_state = IDLE; // Parity error, return to IDLE
                end
            end

            STOP: begin
                if (in) begin
                    next_state = IDLE;
                    out_byte_reg = data_shift;
                    done_reg = 1;
                end
            end
        endcase
    end

    assign out_byte = out_byte_reg;
    assign done = done_reg;

endmodule"
N/A,N/A,-1,87,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

verilog
    // State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        RECEIVE = 3'b010,
        PARITY_CHECK = 3'b011,
        STOP = 3'b100
    } state_t;

    state_t state, next_state;
    reg [3:0] bit_count;
    reg [7:0] data;
    reg parity_bit;
    wire parity_odd;

    // Instantiate the parity module
    parity parity_checker (
        .clk(clk),
        .reset(reset | (state == IDLE)),
        .in(in),
        .odd(parity_odd)
    );

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
        end else begin
            state <= next_state;
        end
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 0)  // Start bit detected
                    next_state = START;
                else
                    next_state = IDLE;
            end
            START: begin
                next_state = RECEIVE;
            end
            RECEIVE: begin
                if (bit_count == 8)
                    next_state = PARITY_CHECK;
                else
                    next_state = RECEIVE;
            end
            PARITY_CHECK: begin
                next_state = STOP;
            end
            STOP: begin
                if (in == 1)  // Stop bit detected
                    next_state = IDLE;
                else
                    next_state = STOP;  // Wait for stop bit
            end
            default: next_state = IDLE;
        endcase
    end

    // Output logic and bit count
    always @(posedge clk) begin
        if (reset) begin
            bit_count <= 0;
            data <= 8'b0;
            parity_bit <= 0;
        end else begin
            case (state)
                IDLE: begin
                    bit_count <= 0;
                    data <= 8'b0;
                    parity_bit <= 0;
                end
                START: begin
                    bit_count <= 0;
                end
                RECEIVE: begin
                    data[bit_count] <= in;
                    bit_count <= bit_count + 1;
                end
                PARITY_CHECK: begin
                    parity_bit <= in;
                end
                STOP: begin
                    // No action needed
                end
            endcase
        end
    end

    // Done signal logic
    assign done = (state == STOP) && (in == 1) && (parity_bit == parity_odd);

    // Output byte logic
    assign out_byte = data;

endmodule"
N/A,N/A,-1,88,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

verilog
    // State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        RECEIVE = 3'b010,
        PARITY_CHECK = 3'b011,
        STOP = 3'b100
    } state_t;

    state_t state, next_state;
    reg [7:0] data_shift;
    reg [3:0] bit_count;
    wire parity_odd;
    reg parity_reset;
    reg done_reg;

    // Instantiate the parity module
    parity parity_inst (
        .clk(clk),
        .reset(parity_reset),
        .in(in),
        .odd(parity_odd)
    );

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
            done_reg <= 0;
            parity_reset <= 1;
        end else begin
            state <= next_state;
            if (state == RECEIVE) bit_count <= bit_count + 1'b1;
            if (state == STOP) done_reg <= 0;
            if (state == IDLE || state == PARITY_CHECK) parity_reset <= 1;
            else parity_reset <= 0;
        end
    end

    // Next state logic
    always @(*) begin
        next_state = state;
        case (state)
            IDLE: begin
                if (in == 0) next_state = START; // Detect start bit (0)
            end
            START: begin
                if (bit_count == 4'd8) next_state = RECEIVE; // Move to RECEIVE after 1 bit (start bit)
            end
            RECEIVE: begin
                if (bit_count == 4'd8) next_state = PARITY_CHECK; // Move to PARITY_CHECK after 8 data bits
            end
            PARITY_CHECK: begin
                if (parity_odd) next_state = STOP; // Check for odd parity
                else next_state = IDLE; // If parity fails, go back to IDLE
            end
            STOP: begin
                if (in == 1) next_state = IDLE; // Expect stop bit (1)
            end
        endcase
    end

    // Output logic
    always @(posedge clk) begin
        if (state == RECEIVE && bit_count < 4'd8) begin
            data_shift <= {in, data_shift[7:1]};
        end
        if (state == STOP && in == 1) begin
            out_byte <= data_shift;
            done_reg <= 1;
        end
    end

    assign done = done_reg;

endmodule"
N/A,N/A,-1,89,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

verilog
    // State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        DATA = 3'b010,
        PARITY = 3'b011,
        STOP = 3'b100,
        ERROR = 3'b101
    } state_t;
    
    state_t state, next_state;
    reg [3:0] bit_count;  // Count the number of bits received
    reg [7:0] data;       // Store the received data byte
    reg parity_bit;       // Store the received parity bit
    wire odd_parity;      // Output from the parity module
    reg parity_reset;     // Control signal to reset the parity module
    
    // Instantiate the parity module
    parity parity_inst (
        .clk(clk),
        .reset(parity_reset),
        .in(in),
        .odd(odd_parity)
    );
    
    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
            parity_reset <= 1;
        end else begin
            state <= next_state;
            if (state == DATA) begin
                data <= {in, data[7:1]};  // Shift in data bits
                bit_count <= bit_count + 1;
            end
            if (state == PARITY) begin
                parity_bit <= in;  // Capture the parity bit
            end
            if (state == IDLE || state == STOP) begin
                bit_count <= 0;
                parity_reset <= 1;  // Reset the parity calculation
            end else begin
                parity_reset <= 0;
            end
        end
    end
    
    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (!in) next_state = START;  // Start bit detected
                else next_state = IDLE;
            end
            START: begin
                if (bit_count == 0) next_state = DATA;  // Move to data reception
                else next_state = START;
            end
            DATA: begin
                if (bit_count == 8) next_state = PARITY;  // Move to parity bit reception
                else next_state = DATA;
            end
            PARITY: begin
                next_state = STOP;  // Move to stop bit reception
            end
            STOP: begin
                if (in && (odd_parity ^ parity_bit)) begin  // Check for valid stop bit and parity
                    next_state = IDLE;
                end else begin
                    next_state = ERROR;
                end
            end
            ERROR: begin
                if (in) next_state = IDLE;  // Wait for a stop bit to return to IDLE
                else next_state = ERROR;
            end
            default: next_state = IDLE;
        endcase
    end
    
    // Output logic
    assign done = (state == STOP) && (in) && (odd_parity ^ parity_bit);
    assign out_byte = data;

endmodule"
N/A,N/A,-1,90,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

verilog
    // State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        RECEIVE = 3'b010,
        PARITY_CHECK = 3'b011,
        STOP = 3'b100
    } state_t;

    state_t state, next_state;
    reg [3:0] bit_count;
    reg [7:0] shift_reg;
    wire parity_odd;
    reg parity_reset;
    reg done_reg;

    // Instantiate the parity module
    parity parity_inst (
        .clk(clk),
        .reset(parity_reset),
        .in(in),
        .odd(parity_odd)
    );

    // State transition
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
            shift_reg <= 0;
            done_reg <= 0;
        end else begin
            state <= next_state;
            if (state == RECEIVE) begin
                shift_reg <= {in, shift_reg[7:1]};
                bit_count <= bit_count + 1;
            end
            if (state == PARITY_CHECK) begin
                done_reg <= (parity_odd && in);
            end else begin
                done_reg <= 0;
            end
        end
    end

    // Next state logic
    always @(*) begin
        next_state = state;
        parity_reset = 0;
        case (state)
            IDLE: begin
                if (in == 0) begin
                    next_state = START;
                    parity_reset = 1;
                end
            end
            START: begin
                if (in == 0) begin
                    next_state = RECEIVE;
                end
            end
            RECEIVE: begin
                if (bit_count == 8) begin
                    next_state = PARITY_CHECK;
                end
            end
            PARITY_CHECK: begin
                next_state = STOP;
            end
            STOP: begin
                if (in == 1) begin
                    next_state = IDLE;
                end
            end
        endcase
    end

    // Output assignments
    assign out_byte = shift_reg;
    assign done = done_reg;

endmodule"
N/A,N/A,-1,91,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

verilog
    // State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        RECEIVE = 3'b010,
        PARITY_CHECK = 3'b011,
        STOP = 3'b100
    } state_t;

    state_t state, next_state;
    reg [7:0] data_shift;
    reg [3:0] bit_count;
    wire parity_odd;
    reg parity_reset;
    reg done_reg;

    // Instantiate the parity module
    parity parity_inst (
        .clk(clk),
        .reset(parity_reset),
        .in(in),
        .odd(parity_odd)
    );

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
            done_reg <= 0;
            parity_reset <= 1;
        end else begin
            state <= next_state;
            if (state == RECEIVE) bit_count <= bit_count + 1'b1;
            if (state == STOP) done_reg <= 0;
            if (state == PARITY_CHECK && parity_odd) done_reg <= 1;
        end
    end

    // Next state logic
    always @(*) begin
        next_state = state;
        parity_reset = 0;
        case (state)
            IDLE: begin
                if (!in) next_state = START;  // Detect start bit
            end
            START: begin
                next_state = RECEIVE;
                bit_count = 0;
                parity_reset = 1;
            end
            RECEIVE: begin
                if (bit_count == 8) next_state = PARITY_CHECK;
            end
            PARITY_CHECK: begin
                if (parity_odd) next_state = STOP;
                else next_state = IDLE;  // Parity error, wait for next start bit
            end
            STOP: begin
                if (in) next_state = IDLE;  // Detect stop bit
                else next_state = START;  // If stop bit not detected, look for next start bit
            end
        endcase
    end

    // Output logic
    always @(posedge clk) begin
        if (state == RECEIVE && bit_count < 8) begin
            data_shift <= {in, data_shift[7:1]};
        end
    end

    assign out_byte = data_shift;
    assign done = done_reg;

endmodule"
N/A,N/A,-1,92,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

verilog
    // State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        DATA = 3'b010,
        PARITY = 3'b011,
        STOP = 3'b100,
        ERROR = 3'b101
    } state_t;
    
    state_t state, next_state;
    reg [3:0] bit_count;  // Count the number of bits received
    reg [7:0] data;       // Store the received data byte
    reg parity_bit;       // Store the received parity bit
    wire odd_parity;      // Output from the parity module

    // Instantiate the parity module
    parity parity_inst (
        .clk(clk),
        .reset(reset | (state == IDLE) | (state == START)),
        .in(in),
        .odd(odd_parity)
    );

    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
            data <= 8'b0;
            parity_bit <= 0;
        end else begin
            state <= next_state;
            if (state == DATA) begin
                data <= {in, data[7:1]};  // Shift in the data bits
                bit_count <= bit_count + 1;
            end else if (state == PARITY) begin
                parity_bit <= in;  // Capture the parity bit
            end else if (state == STOP) begin
                bit_count <= 0;  // Reset bit count for the next byte
            end
        end
    end

    // Next state logic
    always @(*) begin
        next_state = state;
        case (state)
            IDLE: begin
                if (in == 0)  // Detect start bit
                    next_state = START;
            end
            START: begin
                if (bit_count == 0)  // Wait for the start bit to be fully received
                    next_state = DATA;
            end
            DATA: begin
                if (bit_count == 8)  // After 8 data bits, move to parity
                    next_state = PARITY;
            end
            PARITY: begin
                next_state = STOP;  // Move to stop after parity bit
            end
            STOP: begin
                if (in == 1) begin  // Check for stop bit
                    if (odd_parity && parity_bit)  // Check for odd parity
                        next_state = IDLE;  // Correct byte received
                    else
                        next_state = ERROR;  // Parity error
                end
            end
            ERROR: begin
                if (in == 1)  // Wait for stop bit to return to IDLE
                    next_state = IDLE;
            end
        endcase
    end

    // Output logic
    assign out_byte = data;
    assign done = (state == STOP && in == 1 && odd_parity && parity_bit);

endmodule"
N/A,N/A,-1,93,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

verilog
    // State encoding
    typedef enum reg [2:0] {
        IDLE,
        START,
        DATA,
        PARITY,
        STOP
    } state_t;

    reg [2:0] state, next_state;
    reg [3:0] bit_count; // Counts bits from 0 to 8 (8 data bits + 1 parity bit)
    reg [7:0] data_reg;  // Stores the received data byte
    wire odd_parity;     // Output from the parity module
    reg parity_reset;    // Reset signal for the parity module

    // Instantiate the parity module
    parity parity_checker (
        .clk(clk),
        .reset(parity_reset),
        .in(in),
        .odd(odd_parity)
    );

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
            data_reg <= 0;
            parity_reset <= 1;
        end else begin
            state <= next_state;
        end
    end

    // Next state logic
    always @(*) begin
        next_state = state;
        parity_reset = 0;
        done = 0;

        case (state)
            IDLE: begin
                if (in == 0) begin // Detect start bit
                    next_state = START;
                    parity_reset = 1; // Reset parity on start bit
                end
            end

            START: begin
                if (bit_count == 0) begin
                    next_state = DATA;
                end
            end

            DATA: begin
                if (bit_count < 8) begin
                    data_reg[bit_count] = in; // Shift in data bits
                end
                if (bit_count == 8) begin
                    next_state = PARITY;
                end
            end

            PARITY: begin
                if (bit_count == 9) begin
                    if (odd_parity) begin
                        next_state = STOP;
                    end else begin
                        next_state = IDLE; // Parity failed, go back to IDLE
                    end
                end
            end

            STOP: begin
                if (in == 1) begin // Check for stop bit
                    done = 1;
                    next_state = IDLE;
                end else begin
                    next_state = IDLE; // Invalid stop bit, go back to IDLE
                end
            end
        endcase
    end

    // Bit count logic
    always @(posedge clk) begin
        if (reset || state == IDLE || state == START) begin
            bit_count <= 0;
        end else if (state == DATA || state == PARITY) begin
            bit_count <= bit_count + 1;
        end
    end

    // Output assignment
    assign out_byte = data_reg;

endmodule"
N/A,N/A,-1,94,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

verilog
    // State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        RECEIVE = 3'b010,
        PARITY_CHECK = 3'b011,
        STOP = 3'b100
    } state_t;

    state_t state, next_state;
    reg [7:0] data_shift;
    reg [3:0] bit_count;
    wire parity_odd;
    reg parity_reset;
    reg [7:0] out_byte_reg;
    reg done_reg;

    // Instantiate the parity module
    parity parity_inst (
        .clk(clk),
        .reset(parity_reset),
        .in(in),
        .odd(parity_odd)
    );

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
            parity_reset <= 1;
            done_reg <= 0;
        end else begin
            state <= next_state;
            if (state == RECEIVE) begin
                data_shift <= {in, data_shift[7:1]};
                bit_count <= bit_count + 1;
            end
        end
    end

    // Next state logic
    always @(*) begin
        next_state = state;
        parity_reset = 0;
        done_reg = 0;
        case (state)
            IDLE: begin
                if (~in) begin
                    next_state = START;
                    parity_reset = 1; // Reset parity on start bit
                end
            end
            START: begin
                if (in) begin
                    next_state = RECEIVE;
                end
            end
            RECEIVE: begin
                if (bit_count == 8) begin
                    next_state = PARITY_CHECK;
                end
            end
            PARITY_CHECK: begin
                if (parity_odd == 1'b1) begin
                    next_state = STOP;
                end else begin
                    next_state = IDLE; // Parity check failed
                end
            end
            STOP: begin
                if (in) begin
                    out_byte_reg = data_shift;
                    done_reg = 1;
                    next_state = IDLE;
                end else begin
                    next_state = IDLE; // Stop bit not detected
                end
            end
        endcase
    end

    // Output logic
    assign out_byte = out_byte_reg;
    assign done = done_reg;

endmodule"
N/A,N/A,-1,95,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

verilog
    // State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        RECEIVE = 3'b010,
        PARITY_CHECK = 3'b011,
        STOP = 3'b100
    } state_t;

    state_t state, next_state;
    reg [7:0] data_shift;
    reg [3:0] bit_count;
    wire parity_odd;
    reg parity_reset;
    reg done_reg;

    // Instantiate the parity module
    parity parity_inst (
        .clk(clk),
        .reset(parity_reset),
        .in(in),
        .odd(parity_odd)
    );

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
            parity_reset <= 1;
            done_reg <= 0;
        end else begin
            state <= next_state;
            if (state == RECEIVE) bit_count <= bit_count + 1'b1;
            if (state == START) parity_reset <= 0; // Start counting parity
            if (state == STOP) parity_reset <= 1;  // Reset parity counter
        end
    end

    // Next state logic
    always @(*) begin
        next_state = state;
        done_reg = 0; // Default

        case (state)
            IDLE: begin
                if (in == 0) // Detect start bit
                    next_state = START;
            end
            START: begin
                next_state = RECEIVE;
            end
            RECEIVE: begin
                if (bit_count == 8)
                    next_state = PARITY_CHECK;
            end
            PARITY_CHECK: begin
                if (parity_odd == in) // Check parity bit
                    next_state = STOP;
                else
                    next_state = IDLE; // Parity error, go to IDLE
            end
            STOP: begin
                if (in == 1) begin // Detect stop bit
                    done_reg = 1;
                    next_state = IDLE;
                end else begin
                    next_state = IDLE; // Error, return to IDLE
                end
            end
        endcase
    end

    // Output logic
    always @(posedge clk) begin
        if (state == RECEIVE)
            data_shift <= {in, data_shift[7:1]}; // Shift in the bit
    end

    assign out_byte = data_shift;
    assign done = done_reg;

endmodule"
N/A,N/A,-1,96,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

verilog
    // State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        RECEIVE = 3'b010,
        PARITY_CHECK = 3'b011,
        STOP = 3'b100
    } state_t;

    state_t state, next_state;
    reg [3:0] bit_count;
    reg [7:0] data;
    reg parity_bit;
    wire parity_odd;

    // Instantiate the parity module
    parity parity_checker (
        .clk(clk),
        .reset(reset | (state == IDLE)),
        .in(in),
        .odd(parity_odd)
    );

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
        end else begin
            state <= next_state;
        end
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 0)  // Start bit detected
                    next_state = START;
                else
                    next_state = IDLE;
            end
            START: begin
                next_state = RECEIVE;
            end
            RECEIVE: begin
                if (bit_count == 8)
                    next_state = PARITY_CHECK;
                else
                    next_state = RECEIVE;
            end
            PARITY_CHECK: begin
                next_state = STOP;
            end
            STOP: begin
                if (in == 1)  // Stop bit detected
                    next_state = IDLE;
                else
                    next_state = STOP;  // Wait for stop bit
            end
            default: next_state = IDLE;
        endcase
    end

    // Output logic and bit count
    always @(posedge clk) begin
        if (reset) begin
            bit_count <= 0;
            data <= 8'b0;
            parity_bit <= 0;
        end else begin
            case (state)
                IDLE: begin
                    bit_count <= 0;
                    data <= 8'b0;
                    parity_bit <= 0;
                end
                START: begin
                    bit_count <= 0;
                end
                RECEIVE: begin
                    data[bit_count] <= in;
                    bit_count <= bit_count + 1;
                end
                PARITY_CHECK: begin
                    parity_bit <= in;
                end
                STOP: begin
                    // Nothing to do
                end
            endcase
        end
    end

    // Done signal logic
    assign done = (state == STOP) && (in == 1) && (parity_bit == parity_odd);

    // Output byte logic
    assign out_byte = data;

endmodule"
N/A,N/A,-1,97,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

verilog
    // State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        RECEIVE = 3'b010,
        PARITY_CHECK = 3'b011,
        STOP = 3'b100
    } state_t;

    // State variables
    reg [2:0] state, next_state;
    reg [3:0] bit_count; // Count 9 bits (8 data + 1 parity)
    reg [7:0] data;
    reg parity_error;

    // Parity checker instance
    wire odd_parity;
    parity parity_checker (
        .clk(clk),
        .reset(reset || (state == IDLE)), // Reset parity checker in IDLE state
        .in(in),
        .odd(odd_parity)
    );

    // State transition
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
            data <= 8'b0;
            parity_error <= 0;
        end else begin
            state <= next_state;
        end
    end

    // Next state logic
    always @(*) begin
        next_state = state; // Default to hold state
        case (state)
            IDLE: begin
                if (in == 0) // Start bit detected
                    next_state = START;
            end
            START: begin
                if (bit_count == 4'd0) begin
                    next_state = RECEIVE;
                end
            end
            RECEIVE: begin
                if (bit_count == 4'd8) begin
                    next_state = PARITY_CHECK;
                end
            end
            PARITY_CHECK: begin
                if (odd_parity) begin
                    next_state = STOP;
                end else begin
                    next_state = IDLE; // Parity error, wait for new start
                    parity_error = 1;
                end
            end
            STOP: begin
                if (in == 1) begin // Stop bit detected
                    next_state = IDLE;
                end else begin
                    next_state = IDLE; // Error, wait for new start
                end
            end
        endcase
    end

    // Bit counter and data shifting
    always @(posedge clk) begin
        if (reset || state == IDLE) begin
            bit_count <= 0;
            data <= 8'b0;
        end else if (state == RECEIVE) begin
            if (bit_count < 4'd8) begin
                data <= {in, data[7:1]}; // Shift in LSB first
                bit_count <= bit_count + 1;
            end
        end else if (state == PARITY_CHECK) begin
            bit_count <= bit_count + 1; // Count parity bit
        end
    end

    // Output logic
    assign out_byte = data;
    assign done = (state == STOP) && (in == 1) && !parity_error;

endmodule"
N/A,N/A,-1,98,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

verilog
    // State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        RECEIVE = 3'b010,
        PARITY_CHECK = 3'b011,
        STOP = 3'b100
    } state_t;

    state_t state, next_state;
    reg [7:0] data_shift;
    reg [3:0] bit_count;
    wire parity_odd;
    reg parity_reset;
    reg [7:0] out_byte_reg;
    reg done_reg;

    // Instantiate the parity module
    parity parity_inst (
        .clk(clk),
        .reset(parity_reset),
        .in(in),
        .odd(parity_odd)
    );

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
            parity_reset <= 1;
            done_reg <= 0;
        end else begin
            state <= next_state;
            if (state == RECEIVE) begin
                data_shift <= {in, data_shift[7:1]};
                bit_count <= bit_count + 1;
            end
        end
    end

    // Next state logic
    always @(*) begin
        next_state = state;
        parity_reset = 0;
        done_reg = 0;
        case (state)
            IDLE: begin
                if (~in) begin
                    next_state = START;
                end
            end
            START: begin
                if (bit_count == 4'd0) begin
                    next_state = RECEIVE;
                end
            end
            RECEIVE: begin
                if (bit_count == 4'd8) begin
                    next_state = PARITY_CHECK;
                end
            end
            PARITY_CHECK: begin
                if (parity_odd == in) begin
                    next_state = STOP;
                end else begin
                    next_state = IDLE;
                end
            end
            STOP: begin
                if (in) begin
                    out_byte_reg = data_shift;
                    done_reg = 1;
                    next_state = IDLE;
                end
            end
        endcase
    end

    // Output logic
    assign out_byte = out_byte_reg;
    assign done = done_reg;

    // Reset the parity checker at the start of a new byte
    always @(posedge clk) begin
        if (reset || state == IDLE) begin
            parity_reset <= 1;
        end else begin
            parity_reset <= 0;
        end
    end

    // Reset bit count at the start of a new byte
    always @(posedge clk) begin
        if (reset || state == IDLE) begin
            bit_count <= 0;
        end
    end

endmodule"
N/A,N/A,-1,99,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

verilog
    // State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        RECEIVE = 3'b010,
        PARITY_CHECK = 3'b011,
        STOP = 3'b100
    } state_t;

    state_t state, next_state;
    reg [7:0] data_shift;
    reg [3:0] bit_count;
    wire parity_odd;
    reg parity_reset;
    reg done_reg;

    // Instantiate the parity module
    parity parity_inst (
        .clk(clk),
        .reset(parity_reset),
        .in(in),
        .odd(parity_odd)
    );

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
            done_reg <= 0;
            parity_reset <= 1;
        end else begin
            state <= next_state;
            if (state == RECEIVE) bit_count <= bit_count + 1'b1;
            if (state == STOP) done_reg <= 0;
            if (state == PARITY_CHECK && parity_odd) done_reg <= 1;
        end
    end

    // Next state logic
    always @(*) begin
        next_state = state;
        parity_reset = 0;
        case (state)
            IDLE: begin
                if (!in) next_state = START;  // Detect start bit
            end
            START: begin
                next_state = RECEIVE;
                bit_count = 0;
                parity_reset = 1;
            end
            RECEIVE: begin
                if (bit_count == 8) next_state = PARITY_CHECK;
            end
            PARITY_CHECK: begin
                if (parity_odd) next_state = STOP;
                else next_state = IDLE;  // Parity error, go back to idle
            end
            STOP: begin
                if (in) next_state = IDLE;  // Stop bit detected
                else next_state = START;  // If no stop bit, assume it's a new start bit
            end
        endcase
    end

    // Output logic
    always @(posedge clk) begin
        if (state == RECEIVE) begin
            data_shift <= {in, data_shift[7:1]};
        end
    end

    assign out_byte = data_shift;
    assign done = done_reg;

endmodule"
