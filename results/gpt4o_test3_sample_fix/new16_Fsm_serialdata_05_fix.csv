Area,Delay,Score,Current Run,Episode,Verilog,Time,Tokens
N/A,N/A,-0.1,0,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

reg [3:0] state, next_state;
    reg [7:0] shift_reg;
    reg [3:0] bit_count;

    localparam IDLE = 4'd0,
               START = 4'd1,
               DATA = 4'd2,
               STOP = 4'd3;

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 4'd0;
        end else begin
            state <= next_state;
            if (state == DATA) begin
                shift_reg <= {in, shift_reg[7:1]}; // Shift in bits
                bit_count <= bit_count + 4'd1;    // Increment bit count
            end else if (state == IDLE || state == START) begin
                shift_reg <= 8'd0;
                bit_count <= 4'd0;
            end
        end
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: next_state = in ? IDLE : START; // Wait for start bit
            START: next_state = DATA;
            DATA: next_state = (bit_count < 4'd8) ? DATA : STOP; // Collect 8 bits
            STOP: next_state = in ? IDLE : START; // Check stop bit and restart
            default: next_state = IDLE;
        endcase
    end

    // Output logic
    assign done = (state == STOP) && in; // Done when in STOP state with stop bit valid
    assign out_byte = (done) ? shift_reg : 8'bx; // Output valid byte at done

endmodule",6.44803,370
N/A,N/A,-1,1,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START_BIT = 3'b001,
        DATA = 3'b010,
        STOP_BIT = 3'b011,
        DONE = 3'b100
    } state_t;

    state_t state, next_state;
    reg [7:0] shift_reg;
    reg [2:0] bit_counter;

    // State transition logic
    always @(posedge clk) begin
        if (reset)
            state <= IDLE;
        else
            state <= next_state;
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: next_state = in ? IDLE : START_BIT; // Wait for start bit (0)
            START_BIT: next_state = DATA;
            DATA: next_state = (bit_counter == 3'b111) ? STOP_BIT : DATA;
            STOP_BIT: next_state = in ? DONE : IDLE; // Check for stop bit (1)
            DONE: next_state = in ? IDLE : START_BIT; // After a byte is received, look for new start bit
            default: next_state = IDLE;
        endcase
    end

    // Output logic and data path
    always @(posedge clk) begin
        if (reset) begin
            done <= 1'b0;
            bit_counter <= 3'b0;
            shift_reg <= 8'b0;
        end else begin
            case (state)
                IDLE: begin
                    done <= 1'b0;
                    bit_counter <= 3'b0;
                end
                START_BIT: begin
                    done <= 1'b0;
                end
                DATA: begin
                    shift_reg <= {in, shift_reg[7:1]}; // Shift in the serial data
                    bit_counter <= bit_counter + 1'b1;
                end
                STOP_BIT: begin
                    done <= in; // Set done if stop bit is correct
                end
                DONE: begin
                    done <= 1'b1;
                end
            endcase
        end
    end

    // Assign output byte
    assign out_byte = (done) ? shift_reg : 8'bx;

endmodule",6.014869,856
N/A,N/A,-1,2,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Define states for the FSM
    typedef enum logic [2:0] {
        IDLE, START_BIT, DATA_BITS, STOP_BIT, DONE
    } state_t;

    state_t state, next_state;
    reg [7:0] shift_reg;
    reg [3:0] bit_counter;

    // Combinational logic for state transitions
    always_comb begin
        next_state = state;
        case (state)
            IDLE: begin
                if (in == 0) // Start bit is detected
                    next_state = START_BIT;
            end
            START_BIT: begin
                next_state = DATA_BITS;
            end
            DATA_BITS: begin
                if (bit_counter == 8)
                    next_state = STOP_BIT;
            end
            STOP_BIT: begin
                if (in == 1) // Valid stop bit
                    next_state = DONE;
                else
                    next_state = IDLE; // Error, go back to IDLE
            end
            DONE: begin
                next_state = IDLE;
            end
        endcase
    end

    // Sequential logic for state and datapath operations
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_counter <= 0;
            shift_reg <= 8'b0;
        end
        else begin
            state <= next_state;
            case (state)
                START_BIT: begin
                    bit_counter <= 0;
                end
                DATA_BITS: begin
                    shift_reg <= {in, shift_reg[7:1]};
                    bit_counter <= bit_counter + 1;
                end
                DONE: begin
                    // Latch the byte
                    out_byte <= shift_reg;
                end
                default: begin
                    // Reset or hold values in other states
                end
            endcase
        end
    end

    // Assign done signal
    assign done = (state == DONE);

endmodule",5.868705,1276
N/A,N/A,-0.1,3,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

parameter IDLE = 2'd0;
    parameter START = 2'd1;
    parameter DATA = 2'd2;
    parameter STOP = 2'd3;

    reg [1:0] state, next_state;
    reg [3:0] bit_index;
    reg [7:0] shift_reg;
    reg stop_error;

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
        end else begin
            state <= next_state;
        end
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 1'b0)    // Detect start bit
                    next_state = START;
                else
                    next_state = IDLE;
            end

            START: begin
                if (in == 1'b0)
                    next_state = DATA;
                else
                    next_state = IDLE;
            end

            DATA: begin
                if (bit_index == 4'd8)
                    next_state = STOP;
                else
                    next_state = DATA;
            end

            STOP: begin
                if (in == 1'b1 && !stop_error)
                    next_state = IDLE;
                else if (in == 1'b0)
                    next_state = DATA;  // Restart if start detected
                else
                    next_state = STOP;
            end

            default: next_state = IDLE;
        endcase
    end

    // Register to hold serial input and output logic
    always @(posedge clk) begin
        if (reset) begin
            bit_index <= 4'd0;
            shift_reg <= 8'b0;
            stop_error <= 1'b0;
        end else if (state == DATA) begin
            shift_reg <= {in, shift_reg[7:1]};
            bit_index <= bit_index + 1;
        end else if (state == STOP) begin
            stop_error <= (in != 1'b1);  // Check for valid stop bit
        end else begin
            bit_index <= 4'd0;
            stop_error <= 1'b0;
        end
    end

    // Done signal and output assignment
    assign done = (state == STOP) && (in == 1'b1) && !stop_error;
    assign out_byte = shift_reg;

endmodule",7.152077,1792
N/A,N/A,-0.1,4,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

reg [3:0] state, next_state;
    reg [7:0] shift_reg;
    reg [2:0] bit_count;
    reg latch;

    // State encoding
    localparam IDLE     = 4'd0,
               START    = 4'd1,
               RECEIVE  = 4'd2,
               STOP     = 4'd3,
               DONE     = 4'd4,
               ERROR    = 4'd5;

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
        end else begin
            state <= next_state;
        end
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 1'b0) // Start bit detected
                    next_state = START;
                else
                    next_state = IDLE;
            end
            START: begin
                next_state = RECEIVE;
                bit_count = 3'd0;
            end
            RECEIVE: begin
                if (bit_count == 3'd7)
                    next_state = STOP;
                else
                    next_state = RECEIVE;
            end
            STOP: begin
                if (in == 1'b1) // Correct stop bit
                    next_state = DONE;
                else
                    next_state = ERROR;
            end
            DONE: begin
                next_state = IDLE;
            end
            ERROR: begin
                if (in == 1'b1) // Find stop bit before restarting
                    next_state = IDLE;
                else
                    next_state = ERROR;
            end
            default: next_state = IDLE;
        endcase
    end

    // Shift register logic
    always @(posedge clk) begin
        if (state == RECEIVE) begin
            shift_reg <= {in, shift_reg[7:1]}; // Shift in the incoming bits, LSB first
            bit_count <= bit_count + 3'd1;
        end
        if (state == DONE) begin
            latch <= 1'b1;
        end else begin
            latch <= 1'b0;
        end
    end

    // Output logic
    assign out_byte = latch ? shift_reg : 8'bxxxx_xxxx;
    assign done = (state == DONE);

endmodule",7.154068,2296
N/A,N/A,-1,5,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State enumeration for the FSM
    typedef enum logic [2:0] {
        IDLE,       // Waiting for start bit
        RECEIVE,    // Receiving 8 data bits
        STOP,       // Verifying stop bit
        DONE        // Byte received successfully
    } state_t;
    
    state_t state, next_state;
    logic [7:0] shift_reg; // Shift register for data bits
    logic [3:0] bit_count; // Count the number of bits received

    // FSM sequential logic
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
        end else begin
            state <= next_state;
            // Count bits only in RECEIVE state
            if (state == RECEIVE) begin
                bit_count <= bit_count + 1;
            end else begin
                bit_count <= 0; // Reset bit count in other states
            end
        end
    end

    // FSM combinational logic
    always_comb begin
        next_state = state; // Default to stay in current state
        case (state)
            IDLE: begin
                if (in == 0) begin // Start bit detected
                    next_state = RECEIVE;
                end
            end
            RECEIVE: begin
                // Shift in the bits
                shift_reg = {in, shift_reg[7:1]};
                if (bit_count == 8) begin
                    next_state = STOP;
                end
            end
            STOP: begin
                if (in == 1) begin // Stop bit detected
                    next_state = DONE;
                end else if (in == 0) begin // Consider a false stop bit
                    next_state = IDLE; // Wait for correct stop bit
                end
            end
            DONE: begin
                next_state = IDLE; // Return to IDLE for the next byte
            end
        endcase
    end

    // Output logic
    assign out_byte = (state == DONE) ? shift_reg : 8'd0; // Output data when done
    assign done = (state == DONE);

endmodule",5.378082,2759
N/A,N/A,-1,6,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Define the states of the FSM
    typedef enum logic [2:0] {
        IDLE,
        START,
        RECEIVE,
        STOP
    } state_t;

    state_t current_state, next_state;

    // Bit counter for data reception
    reg [2:0] bit_count;
    reg [7:0] shift_reg;

    // Output signals
    reg done_reg;
    reg [7:0] out_byte_reg;

    // State transition logic
    always_ff @(posedge clk) begin
        if (reset) begin
            current_state <= IDLE;
            bit_count <= 3'b000;
            shift_reg <= 8'b0;
            out_byte_reg <= 8'b0;
            done_reg <= 1'b0;
        end else begin
            current_state <= next_state;

            // When in RECEIVE state, shift in the data bits
            if (current_state == RECEIVE) begin
                bit_count <= bit_count + 3'b001;
                shift_reg <= {in, shift_reg[7:1]};
            end

            // When in STOP state and if the transition to IDLE happens
            if ((current_state == STOP) && (next_state == IDLE)) begin
                out_byte_reg <= shift_reg;
                done_reg <= 1'b1;
            end else begin
                done_reg <= 1'b0;
            end
        end
    end

    // Next state logic
    always_comb begin
        // Default to staying in the same state
        next_state = current_state;

        case (current_state)
            IDLE: begin
                if (in == 1'b0) begin
                    next_state = START;
                end
            end
            START: begin
                next_state = RECEIVE;
            end
            RECEIVE: begin
                if (bit_count == 3'b111) begin
                    next_state = STOP;
                end
            end
            STOP: begin
                if (in == 1'b1) begin
                    next_state = IDLE;
                end
            end
            default: begin
                next_state = IDLE;
            end
        endcase
    end

    // Assign outputs
    assign out_byte = out_byte_reg;
    assign done = done_reg;

endmodule",8.609076,3245
N/A,N/A,-0.1,7,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

parameter IDLE = 2'b00, START = 2'b01, DATA = 2'b10, STOP = 2'b11;
    
    reg [1:0] state, next_state;
    reg [7:0] shift_reg;
    reg [3:0] bit_count;  // 4 bits to count up to 8
    reg done_reg;
    
    // State transition
    always @(posedge clk) begin
        if (reset)
            state <= IDLE;
        else
            state <= next_state;
    end
    
    // FSM logic
    always @(*) begin
        next_state = state;
        done_reg = 0;
        
        case (state)
            IDLE: begin
                if (in == 0)
                    next_state = START; // Detect start bit (0)
            end
            START: begin
                next_state = DATA;
                bit_count = 0;
            end
            DATA: begin
                if (bit_count < 8)
                    next_state = DATA;
                else
                    next_state = in ? STOP : IDLE; // Check for stop bit (1)
            end
            STOP: begin
                done_reg = 1;
                if (in == 1)
                    next_state = IDLE; // Return to IDLE on successful byte receipt
                else
                    next_state = START; // If stop bit not correct, wait for a new start bit
            end
        endcase
    end
    
    // Count bits and shift the input bits into shift register
    always @(posedge clk) begin
        if (reset) begin
            shift_reg <= 8'b0;
            bit_count <= 4'b0;
        end
        else if (state == DATA) begin
            shift_reg <= {in, shift_reg[7:1]}; // LSB first
            bit_count <= bit_count + 1;
        end
    end

    // Output assignments
    assign out_byte = shift_reg;
    assign done = done_reg;
    
endmodule",6.635068,3682
N/A,N/A,-1,8,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        RECEIVE,
        STOP
    } state_t;

    state_t state, next_state;
    reg [7:0] data_shift_reg;  // Shift register to collect received bits
    reg [2:0] bit_count;       // Counter for received bits

    // FSM - State transition logic
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
        end
        else begin
            state <= next_state;
        end
    end

    // FSM - Next state logic
    always_comb begin
        next_state = state; // Default: stay in the same state
        case (state)
            IDLE: begin
                if (!in)  // Detect start bit (active low)
                    next_state = START;
            end
            START: begin
                next_state = RECEIVE;
            end
            RECEIVE: begin
                if (bit_count == 7)  // All 8 data bits received
                    next_state = STOP;
            end
            STOP: begin
                if (in)  // Check for stop bit (active high)
                    next_state = IDLE;
                else
                    next_state = START; // Missed stop bit, start again
            end
        endcase
    end

    // Datapath logic
    always_ff @(posedge clk) begin
        if (reset) begin
            data_shift_reg <= 8'd0;
            bit_count <= 3'd0;
        end
        else begin
            case (state)
                IDLE: begin
                    bit_count <= 3'd0;
                end
                START: begin
                    data_shift_reg <= 8'd0; // Clear shift register
                end
                RECEIVE: begin
                    data_shift_reg <= {in, data_shift_reg[7:1]}; // Shift in LSB first
                    bit_count <= bit_count + 1;
                end
                STOP: begin
                    // Nothing
                end
            endcase
        end
    end

    // Output logic
    assign out_byte = (state == STOP && in) ? data_shift_reg : 8'd0;
    assign done = (state == STOP && in);

endmodule",8.765081,4176
N/A,N/A,-1,9,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP,
        DONE
    } state_t;

    state_t state, next_state;
    logic [7:0] shift_reg;
    logic [2:0] bit_count;

    // Synchronous state transition
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            shift_reg <= 8'b0;
            bit_count <= 3'b0;
        end else begin
            state <= next_state;
            if (state == DATA) begin
                shift_reg <= {in, shift_reg[7:1]};
                bit_count <= bit_count + 1;
            end else begin
                bit_count <= 3'b0;
            end
        end
    end

    // Combinational logic for state transitions
    always_comb begin
        next_state = state; // Default to no change in state
        done = 1'b0;

        case (state)
            IDLE: begin
                if (in == 1'b0) // Start bit detected
                    next_state = START;
            end
            START: begin
                next_state = DATA; // Transition to data state after start bit
            end
            DATA: begin
                if (bit_count == 3'b111) // Received 8 bits
                    next_state = STOP;
            end
            STOP: begin
                if (in == 1'b1) begin // Stop bit detected
                    next_state = DONE;
                end else if (in == 1'b0) begin
                    next_state = IDLE; // Error case, wait for stop bit
                end
            end
            DONE: begin
                done = 1'b1;
                next_state = IDLE; // Return to idle after outputting
            end
        endcase
    end

    // Output logic
    assign out_byte = (done) ? shift_reg : 8'bxxxx_xxxx;

endmodule",7.150089,4612
N/A,N/A,-1,10,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);


    // State Encoding
    typedef enum logic [2:0] {
        IDLE = 3'b000,
        START_BIT = 3'b001,
        DATA_BITS = 3'b010,
        STOP_BIT = 3'b011,
        DONE = 3'b100
    } state_t;

    // Signal Declarations
    state_t state, next_state;
    logic [7:0] shift_reg;
    logic [3:0] bit_count;

    // State Transitions
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            shift_reg <= 8'b0;
            bit_count <= 4'd0;
        end else begin
            state <= next_state;
            if (state == DATA_BITS) begin
                shift_reg <= {in, shift_reg[7:1]};
                bit_count <= bit_count + 1;
            end
            if (state == START_BIT) begin
                bit_count <= 4'd0;
            end
        end
    end

    // Next State Logic
    always_comb begin
        case (state)
            IDLE: begin
                if (!in) // Start bit detected (active low)
                    next_state = START_BIT;
                else
                    next_state = IDLE;
            end
            START_BIT: begin
                next_state = DATA_BITS;
            end
            DATA_BITS: begin
                if (bit_count == 4'd8) // All 8 data bits received
                    next_state = STOP_BIT;
                else
                    next_state = DATA_BITS;
            end
            STOP_BIT: begin
                if (in) // Stop bit detected (active high)
                    next_state = DONE;
                else
                    next_state = START_BIT; // Await a valid stop bit
            end
            DONE: begin
                next_state = IDLE;
            end
            default: next_state = IDLE;
        endcase
    end

    // Output Logic
    assign done = (state == DONE);
    assign out_byte = (state == DONE) ? shift_reg : 8'bx;
    
endmodule",5.645178,5060
N/A,N/A,-1,11,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum reg [2:0] {
        IDLE = 3'd0,
        START = 3'd1,
        RECEIVE = 3'd2,
        STOP = 3'd3,
        DONE = 3'd4
    } state_t;
    
    state_t state, next_state;

    reg [7:0] shift_reg; // Shift register for constructing the output byte
    reg [3:0] bit_count; // Counter to track the number of received bits

    // State transition
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 4'd0;
            shift_reg <= 8'd0;
        end
        else begin
            state <= next_state;
        end
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 1'b0)    // Detect start bit (0)
                    next_state = START;
                else
                    next_state = IDLE;
            end
            START: begin
                // Transition to RECEIVE on the next clock cycle
                next_state = RECEIVE;
            end
            RECEIVE: begin
                if (bit_count == 4'd8) // After receiving 8 data bits
                    next_state = STOP;
                else
                    next_state = RECEIVE;
            end
            STOP: begin
                if (in == 1'b1)    // Detect stop bit (1)
                    next_state = DONE;
                else
                    next_state = IDLE;
            end
            DONE: begin
                // Return to IDLE after ""done"" signal is asserted
                next_state = IDLE;
            end
            default: next_state = IDLE;
        endcase
    end

    // Output logic and data path
    always @(posedge clk) begin
        if (reset) begin
            bit_count <= 4'd0;
            shift_reg <= 8'd0;
        end
        else if (state == RECEIVE) begin
            shift_reg <= {in, shift_reg[7:1]};  // Shift in the incoming bit
            bit_count <= bit_count + 1;
        end
        else if (state == DONE) begin
            bit_count <= 4'd0;  // Reset bit counter
        end
    end

    assign done = (state == DONE);
    assign out_byte = (state == DONE) ? shift_reg : 8'dx;

endmodule",7.818067,5602
N/A,N/A,-0.1,12,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

reg [3:0] state, next_state;
    reg [7:0] shift_reg;
    reg [2:0] bit_count;
    
    localparam IDLE       = 4'd0,
               START_BIT  = 4'd1,
               RECEIVE    = 4'd2,
               STOP_BIT   = 4'd3,
               DONE       = 4'd4;

    // State transition
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
        end else begin
            state <= next_state;
        end
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 1'b0) 
                    next_state = START_BIT;
                else 
                    next_state = IDLE;
            end
            START_BIT: begin
                next_state = RECEIVE;
            end
            RECEIVE: begin
                if (bit_count == 3'd7)
                    next_state = STOP_BIT;
                else
                    next_state = RECEIVE;
            end
            STOP_BIT: begin
                if (in == 1'b1)
                    next_state = DONE;
                else
                    next_state = IDLE;
            end
            DONE: begin
                next_state = IDLE;
            end
            default: next_state = IDLE;
        endcase
    end

    // Output and data path controls
    always @(posedge clk) begin
        if (reset) begin
            shift_reg <= 8'd0;
            bit_count <= 3'd0;
        end else begin
            case (state)
                IDLE: begin
                    bit_count <= 3'd0;
                end
                RECEIVE: begin
                    shift_reg <= {in, shift_reg[7:1]};
                    bit_count <= bit_count + 1'b1;
                end
                default: begin
                    // Do nothing
                end
            endcase
        end
    end

    // Done and out_byte signals
    assign done = (state == DONE);
    assign out_byte = (state == DONE) ? shift_reg : 8'd0;

endmodule",7.659052,6067
N/A,N/A,-1,13,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE  = 3'b000,
        START = 3'b001,
        DATA  = 3'b010,
        STOP  = 3'b011,
        DONE  = 3'b100
    } state_t;

    state_t state, next_state;

    reg [2:0] bit_counter;  // 3-bit counter for counting 8 data bits
    reg [7:0] shift_reg;    // Register to shift in the serial data

    // FSM state transition
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
        end else begin
            state <= next_state;
        end
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 1'b0)  // Start bit detected
                    next_state = START;
                else
                    next_state = IDLE;
            end

            START: begin
                next_state = DATA;
            end

            DATA: begin
                if (bit_counter == 3'b111)  // 8 data bits received
                    next_state = STOP;
                else
                    next_state = DATA;
            end

            STOP: begin
                if (in == 1'b1)  // Stop bit detected
                    next_state = DONE;
                else
                    next_state = IDLE;  // Invalid stop bit, wait for new start bit
            end

            DONE: begin
                next_state = IDLE;  // Return to IDLE after completing the byte reception
            end

            default: next_state = IDLE;
        endcase
    end

    // Output logic and bit counter
    always @(posedge clk) begin
        if (reset) begin
            out_byte <= 8'b0;
            bit_counter <= 3'b0;
            done <= 1'b0;
            shift_reg <= 8'b0;
        end else begin
            case (state)
                IDLE: begin
                    bit_counter <= 3'b0;
                    done <= 1'b0;
                    shift_reg <= 8'b0;
                end

                START: begin
                    // Start bit, reset bit_counter and shift_reg
                    bit_counter <= 3'b0;
                    shift_reg <= 8'b0;
                end

                DATA: begin
                    shift_reg <= {in, shift_reg[7:1]};  // Shift in the new bit, LSB first
                    bit_counter <= bit_counter + 1'b1;
                end

                STOP: begin
                    // No action required in stop state
                end

                DONE: begin
                    out_byte <= shift_reg;
                    done <= 1'b1;  // Indicate that a valid byte has been received
                end
            endcase
        end
    end

endmodule",9.440071,6693
N/A,N/A,-1,14,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State Declaration
    typedef enum logic [2:0] {
        IDLE, START_BIT, DATA, STOP
    } state_t;
    
    state_t curr_state, next_state;
    logic [2:0] bit_counter; // Counter for data bits
    logic [7:0] shift_register; // Register to store data bits

    // State Transition Logic
    always_ff @(posedge clk or posedge reset) begin
        if (reset) begin
            curr_state <= IDLE;
            bit_counter <= 3'd0;
            shift_register <= 8'd0;
        end else begin
            curr_state <= next_state;
            if (curr_state == START_BIT) begin
                bit_counter <= 3'd0;
            end else if (curr_state == DATA) begin
                bit_counter <= bit_counter + 1;
            end
        end
    end

    // Next State Logic
    always_comb begin
        next_state = curr_state;
        case (curr_state)
            IDLE: begin
                if (in == 0) // Start bit detected
                    next_state = START_BIT;
            end
            START_BIT: begin
                next_state = DATA; // Move to data bit reception
            end
            DATA: begin
                if (bit_counter == 3'd7) // Last data bit received
                    next_state = STOP;
                else
                    next_state = DATA;
            end
            STOP: begin
                if (in == 1) // Stop bit detected
                    next_state = IDLE; // Go back to idle to receive next byte
                else
                    next_state = IDLE; // Error recovery, ignore this byte
            end
            default: next_state = IDLE;
        endcase
    end

    // Output Logic
    always_ff @(posedge clk) begin
        if (curr_state == DATA) begin
            shift_register <= {in, shift_register[7:1]}; // Shift in the incoming bit
        end
    end

    // Assign output
    assign out_byte = shift_register;
    assign done = (curr_state == STOP && in == 1); // 'done' is asserted when STOP state is reached with valid stop bit

endmodule",7.389093,7171
N/A,N/A,-0.1,15,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

parameter IDLE = 2'd0, START = 2'd1, DATA = 2'd2, STOP = 2'd3;
    reg [1:0] state, next_state;
    reg [3:0] bit_count; // to count data bits
    reg [7:0] shift_reg;
    reg byte_received;

    // Current state logic (Sequential)
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 4'd0;
            shift_reg <= 8'd0;
            byte_received <= 1'b0;
        end else begin
            state <= next_state;
            if (state == DATA) begin
                shift_reg <= {in, shift_reg[7:1]};
                bit_count <= bit_count + 1'b1;
            end

            if (state == STOP) begin
                byte_received <= 1'b1;
            end else begin
                byte_received <= 1'b0;
            end
        end
    end

    // Next state logic (Combinational)
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 1'b0) // Detect start bit
                    next_state = START;
                else
                    next_state = IDLE;
            end
            START: begin
                next_state = DATA;
            end
            DATA: begin
                if (bit_count == 4'd8)
                    next_state = STOP;
                else
                    next_state = DATA;
            end
            STOP: begin
                if (in == 1'b1) // Detect stop bit
                    next_state = IDLE;
                else
                    next_state = STOP; // Wait for stop bit
            end
            default: next_state = IDLE;
        endcase
    end

    // Output logic
    assign out_byte = shift_reg;
    assign done = byte_received;

endmodule",7.796082,7588
N/A,N/A,-0.1,16,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

reg [3:0] state, next_state;
    reg [7:0] data_shift_reg;
    reg [2:0] bit_counter;
    reg stop_bit_detected;

    // State encoding
    localparam IDLE      = 4'd0,
               START     = 4'd1,
               RECEIVING = 4'd2,
               STOP      = 4'd3,
               DONE      = 4'd4;

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_counter <= 3'd0;
            data_shift_reg <= 8'd0;
            stop_bit_detected <= 1'b0;
        end
        else begin
            state <= next_state;
        end
    end

    // Next state and datapath logic
    always @(*) begin
        next_state = state; // Default stay in the same state
        case (state)
            IDLE: begin
                if (!in) begin
                    next_state = START;
                end
            end
            START: begin
                next_state = RECEIVING;
            end
            RECEIVING: begin
                if (bit_counter == 3'd7) begin
                    next_state = STOP;
                end
            end
            STOP: begin
                if (in) begin
                    stop_bit_detected = 1'b1;
                    next_state = DONE;
                end
            end
            DONE: begin
                next_state = IDLE;
            end
        endcase
    end

    // Counter and shift register logic
    always @(posedge clk) begin
        if (state == START) begin
            bit_counter <= 3'd0;
        end
        else if (state == RECEIVING) begin
            data_shift_reg <= {in, data_shift_reg[7:1]};
            bit_counter <= bit_counter + 3'd1;
        end
    end

    // Output logic
    assign out_byte = data_shift_reg;
    assign done = (state == DONE);

endmodule",7.28006,8029
N/A,N/A,-0.1,17,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding for FSM
    localparam IDLE = 2'b00,
               START = 2'b01,
               DATA = 2'b10,
               STOP = 2'b11;

    reg [1:0] state, next_state;
    reg [7:0] shift_reg;
    reg [2:0] bit_count;
    reg done_reg;
    
    // State transition logic (combinational)
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 0)         // Start bit detected
                    next_state = START;
                else
                    next_state = IDLE;
            end
            START: begin
                if (bit_count == 3'd7)
                    next_state = DATA;
                else
                    next_state = START;
            end
            DATA: begin
                if (bit_count == 3'd0) // All data bits are received
                    next_state = STOP;
                else
                    next_state = DATA;
            end
            STOP: begin
                if (in == 1)         // Stop bit correctly detected
                    next_state = IDLE;
                else
                    next_state = STOP;
            end
            default: next_state = IDLE;
        endcase
    end

    // State flip-flops (synchronous reset)
    always @(posedge clk) begin
        if (reset)
            state <= IDLE;
        else
            state <= next_state;
    end

    // Shift register and bit counter
    always @(posedge clk) begin
        if (reset) begin
            shift_reg <= 8'b0;
            bit_count <= 3'd0;
            done_reg <= 0;
        end
        else begin
            case (state)
                IDLE: begin
                    done_reg <= 0;
                    if (in == 0)
                        bit_count <= 3'd7; // Prepare to receive 8 bits
                end
                START: begin
                    bit_count <= bit_count - 1;
                end
                DATA: begin
                    shift_reg <= {in, shift_reg[7:1]}; // Shift in LSB first
                    bit_count <= bit_count - 1;
                end
                STOP: begin
                    if (in == 1) begin
                        done_reg <= 1;
                        bit_count <= 3'd0;
                    end
                end
            endcase
        end
    end

    // Output assignments
    assign out_byte = shift_reg;
    assign done = done_reg;

endmodule",12.609056,8574
N/A,N/A,-1,18,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// FSM states
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP,
        DONE,
        ERROR
    } state_t;

    state_t state, next_state;
    logic [2:0] bit_counter;
    logic [7:0] shift_reg;
    logic done_reg;

    // Combinational logic for state transitions
    always_comb begin
        next_state = state; // Default to no state change
        case (state)
            IDLE: if (!in) next_state = START; // Start bit detected
            START: next_state = DATA;
            DATA: if (bit_counter == 7) next_state = STOP;
                  else next_state = DATA;
            STOP: if (in) next_state = DONE; // Stop bit is correct
                  else next_state = ERROR;
            DONE: next_state = IDLE;
            ERROR: if (in) next_state = IDLE; // Wait for next start bit
        endcase
    end

    // Sequential logic for state transitions and outputs
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_counter <= 0;
            shift_reg <= 8'h00;
            done_reg <= 0;
        end else begin
            state <= next_state;
            case (state)
                IDLE: begin
                    bit_counter <= 0;
                    shift_reg <= 8'h00;
                    done_reg <= 0;
                end
                START: begin
                    bit_counter <= 0;
                end
                DATA: begin
                    shift_reg <= {in, shift_reg[7:1]}; // Shift in data bits
                    bit_counter <= bit_counter + 1;
                end
                STOP: begin
                    done_reg <= 1;
                end
                DONE: begin
                    done_reg <= 0;
                end
                ERROR: begin
                    done_reg <= 0;
                end
            endcase
        end
    end

    // Outputs
    assign out_byte = shift_reg;
    assign done = done_reg;

endmodule",6.265091,9027
N/A,N/A,-1,19,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP,
        DONE
    } state_t;
    
    state_t current_state, next_state;
    reg [7:0] shift_reg;
    reg [2:0] bit_count;

    // State transition logic
    always_ff @(posedge clk) begin
        if (reset) begin
            current_state <= IDLE;
            shift_reg <= 8'b0;
            bit_count <= 3'b0;
        end else begin
            current_state <= next_state;
            if (current_state == DATA) begin
                shift_reg <= {in, shift_reg[7:1]};
                bit_count <= bit_count + 1;
            end else if (current_state == DONE) begin
                bit_count <= 3'b0;
            end
        end
    end

    // Next state logic
    always_comb begin
        next_state = current_state;
        case (current_state)
            IDLE: begin
                if (in == 0) // Detect start bit
                    next_state = START;
            end
            START: begin
                next_state = DATA;
            end
            DATA: begin
                if (bit_count == 3'b111) // Check if all 8 data bits are read
                    next_state = STOP;
            end
            STOP: begin
                if (in == 1) // Check for stop bit
                    next_state = DONE;
                else
                    next_state = IDLE;
            end
            DONE: begin
                next_state = IDLE;
            end
            default: next_state = IDLE;
        endcase
    end

    // Output logic
    assign done = (current_state == DONE);
    assign out_byte = done ? shift_reg : 8'bxxxx_xxxx;

endmodule",9.135004,9426
N/A,N/A,-1,20,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        RECEIVE,
        STOP,
        DONE
    } state_t;

    state_t state, next_state;
    reg [7:0] shift_reg;
    reg [2:0] bit_count;

    always_ff @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= IDLE;
            shift_reg <= 8'b0;
            bit_count <= 3'b0;
        end else begin
            state <= next_state;
            if (state == RECEIVE) begin
                shift_reg <= {in, shift_reg[7:1]};
                bit_count <= bit_count + 1;
            end
        end
    end

    always_comb begin
        next_state = state;
        done = 0;
        out_byte = 8'b0;
        
        case (state)
            IDLE: begin
                if (in == 0)  // Detect start bit
                    next_state = START;
            end
            
            START: begin
                next_state = RECEIVE;
            end
            
            RECEIVE: begin
                if (bit_count == 7)
                    next_state = STOP;
            end
            
            STOP: begin
                if (in == 1) begin // Check stop bit
                    next_state = DONE;
                end else begin
                    next_state = IDLE; // Error, wait for stop bit
                end
            end
            
            DONE: begin
                done = 1;
                out_byte = shift_reg;  // Output the received byte
                next_state = IDLE;
            end
            
            default: next_state = IDLE;
        endcase
    end

endmodule",12.763082,9794
N/A,N/A,-1,21,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Declare FSM states.
    typedef enum logic [1:0] {
        IDLE,
        START,
        RECEIVE,
        STOP
    } state_t;
    
    // State registers
    state_t current_state, next_state;

    // Shift register to hold incoming serial bits
    reg [7:0] shift_reg;
    reg [2:0] bit_count; // Counter for received bits

    // Output logic
    assign out_byte = shift_reg;
    assign done = (current_state == STOP);

    // State transition logic
    always_ff @(posedge clk) begin
        if (reset) begin
            current_state <= IDLE;
            bit_count <= 3'b000;
            shift_reg <= 8'b0;
        end
        else begin
            current_state <= next_state;
            if (current_state == RECEIVE)
                bit_count <= bit_count + 1;
        end
    end

    // Next state logic
    always_comb begin
        next_state = current_state; // Default to stay in the same state
        case (current_state)
            IDLE: begin
                if (in == 0) // Detect start bit
                    next_state = START;
            end
            START: begin
                next_state = RECEIVE;
            end
            RECEIVE: begin
                if (bit_count == 3'd7) begin // All data bits received
                    next_state = STOP;
                end
            end
            STOP: begin
                if (in == 1) // Correct stop bit
                    next_state = IDLE;
                else
                    next_state = STOP; // Stay in STOP until a correct stop bit is detected
            end
        endcase
    end

    // Shift register logic
    always_ff @(posedge clk) begin
        if (current_state == RECEIVE)
            shift_reg <= {in, shift_reg[7:1]}; // Shift in LSB first
    end

endmodule",11.536088,10208
N/A,N/A,-1,22,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Define state encoding
    typedef enum logic [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        RECEIVE = 3'b010,
        STOP = 3'b011,
        DONE = 3'b100
    } state_t;
    
    state_t current_state, next_state;
    logic [7:0] shift_reg;
    logic [2:0] bit_count;

    // FSM sequential logic
    always_ff @(posedge clk) begin
        if (reset) begin
            current_state <= IDLE;
            shift_reg <= 8'd0;
            bit_count <= 3'd0;
        end else begin
            current_state <= next_state;
        end
    end

    // FSM combinational logic
    always_comb begin
        next_state = current_state; // Default state stays the same

        case (current_state)
            IDLE: begin
                if (~in) // Detect start bit
                    next_state = START;
            end

            START: begin
                if (in) // If not start bit, keep looking
                    next_state = IDLE;
                else
                    next_state = RECEIVE;
            end

            RECEIVE: begin
                if (bit_count == 3'd7)
                    next_state = STOP;
            end

            STOP: begin
                if (in) // Verify stop bit
                    next_state = DONE;
                else
                    next_state = IDLE;
            end

            DONE: begin
                next_state = IDLE;
            end

            default: next_state = IDLE;
        endcase
    end

    // Datapath logic
    always_ff @(posedge clk) begin
        if (current_state == RECEIVE) begin
            shift_reg <= {in, shift_reg[7:1]}; // Shift in LSB first
            bit_count <= bit_count + 1;
        end else if (current_state == IDLE || current_state == STOP) begin
            bit_count <= 3'd0; // Reset bit count
        end
    end

    // Output logic
    assign out_byte = (current_state == DONE) ? shift_reg : 8'bxxxxxxxx;
    assign done = (current_state == DONE);

endmodule",12.602097,10688
N/A,N/A,-1,23,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State definitions
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP,
        DONE
    } state_t;
    
    state_t state, next_state;
    reg [7:0] data_shift_reg;
    reg [2:0] bit_counter;
    wire is_start, is_stop;

    // State transition (sequential)
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_counter <= 3'd0;
            data_shift_reg <= 8'd0;
        end else begin
            state <= next_state;
            if (state == DATA) begin
                data_shift_reg <= {in, data_shift_reg[7:1]};
                bit_counter <= bit_counter + 3'd1;
            end
        end
    end
    
    // Next state logic (combinational)
    always @(*) begin
        case (state)
            IDLE: next_state = is_start ? START : IDLE;
            START: next_state = DATA;
            DATA: next_state = (bit_counter == 3'd7) ? STOP : DATA;
            STOP: next_state = is_stop ? DONE : IDLE;
            DONE: next_state = IDLE;
            default: next_state = IDLE;
        endcase
    end

    // Output logic
    assign is_start = ~in; // we assume start bit is low (0)
    assign is_stop = in; // we assume stop bit is high (1)
    assign done = (state == DONE);
    assign out_byte = (done) ? data_shift_reg : 8'dx; // don't-care if not done

endmodule",6.455673,11051
N/A,N/A,-1,24,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// FSM State encoding
    typedef enum logic [1:0] {
        IDLE    = 2'b00,
        START   = 2'b01,
        RECEIVE = 2'b10,
        STOP    = 2'b11
    } state_t;
    
    state_t state, next_state;
    logic [7:0] shift_reg;
    logic [2:0] bit_count;
    logic stop_bit_received;

    // State transition
    always_ff @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= IDLE;
        end else begin
            state <= next_state;
        end
    end

    // Next state logic
    always_comb begin
        next_state = state;
        case (state)
            IDLE: begin
                if (in == 0) // Detect start bit
                    next_state = START;
            end
            START: begin
                next_state = RECEIVE;
            end
            RECEIVE: begin
                if (bit_count == 3'b111) // Received 8 bits
                    next_state = STOP;
            end
            STOP: begin
                if (in == 1) // Detect stop bit
                    next_state = IDLE;
                else
                    next_state = IDLE; // Error recovery, wait until line is idle
            end
        endcase
    end

    // Datapath logic for bit receiving and shifting
    always_ff @(posedge clk) begin
        if (reset) begin
            shift_reg <= 8'b0;
            bit_count <= 3'b0;
            done <= 1'b0;
            out_byte <= 8'b0;
        end else begin
            done <= 1'b0; // Default done to 0
            case (state)
                RECEIVED:
                  shift_reg <= {in, shift_reg[7:1]}; // Shift in the bits received, LSB first
                  bit_count <= bit_count + 3'd1;

                STOP: begin
                    if (in == 1) begin
                        out_byte <= shift_reg;
                        done <= 1'b1;
                    end
                end
            endcase
        end
    end

endmodule",8.051086,11524
N/A,N/A,-1,25,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Define FSM states
    typedef enum logic [2:0] {
        IDLE,
        START_BIT,
        DATA_BITS,
        STOP_BIT
    } state_t;
    
    state_t state, next_state;
    reg [2:0] bit_count;      // Counter for data bits
    reg [7:0] shift_reg;      // Shift register for data byte
    reg stop_err;             // Flag for stop bit error

    // State Transition logic
    always_ff @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= IDLE;
        end else begin
            state <= next_state;
        end
    end

    // Next State logic
    always_comb begin
        case(state)
            IDLE: begin
                if (in == 0) // Detect start bit (expecting 0)
                    next_state = START_BIT;
                else
                    next_state = IDLE;
            end
            START_BIT: begin
                next_state = DATA_BITS;
            end
            DATA_BITS: begin
                if (bit_count == 3'b111)
                    next_state = STOP_BIT;
                else
                    next_state = DATA_BITS;
            end
            STOP_BIT: begin
                if (in == 1) // Detect stop bit (expecting 1)
                    next_state = IDLE;
                else
                    next_state = STOP_BIT; // Remain in STOP_BIT until correct stop bit is detected
            end
            default: next_state = IDLE;
        endcase
    end

    // Output logic and datapath
    always_ff @(posedge clk) begin
        if (reset) begin
            bit_count <= 3'b0;
            shift_reg <= 8'b0;
            done <= 1'b0;
            stop_err <= 1'b0;
        end else begin
            done <= 1'b0;
            case(state)
                START_BIT: begin
                    bit_count <= 3'b0;
                end
                DATA_BITS: begin
                    shift_reg <= {in, shift_reg[7:1]}; // Shift in the bits (LSB first)
                    bit_count <= bit_count + 3'b1;
                end
                STOP_BIT: begin
                    if (in == 1 && !stop_err) begin
                        out_byte <= shift_reg; // Parallel load of byte when done
                        done <= 1'b1;          // Indicate a complete byte
                    end else begin
                        stop_err <= 1'b1;      // Flag stop bit error
                    end
                end
                default: begin
                    // No action needed
                end
            endcase
        end
    end

endmodule",11.343084,12101
N/A,N/A,-1,26,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State declarations for FSM
    typedef enum logic [2:0] {
        IDLE,       // Waiting for start bit
        START,      // Start bit detected
        RECEIVE,    // Receiving data bits
        STOP,       // Stop bit detection
        DONE        // Byte received successfully
    } state_t;
    
    state_t state, next_state;
    reg [7:0] data_shift;  // Shift register for received data
    reg [2:0] bit_count;   // Counter for number of received data bits
    reg stop_bit_detected;
    
    // State transition logic
    always_ff @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= IDLE;
        end else begin
            state <= next_state;
        end
    end

    // State output and next state logic
    always_comb begin
        done = 1'b0;               // Default value
        next_state = state;        // Default to stay in the current state
        stop_bit_detected = 1'b0;

        case(state)
            IDLE: begin
                if (in == 1'b0)    // Detect start bit
                    next_state = START;
            end

            START: begin
                next_state = RECEIVE;  // Move to data receiving state
                bit_count = 3'b000;    // Initialize bit counter
            end

            RECEIVE: begin
                if (bit_count == 3'b111) begin
                    next_state = STOP;
                end
            end

            STOP: begin
                if (in == 1'b1) begin  // Verify stop bit
                    done = 1'b1;       // Byte reception complete
                    next_state = DONE;
                end else begin
                    next_state = IDLE; // Mismatch, wait for next start bit
                end
            end

            DONE: begin
                next_state = IDLE; // Return to idle for next byte
            end
        endcase
    end
    
    // Data shift register logic
    always_ff @(posedge clk) begin
        if (state == RECEIVE) begin
            data_shift <= {in, data_shift[7:1]}; // Shift in the LSB
            bit_count <= bit_count + 1;
        end
    end
    
    // Output logic
    assign out_byte = (done) ? data_shift : 8'bxxxxxxxx; // Valid output when done
    
endmodule",9.752085,12627
N/A,N/A,-0.1,27,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

parameter IDLE = 2'd0, START = 2'd1, DATA = 2'd2, STOP = 2'd3;
    reg [1:0] state, next_state;
    reg [2:0] bit_count;
    reg [7:0] shift_reg;

    // FSM: State Transition
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
        end else begin
            state <= next_state;
        end
    end

    // FSM: Next State Logic
    always @(*) begin
        case (state)
            IDLE: next_state = in ? IDLE : START;
            START: next_state = (in == 0) ? DATA : IDLE;
            DATA: next_state = (bit_count == 3'd7) ? STOP : DATA;
            STOP: next_state = in ? IDLE : START;
            default: next_state = IDLE;
        endcase
    end

    // FSM: Bit Counter and Shift Register
    always @(posedge clk) begin
        if (reset) begin
            bit_count <= 3'd0;
        end else if (state == DATA) begin
            bit_count <= bit_count + 1'b1;
            shift_reg <= {in, shift_reg[7:1]};
        end else if (state != DATA) begin
            bit_count <= 3'd0;
        end
    end

    // Output Logic
    assign done = (state == STOP) && in;
    assign out_byte = (done) ? shift_reg : 8'hxx;
    
endmodule",11.084127,12974
N/A,N/A,-1,28,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [1:0] {
        IDLE,
        START,
        RECV,
        STOP
    } state_t;

    state_t state, next_state;
    reg [7:0] received_data;
    reg [2:0] bit_count;

    // FSM state transition
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
        end else begin
            state <= next_state;
        end
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: next_state = (in == 0) ? START : IDLE; // Start bit detected
            START: next_state = RECV;
            RECV: next_state = (bit_count == 3'd7) ? STOP : RECV;
            STOP: next_state = (in == 1) ? IDLE : START; // Wait for stop bit
            default: next_state = IDLE;
        endcase
    end

    // Datapath logic
    always @(posedge clk) begin
        if (reset) begin
            received_data <= 8'b0;
            bit_count <= 3'd0;
        end else begin
            case (state)
                START: bit_count <= 3'd0; // Reset bit count at start
                RECV: begin
                    received_data[bit_count] <= in; // Shift in data bits
                    bit_count <= bit_count + 1;
                end
                STOP: begin
                    // Do nothing
                end
                default: begin
                    // Do nothing
                end
            endcase
        end
    end

    // Output logic
    assign out_byte = (state == STOP && in == 1) ? received_data : 8'bX;
    assign done = (state == STOP && in == 1);
    
endmodule",9.383059,13382
N/A,N/A,-1,29,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Define states
    typedef enum logic [2:0] {
        IDLE, START, RECEIVE, STOP, DONE
    } state_t;

    state_t state, next_state;
    reg [2:0] bit_count; // Counter for received bits
    reg [7:0] shift_reg; // Shift register for received data

    // State transition logic
    always_ff @(posedge clk) begin
        if (reset)
            state <= IDLE;
        else
            state <= next_state;
    end

    // State machine logic
    always_comb begin
        // Default output values
        next_state = state;
        done = 0;

        case (state)
            IDLE: begin
                bit_count = 0; // Reset bit counter
                if (in == 0) // Detect start bit
                    next_state = START;
                else
                    next_state = IDLE;
            end

            START: begin
                if (in == 0) // Validate start bit
                    next_state = RECEIVE;
                else
                    next_state = IDLE;
            end

            RECEIVE: begin
                if (bit_count < 7) begin
                    next_state = RECEIVE;
                end else begin
                    next_state = STOP;
                end
            end

            STOP: begin
                if (in == 1) begin // Validate stop bit
                    done = 1;
                    next_state = DONE;
                end else begin
                    next_state = IDLE;
                end
            end

            DONE: begin
                done = 1; // Signal data reception is complete
                next_state = IDLE;
            end
            
            default: begin
                next_state = IDLE;
            end
        endcase
    end

    // Datapath: Shift register logic
    always_ff @(posedge clk) begin
        if (reset) begin
            shift_reg <= 0;
            bit_count <= 0;
        end
        else if (state == RECEIVE) begin
            shift_reg <= {in, shift_reg[7:1]}; // Shift in LSB first
            bit_count <= bit_count + 1;
        end
    end

    // Output the byte upon completion
    assign out_byte = (done) ? shift_reg : 8'bx; // 'x' for don't-care

endmodule",9.058082,13883
N/A,N/A,-0.1,30,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

reg [3:0] state, next_state;
    reg [7:0] shift_reg;
    reg [3:0] bit_count;
    
    // State encoding
    localparam IDLE     = 4'd0;
    localparam START    = 4'd1;
    localparam RECEIVE  = 4'd2;
    localparam STOP     = 4'd3;
    localparam DONE     = 4'd4;

    // State transitions
    always @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
        end else begin
            state <= next_state;
            if (state == RECEIVE) begin
                bit_count <= bit_count + 1;
            end else begin
                bit_count <= 0;
            end
        end
    end

    // Next state logic and datapath operations
    always @(*) begin
        next_state = state;  // Default next state is the same as current state
        case (state)
            IDLE: begin
                if (in == 1'b0) begin  // Detect a start bit
                    next_state = START;
                end
            end
            START: begin
                next_state = RECEIVE;
            end
            RECEIVE: begin
                if (bit_count < 8) begin
                    shift_reg = {in, shift_reg[7:1]};  // Shift in the data bits
                end
                if (bit_count == 8) begin
                    next_state = STOP;
                end
            end
            STOP: begin
                if (in == 1'b1) begin  // Check for a valid stop bit
                    next_state = DONE;
                end else begin
                    next_state = IDLE;  // Invalid stop bit, reset
                end
            end
            DONE: begin
                next_state = IDLE;  // Done
            end
        endcase
    end

    // Output logic
    assign done = (state == DONE);
    assign out_byte = (state == DONE) ? shift_reg : 8'bxxxx_xxxx;

endmodule",21.438149,14344
N/A,N/A,-1,31,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Define states
    typedef enum logic [2:0] {
        IDLE,
        START_BIT,
        DATA_BITS,
        STOP_BIT,
        DONE
    } state_t;

    state_t current_state, next_state;
    reg [2:0] bit_count;
    reg [7:0] shift_reg;
    reg done_reg;

    assign out_byte = shift_reg;
    assign done = done_reg;

    // State transition logic
    always_ff @(posedge clk) begin
        if (reset) begin
            current_state <= IDLE;
            bit_count <= 0;
            shift_reg <= 8'b0;
            done_reg <= 1'b0;
        end else begin
            current_state <= next_state;
        end
    end

    // Next state logic and data path
    always_comb begin
        next_state = current_state;
        done_reg = 1'b0;

        case (current_state)
            IDLE: begin
                if (in == 1'b0) begin // Detect start bit
                    next_state = START_BIT;
                end
            end

            START_BIT: begin
                next_state = DATA_BITS;
                bit_count = 0;
            end

            DATA_BITS: begin
                shift_reg = {in, shift_reg[7:1]}; // Shift in LSB first
                if (bit_count == 3'd7) begin
                    next_state = STOP_BIT;
                end else begin
                    bit_count = bit_count + 1;
                end
            end

            STOP_BIT: begin
                if (in == 1'b1) begin // Check for valid stop bit
                    next_state = DONE;
                end else begin
                    next_state = IDLE; // Error, await new start bit
                end
            end

            DONE: begin
                done_reg = 1'b1;
                next_state = IDLE; // Return to IDLE for next byte
            end

            default: next_state = IDLE;
        endcase
    end

endmodule",12.578088,14779
N/A,N/A,-1,32,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Define the states for the finite state machine
    typedef enum logic [2:0] {
        IDLE,   // Waiting for start bit
        START,  // Start bit received
        DATA,   // Receiving data bits
        STOP,   // Stop bit check
        DONE    // Byte received successfully
    } state_t;

    state_t state, next_state;  // Current and next state variables
    reg [7:0] shift_reg;        // Shift register for incoming bits
    reg [2:0] bit_count;        // Count of received data bits

    // State transition logic (synchronous)
    always_ff @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= IDLE;
        end else begin
            state <= next_state;
        end
    end

    // Next state and output logic
    always_comb begin
        // Default values
        next_state = state;
        done = 1'b0;
        out_byte = shift_reg;

        case (state)
            IDLE: begin
                if (in == 1'b0) begin  // Start bit detected
                    next_state = START;
                end
            end
            START: begin
                next_state = DATA;
                bit_count = 3'd0;  // Initialize bit counter
            end
            DATA: begin
                shift_reg = {in, shift_reg[7:1]};  // Shift in the bit
                if (bit_count == 3'd7) begin
                    next_state = STOP;
                end
                bit_count = bit_count + 1;
            end
            STOP: begin
                if (in == 1'b1) begin  // Stop bit detected
                    next_state = DONE;
                end else begin
                    next_state = IDLE;  // Invalid, reset
                end
            end
            DONE: begin
                done = 1'b1;
                next_state = IDLE;  // Return to IDLE for next byte
            end
        endcase
    end
endmodule",11.216155,15224
N/A,N/A,-1,33,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State declaration for the FSM
    typedef enum reg [2:0] {
        IDLE,
        START,
        DATA,
        STOP,
        DONE
    } state_t;

    state_t current_state, next_state;

    reg [7:0] shift_register;
    reg [2:0] bit_count;
    reg received_stop_bit;

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            current_state <= IDLE;
            bit_count <= 3'd0;
            shift_register <= 8'd0;
            received_stop_bit <= 1'b0;
        end else begin
            current_state <= next_state;

            // Shift the incoming bit into the shift register during DATA state
            if (current_state == DATA) begin
                shift_register <= {in, shift_register[7:1]};
                bit_count <= bit_count + 1;
            end

            // Check for stop bit in STOP state
            if (current_state == STOP) begin
                received_stop_bit <= in;
            end
        end
    end

    // Next state logic
    always @(*) begin
        case (current_state)
            IDLE: begin
                if (in == 0)  // Detect start bit (active low)
                    next_state = START;
                else
                    next_state = IDLE;
            end

            START: begin
                next_state = DATA;
            end

            DATA: begin
                if (bit_count == 3'd7)
                    next_state = STOP;
                else
                    next_state = DATA;
            end

            STOP: begin
                if (received_stop_bit)
                    next_state = DONE;
                else
                    next_state = IDLE; // If stop bit not here, go back to IDLE
            end

            DONE: begin
                next_state = IDLE;
            end

            default: next_state = IDLE;
        endcase
    end

    // Output logic
    assign out_byte = shift_register;
    assign done = (current_state == DONE);

endmodule",7.571082,15666
N/A,N/A,-1,34,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,      // Waiting for the start bit
        START,     // Start bit has been detected
        DATA,      // Receiving data bits
        STOP,      // Waiting for the stop bit
        DONE       // Done receiving a complete byte
    } state_t;

    state_t state, next_state;

    // Data registers
    reg [7:0] shift_reg;
    reg [2:0] bit_count;

    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
        end
        else begin
            state <= next_state;
        end
    end

    always_ff @(posedge clk) begin
        if (reset) begin
            bit_count <= 3'd0;
            shift_reg <= 8'd0;
        end
        else if (state == DATA) begin
            shift_reg <= {in, shift_reg[7:1]}; // Shift in the new bit
            bit_count <= bit_count + 1;
        end
    end

    always_comb begin
        next_state = state;
        case (state)
            IDLE: begin
                if (in == 1'b0) // Start bit detected
                    next_state = START;
            end
            START: begin
                next_state = DATA;
            end
            DATA: begin
                if (bit_count == 3'd7) // 8 data bits received
                    next_state = STOP;
            end
            STOP: begin
                if (in == 1'b1) // Stop bit received
                    next_state = DONE;
                else 
                    next_state = IDLE; // Invalid stop bit, restart
            end
            DONE: begin
                next_state = IDLE; // Ready for the next byte
            end
        endcase
    end

    assign out_byte = (state == DONE) ? shift_reg : 8'd0;
    assign done = (state == DONE);

endmodule",7.897087,16100
N/A,N/A,-1,35,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE    = 3'b000,
        START   = 3'b001,
        RECEIVE = 3'b010,
        STOP    = 3'b011,
        DONE    = 3'b100
    } state_t;
    
    state_t state, next_state;
    logic [2:0] bit_count;
    logic [7:0] shift_reg;
    
    // State register
    always_ff @(posedge clk) begin
        if (reset)
            state <= IDLE;
        else
            state <= next_state;
    end
    
    // Next state logic
    always_comb begin
        case (state)
            IDLE: begin
                if (in == 0)
                    next_state = START;
                else
                    next_state = IDLE;
            end
            START: begin
                next_state = RECEIVE;
            end
            RECEIVE: begin
                if (bit_count == 3'd7)
                    next_state = STOP;
                else
                    next_state = RECEIVE;
            end
            STOP: begin
                if (in == 1)
                    next_state = DONE;
                else
                    next_state = IDLE; // Wait for a stop bit
            end
            DONE: begin
                next_state = IDLE;
            end
            default: begin
                next_state = IDLE;
            end
        endcase
    end
    
    // Output logic and bit counter
    always_ff @(posedge clk) begin
        if (reset) begin
            bit_count <= 3'd0;
            shift_reg <= 8'd0;
        end
        else if (state == RECEIVE) begin
            shift_reg <= {in, shift_reg[7:1]}; // Shift in new bit
            bit_count <= bit_count + 1;
        end
        else if (state == DONE || state == IDLE) begin
            bit_count <= 3'd0;
        end
    end
    
    // Output assignments
    assign out_byte = (state == DONE) ? shift_reg : 8'dx;
    assign done = (state == DONE);

endmodule",8.619086,16564
N/A,N/A,-1,36,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,           // Waiting for start bit
        DATA_BITS,      // Receiving data bits
        STOP_BIT,       // Checking stop bit
        DONE            // Byte received correctly
    } state_t;

    state_t current_state, next_state;
    logic [7:0] shift_reg;
    logic [2:0] bit_counter;

    // FSM state transition
    always_ff @(posedge clk) begin
        if (reset) begin
            current_state <= IDLE;
        end else begin
            current_state <= next_state;
        end
    end

    // Next state logic and bit counter
    always_comb begin
        next_state = current_state;
        case (current_state)
            IDLE: begin
                if (~in) begin  // Start bit detected
                    next_state = DATA_BITS;
                end
            end
            DATA_BITS: begin
                if (bit_counter == 3'd7) begin
                    next_state = STOP_BIT;
                end
            end
            STOP_BIT: begin
                if (in) begin  // Stop bit detected
                    next_state = DONE;
                end else begin
                    next_state = IDLE;
                end
            end
            DONE: begin
                next_state = IDLE;
            end
        endcase
    end

    // Output logic and bit shifting
    always_ff @(posedge clk) begin
        if (reset) begin
            shift_reg <= 8'b0;
            bit_counter <= 3'b0;
            done <= 1'b0;
        end else begin
            case (current_state)
                IDLE: begin
                    bit_counter <= 3'b0;
                    done <= 1'b0;
                end
                DATA_BITS: begin
                    shift_reg <= {in, shift_reg[7:1]};  // LSB first
                    bit_counter <= bit_counter + 1'b1;
                end
                STOP_BIT: begin
                    // Do nothing here, just wait for stop bit
                end
                DONE: begin
                    done <= 1'b1;
                end
            endcase
        end
    end

    // Output the received byte when in DONE state
    assign out_byte = (done) ? shift_reg : 8'bx;

endmodule",9.748082,17065
N/A,N/A,-0.1,37,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

parameter IDLE = 2'b00, START = 2'b01, DATA = 2'b10, STOP = 2'b11;
    reg [1:0] state, next_state;
    reg [7:0] shift_reg;
    reg [2:0] bit_count;

    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            shift_reg <= 8'b0;
            bit_count <= 3'b0;
        end else begin
            state <= next_state;
            if (state == DATA) begin
                shift_reg <= {in, shift_reg[7:1]};
                bit_count <= bit_count + 1;
            end else begin
                bit_count <= 3'b0;
            end
        end
    end

    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 0)
                    next_state = START;
                else
                    next_state = IDLE;
            end

            START: begin
                next_state = DATA;
            end

            DATA: begin
                if (bit_count == 3'b111)
                    next_state = STOP;
                else
                    next_state = DATA;
            end

            STOP: begin
                if (in == 1)
                    next_state = IDLE;
                else
                    next_state = STOP;
            end

            default: begin
                next_state = IDLE;
            end
        endcase
    end

    assign done = (state == STOP && in == 1);
    assign out_byte = shift_reg;

endmodule",8.657065,17409
N/A,N/A,-1,38,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP,
        DONE
    } state_t;

    state_t state, next_state;
    logic [2:0] bit_counter;
    logic [7:0] data_reg;
    logic shifted_in;

    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_counter <= 0;
            data_reg <= 8'h00;
        end else begin
            state <= next_state;
            if (state == DATA) begin
                data_reg <= {in, data_reg[7:1]};
                bit_counter <= bit_counter + 1;
            end else if (state != DATA) begin
                bit_counter <= 0;
            end
        end
    end

    always_comb begin
        next_state = state;
        done = 0;
        case (state)
            IDLE: begin
                if (in == 0)
                    next_state = START;
            end
            START: begin
                next_state = DATA;
            end
            DATA: begin
                if (bit_counter == 7) begin
                    next_state = STOP;
                end
            end
            STOP: begin
                if (in == 1)
                    next_state = DONE;
                else
                    next_state = IDLE;
            end
            DONE: begin
                done = 1;
                next_state = IDLE;
            end
        endcase
    end
    
    assign out_byte = (done) ? data_reg : 8'h00;

endmodule",6.306063,17753
N/A,N/A,-1,39,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

typedef enum reg [2:0] {
        IDLE,       // 000
        START,      // 001
        RECEIVE,    // 010
        STOP        // 011
    } state_t;

    state_t state, next_state;
    reg [7:0] shift_reg;
    reg [2:0] bit_counter;

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
        end else begin
            state <= next_state;
        end
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 0) // Detect start bit
                    next_state = START;
                else
                    next_state = IDLE;
            end
            START: begin
                next_state = RECEIVE;
            end
            RECEIVE: begin
                if (bit_counter == 3'd7)
                    next_state = STOP;
                else
                    next_state = RECEIVE;
            end
            STOP: begin
                if (in == 1) // Check for stop bit
                    next_state = IDLE;
                else
                    next_state = STOP; // Wait for a stop bit
            end
            default: next_state = IDLE;
        endcase
    end

    // Datapath to read input and form byte
    always @(posedge clk) begin
        if (reset) begin
            shift_reg <= 8'b0;
            bit_counter <= 3'd0;
        end else begin
            case (state)
                RECEIVE: begin
                    shift_reg <= {in, shift_reg[7:1]}; // Shift in least significant bit
                    bit_counter <= bit_counter + 1;
                end
                STOP: begin
                    if (in == 1) // Valid stop bit
                        bit_counter <= 3'd0;
                end
                default: begin
                    bit_counter <= 3'd0;
                    // No change to shift_reg needed
                end
            endcase
        end
    end

    // Output logic
    assign out_byte = (state == STOP && in == 1) ? shift_reg : 8'b0;
    assign done = (state == STOP && in == 1);

endmodule",12.549076,18247
N/A,N/A,-0.1,40,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

parameter IDLE = 0, START = 1, DATA = 2, STOP = 3;
    reg [1:0] state, next_state;
    reg [2:0] bit_counter;
    reg [7:0] data;
    reg valid;

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_counter <= 0;
            valid <= 0;
        end else begin
            state <= next_state;

            if (state == DATA) begin
                data <= {in, data[7:1]}; // Shift data in, LSB first
                bit_counter <= bit_counter + 1;
            end

            if (state == STOP && in == 1) begin
                valid <= 1; // Stop bit valid when high
            end else begin
                valid <= 0;
            end

            if (state == IDLE || state == STOP) begin
                bit_counter <= 0;
            end
        end
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: next_state = (in == 0) ? START : IDLE; // Detect start bit
            START: next_state = DATA; // Move to data collection after start bit
            DATA: next_state = (bit_counter == 7) ? STOP : DATA; // Collect 8 bits
            STOP: next_state = (in == 1) ? IDLE : STOP; // Validate stop bit
            default: next_state = IDLE;
        endcase
    end

    // Output logic
    assign out_byte = data;
    assign done = valid;

endmodule",9.027074,18617
N/A,N/A,-1,41,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

reg [3:0] state, next_state;
    reg [7:0] shift_reg;
    reg [2:0] bit_count;

    // State Encoding
    localparam IDLE = 4'd0,
               START = 4'd1,
               RECEIVE = 4'd2,
               STOP = 4'd3;

    // FSM
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
        end else begin
            state <= next_state;
        end
    end

    always @(*) begin
        case (state)
            IDLE: next_state = (in == 0) ? START : IDLE;  // Detect start bit
            START: next_state = RECEIVE;
            RECEIVE: next_state = (bit_count == 3'd7) ? STOP : RECEIVE;
            STOP: next_state = (in == 1) ? IDLE : RECEIVE; // Continue to wait for valid stop or handle dropout
            default: next_state = IDLE;
        endcase
    end

    // Datapath
    always @(posedge clk) begin
        if (reset) begin
            shift_reg <= 8'd0;
            bit_count <= 3'd0;
            done <= 1'b0;
        end else begin
            case (state)
                RECEIVE: begin
                    shift_reg <= {in, shift_reg[7:1]};  // Shift in new bit
                    bit_count <= bit_count + 1'b1;
                    done <= 1'b0;
                end
                STOP: begin
                    if (in == 1) begin
                        out_byte <= shift_reg;
                        done <= 1'b1;
                    end else begin
                        done <= 1'b0;  // Invalid stop, wait for correct
                    end
                    bit_count <= 3'd0;
                end
                default: done <= 1'b0;
            endcase
        end
    end
endmodule",11.179416,19041
N/A,N/A,-1,42,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        DATA = 3'b010,
        STOP = 3'b011,
        DONE = 3'b100
    } state_t;

    state_t state, next_state;
    logic [2:0] bit_count;
    logic [7:0] shift_reg;

    // FSM sequential block
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
            shift_reg <= 8'h00;
        end else begin
            state <= next_state;

            case (state)
                START: begin
                    bit_count <= 0;
                end
                DATA: begin
                    bit_count <= bit_count + 1;
                    shift_reg <= {in, shift_reg[7:1]};
                end
                STOP: begin
                    bit_count <= 0;
                end
                DONE: begin
                    bit_count <= 0;
                end
                default: ; // no operation in IDLE
            endcase
        end
    end

    // FSM combinational next state logic
    always_comb begin
        next_state = state;
        case (state)
            IDLE: begin
                if (in == 1'b0) begin // Detect start bit
                    next_state = START;
                end
            end
            START: begin
                next_state = DATA;
            end
            DATA: begin
                if (bit_count == 3'b111) begin // 8 data bits received
                    next_state = STOP;
                end
            end
            STOP: begin
                if (in == 1'b1) begin // Detect stop bit
                    next_state = DONE;
                end else begin
                    next_state = IDLE;
                end
            end
            DONE: begin
                next_state = IDLE; // Ready for next byte
            end
        endcase
    end

    assign done = (state == DONE);
    assign out_byte = (state == DONE) ? shift_reg : 8'hZZ;

endmodule",9.470999,19505
N/A,N/A,-0.1,43,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

reg [3:0] state;
    reg [3:0] next_state;
    reg [7:0] shift_reg;
    reg [2:0] bit_count;
  
    // Define states
    localparam IDLE = 4'b0001,
               START = 4'b0010,
               RECEIVE = 4'b0100,
               STOP = 4'b1000;
  
    // State transition logic (combinational)
    always @(*) begin
        case (state)
            IDLE: begin
                if (!in) begin // Start bit detected
                    next_state = START;
                end 
                else begin
                    next_state = IDLE;
                end
            end
            START: begin
                next_state = RECEIVE;
            end
            RECEIVE: begin
                if (bit_count == 3'b111) begin // 8 bits received
                    next_state = STOP;
                end 
                else begin
                    next_state = RECEIVE;
                end
            end
            STOP: begin
                if (in) begin // Stop bit detected
                    next_state = IDLE;
                end 
                else begin
                    next_state = RECEIVE; // Wait in RECEIVE state till a stop bit is detected
                end
            end
            default: next_state = IDLE;
        endcase
    end

    // State flip-flops (sequential)
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 3'b000;
        end 
        else begin
            state <= next_state;
            if (state == RECEIVE) begin
                if (in || !in) begin // Clock in the new bit
                    shift_reg <= {in, shift_reg[7:1]};
                    bit_count <= bit_count + 1;
                end
            end 
            else if (state == IDLE) begin
                bit_count <= 3'b000;
            end
        end
    end

    // Output logic
    assign done = (state == STOP) && in; // Done when stop bit is correctly detected
    assign out_byte = done ? shift_reg : 8'bx; // Output the byte when done
endmodule",12.294077,19976
N/A,N/A,-1,44,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State declaration
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;
    state_t current_state, next_state;
    
    // Counter and shift register
    reg [2:0] bit_counter;
    reg [7:0] shift_reg;

    // Synchronous state transition with reset
    always @(posedge clk) begin
        if (reset) begin
            current_state <= IDLE;
            bit_counter <= 3'b0;
            shift_reg <= 8'b0;
            done <= 1'b0;
        end else begin
            current_state <= next_state;
            if (current_state == DATA) begin
                shift_reg <= {in, shift_reg[7:1]};
                bit_counter <= bit_counter + 1;
            end
            if (current_state == STOP && in == 1'b1) begin
                done <= 1'b1;
            end else begin
                done <= 1'b0;
            end
        end
    end

    // Next state logic
    always @(*) begin
        case (current_state)
            IDLE: begin
                if (in == 1'b0)
                    next_state = START;
                else
                    next_state = IDLE;
            end
            START: begin
                next_state = DATA; // Start bit detected
            end
            DATA: begin
                if (bit_counter == 3'b111)
                    next_state = STOP;
                else
                    next_state = DATA;
            end
            STOP: begin
                if (in == 1'b1) // Stop bit should be received as '1'
                    next_state = IDLE;
                else
                    next_state = STOP; // Wait for correct stop bit
            end
            default: next_state = IDLE;
        endcase
    end

    // Output logic for out_byte
    assign out_byte = (done) ? shift_reg : 8'b0;

endmodule",5.963106,20404
N/A,N/A,-1,45,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        RECEIVE = 3'b010,
        STOP = 3'b011,
        VERIFY = 3'b100
    } state_t;

    state_t state, next_state;
    reg [7:0] data_shift; // Shift register for data bits
    reg [2:0] bit_counter; // Counter for received bits

    // State transition
    always_ff @(posedge clk) begin
        if (reset)
            state <= IDLE;
        else
            state <= next_state;
    end

    // Next state logic
    always_comb begin
        next_state = state; // Default: stay in the current state
        case (state)
            IDLE: if (in == 1'b0) next_state = START; // Detect start bit
            
            START: next_state = RECEIVE;
            
            RECEIVE: begin
                if (bit_counter == 3'd7)
                    next_state = STOP; // After receiving 8 bits, go to STOP state
            end
            
            STOP: next_state = VERIFY;

            VERIFY: begin
                if (in == 1'b1) // Check stop bit
                    next_state = IDLE; // Byte correctly received
                else
                    next_state = STOP; // Wait for stop bit
            end
            
            default: next_state = IDLE;
        endcase
    end

    // Output logic and data handling
    always_ff @(posedge clk) begin
        if (reset) begin
            data_shift <= 8'b0;
            bit_counter <= 3'b0;
            done <= 1'b0;
        end else begin
            done <= 1'b0;
            case (state)
                START: begin
                    bit_counter <= 3'b0;
                    data_shift <= 8'b0;
                end

                RECEIVE: begin
                    data_shift <= {in, data_shift[7:1]}; // Shift the incoming bit in
                    bit_counter <= bit_counter + 3'b1;
                end

                VERIFY: begin
                    if (next_state == IDLE)
                        done <= 1'b1;
                end

                default: ;
            endcase
        end
    end

    assign out_byte = data_shift;

endmodule",6.060081,20907
N/A,N/A,-1,46,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Define states for the FSM
    typedef enum logic [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        RECEIVE = 3'b010,
        STOP = 3'b011,
        DONE = 3'b100
    } state_t;

    state_t current_state, next_state;
    
    reg [7:0] data_shift_reg; // To shift in the incoming bits
    reg [2:0] bit_counter;    // To count received data bits
    reg stop_bit_detected;

    // State transition logic (Moore state machine)
    always_ff @(posedge clk or posedge reset) begin
        if (reset) begin
            current_state <= IDLE;
            bit_counter <= 3'b0;
            data_shift_reg <= 8'b0;
            stop_bit_detected <= 1'b0;
        end else begin
            current_state <= next_state;
            if (current_state == RECEIVE) begin
                data_shift_reg <= {in, data_shift_reg[7:1]};
                bit_counter <= bit_counter + 1'b1;
            end
            if (current_state == STOP) begin
                stop_bit_detected <= in;
            end
        end
    end
    
    // Next state logic
    always_comb begin
        next_state = current_state;
        case (current_state)
            IDLE: 
                if (in == 1'b0) // Start bit detected (LSB first)
                    next_state = START;
            START: 
                next_state = RECEIVE; // Move to receive data bits
            RECEIVE: 
                if (bit_counter == 3'b111) // Received all 8 data bits
                    next_state = STOP;
            STOP: 
                if (stop_bit_detected == 1'b1)
                    next_state = DONE; // Valid byte received
                else
                    next_state = IDLE; // Incorrect stop bit, reset
            DONE: 
                next_state = IDLE; // Go back to IDLE for next byte
            default: 
                next_state = IDLE;
        endcase
    end
    
    // Output logic
    assign done = (current_state == DONE);
    assign out_byte = data_shift_reg;

endmodule",6.280084,21388
N/A,N/A,-1,47,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

reg [3:0] state, next_state;
    reg [7:0] shift_reg;
    reg [2:0] bit_count;
    reg start_received, data_received, stop_received;

    localparam IDLE = 0,
               START = 1,
               DATA = 2,
               STOP = 3;

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
        end else begin
            state <= next_state;
        end
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: next_state = in ? IDLE : START;
            START: next_state = in ? DATA : START;
            DATA: next_state = (bit_count == 3'd7) ? STOP : DATA;
            STOP: next_state = in ? IDLE : STOP;
            default: next_state = IDLE;
        endcase
    end

    // Output logic and bit counter
    always @(posedge clk) begin
        if (reset) begin
            shift_reg <= 8'b0;
            bit_count <= 3'b0;
            done <= 1'b0;
            start_received <= 1'b0;
            data_received <= 1'b0;
            stop_received <= 1'b0;
        end else begin
            case (state)
                IDLE: begin
                    done <= 1'b0;
                    bit_count <= 3'b0;
                end
                START: begin
                    start_received <= 1'b1;
                end
                DATA: begin
                    shift_reg <= {in, shift_reg[7:1]};
                    bit_count <= bit_count + 1'b1;
                    if (bit_count == 3'd7)
                        data_received <= 1'b1;
                end
                STOP: begin
                    if (in) begin
                        done <= 1'b1;
                        stop_received <= 1'b1;
                    end
                end
            endcase
        end
    end

    assign out_byte = (done && stop_received) ? shift_reg : 8'hzz;

endmodule",6.283061,21849
N/A,N/A,-1,48,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

typedef enum reg [2:0] {IDLE, START, DATA, STOP} state_type;
    state_type state, next_state;
    
    reg [7:0] shift_reg;
    reg [2:0] bit_counter;
    reg stop_bit_correct;
    
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            shift_reg <= 8'b0;
            bit_counter <= 3'b0;
            stop_bit_correct <= 1'b0;
        end
        else begin
            state <= next_state;
        end
    end
    
    always @* begin
        next_state = state; // Default to stay in current state
        done = 1'b0;
        stop_bit_correct = 1'b0;
        
        case (state)
            IDLE: begin
                if (in == 1'b0) // Detect start bit
                    next_state = START;
            end
            
            START: begin
                if (bit_counter == 3'd7) begin
                    bit_counter = 3'b0;
                    next_state = DATA;
                end
                else
                    bit_counter = bit_counter + 1'b1;
            end
            
            DATA: begin
                if (bit_counter == 3'd7) begin
                    next_state = STOP;
                end
                shift_reg = {in, shift_reg[7:1]}; // Shift in the data bits
                bit_counter = bit_counter + 1'b1;
            end
            
            STOP: begin
                if (in == 1'b1) begin // Check stop bit
                    done = 1'b1;
                    stop_bit_correct = 1'b1;
                    next_state = IDLE;
                end
                // Invalid stop bit logic is handled by staying in STOP until a '1' is detected
            end
            
        endcase
    end
    
    // Output logic
    assign out_byte = (done && stop_bit_correct) ? shift_reg : 8'bx;
endmodule",5.078057,22279
N/A,N/A,-1,49,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        DATA = 3'b010,
        STOP = 3'b011,
        DONE = 3'b100
    } state_t;
    
    state_t state, next_state;
    logic [7:0] data_reg;
    logic [2:0] bit_counter;
    
    // State transition logic
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            data_reg <= 8'd0;
            bit_counter <= 3'd0;
        end
        else begin
            state <= next_state;
            if(state == DATA) begin
                data_reg <= {in, data_reg[7:1]};
                bit_counter <= bit_counter + 1;
            end
            if(state == DONE) begin
                bit_counter <= 3'd0;
            end
        end
    end
    
    // Next state logic
    always_comb begin
        next_state = state;
        case (state)
            IDLE: begin
                if (in == 0) // Start bit
                    next_state = START;
            end
            
            START: begin
                next_state = DATA;
            end
            
            DATA: begin
                if (bit_counter == 3'd7)
                    next_state = STOP;
            end
            
            STOP: begin
                if (in == 1) // Stop bit
                    next_state = DONE;
                else
                    next_state = IDLE;
            end
            
            DONE: begin
                next_state = IDLE;
            end
            
            default: next_state = IDLE;
        endcase
    end
    
    // Output logic
    assign done = (state == DONE);
    assign out_byte = (done) ? data_reg : 8'd0;

endmodule",4.665085,22683
N/A,N/A,-0.1,50,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    localparam IDLE = 2'b00,
               START = 2'b01,
               DATA = 2'b10,
               STOP = 2'b11;

    reg [1:0] state, next_state;
    reg [2:0] bit_count;
    reg [7:0] data_reg;
    
    // FSM state transition
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 3'b000;
            data_reg <= 8'b00000000;
        end else begin
            state <= next_state;
        end
    end

    // FSM next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 0)
                    next_state = START;
                else
                    next_state = IDLE;
            end
            START: begin
                next_state = DATA;
            end
            DATA: begin
                if (bit_count == 3'b111)
                    next_state = STOP;
                else
                    next_state = DATA;
            end
            STOP: begin
                if (in == 1)
                    next_state = IDLE;
                else
                    next_state = STOP;
            end
            default: next_state = IDLE;
        endcase
    end

    // Data path logic
    always @(posedge clk) begin
        if (reset) begin
            bit_count <= 3'b000;
            data_reg <= 8'b00000000;
        end else if (state == DATA) begin
            data_reg <= {in, data_reg[7:1]};
            bit_count <= bit_count + 1'b1;
        end
    end

    // Output logic
    assign out_byte = data_reg;
    assign done = (state == STOP) && (in == 1);

endmodule",5.521523,23087
N/A,N/A,-1,51,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// FSM states
    typedef enum logic [1:0] {
        IDLE,
        START,
        RECEIVE,
        STOP
    } state_t;
    
    state_t state, next_state;
    reg [7:0] data_shift_reg;
    reg [3:0] bit_counter;
    reg byte_received;
   
    // State transitions
    always_ff @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= IDLE;
            data_shift_reg <= 8'b0;
            bit_counter <= 4'b0;
        end else begin
            state <= next_state;
            if (state == RECEIVE) begin
                data_shift_reg <= {in, data_shift_reg[7:1]};
                bit_counter <= bit_counter + 1;
            end
        end
    end

    // Next state logic
    always_comb begin
        next_state = state;
        case (state)
            IDLE: begin
                if (in == 0)  // Detect start bit
                    next_state = START;
            end
            START: begin
                next_state = RECEIVE;
                bit_counter = 0;
            end
            RECEIVE: begin
                if (bit_counter == 8)
                    next_state = (in == 1) ? STOP : IDLE;  // Expect stop bit
            end
            STOP: begin
                next_state = IDLE;
            end
        endcase
    end

    // Output logic
    assign out_byte = data_shift_reg;
    assign done = (state == STOP);

    // Reset byte_received after data read
    always_ff @(posedge clk or posedge reset) begin
        if (reset)
            byte_received <= 0;
        else if (state == STOP)
            byte_received <= 1;
        else if (done)
            byte_received <= 0;
    end

endmodule",6.013104,23489
N/A,N/A,-0.1,52,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

reg [3:0] state, next_state;
    reg [7:0] shift_reg;
    reg [2:0] bit_count;
    
    // State Encoding
    localparam IDLE = 4'd0,
               START = 4'd1,
               DATA = 4'd2,
               STOP = 4'd3;

    // State transition logic
    always @(posedge clk) begin
        if (reset)
            state <= IDLE;
        else
            state <= next_state;
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 0) // Start bit detection
                    next_state = START;
                else
                    next_state = IDLE;
            end
            START: begin
                next_state = DATA;
            end
            DATA: begin
                if (bit_count == 3'd7)
                    next_state = STOP;
                else
                    next_state = DATA;
            end
            STOP: begin
                if (in == 1) // Valid stop bit
                    next_state = IDLE;
                else
                    next_state = STOP; // Wait for a valid stop bit
            end
            default: next_state = IDLE;
        endcase
    end

    // Output logic
    assign done = (state == STOP) && (in == 1);
    assign out_byte = (done) ? shift_reg : 8'bx; // Output valid when done is high

    // Shift register and bit_counter logic
    always @(posedge clk) begin
        if (reset) begin
            shift_reg <= 8'd0;
            bit_count <= 3'd0;
        end
        else if (state == DATA) begin
            shift_reg <= {in, shift_reg[7:1]}; // Serial shift in data bit
            bit_count <= bit_count + 1'b1;
        end
        else if (state == IDLE) begin
            bit_count <= 3'd0;
        end
    end

endmodule",5.96006,23934
N/A,N/A,-1,53,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State declaration
    typedef enum logic [2:0] {
        IDLE, START, DATA, STOP, DONE
    } state_t;
    
    state_t current_state, next_state;
    logic [7:0] shift_reg;
    logic [2:0] bit_counter;

    // State transition logic
    always_ff @(posedge clk) begin
        if (reset) begin
            current_state <= IDLE;
            shift_reg <= 8'b0;
            bit_counter <= 3'b0;
        end else begin
            current_state <= next_state;
        end
    end

    // Next state logic
    always_comb begin
        case (current_state)
            IDLE: begin
                if (in == 1'b0) // Start bit detected
                    next_state = START;
                else 
                    next_state = IDLE;
            end
            START: begin
                next_state = DATA;
            end
            DATA: begin
                if (bit_counter == 3'b111)
                    next_state = STOP;
                else
                    next_state = DATA;
            end
            STOP: begin
                if (in == 1'b1) // Stop bit detected
                    next_state = DONE;
                else
                    next_state = IDLE; // Error: Wait for stop bit before retry
            end
            DONE: begin
                next_state = IDLE;
            end
            default: next_state = IDLE;
        endcase
    end

    // Output logic
    always_ff @(posedge clk) begin
        // Reset or at the start of DATA state
        if (reset || (current_state == IDLE && next_state == START)) begin
            shift_reg <= 8'b0;
            bit_counter <= 3'b0;
        end

        // Shift data bits in when in DATA state
        if (current_state == DATA) begin
            shift_reg <= {in, shift_reg[7:1]};
            bit_counter <= bit_counter + 1'b1;
        end
    end

    // Assign outputs
    assign out_byte = shift_reg;
    assign done = (current_state == DONE);

endmodule",5.435103,24394
N/A,N/A,-1,54,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        RECEIVE = 3'b010,
        STOP = 3'b011,
        COMPLETE = 3'b100
    } state_t;
    
    state_t state, next_state;
    logic [7:0] shift_reg;
    logic [2:0] bit_count;

    // FSM state transition
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
        end else begin
            state <= next_state;
        end
    end

    // FSM next state logic
    always_comb begin
        next_state = state;
        case (state)
            IDLE: begin
                if (in == 1'b0)  // Start bit detected
                    next_state = START;
            end
            START: begin
                // Stay in START state for 1 clock to sync
                next_state = RECEIVE;
            end
            RECEIVE: begin
                if (bit_count == 3'd7)  // 8 bits received
                    next_state = STOP;
            end
            STOP: begin
                if (in == 1'b1)  // Valid stop bit detected
                    next_state = COMPLETE;
                else
                    next_state = IDLE;  // Invalid stop bit, wait for next byte
            end
            COMPLETE: begin
                next_state = IDLE;  // Return to IDLE after completing
            end
            default: next_state = IDLE;
        endcase
    end

    // Bit count and shift register
    always_ff @(posedge clk) begin
        if (reset) begin
            bit_count <= 3'd0;
            shift_reg <= 8'd0;
        end else if (state == RECEIVE) begin
            shift_reg <= {in, shift_reg[7:1]};  // Shift in LSB first
            bit_count <= bit_count + 1;
        end else if (state != RECEIVE) begin
            bit_count <= 3'd0;
        end
    end

    // Output logic
    assign done = (state == COMPLETE);
    assign out_byte = (done) ? shift_reg : 8'dx;

endmodule",5.97308,24884
N/A,N/A,-1,55,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        DATA = 3'b010,
        STOP = 3'b011,
        DONE = 3'b100
    } state_t;

    state_t current_state, next_state;
    reg [7:0] shift_reg;
    reg [2:0] bit_count;

    // Next state logic
    always_comb begin
        case (current_state)
            IDLE: next_state = (in == 0) ? START : IDLE;
            START: next_state = DATA;
            DATA: next_state = (bit_count == 3'b111) ? STOP : DATA;
            STOP: next_state = (in == 1) ? DONE : IDLE;
            DONE: next_state = (in == 1) ? IDLE : START;
        endcase
    end

    // State transition and output logic
    always_ff @(posedge clk) begin
        if (reset) begin
            current_state <= IDLE;
            bit_count <= 3'b000;
            shift_reg <= 8'b0;
            done <= 0;
        end else begin
            current_state <= next_state;
            case (current_state)
                IDLE: begin
                    bit_count <= 3'b000;
                    shift_reg <= 8'b0;
                    done <= 0;
                end
                START: begin
                    bit_count <= 3'b000;
                end
                DATA: begin
                    shift_reg <= {in, shift_reg[7:1]}; // Shift in the LSB first
                    bit_count <= bit_count + 1;
                end
                STOP: begin
                    if (in) begin
                        done <= 1;
                        out_byte <= shift_reg;
                    end
                end
                DONE: begin
                    done <= 0;
                end
            endcase
        end
    end

endmodule",5.33209,25307
N/A,N/A,-1,56,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum reg [2:0] {
        IDLE  = 3'b000,
        START = 3'b001,
        DATA  = 3'b010,
        STOP  = 3'b011
    } state_t;
    
    state_t state, next_state;
    reg [2:0] bit_counter;
    reg [7:0] shift_reg;
    
    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_counter <= 3'b000;
        end
        else begin
            state <= next_state;
            if (state == DATA)
                bit_counter <= bit_counter + 1;
            else
                bit_counter <= 3'b000;
        end
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                done = 0;
                if (in == 0)  // Detect start bit (active low)
                    next_state = START;
                else
                    next_state = IDLE;
            end
            START: begin
                done = 0;
                next_state = DATA;
            end
            DATA: begin
                done = 0;
                if (bit_counter == 3'd7)
                    next_state = STOP;
                else
                    next_state = DATA;
            end
            STOP: begin
                if (in == 1) begin  // Detect stop bit (active high)
                    done = 1;
                    next_state = IDLE;
                end
                else begin
                    done = 0;
                    next_state = STOP;
                end
            end
            default: begin
                done = 0;
                next_state = IDLE;
            end
        endcase
    end

    // Datapath logic: shift in the serial bits
    always @(posedge clk) begin
        if (reset)
            shift_reg <= 8'b0;
        else if (state == DATA)
            shift_reg <= {in, shift_reg[7:1]};  // Shift in data, LSB first
    end

    // Output
    assign out_byte = shift_reg;

endmodule",6.858061,25781
N/A,N/A,-1,57,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State declarations
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP,
        WAIT_STOP
    } state_t;
    
    // State variables
    state_t current_state, next_state;
    logic [2:0] bit_counter;
    logic [7:0] shift_reg;
    logic stop_bit;
    
    // State transition logic
    always_ff @(posedge clk) begin
        if (reset) begin
            current_state <= IDLE;
            bit_counter <= 0;
            shift_reg <= 8'b0;
        end else begin
            current_state <= next_state;
            if (next_state == DATA) begin
                shift_reg <= {in, shift_reg[7:1]};
                bit_counter <= bit_counter + 3'b1;
            end
        end
    end
    
    // Next state logic
    always_comb begin
        next_state = current_state; // Default state stays the same
        done = 1'b0;
        stop_bit = 1'b0;
        case (current_state)
            IDLE: begin
                if (in == 0) // Start bit detected
                    next_state = START;
            end
            START: begin
                next_state = DATA;
                bit_counter = 3'b0;
            end
            DATA: begin
                if (bit_counter == 3'd7) // All data bits received
                    next_state = STOP;
            end
            STOP: begin
                if (in == 1) begin // Stop bit received correctly
                    done = 1'b1;
                    next_state = IDLE;
                end else begin
                    next_state = WAIT_STOP; // Wait for stop bit
                end
            end
            WAIT_STOP: begin
                if (in == 1) // Stop bit detected
                    next_state = IDLE;
            end
        endcase
    end

    // Output logic
    assign out_byte = shift_reg;

endmodule",4.897086,26204
N/A,N/A,-0.1,58,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

reg [3:0] state;
    reg [3:0] next_state;
    reg [7:0] shift_reg; // Register to hold the 8 data bits
    reg [2:0] bit_count; // Counter for the number of data bits shifted in

    localparam IDLE = 4'd0;
    localparam START = 4'd1;
    localparam BIT_0 = 4'd2;
    localparam BIT_1 = 4'd3;
    localparam BIT_2 = 4'd4;
    localparam BIT_3 = 4'd5;
    localparam BIT_4 = 4'd6;
    localparam BIT_5 = 4'd7;
    localparam BIT_6 = 4'd8;
    localparam BIT_7 = 4'd9;
    localparam STOP = 4'd10;
    localparam DONE = 4'd11;

    // State Transition
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
        end else begin
            state <= next_state;
        end
    end

    // Next State Logic
    always @(*) begin
        case (state)
            IDLE: next_state = in ? IDLE : START; // Wait for the start bit (0)
            START: next_state = BIT_0; // Move to the first bit state
            BIT_0: next_state = BIT_1;
            BIT_1: next_state = BIT_2;
            BIT_2: next_state = BIT_3;
            BIT_3: next_state = BIT_4;
            BIT_4: next_state = BIT_5;
            BIT_5: next_state = BIT_6;
            BIT_6: next_state = BIT_7;
            BIT_7: next_state = STOP;
            STOP: next_state = in ? DONE : IDLE; // Check for stop bit (should be 1)
            DONE: next_state = IDLE; // Return to waiting for a new start bit
            default: next_state = IDLE;
        endcase
    end

    // Output and Datapath
    assign done = (state == DONE); // Indicate byte reception is done
    assign out_byte = shift_reg; // Output the received data byte

    // Shift Register Logic
    always @(posedge clk) begin
        if (reset) begin
            shift_reg <= 8'b0;
            bit_count <= 3'b0;
        end else if (state == START) begin
            bit_count <= 3'd0;
        end else if (state >= BIT_0 && state <= BIT_7) begin
            shift_reg <= {in, shift_reg[7:1]}; // Shift in each bit
            bit_count <= bit_count + 3'd1;
        end
    end
endmodule",8.611089,26819
N/A,N/A,-0.1,59,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

reg [3:0] state, next_state;
    reg [2:0] bit_count; // Counter for data bits
    reg [7:0] data; // Data shift register
    
    localparam IDLE = 4'd0,
               START = 4'd1,
               DATA = 4'd2,
               STOP = 4'd3,
               DONE = 4'd4;

    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 3'd0;
            data <= 8'b0;
        end else begin
            state <= next_state;
        end
    end

    always @(*) begin
        next_state = state; // Default state transition: remain in current state
        case (state)
            IDLE: begin
                if (in == 1'b0) // Start bit detected
                    next_state = START;
            end

            START: begin
                next_state = DATA;
                bit_count = 3'd0;
            end

            DATA: begin
                if (bit_count < 3'd7) begin
                    next_state = DATA;
                end else begin
                    next_state = STOP;
                end
            end

            STOP: begin
                if (in == 1'b1) // Stop bit is correct
                    next_state = DONE;
                else
                    next_state = IDLE; // Error, wait for next start bit
            end

            DONE: begin
                next_state = IDLE; // Output data is valid when done is high
            end
        endcase
    end

    always @(posedge clk) begin
        if (state == DATA) begin
            data <= {in, data[7:1]}; // Shift in data bits
            bit_count <= bit_count + 1;
        end
    end

    assign out_byte = (state == DONE) ? data : 8'bx; 
    assign done = (state == DONE);

endmodule",9.747084,27246
N/A,N/A,-1,60,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// States for the FSM
    typedef enum reg [1:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    state_t state, next_state;
    reg [2:0] bit_count;      // Counter for data bits
    reg [7:0] data_shift;     // Shift register for receiving data

    // State transition logic
    always @(posedge clk or posedge reset) begin
        if (reset)
            state <= IDLE;
        else
            state <= next_state;
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 0) // Start bit detection
                    next_state = START;
                else
                    next_state = IDLE;
            end
            START: begin
                next_state = DATA;
            end
            DATA: begin
                if (bit_count == 7)
                    next_state = STOP;
                else
                    next_state = DATA;
            end
            STOP: begin
                if (in == 1) // Correct stop bit
                    next_state = IDLE;
                else
                    next_state = STOP; // Wait for correct stop bit
            end
        endcase
    end

    // Output and datapath logic
    always @(posedge clk) begin
        if (reset) begin
            bit_count <= 0;
            data_shift <= 8'b0;
        end
        else begin
            case (state)
                IDLE: begin
                    bit_count <= 0;
                    data_shift <= 8'b0;
                end
                START: begin
                    // Prepare for incoming data bits
                end
                DATA: begin
                    data_shift <= {in, data_shift[7:1]}; // Shift in bits
                    bit_count <= bit_count + 1;
                end
                STOP: begin
                    // Check if stop bit is correct
                end
            endcase
        end
    end

    assign done = (state == STOP) && (in == 1);
    assign out_byte = data_shift;

endmodule",7.71807,27705
N/A,N/A,-1,61,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE, START, DATA, STOP, DONE
    } state_t;

    state_t state, next_state;
    reg [2:0] bit_count;
    reg [7:0] shift_reg;
    reg done_reg;

    // Output assignments
    assign out_byte = shift_reg;
    assign done = done_reg;

    // State transition logic
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 3'd0;
            shift_reg <= 8'd0;
            done_reg <= 1'b0;
        end else begin
            state <= next_state;

            // State dependent logic
            case (state)
                IDLE: begin
                    if (in == 1'b0) begin // Start bit detected
                        next_state <= START;
                    end else begin
                        next_state <= IDLE;
                    end
                end

                START: begin
                    next_state <= DATA;
                    shift_reg <= 8'd0; // Clear shift register for new byte
                    bit_count <= 3'd0; // Reset bit count
                end

                DATA: begin
                    shift_reg <= {in, shift_reg[7:1]}; // Shift in the incoming data bit (LSB first)
                    bit_count <= bit_count + 1;
                    if (bit_count == 3'd7) begin
                        next_state <= STOP;
                    end else begin
                        next_state <= DATA;
                    end
                end

                STOP: begin
                    if (in == 1'b1) begin // Stop bit detected
                        next_state <= DONE;
                        done_reg <= 1'b1;
                    end else begin
                        next_state <= IDLE; // Error handling, wait for correct stop bit
                    end
                end

                DONE: begin
                    next_state <= IDLE;
                    done_reg <= 1'b0;
                end

                default: begin
                    next_state <= IDLE;
                end
            endcase
        end
    end
endmodule",8.73711,28156
N/A,N/A,-1,62,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// States for the FSM
    typedef enum logic [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        RECEIVE = 3'b010,
        STOP = 3'b011
    } state_t;

    state_t current_state, next_state;

    // Datapath registers
    reg [7:0] data_shift_reg;
    reg [2:0] bit_count;

    // FSM logic: synchronous state transition
    always @(posedge clk or posedge reset) begin
        if (reset) begin
            current_state <= IDLE;
            bit_count <= 3'd0;
        end else begin
            current_state <= next_state;
            if (next_state == RECEIVE) begin
                data_shift_reg <= {in, data_shift_reg[7:1]};
                bit_count <= bit_count + 1;
            end else if (next_state == START || next_state == IDLE) begin
                bit_count <= 3'd0;
            end
        end
    end

    // FSM logic: next state logic
    always @(*) begin
        case (current_state)
            IDLE: begin
                if (in == 1'b0) // Detect start bit
                    next_state = START;
                else
                    next_state = IDLE;
            end
            START: begin
                next_state = RECEIVE;
            end
            RECEIVE: begin
                if (bit_count == 3'd7)
                    next_state = STOP;
                else
                    next_state = RECEIVE;
            end
            STOP: begin
                if (in == 1'b1) // Check stop bit
                    next_state = IDLE;
                else
                    next_state = STOP;
            end
            default: next_state = IDLE;
        endcase
    end

    // Output logic
    assign done = (current_state == STOP && in == 1'b1);
    assign out_byte = done ? data_shift_reg : 8'd0;

endmodule",6.527066,28586
N/A,N/A,-1,63,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State declaration
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;
    
    state_t state, next_state;

    // Datapath register to store incoming bits
    reg [7:0] data_reg;
    reg [3:0] bit_count;

    // Done signal
    reg done_reg;
    assign done = done_reg;

    // Output byte assignment
    assign out_byte = data_reg;

    // State transition and datapath logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            data_reg <= 8'b0;
            bit_count <= 4'b0;
            done_reg <= 1'b0;
        end else begin
            state <= next_state;

            case (state)
                IDLE: begin
                    done_reg <= 1'b0;
                    if (in == 0) // Detect start bit
                        next_state <= START;
                end

                START: begin
                    next_state <= DATA;
                end

                DATA: begin
                    data_reg[bit_count] <= in; // Shift in data bits
                    bit_count <= bit_count + 1;

                    if (bit_count == 4'd7)
                        next_state <= STOP;
                end

                STOP: begin
                    if (in == 1) begin // Verify stop bit
                        done_reg <= 1'b1;
                    end
                    next_state <= IDLE;
                    bit_count <= 4'b0; // Reset bit counter
                end
            endcase
        end
    end
endmodule",6.347064,28937
N/A,N/A,-1,64,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,     // Waiting for start bit
        START,    // Start bit detected
        DATA,     // Collecting data bits
        STOP,     // Waiting for stop bit
        DONE      // Finished
    } state_t;
    
    state_t state, next_state;
    reg [7:0] shift_reg; // Shift register to collect data bits
    reg [2:0] bit_counter; // Counter for data bits

    // State transition logic
    always_ff @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= IDLE;
            bit_counter <= 3'b0;
        end else begin
            state <= next_state;
            if (state == DATA) begin
                shift_reg <= {in, shift_reg[7:1]}; // Shift in the input bit
                bit_counter <= bit_counter + 1'b1;
            end
        end
    end

    // Next state logic
    always_comb begin
        next_state = state;
        case (state)
            IDLE: begin
                if (in == 1'b0) // Detect start bit (assuming active low)
                    next_state = START;
            end
            START: begin
                next_state = DATA; // Move to data collection
            end
            DATA: begin
                if (bit_counter == 3'd7) // All 8 bits collected
                    next_state = STOP;
            end
            STOP: begin
                if (in == 1'b1) // Detect stop bit (assuming active high)
                    next_state = DONE;
                else
                    next_state = IDLE; // Invalid sequence, reset
            end
            DONE: begin
                next_state = IDLE; // Ready for next byte
            end
        endcase
    end

    // Output logic
    assign done = (state == DONE);
    assign out_byte = (done) ? shift_reg : 8'b0;

endmodule",7.949152,29373
N/A,N/A,-1,65,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum reg [2:0] {
        IDLE,       // Waiting for start bit
        RECEIVE,    // Receiving data bits
        STOP_BIT    // Waiting for stop bit
    } state_t;

    // State registers
    state_t current_state, next_state;

    // Register to shift in data bits
    reg [7:0] data_shift_reg;
    reg [3:0] bit_count;

    // Output register for the finished byte
    reg [7:0] received_byte;
    reg done_reg;

    // State transition logic
    always @(posedge clk or posedge reset) begin
        if (reset) begin
            current_state <= IDLE;
            bit_count <= 4'd0;
            data_shift_reg <= 8'b0;
            done_reg <= 1'b0;
            received_byte <= 8'b0;
        end else begin
            current_state <= next_state;

            // In RECEIVE state, shift in data bits
            if (current_state == RECEIVE) begin
                data_shift_reg <= {in, data_shift_reg[7:1]};
                bit_count <= bit_count + 1;
            end

            // When a byte is done and validated, latch it
            if (current_state == STOP_BIT && in) begin
                received_byte <= data_shift_reg;
            end

            // Done flag
            done_reg <= (current_state == STOP_BIT && in);
        end
    end

    // Next state logic
    always @(*) begin
        case (current_state)
            IDLE: begin
                if (~in) 
                    next_state = RECEIVE;  // Detect start bit (low)
                else 
                    next_state = IDLE;
            end

            RECEIVE: begin
                if (bit_count == 8) 
                    next_state = STOP_BIT; // Move to STOP_BIT after 8 data bits
                else 
                    next_state = RECEIVE;
            end

            STOP_BIT: begin
                if (in) 
                    next_state = IDLE;     // Stop bit detected, go back to IDLE
                else 
                    next_state = STOP_BIT; // Wait if stop bit is wrong
            end

            default: next_state = IDLE;
        endcase
    end

    // Output assignments
    assign out_byte = received_byte;
    assign done = done_reg;

endmodule",10.237071,29880
N/A,N/A,-1,66,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State machine definition
    typedef enum logic [2:0] {
        IDLE,        // Waiting for start bit
        RECEIVE,     // Receiving byte
        VERIFY_STOP  // Verify stop bit
    } state_t;

    state_t current_state, next_state;

    reg [7:0] shift_reg; // Register to store incoming bits
    reg [3:0] bit_count; // Counter for the number of bits received

    // State update (sequential logic)
    always_ff @(posedge clk or posedge reset) begin
        if (reset) begin
            current_state <= IDLE;
            shift_reg <= 8'b0;
            bit_count <= 4'b0;
        end else begin
            current_state <= next_state;
            
            // Shift in bits during receive state
            if (current_state == RECEIVE && bit_count < 8) begin
                shift_reg <= {in, shift_reg[7:1]}; // Shift incoming bit
                bit_count <= bit_count + 1;
            end

            // Reset bit_count and shift_reg if verifying stop bit
            if (current_state == VERIFY_STOP) begin
                bit_count <= 4'b0;
            end
        end
    end

    // Next state logic (combinational logic)
    always_comb begin
        next_state = current_state; // Default
        done = 1'b0; // Default
        case (current_state)
            IDLE: begin
                if (in == 1'b0) // Detect start bit (logic low)
                    next_state = RECEIVE;
            end
            RECEIVE: begin
                if (bit_count == 8) // After receiving 8 bits
                    next_state = VERIFY_STOP;
            end
            VERIFY_STOP: begin
                if (in == 1'b1) begin // Check stop bit (logic high)
                    done = 1'b1; // Set done flag
                    next_state = IDLE;
                end
            end
        endcase
    end

    // Output logic
    assign out_byte = done ? shift_reg : 8'bxxxx_xxxx;

endmodule",8.153082,30335
N/A,N/A,-1,67,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State declaration
    typedef enum logic [2:0] {
        IDLE,       // Waiting for start bit
        START,      // Start bit detected
        DATA,       // Receiving data bits
        STOP,       // Checking stop bit
        DONE        // Byte received correctly
    } state_t;

    state_t state, next_state;

    reg [3:0] bit_count;
    reg [7:0] shift_reg;
    
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
            shift_reg <= 0;
        end else begin
            state <= next_state;
            if (state == DATA) begin
                shift_reg <= {in, shift_reg[7:1]};
                bit_count <= bit_count + 1;
            end
        end
    end

    always_comb begin
        next_state = state;
        done = 0;
        case (state)
            IDLE: begin
                if (in == 0)  // Detect start bit
                    next_state = START;
            end
            START: begin
                next_state = DATA;
                bit_count = 0;
            end
            DATA: begin
                if (bit_count == 8)
                    next_state = STOP;
            end
            STOP: begin
                if (in == 1) begin // Check stop bit
                    next_state = DONE;
                    done = 1;
                end else
                    next_state = IDLE; // Stop bit failed, reset
            end
            DONE: begin
                next_state = IDLE; // Return to IDLE after byte received
            end
        endcase
    end
    
    assign out_byte = (done) ? shift_reg : 8'bxxxxxxxx;  // valid only when done is high

endmodule",7.533088,30730
N/A,N/A,-1,68,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic[2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        DATA = 3'b010,
        STOP = 3'b011,
        DONE = 3'b100
    } state_t;
    
    state_t state, next_state;
    logic [2:0] bit_counter; // Count up to 8 for 8 data bits
    logic [7:0] shift_reg;   // Shift register to hold incoming data bits
    logic valid_stop;        // Indicates a valid stop bit is encountered
    
    always_ff @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= IDLE;
            bit_counter <= 3'b000;
            shift_reg <= 8'b00000000;
            valid_stop <= 1'b0;
        end
        else begin
            state <= next_state;
            if (state == DATA && next_state == DATA) begin
                shift_reg <= {in, shift_reg[7:1]}; // Shift in new data bit
                bit_counter <= bit_counter + 1'b1;
            end
            if (state == STOP && next_state == DONE) begin
                valid_stop <= 1'b1;
            end
            else if (next_state == IDLE || next_state == START) begin
                valid_stop <= 1'b0;
            end
        end
    end

    always_comb begin
        // Default assignments
        next_state = state;
        case (state)
            IDLE: begin
                done = 1'b0; 
                if (in == 1'b0)    // Detect start bit
                    next_state = START;
            end
            START: begin
                if (in == 1'b0)
                    next_state = DATA;  // Move to data state
            end
            DATA: begin
                if (bit_counter == 3'b111)  // Last data bit received
                    next_state = STOP;
            end
            STOP: begin
                if (in == 1'b1)    // Valid stop bit
                    next_state = DONE;
                else
                    next_state = IDLE; // Invalid stop bit, restart
            end
            DONE: begin
                done = 1'b1;
                next_state = IDLE;  // Prepare for the next byte reception
            end
            default: next_state = IDLE;
        endcase
    end

    assign out_byte = (valid_stop) ? shift_reg : 8'bxxxxxxxx;

endmodule",10.698081,31281
N/A,N/A,-1,69,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding for FSM
    typedef enum logic [2:0] {
        IDLE,           // Waiting for start bit
        START,          // Start bit detected
        DATA,           // Receiving data bits
        STOP,           // Checking stop bit
        DONE            // Byte received successfully
    } state_t;

    state_t state, next_state;

    reg [7:0] data_shift; // Datapath to hold the received bits
    reg [2:0] bit_count;  // Counter for the number of bits received

    assign done = (state == DONE); // Output done when in DONE state
    assign out_byte = data_shift;  // Output the received byte when in DONE state

    // State transition logic
    always_ff @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= IDLE;
        end else begin
            state <= next_state;
        end
    end

    // State machine logic
    always_comb begin
        next_state = state; // Default to holding the current state
        case (state)
            IDLE: begin
                if (in == 0) // Start bit detected (0)
                    next_state = START;
            end
            START: begin
                next_state = DATA; // Move to DATA state
                bit_count = 0;
            end
            DATA: begin
                if (bit_count == 8) begin
                    next_state = STOP;
                end
            end
            STOP: begin
                if (in == 1) // Check stop bit (1)
                    next_state = DONE;
                else
                    next_state = IDLE; // If stop bit incorrect, return to IDLE
            end
            DONE: begin
                next_state = IDLE; // After processing, return to IDLE
            end
        endcase
    end

    // Datapath logic - shifting in data bits
    always_ff @(posedge clk) begin
        if (state == DATA) begin
            data_shift <= {in, data_shift[7:1]}; // Shift in the received bit
            bit_count <= bit_count + 1;
        end
    end

endmodule",13.357086,31754
N/A,N/A,-1,70,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State declarations
    typedef enum logic [2:0] {
        IDLE,
        START_BIT,
        DATA_BITS,
        STOP_BIT,
        DONE_STATE
    } state_t;

    state_t state, next_state;
    reg [7:0] shift_reg;
    reg [3:0] bit_count;

    // State transition logic (combinational)
    always_comb begin
        next_state = state;
        case (state)
            IDLE: begin
                if (!in)  // Start bit detected (in is low)
                    next_state = START_BIT;
            end
            START_BIT: begin
                next_state = DATA_BITS;
            end
            DATA_BITS: begin
                if (bit_count == 8)
                    next_state = STOP_BIT;
            end
            STOP_BIT: begin
                if (in)  // Stop bit detected (in is high)
                    next_state = DONE_STATE;
                else
                    next_state = IDLE;  // Invalid byte, return to IDLE
            end
            DONE_STATE: begin
                next_state = IDLE;
            end
        endcase
    end

    // State flip-flops (sequential)
    always_ff @(posedge clk or posedge reset) begin
        if (reset)
            state <= IDLE;
        else
            state <= next_state;
    end

    // Output logic
    assign done = (state == DONE_STATE);
    assign out_byte = (state == DONE_STATE) ? shift_reg : 8'd0;

    // Shift register and bit counting
    always_ff @(posedge clk) begin
        if (reset) begin
            shift_reg <= 8'd0;
            bit_count <= 4'd0;
        end
        else if (state == DATA_BITS) begin
            shift_reg <= {in, shift_reg[7:1]};  // Shift in the data bits
            bit_count <= bit_count + 1;
        end
        else if (state == STOP_BIT || state == DONE_STATE) begin
            bit_count <= 4'd0;
        end
    end

endmodule",11.025087,32205
N/A,N/A,-0.1,71,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

reg [3:0] state, next_state;
    reg [7:0] data_shift;
    reg [3:0] bit_count;

    // State encoding
    localparam IDLE = 4'd0,
               START = 4'd1,
               RECEIVE = 4'd2,
               STOP = 4'd3,
               DONE = 4'd4,
               ERROR = 4'd5;

    // State transition and output logic
    always @(*) begin
        next_state = state;
        case (state)
            IDLE: begin
                if (in == 1'b0)
                    next_state = START;
            end
            
            START: begin
                if (in == 1'b0)
                    next_state = RECEIVE;
                else
                    next_state = IDLE;
            end
            
            RECEIVE: begin
                if (bit_count == 4'd8)
                    next_state = STOP;
            end
            
            STOP: begin
                if (in == 1'b1)
                    next_state = DONE;
                else
                    next_state = ERROR;
            end
            
            DONE: begin
                next_state = IDLE;
            end
            
            ERROR: begin
                if (in == 1'b1)
                    next_state = IDLE;
            end
            
            default: next_state = IDLE;
        endcase
    end

    // State update and bit counter
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
            data_shift <= 0;
        end else begin
            state <= next_state;
            if (state == RECEIVE) begin
                data_shift <= {in, data_shift[7:1]};
                bit_count <= bit_count + 1;
            end else begin
                bit_count <= 0;
            end
            if (state == DONE) begin
                // Preserve the data byte on done
                data_shift <= data_shift;
            end
        end
    end

    // Output assignment
    assign out_byte = data_shift;
    assign done = (state == DONE);

endmodule",6.251082,32656
N/A,N/A,-1,72,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,    // Initial state
        START,   // Start bit detected
        DATA,    // Receiving data bits
        STOP,    // Stop bit to be verified
        DONE     // Successfully received byte
    } state_t;

    state_t state, next_state;
    reg [7:0] shift_reg;  // To hold the received data bits
    reg [2:0] bit_count;  // To count the number of bits received

    // State transition logic
    always_ff @(posedge clk) begin
        if (reset)
            state <= IDLE;
        else
            state <= next_state;
    end

    // Determine the next state - State transition
    always_comb begin
        next_state = state;  // Default to holding state
        case (state)
            IDLE: if (in == 0)                // Detect start bit
                      next_state = START;
            START: next_state = DATA;         // Move to data state
            DATA: if (bit_count == 7)          // All 8 data bits received
                      next_state = STOP;
            STOP: if (in == 1)                // Verify stop bit
                      next_state = DONE;
                   else if (in == 0)          // Wait for correct stop bit
                      next_state = IDLE;
            DONE: next_state = IDLE;          // Go back to IDLE after done
        endcase
    end

    // Datapath operations
    always_ff @(posedge clk) begin
        if (reset) begin
            shift_reg <= 8'b0;
            bit_count <= 3'b0;
        end
        else begin
            case (state)
                START: begin
                    shift_reg <= 8'b0;        // Clear shift register at start bit
                    bit_count <= 3'b0;
                end
                DATA: begin
                    shift_reg <= {in, shift_reg[7:1]}; // Shift in the new bit
                    bit_count <= bit_count + 1'b1;     // Increment bit count
                end
                DONE: begin
                    shift_reg <= shift_reg;  // Hold the value in DONE state
                    bit_count <= 3'b0;
                end
            endcase
        end
    end
    
    // Output logic
    assign out_byte = (state == DONE) ? shift_reg : 8'bx; // Valid during DONE state
    assign done = (state == DONE);                         // Done signal during DONE state

endmodule",7.560096,33209
N/A,N/A,-0.1,73,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

reg [3:0] state, next_state;
    reg [7:0] data_reg;
    reg [2:0] bit_counter;

    // State Definitions
    localparam IDLE      = 4'd0,
               START_BIT = 4'd1,
               DATA_BITS = 4'd2,
               STOP_BIT  = 4'd3,
               DONE      = 4'd4;

    // State Machine
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_counter <= 3'd0;
            data_reg <= 8'd0;
        end else begin
            state <= next_state;
        end
    end

    // Next State Logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 0) // Start bit detected
                    next_state = START_BIT;
                else
                    next_state = IDLE;
            end
            START_BIT: begin
                next_state = DATA_BITS;
            end
            DATA_BITS: begin
                if (bit_counter == 3'd7)
                    next_state = STOP_BIT;
                else
                    next_state = DATA_BITS;
            end
            STOP_BIT: begin
                if (in == 1) // Stop bit detected
                    next_state = DONE;
                else
                    next_state = START_BIT; // Invalid stop bit, find new start bit
            end
            DONE: begin
                next_state = IDLE;
            end
            default: next_state = IDLE;
        endcase
    end

    // Datapath and bit counter
    always @(posedge clk) begin
        if (reset) begin
            bit_counter <= 3'd0;
            data_reg <= 8'd0;
        end else if(state == DATA_BITS) begin
            data_reg <= {in, data_reg[7:1]}; // Shift in data bit
            bit_counter <= bit_counter + 3'd1;
        end else if(state == IDLE) begin
            bit_counter <= 3'd0;
        end
    end

    // Output logic
    assign out_byte = (state == DONE) ? data_reg : 8'd0;
    assign done = (state == DONE);

endmodule",15.172064,33696
N/A,N/A,-1,74,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [1:0] {
        IDLE = 2'b00,     // Waiting for a start bit
        RECEIVE = 2'b01,  // Receiving data bits
        STOP = 2'b10      // Verifying stop bit
    } state_t;

    state_t current_state, next_state;
    reg [2:0] bit_counter;  // To count the number of received data bits
    reg [7:0] shift_register; // To store the received bits

    // Combinational logic for next state and outputs
    always_comb begin
        next_state = current_state; // Default to current state
        done = 0; // Default done signal
        case (current_state)
            IDLE: begin
                if (in == 0) // Detected start bit
                    next_state = RECEIVE;
            end
            RECEIVE: begin
                if (bit_counter == 3'd7) // All 8 data bits received
                    next_state = STOP;
            end
            STOP: begin
                if (in == 1) // Correct stop bit detected
                    done = 1; // Indicate byte reception is complete
                next_state = IDLE; // Prepare for the next byte
            end
        endcase
    end

    // Sequential logic for state transitions and data reception
    always_ff @(posedge clk) begin
        if (reset) begin
            current_state <= IDLE;
            bit_counter <= 3'd0;
            shift_register <= 8'd0;
        end else begin
            current_state <= next_state;
            if (current_state == RECEIVE) begin
                shift_register <= {in, shift_register[7:1]}; // Shift in the new bit
                bit_counter <= bit_counter + 1;
            end else begin // IDLE or STOP
                bit_counter <= 3'd0; // Reset counter on IDLE or STOP
            end
        end
    end

    assign out_byte = shift_register; // When done is asserted, this holds the received byte

endmodule",9.532085,34144
N/A,N/A,-1,75,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum reg [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        DATA = 3'b010,
        STOP = 3'b011,
        DONE = 3'b100
    } state_t;

    state_t state, next_state;
    reg [2:0] bit_count;       // Counter for tracking bit position in a byte
    reg [7:0] data_reg;        // Data register to store received data bits

    // State transition
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
        end else begin
            state <= next_state;
        end
    end

    // Next state logic and data path
    always @(posedge clk) begin
        if (reset) begin
            bit_count <= 3'd0;
            data_reg <= 8'd0;
        end else begin
            case (state)
                IDLE: begin
                    bit_count <= 3'd0;
                    if (in == 1'b0)  // Start bit detected
                        next_state <= START;
                    else
                        next_state <= IDLE;
                end
                START: begin
                    next_state <= DATA;
                end
                DATA: begin
                    data_reg[bit_count] <= in;  // Shift in the incoming bit
                    if (bit_count == 3'd7)
                        next_state <= STOP;
                    else begin
                        bit_count <= bit_count + 1;
                        next_state <= DATA;
                    end
                end
                STOP: begin
                    if (in == 1'b1)  // Stop bit detected
                        next_state <= DONE;
                    else
                        next_state <= IDLE;  // Wait for a proper stop bit
                end
                DONE: begin
                    next_state <= IDLE;  // Return to IDLE after marking done
                end
            endcase
        end
    end

    // Output logic
    assign out_byte = data_reg;
    assign done = (state == DONE);

endmodule",9.060071,34592
N/A,N/A,-0.1,76,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

parameter IDLE = 2'd0, START = 2'd1, DATA = 2'd2, STOP = 2'd3;
    reg [1:0] state, next_state;
    reg [3:0] bit_counter;
    reg [7:0] shift_reg;
    reg byte_done;

    // FSM state transition
    always @(posedge clk) begin
        if (reset)
            state <= IDLE;
        else
            state <= next_state;
    end

    // FSM next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 1'b0)
                    next_state = START;
                else
                    next_state = IDLE;
            end
            START: begin
                next_state = DATA;
            end
            DATA: begin
                if (bit_counter == 4'd8)
                    next_state = STOP;
                else
                    next_state = DATA;
            end
            STOP: begin
                if (in == 1'b1)
                    next_state = IDLE;
                else
                    next_state = STOP;
            end
            default: next_state = IDLE;
        endcase
    end

    // Counter and shift register logic
    always @(posedge clk) begin
        if (reset) begin
            bit_counter <= 4'd0;
            shift_reg <= 8'd0;
            byte_done <= 1'b0;
        end
        else begin
            case (state)
                IDLE: begin
                    bit_counter <= 4'd0;
                    byte_done <= 1'b0;
                end
                START: begin
                    bit_counter <= 4'd0;
                    byte_done <= 1'b0;
                end
                DATA: begin
                    shift_reg <= {in, shift_reg[7:1]};
                    bit_counter <= bit_counter + 1'b1;
                end
                STOP: begin
                    if (in == 1'b1) begin
                        byte_done <= 1'b1;
                    end
                end
            endcase
        end
    end

    // Output logic
    assign out_byte = shift_reg;
    assign done = byte_done;

endmodule",7.442073,35066
N/A,N/A,-1,77,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State definitions
    typedef enum reg [1:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    state_t current_state, next_state;

    reg [7:0] shift_reg;
    reg [2:0] bit_count;

    // FSM: State transition and output logic
    always @(posedge clk) begin
        if (reset) begin
            current_state <= IDLE;
            shift_reg <= 8'b0;
            bit_count <= 3'b0;
        end else begin
            current_state <= next_state;
            if (current_state == DATA) begin
                shift_reg <= {in, shift_reg[7:1]};
                bit_count <= bit_count + 1;
            end
            if (current_state == STOP && next_state == START) begin
                bit_count <= 3'b0;
            end
        end
    end

    always @(*) begin
        next_state = current_state;
        case (current_state)
            IDLE: begin
                done = 1'b0;
                if (in == 1'b0) // Detect start bit
                    next_state = START;
            end

            START: begin
                if (in == 1'b0) // Confirm start bit
                    next_state = DATA;
                else
                    next_state = IDLE; // false start, go back to idle
            end

            DATA: begin
                if (bit_count == 3'b111) // Collected 8 bits
                    next_state = STOP;
            end

            STOP: begin
                done = 1'b0;
                if (in == 1'b1) begin // Correct stop bit
                    next_state = IDLE;
                    done = 1'b1;
                end
            end
        endcase
    end

    // Output the result
    assign out_byte = shift_reg;
endmodule",7.056077,35475
N/A,N/A,-0.1,78,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

parameter IDLE = 2'b00, START = 2'b01, DATA = 2'b10, STOP = 2'b11;
    reg [1:0] state, next_state;
    reg [3:0] bit_counter;
    reg [7:0] shift_reg;
    reg done_reg;

    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_counter <= 4'd0;
            shift_reg <= 8'd0;
            done_reg <= 1'b0;
        end
        else begin
            state <= next_state;
            
            if (state == DATA) begin
                shift_reg <= {in, shift_reg[7:1]}; // Shift in the bit
                bit_counter <= bit_counter + 1;
            end

            if (state == STOP) begin
                done_reg <= 1'b1; // Set done flag when the stop bit is verified
            end
            else begin
                done_reg <= 1'b0;
            end
        end
    end

    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 1'b0) // Start bit detected
                    next_state = START;
                else
                    next_state = IDLE;
            end
            START: begin
                next_state = DATA;
            end
            DATA: begin
                if (bit_counter == 4'd8) // All bits received
                    next_state = STOP;
                else
                    next_state = DATA;
            end
            STOP: begin
                if (in == 1'b1) // Stop bit detected
                    next_state = IDLE;
                else
                    next_state = STOP; // Wait for stop bit
            end
            default: next_state = IDLE;
        endcase
    end

    assign out_byte = shift_reg;
    assign done = done_reg;

endmodule",5.868148,35889
N/A,N/A,-0.1,79,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Internal signals
    reg [3:0] state, next_state;
    reg [7:0] byte_data;
    reg [3:0] bit_counter;
    reg valid_byte;

    // State Encoding
    localparam IDLE = 4'b0000,
               START = 4'b0001,
               RECEIVE = 4'b0010,
               STOP = 4'b0011,
               DONE = 4'b0100;

    // FSM State transitions
    always @(posedge clk) begin
        if (reset)
            state <= IDLE;
        else
            state <= next_state;
    end

    // Next state logic and outputs
    always @(*) begin
        next_state = state;
        case (state)
            IDLE: begin
                if (in == 0)
                    next_state = START;
            end
            START: begin
                next_state = RECEIVE;
            end
            RECEIVE: begin
                if (bit_counter == 8)
                    next_state = STOP;
            end
            STOP: begin
                if (in == 1)
                    next_state = DONE;
                else
                    next_state = IDLE; // Return to IDLE if stop bit is incorrect
            end
            DONE: begin
                next_state = IDLE;
            end
        endcase
    end

    // Control signals and datapath
    always @(posedge clk) begin
        if (reset) begin
            byte_data <= 8'b0;
            bit_counter <= 0;
            valid_byte <= 0;
        end else begin
            case (state)
                START: begin
                    bit_counter <= 0;
                    valid_byte <= 0;
                end
                RECEIVE: begin
                    byte_data <= {in, byte_data[7:1]}; // Shift in LSB first
                    bit_counter <= bit_counter + 1;
                end
                STOP: begin
                    if (in == 1) begin
                        valid_byte <= 1;
                    end
                end
                DONE: begin
                    valid_byte <= 0;
                end
            endcase
        end
    end

    // Output assignments
    assign out_byte = valid_byte ? byte_data : 8'bxxxx_xxxx;
    assign done = (state == DONE);

endmodule",10.074071,36381
N/A,N/A,-0.1,80,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

parameter IDLE = 2'd0, START = 2'd1, DATA = 2'd2, STOP = 2'd3;
    reg [1:0] state, next_state;
    reg [3:0] bit_count;
    reg [7:0] shift_reg;
    reg done_reg;

    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 4'd0;
            shift_reg <= 8'd0;
        end else begin
            state <= next_state;
            if (state == DATA) begin
                shift_reg <= {in, shift_reg[7:1]};
                bit_count <= bit_count + 1;
            end else if (state == START) begin
                bit_count <= 4'd0;
            end
        end
    end

    always @(*) begin
        next_state = state;
        done_reg = 1'b0;

        case (state)
            IDLE: begin
                if (!in) next_state = START;  // Detect start bit
            end
            START: begin
                if (in == 1'b0) next_state = DATA;
                else next_state = IDLE;  // False start bit, stay in idle
            end
            DATA: begin
                if (bit_count == 4'd8) next_state = STOP;
            end
            STOP: begin
                if (in) begin
                    next_state = IDLE;
                    done_reg = 1'b1;  // Byte successfully received
                end else begin
                    next_state = DATA; // Error, search for new start
                end
            end
            default: next_state = IDLE;
        endcase
    end

    assign out_byte = shift_reg;
    assign done = done_reg;

endmodule",4.965064,36774
N/A,N/A,-0.1,81,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    localparam IDLE = 2'b00, START = 2'b01, DATA = 2'b10, STOP = 2'b11;

    reg [1:0] state, next_state;
    reg [2:0] bit_count;
    reg [7:0] data_reg;
    reg done_reg;

    // FSM state transition
    always @(posedge clk) begin
        if (reset)
            state <= IDLE;
        else
            state <= next_state;
    end

    // FSM next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 0)   // Start bit detected
                    next_state = START;
                else
                    next_state = IDLE;
            end
            START: begin
                next_state = DATA;
            end
            DATA: begin
                if (bit_count == 3'd7)
                    next_state = STOP;
                else
                    next_state = DATA;
            end
            STOP: begin
                if (in == 1)   // Stop bit detected
                    next_state = IDLE;
                else
                    next_state = STOP;  // Wait for stop bit
            end
        endcase
    end

    // Bit counter and data shift register
    always @(posedge clk) begin
        if (reset) begin
            bit_count <= 0;
            data_reg <= 8'b0;
            done_reg <= 0;
        end
        else begin
            case (state)
                START: begin
                    bit_count <= 0;
                    data_reg <= 8'b0;
                    done_reg <= 0;
                end
                DATA: begin
                    data_reg <= {in, data_reg[7:1]};  // Shift in the LSB first
                    bit_count <= bit_count + 1;
                end
                STOP: begin
                    if (in == 1) begin
                        done_reg <= 1;
                    end
                end
                IDLE: begin
                    done_reg <= 0;
                end
            endcase
        end
    end

    // Assign the outputs
    assign done = done_reg;
    assign out_byte = (done) ? data_reg : 8'bx;  // Use don't-care when not done

endmodule",7.230064,37274
N/A,N/A,-0.1,82,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

reg [3:0] state, next_state;
    reg [7:0] shift_reg;
    reg [3:0] bit_count;
    reg valid_byte;

    // State encoding
    localparam IDLE        = 4'd0;
    localparam START       = 4'd1;
    localparam DATA        = 4'd2;
    localparam STOP_CHECK  = 4'd3;
    localparam DONE        = 4'd4;

    // State transition logic
    always @(*) begin
        next_state = state; // Default to hold state
        case (state)
            IDLE: begin
                if (!in) begin
                    next_state = START; // Detect start bit
                end
            end
            START: begin
                if (in) begin
                    next_state = DATA;
                    bit_count = 4'd0;   // Reset bit counter
                end
            end
            DATA: begin
                if (bit_count == 4'd8) begin
                    next_state = STOP_CHECK;
                end
            end
            STOP_CHECK: begin
                if (in) begin
                    next_state = DONE; // Stop bit detected
                end else begin
                    next_state = IDLE;
                end
            end
            DONE: begin
                next_state = IDLE;
            end
        endcase
    end

    // State update and shift register logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            shift_reg <= 8'd0;
            bit_count <= 4'd0;
            valid_byte <= 0;
        end else begin
            state <= next_state;
            case (state)
                START: begin
                    if (in) begin
                        valid_byte <= 0;
                    end
                end
                DATA: begin
                    shift_reg <= {in, shift_reg[7:1]}; // Shift in the data bits
                    bit_count <= bit_count + 1;
                end
                STOP_CHECK: begin
                    if (in) begin
                        valid_byte <= 1; // Mark byte as valid when stop bit detected correctly
                    end
                end
                DONE: begin
                    bit_count <= 4'd0;
                end
            endcase
        end
    end

    assign done = (state == DONE) && valid_byte;
    assign out_byte = (done) ? shift_reg : 8'b0;

endmodule",7.17308,37801
N/A,N/A,-1,83,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum reg [1:0] {IDLE = 2'b00, START = 2'b01, DATA = 2'b10, STOP = 2'b11} state_t;
    state_t state, next_state;

    reg [7:0] shift_reg;
    reg [2:0] bit_counter;

    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            shift_reg <= 8'b0;
            bit_counter <= 3'b0;
        end else begin
            state <= next_state;
            if (state == DATA)
                shift_reg <= {in, shift_reg[7:1]};
        end
    end

    always @(*) begin
        next_state = state;
        done = 1'b0;
        
        case (state)
            IDLE: begin
                if (in == 0) next_state = START; // Detect start bit
            end
            START: begin
                next_state = DATA;
                bit_counter = 3'b0;
            end
            DATA: begin
                bit_counter = bit_counter + 1;
                if (bit_counter == 3'b111)
                    next_state = STOP;
            end
            STOP: begin
                if (in == 1) begin
                    next_state = IDLE;
                    done = 1'b1;
                end else begin
                    // Stay in STOP state until stop bit is found
                    next_state = STOP;
                end
            end
        endcase
    end

    assign out_byte = (done) ? shift_reg : 8'b0;

endmodule",5.517076,38152
N/A,N/A,-1,84,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State Definitions
    typedef enum logic [2:0] {
        IDLE = 3'b000,
        START = 3'b001,
        DATA = 3'b010,
        STOP = 3'b011,
        DONE = 3'b100
    } state_t;

    // Registers for state, data, and bit count
    state_t state, next_state;
    reg [7:0] shift_reg;
    reg [3:0] bit_count;

    // State transition logic
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            shift_reg <= 8'b0;
            bit_count <= 4'b0;
        end else begin
            state <= next_state;
            if (state == DATA) begin
                shift_reg <= {in, shift_reg[7:1]}; // Shift in new bit
                bit_count <= bit_count + 1;
            end
        end
    end

    // Next state logic
    always_comb begin
        next_state = state; // Default is to stay in the current state
        case (state)
            IDLE: begin
                if (in == 1'b0) // Start bit detected
                    next_state = START;
            end
            START: begin
                next_state = DATA;
            end
            DATA: begin
                if (bit_count == 4'd8) // 8 data bits received
                    next_state = STOP;
            end
            STOP: begin
                if (in == 1'b1) // Stop bit detected
                    next_state = DONE;
                else
                    next_state = IDLE; // Erroneous byte, wait for the next stop
            end
            DONE: begin
                next_state = IDLE; // After acknowledging
            end
        endcase
    end

    // Output logic
    assign out_byte = shift_reg;
    assign done = (state == DONE);

endmodule",6.795088,38573
N/A,N/A,-1,85,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State definitions
    typedef enum logic [2:0] {
        IDLE,
        START,
        RECEIVE,
        STOP,
        DONE
    } state_t;

    // State and next state registers
    state_t state, next_state;
    reg [7:0] data_shift;
    reg [2:0] bit_count;

    // FSM sequential logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            data_shift <= 8'b0;
            bit_count <= 3'b0;
        end else begin
            state <= next_state;
            if (state == RECEIVE) begin
                data_shift <= {in, data_shift[7:1]}; // Shift in the new bit
                bit_count <= bit_count + 1;
            end else if (state == IDLE || state == DONE) begin
                bit_count <= 3'b0;
            end
        end
    end

    // FSM next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 1'b0) // Start bit detected
                    next_state = START;
                else
                    next_state = IDLE;
            end
            
            START: begin
                next_state = RECEIVE;
            end
            
            RECEIVE: begin
                if (bit_count == 3'b111) // 8 bits received
                    next_state = STOP;
                else
                    next_state = RECEIVE;
            end
            
            STOP: begin
                if (in == 1'b1) // Stop bit detected
                    next_state = DONE;
                else
                    next_state = IDLE; // Wait for next start bit
            end
            
            DONE: begin
                next_state = IDLE;
            end
            
            default: begin
                next_state = IDLE;
            end
        endcase
    end

    // Output logic
    assign done = (state == DONE);
    assign out_byte = data_shift;

endmodule",5.743077,39000
N/A,N/A,-0.1,86,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

reg [3:0] state, next_state;
    reg [7:0] shift_reg;
    reg [3:0] bit_counter;

    localparam IDLE = 4'd0, START = 4'd1, DATA = 4'd2, STOP = 4'd3, DONE = 4'd4, WAIT_STOP = 4'd5;

    // State transition logic
    always @(*) begin
        case (state)
            IDLE: next_state = in ? IDLE : START;
            START: next_state = DATA;
            DATA: next_state = (bit_counter == 4'd8) ? STOP : DATA;
            STOP: next_state = in ? DONE : WAIT_STOP;
            DONE: next_state = in ? IDLE : START;
            WAIT_STOP: next_state = in ? IDLE : WAIT_STOP;
            default: next_state = IDLE;
        endcase
    end

    // State flip-flop
    always @(posedge clk) begin
        if (reset)
            state <= IDLE;
        else
            state <= next_state;
    end

    // Shift register to capture data bits
    always @(posedge clk) begin
        if (reset)
            shift_reg <= 8'h00;
        else if (state == DATA)
            shift_reg <= {in, shift_reg[7:1]};  // Shift in LSB first
    end

    // Bit counter to keep track of received bits
    always @(posedge clk) begin
        if (reset || state == IDLE)
            bit_counter <= 4'd0;
        else if (state == DATA)
            bit_counter <= bit_counter + 1;
    end

    // Output logic
    assign out_byte = shift_reg;
    assign done = (state == DONE);

endmodule",5.269062,39386
N/A,N/A,-1,87,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP,
        DONE
    } state_t;
    
    state_t current_state, next_state;
    logic [2:0] bit_counter;
    logic [7:0] shift_register;

    // State transition logic
    always_ff @(posedge clk) begin
        if (reset) begin
            current_state <= IDLE;
            bit_counter <= 3'd0;
            shift_register <= 8'd0;
        end else begin
            current_state <= next_state;
            if (current_state == DATA) begin
                shift_register <= {in, shift_register[7:1]}; // Shift in new bit
                bit_counter <= bit_counter + 1;
            end
        end
    end

    // Next state and output logic
    always_comb begin
        next_state = current_state; // Default to hold state

        case (current_state)
            IDLE: begin
                if (in == 1'b0) // Start bit detected
                    next_state = START;
            end
            START: begin
                next_state = DATA;
            end
            DATA: begin
                if (bit_counter == 3'd7) // All 8 bits received
                    next_state = STOP;
            end
            STOP: begin
                if (in == 1'b1) // Valid stop bit detected
                    next_state = DONE;
                else
                    next_state = IDLE; // Invalid stop bit, wait for new start
            end
            DONE: begin
                next_state = IDLE;
            end
        endcase
    end

    // Outputs
    assign done = (current_state == DONE);
    assign out_byte = shift_register;

endmodule",5.314082,39770
N/A,N/A,-0.1,88,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

reg [3:0] state, next_state;
    reg [7:0] shift_reg;
    reg [3:0] bit_counter;

    localparam IDLE = 4'd0,
               START = 4'd1,
               DATA = 4'd2,
               STOP = 4'd3,
               DONE = 4'd4;

    // State Transition Logic
    always @(posedge clk) begin
        if (reset)
            state <= IDLE;
        else
            state <= next_state;
    end

    // Next State Logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 0) // Start bit detected
                    next_state = START;
                else
                    next_state = IDLE;
            end
            START: begin
                next_state = DATA;
            end
            DATA: begin
                if (bit_counter < 8)
                    next_state = DATA;
                else
                    next_state = STOP;
            end
            STOP: begin
                if (in == 1)
                    next_state = DONE;
                else
                    next_state = IDLE; // Wait for stop bit
            end
            DONE: begin
                next_state = IDLE;
            end
            default: next_state = IDLE;
        endcase
    end

    // Datapath Logic
    always @(posedge clk) begin
        if (reset) begin
            shift_reg <= 8'b0;
            bit_counter <= 4'b0;
        end else begin
            case (state)
                IDLE: begin
                    shift_reg <= 8'b0;
                    bit_counter <= 4'b0;
                end
                START: begin
                    bit_counter <= 4'b0;
                end
                DATA: begin
                    shift_reg <= {in, shift_reg[7:1]}; // Shift in the serial data
                    bit_counter <= bit_counter + 1;
                end
                STOP: begin
                    // Do nothing
                end
                DONE: begin
                    // Do nothing
                end
            endcase
        end
    end

    // Output Logic
    assign out_byte = shift_reg;
    assign done = (state == DONE);

endmodule",11.866069,40252
N/A,N/A,-1,89,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE     = 3'b000,
        START    = 3'b001,
        RECEIVE  = 3'b010,
        STOP     = 3'b011,
        ACK      = 3'b100
    } state_t;
    
    // State registers
    state_t current_state, next_state;
    reg [7:0] buffer;       // Buffer for received bytes
    reg [2:0] bit_count;    // Counts the number of received bits

    // State transition logic
    always @(posedge clk) begin
        if (reset) begin
            current_state <= IDLE;
            bit_count <= 3'd0;
            buffer <= 8'd0;
        end
        else begin
            current_state <= next_state;
            if (current_state == RECEIVE) begin
                bit_count <= bit_count + 1;
                buffer <= {in, buffer[7:1]}; // Shift serial data into buffer
            end
        end
    end

    // Next state logic
    always @(*) begin
        case (current_state)
            IDLE: begin
                if (in == 0) // Start bit detected
                    next_state = START;
                else
                    next_state = IDLE;
            end
            START: begin
                if (in == 0) // Confirm still in start bit
                    next_state = RECEIVE;
                else
                    next_state = IDLE;
            end
            RECEIVE: begin
                if (bit_count == 3'd7) // Received 8 data bits
                    next_state = STOP;
                else
                    next_state = RECEIVE;
            end
            STOP: begin
                if (in == 1) // Stop bit detected
                    next_state = ACK;
                else
                    next_state = IDLE;
            end
            ACK: begin
                next_state = IDLE; // Acknowledge and return to IDLE
            end
            default: next_state = IDLE;
        endcase
    end

    // Output logic
    assign done = (current_state == ACK);
    assign out_byte = buffer;

endmodule",5.688091,40717
N/A,N/A,-1,90,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

typedef enum logic [1:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    state_t state, next_state;
    logic [7:0] data_shift;
    logic [2:0] bit_count;
    logic [7:0] byte_assembled;

    // State Transition Logic
    always_ff @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 3'b000;
        end else begin
            state <= next_state;
            if (state == DATA) begin
                data_shift <= {in, data_shift[7:1]};
                bit_count <= bit_count + 1;
            end
            if (state == STOP && next_state == IDLE) begin
                byte_assembled <= data_shift;
            end
        end
    end

    // Next State Logic
    always_comb begin
        done = 1'b0;
        next_state = state;
        case (state)
            IDLE: begin
                if (in == 1'b0) // Detects start bit
                    next_state = START;
            end
            START: begin
                next_state = DATA;
                bit_count = 3'b000;
            end
            DATA: begin
                if (bit_count == 3'b111)
                    next_state = STOP;
            end
            STOP: begin
                if (in == 1'b1) begin
                    done = 1'b1;
                    next_state = IDLE;
                end
            end
        endcase
    end

    // Output Logic
    assign out_byte = done ? byte_assembled : 8'h00;

endmodule",5.093088,41086
N/A,N/A,-0.1,91,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

reg [3:0] state, next_state;
    reg [7:0] shift_reg;
    reg [3:0] bit_count;
    reg done_reg;

    localparam IDLE = 0,
               START = 1,
               RECEIVE = 2,
               STOP = 3;

    // State transition
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
        end
        else begin
            state <= next_state;
        end
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 1'b0) // detect start bit (low)
                    next_state = START;
                else
                    next_state = IDLE;
            end

            START: begin
                next_state = RECEIVE;
            end

            RECEIVE: begin
                if (bit_count == 8)
                    next_state = STOP;
                else
                    next_state = RECEIVE;
            end
            
            STOP: begin
                if (in == 1'b1) // stop bit expected (high)
                    next_state = IDLE;
                else
                    next_state = STOP; // stay in stop until the next stop bit is detected
            end

            default: next_state = IDLE;
        endcase
    end

    // Data reception logic
    always @(posedge clk) begin
        if (reset) begin
            bit_count <= 0;
            shift_reg <= 8'd0;
            done_reg <= 1'b0;
        end
        else begin
            case (state)
                IDLE: begin
                    bit_count <= 0;
                    done_reg <= 1'b0;
                end
                
                START: begin
                    // Initializations necessary here if any.
                end

                RECEIVE: begin
                    shift_reg <= {in, shift_reg[7:1]}; // shift in LSB first
                    bit_count <= bit_count + 1;
                end

                STOP: begin
                    if (in == 1'b1) // check for valid stop bit
                        done_reg <= 1'b1;
                    else
                        done_reg <= 1'b0;
                end
            endcase
        end
    end

    // Output logic
    assign done = done_reg;
    assign out_byte = (done_reg) ? shift_reg : 8'dx;

endmodule",7.964087,41602
N/A,N/A,-1,92,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Define states for the FSM
    typedef enum reg [2:0] {
        IDLE,
        START,
        DATA,
        STOP,
        DONE
    } state_t;
    
    state_t state, next_state;
    reg [7:0] shift_reg;
    reg [2:0] bit_counter;

    // FSM logic
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            shift_reg <= 8'b0;
            bit_counter <= 3'd0;
        end else begin
            state <= next_state;
            if (state == DATA) begin
                shift_reg <= {in, shift_reg[7:1]}; // Shift in LSB first
                bit_counter <= bit_counter + 1;
            end else if (state != DATA) begin
                bit_counter <= 3'd0;
            end
        end
    end

    always @(*) begin
        next_state = state;
        case(state)
            IDLE: begin
                if (in == 0) // Start bit detected
                    next_state = START;
            end
            START: begin
                next_state = DATA;
            end
            DATA: begin
                if (bit_counter == 3'd7) // All 8 data bits received
                    next_state = STOP;
            end
            STOP: begin
                if (in == 1) // Stop bit detected
                    next_state = DONE;
                else
                    next_state = IDLE; // Wrong stop bit, reset to start
            end
            DONE: begin
                next_state = IDLE; // Go back to idle state
            end
        endcase
    end
    
    // Output logic
    assign done = (state == DONE);
    assign out_byte = (done ? shift_reg : 8'dx); // Only valid when done

endmodule",5.329102,42004
N/A,N/A,-1,93,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE,
        START,
        RECEIVE,
        STOP,
        DONE
    } state_t;

    state_t current_state, next_state;
    reg [7:0] shift_reg;
    reg [2:0] bit_count;
    reg done_reg;
    
    // Output assignments
    assign out_byte = (done_reg) ? shift_reg : 8'd0;
    assign done = done_reg;
    
    // State transition logic (sequential)
    always_ff @(posedge clk or posedge reset) begin
        if (reset) begin
            current_state <= IDLE;
            bit_count <= 3'd0;
            shift_reg <= 8'd0;
        end else begin
            current_state <= next_state;            
            if (current_state == RECEIVE) begin
                bit_count <= bit_count + 1;
                shift_reg <= {in, shift_reg[7:1]};
            end else if (current_state != RECEIVE) begin
                bit_count <= 3'd0;
                shift_reg <= 8'd0;
            end
        end
    end
    
    // Next state logic (combinational)
    always_comb begin
        next_state = current_state;
        done_reg = 1'b0;
        case (current_state)
            IDLE: begin
                if (in == 0) // Detecting start bit
                    next_state = START;
            end
            START: begin
                next_state = RECEIVE;
            end
            RECEIVE: begin
                if (bit_count == 3'd7) // All 8 data bits received
                    next_state = STOP;
            end
            STOP: begin
                if (in == 1) begin // Expecting stop bit
                    next_state = DONE;
                    done_reg = 1'b1;
                end else begin
                    next_state = IDLE; // Error recovery, go back to IDLE
                end
            end
            DONE: begin
                next_state = IDLE; // Prepare for next byte
            end
            default: begin
                next_state = IDLE;
            end
        endcase
    end

endmodule",6.369083,42472
N/A,N/A,-1,94,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Define states
    typedef enum reg [2:0] {
        IDLE,
        START,
        DATA,
        STOP,
        DONE
    } state_t;

    state_t state, next_state;
    reg [7:0] shift_register;
    reg [3:0] bit_count;
    reg done_reg;

    // State transition logic
    always @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= IDLE;
        end else begin
            state <= next_state;
        end
    end

    // Next state logic and output logic
    always @(*) begin
        next_state = state; // default to hold state
        done_reg = 1'b0;    // default to not done
        case (state)
            IDLE: begin
                if (in == 1'b0) // detect start bit
                    next_state = START;
            end
            START: begin
                if (in == 1'b1) // false start bit detected, return to IDLE
                    next_state = IDLE;
                else 
                    next_state = DATA;
            end
            DATA: begin
                if (bit_count == 4'd8)
                    next_state = STOP;
            end
            STOP: begin
                if (in == 1'b1) // stop bit detected
                    next_state = DONE;
                else
                    next_state = IDLE; // if no stop bit, reset to IDLE
            end
            DONE: begin
                done_reg = 1'b1; // signal that byte is done
                next_state = IDLE; // After byte is done, return to IDLE
            end
        endcase
    end

    // Datapath to shift in serial data to parallel form
    always @(posedge clk) begin
        if (state == DATA) begin
            shift_register <= {in, shift_register[7:1]};
            bit_count <= bit_count + 1;
        end else if (state == IDLE || state == DONE) begin
            bit_count <= 0;
            shift_register <= 8'b0;
        end
    end

    // Assign outputs
    assign out_byte = shift_register;
    assign done = done_reg;

endmodule",5.297072,42956
N/A,N/A,-1,95,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// States in FSM
    typedef enum logic [2:0] {
        IDLE,       // Waiting for start bit
        RECEIVE,    // Receiving data bits
        CHECK_STOP, // Verifying stop bit
        DONE        // Byte successfully received
    } state_t;

    state_t state, next_state;
    reg [7:0] shift_reg;
    reg [3:0] bit_count;

    // State Transition and Output Logic
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            shift_reg <= 8'b0;
            bit_count <= 4'b0;
        end else begin
            state <= next_state;
            if (state == RECEIVE) begin
                shift_reg <= {in, shift_reg[7:1]};
                bit_count <= bit_count + 1;
            end
        end
    end

    // Next State Logic
    always_comb begin
        done = 0;
        next_state = state;
        case (state)
            IDLE: begin
                if (in == 1'b0) begin  // Start bit detected
                    next_state = RECEIVE;
                    bit_count = 0;
                end
            end
            RECEIVE: begin
                if (bit_count == 8) begin
                    next_state = CHECK_STOP;
                end
            end
            CHECK_STOP: begin
                if (in == 1'b1) begin  // Stop bit is correct
                    next_state = DONE;
                    done = 1;
                end else begin  // Wait for next stop bit
                    next_state = IDLE;
                end
            end
            DONE: begin
                done = 1;  // Keep done high for 1 cycle
                next_state = IDLE;
            end
            default: next_state = IDLE;
        endcase
    end

    // Output Logic
    assign out_byte = (done) ? shift_reg : 8'bx;

endmodule",7.169081,43380
N/A,N/A,-1,96,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// State encoding
    typedef enum logic [2:0] {
        IDLE, 
        START, 
        DATA, 
        STOP, 
        DONE
    } state_t;
    
    state_t state, next_state;
    logic [2:0] bit_count;
    logic [7:0] shift_reg;
    
    // State transition logic
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 3'd0;
            shift_reg <= 8'd0;
        end else begin
            state <= next_state;
        end
    end
    
    // Next state logic and output logic
    always_comb begin
        next_state = state; // Default state stays the same
        done = 1'b0;        // Default done is low
        case (state)
            IDLE: begin
                if (!in) 
                    next_state = START; // Start bit detected
            end
            START: begin
                next_state = DATA; // Move to data state
                bit_count = 3'd0;  // Reset bit count
            end
            DATA: begin
                if (bit_count == 3'd7) begin
                    next_state = STOP; // Move to stop state after 8 bits
                end
                shift_reg = {in, shift_reg[7:1]}; // Shift in the new bit
                bit_count = bit_count + 1;
            end
            STOP: begin
                if (in) begin
                    next_state = DONE; // Valid stop bit detected
                end else begin
                    next_state = IDLE; // Invalid stop bit, wait for start bit
                end
            end
            DONE: begin
                done = 1'b1;        // Set done flag
                out_byte = shift_reg; // Output the result
                next_state = IDLE; // Go to idle state for next byte
            end
        endcase
    end
endmodule",5.914088,43809
N/A,N/A,-0.1,97,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

parameter IDLE = 0,
              START = 1,
              RECEIVE = 2,
              STOP = 3,
              DONE = 4;

    reg [2:0] state, next_state;
    reg [7:0] data_shift;
    reg [2:0] bit_count;

    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            data_shift <= 8'b0;
            bit_count <= 0;
        end else begin
            state <= next_state;
            case (state)
                RECEIVE: data_shift <= {in, data_shift[7:1]};
                default: data_shift <= data_shift;
            endcase
        end
    end

    always @(*) begin
        case (state)
            IDLE: next_state = in ? IDLE : START;
            START: next_state = RECEIVE;
            RECEIVE: next_state = (bit_count == 7) ? STOP : RECEIVE;
            STOP: next_state = in ? DONE : IDLE;
            DONE: next_state = in ? IDLE : START;
            default: next_state = IDLE;
        endcase
    end

    always @(posedge clk) begin
        if (state == RECEIVE) begin
            bit_count <= bit_count + 1;
        end else begin
            bit_count <= 0;
        end
    end

    assign out_byte = (state == DONE) ? data_shift : 8'bx;
    assign done = (state == DONE);

endmodule",4.182121,44134
N/A,N/A,-1,98,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Declare state encoding
    typedef enum reg [2:0] {
        IDLE,
        START,
        RECEIVE,
        STOP
    } state_t;

    state_t state, next_state;
    reg [7:0] shift_reg;
    reg [2:0] bit_counter;

    // State transition
    always @(posedge clk) begin
        if (reset)
            state <= IDLE;
        else
            state <= next_state;
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 0)
                    next_state = START;
                else
                    next_state = IDLE;
            end

            START: begin
                next_state = RECEIVE;
            end

            RECEIVE: begin
                if (bit_counter == 3'd7)
                    next_state = STOP;
                else
                    next_state = RECEIVE;
            end

            STOP: begin
                if (in == 1)
                    next_state = IDLE;
                else
                    next_state = RECEIVE;
            end

            default: next_state = IDLE;
        endcase
    end

    // Output and bit shifting logic
    always @(posedge clk) begin
        if (reset) begin
            shift_reg <= 8'b0;
            bit_counter <= 3'b0;
            done <= 1'b0;
        end
        else begin
            case (state)
                IDLE: begin
                    done <= 1'b0;
                end

                START: begin
                    bit_counter <= 3'd0;
                end

                RECEIVE: begin
                    shift_reg <= {in, shift_reg[7:1]}; // Shift in the incoming bit
                    bit_counter <= bit_counter + 1'b1;
                end

                STOP: begin
                    if (in == 1) begin
                        out_byte <= shift_reg;
                        done <= 1'b1;
                    end
                    else begin
                        done <= 1'b0;
                    end
                end
            endcase
        end
    end

endmodule",5.967133,44583
N/A,N/A,-1,99,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// FSM states
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;
    
    state_t state, next_state;
    logic [3:0] bit_count; // Counter for bits
    logic [7:0] shift_reg; // Shift register for data bits
    logic prev_in;

    // FSM logic
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
            prev_in <= 1'b1;
        end else begin
            state <= next_state;
            if (state == DATA) 
                bit_count <= bit_count + 1;
            
            prev_in <= in;
        end
    end

    // Next state logic
    always_comb begin
        next_state = state;
        case (state)
            IDLE: 
                if (!in)
                    next_state = START;
            START: 
                if (prev_in && !in) // Detect start bit
                    next_state = DATA;
            DATA: 
                if (bit_count == 8)
                    next_state = STOP;
            STOP: 
                if (in)
                    next_state = IDLE;
        endcase
    end

    // Output and shift register logic
    always_ff @(posedge clk) begin
        if (reset) begin
            shift_reg <= 8'd0;
        end else if (state == DATA) begin
            shift_reg <= {in, shift_reg[7:1]}; // Shift in the incoming bit
        end
    end

    assign out_byte = (state == STOP && in) ? shift_reg : 8'bx;
    assign done = (state == STOP && in);

endmodule",5.578083,44962
