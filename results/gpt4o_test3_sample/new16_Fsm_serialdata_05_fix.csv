Area,Delay,Score,Current Run,Episode,Verilog,Time,Tokens
N/A,N/A,-1,0,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// FSM states
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    state_t state, next_state;
    logic [2:0] bit_counter; // To count the received data bits
    logic [7:0] byte_shift_reg; // Shift register to hold the data byte

    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_counter <= 3'd0;
            byte_shift_reg <= 8'b0;
        end else begin
            state <= next_state;
        end
    end

    always_comb begin
        next_state = state;
        case (state)
            IDLE: begin
                if (!in)  // Start bit detected
                    next_state = START;
            end
            START: begin
                next_state = DATA;
                bit_counter = 3'd0;
            end
            DATA: begin
                if (bit_counter < 3'd7)
                    next_state = DATA;
                else
                    next_state = STOP;
            end
            STOP: begin
                if (in) // Stop bit is correct
                    next_state = IDLE;
                else
                    next_state = STOP; // Wait for the valid stop bit
            end
        endcase
    end

    always_ff @(posedge clk) begin
        if (state == DATA) begin
            byte_shift_reg <= {in, byte_shift_reg[7:1]}; // Shift in the new bit
            bit_counter <= bit_counter + 1'b1;
        end
        if ((state == STOP) && (in)) begin
            out_byte <= byte_shift_reg; // Parallel readout of the data byte
        end
    end

    // Output logic
    assign done = (state == STOP) && in; // Done when stop bit is detected
    assign out_byte = byte_shift_reg; // Output register (valid when done is high)

endmodule",4.669447,430
N/A,N/A,-1,1,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// FSM states
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;
    
    state_t state, next_state;
    reg [7:0] bit_shift_reg;
    reg [3:0] bit_count; // Count bits from 0 to 7

    // Synchronous logic for state transitions and registers
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
            bit_shift_reg <= 8'd0;
        end else begin
            state <= next_state;

            if (state == DATA) begin
                bit_shift_reg <= {in, bit_shift_reg[7:1]}; // Shift in the incoming bits
                bit_count <= bit_count + 1;
            end

            if (state != DATA) begin
                bit_count <= 0; // Reset the bit count for any state other than DATA
            end
        end
    end

    // Combinational logic for next state
    always_comb begin
        next_state = state; // Default: stay in the current state
        case (state)
            IDLE: begin
                if (in == 0) next_state = START; // Detect start bit (0)
            end

            START: begin
                next_state = DATA; // Transition to DATA state
            end

            DATA: begin
                if (bit_count == 7) next_state = STOP; // Switch to STOP after 8 bits
            end

            STOP: begin
                if (in == 1) next_state = IDLE; // Valid stop bit (1), transition to IDLE
                else next_state = STOP; // Wait for correct stop bit
            end
        endcase
    end

    // Output logic
    assign done = (state == STOP) && (next_state == IDLE) && (in == 1);
    assign out_byte = bit_shift_reg;

endmodule",5.15649,862
N/A,N/A,-1,2,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// FSM states
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    state_t state, next_state;
    logic [2:0] bit_counter; // To track number of received data bits
    logic [7:0] shift_reg;   // To shift in data bits serially

    // State transition logic
    always_ff @(posedge clk or posedge reset) begin
        if (reset)
            state <= IDLE;
        else
            state <= next_state;
    end

    // Next state logic and bit counter/shift register updates
    always_comb begin
        next_state = state;
        case (state)
            IDLE: begin
                if (in == 0) // Detect start bit
                    next_state = START;
            end
            START: begin
                next_state = DATA;
                bit_counter = 0; // Initialize bit counter for data bits
            end
            DATA: begin
                if (bit_counter == 8) // All data bits received
                    next_state = STOP;
            end
            STOP: begin
                if (in == 1) // Correct stop bit
                    next_state = IDLE;
                else
                    next_state = IDLE; // To ensure transition to IDLE even if stop bit is wrong
            end
        endcase
    end

    // Shift register and data count update logic
    always_ff @(posedge clk) begin
        if (state == DATA) begin
            shift_reg <= {in, shift_reg[7:1]}; // Shift in the incoming bit
            bit_counter <= bit_counter + 1;
        end
        else if (state == START || state == STOP) begin
            bit_counter <= 0; // Reset counter when not in DATA state
        end
    end

    // Output logic: done signal and parallel output of received byte
    assign done = (state == STOP && in == 1);
    assign out_byte = done ? shift_reg : 8'bx; // Output valid data on successful byte receipt

endmodule",6.982339,1316
N/A,N/A,-1,3,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// FSM states
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    state_t state, next_state;
    logic [2:0] bit_counter; // Count the number of data bits received (0 to 7)
    logic [7:0] shift_reg; // Datapath to store the bits of the current byte

    // State transition logic (combinational)
    always_comb begin
        next_state = state; // Default state is to remain in current state
        done = 0;

        case (state)
            IDLE: begin
                if (in == 0) begin
                    next_state = START; // Start bit detected
                end
            end

            START: begin
                next_state = DATA; // Move to data state
            end

            DATA: begin
                if (bit_counter == 3'd7) begin
                    next_state = STOP; // All data bits received
                end
            end

            STOP: begin
                if (in == 1) begin
                    done = 1; // Stop bit correct, byte received
                    next_state = IDLE; // Return to idle state for next byte
                end else begin
                    next_state = IDLE; // Stop bit incorrect, reset FSM
                end
            end
        endcase
    end

    // Datapath to latch input bits
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_counter <= 3'd0;
            shift_reg <= 8'b0;
        end else begin
            state <= next_state;

            if (state == DATA) begin
                shift_reg <= {in, shift_reg[7:1]}; // Shift in bits
                bit_counter <= bit_counter + 1'b1;
            end else if (state == STOP) begin
                bit_counter <= 3'd0; // Reset bit counter after stop bit
            end
        end
    end

    assign out_byte = shift_reg;

endmodule",5.915185,1767
N/A,N/A,-1,4,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// FSM states
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;
    
    state_t state, next_state;
    logic [2:0] bit_counter;
    logic [7:0] shift_reg;
    
    // FSM state transition
    always_ff @(posedge clk) begin
        if (reset)
            state <= IDLE;
        else
            state <= next_state;
    end
    
    // Next state logic
    always_comb begin
        case (state)
            IDLE: begin
                if (in == 0) // Detect start bit
                    next_state = START;
                else
                    next_state = IDLE;
            end
            START: begin
                next_state = DATA;
            end
            DATA: begin
                if (bit_counter == 3'd7) // All 8 data bits received
                    next_state = STOP;
                else
                    next_state = DATA;
            end
            STOP: begin
                if (in == 1) // Detect stop bit
                    next_state = IDLE;
                else
                    next_state = STOP; // Wait for stop bit if incorrect
            end
            default: next_state = IDLE;
        endcase
    end
    
    // Datapath
    always_ff @(posedge clk) begin
        if (reset) begin
            shift_reg <= 8'b0;
            bit_counter <= 3'b0;
        end
        else begin
            case (state)
                DATA: begin
                    shift_reg <= {in, shift_reg[7:1]}; // Shift in data bits
                    bit_counter <= bit_counter + 1;
                end
                STOP: begin
                    if (in == 1) begin
                        bit_counter <= 3'b0; // Reset for next byte
                    end
                end
                default: begin
                    // No operation
                end
            endcase
        end
    end
    
    // Output logic
    assign out_byte = shift_reg;
    assign done = (state == STOP) && (in == 1); // Only valid when stop bit is correct

endmodule",4.531296,2234
N/A,N/A,-1,5,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// FSM states
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;
    
    state_t state, next_state;
    reg [7:0] bit_shift_reg;
    reg [2:0] bit_count;

    // FSM state transition
    always @(posedge clk) begin
        if (reset)
            state <= IDLE;
        else
            state <= next_state;
    end

    // Output logic
    always @(posedge clk) begin
        if (reset) begin
            bit_shift_reg <= 8'b0;
            bit_count <= 3'b0;
        end
        else begin
            case (state)
                IDLE: begin
                    bit_shift_reg <= 8'b0;
                    bit_count <= 3'b0;
                end
                START: begin
                    if (in == 1'b0) begin // Detected a start bit
                        next_state <= DATA;
                    end
                end
                DATA: begin
                    bit_shift_reg <= {in, bit_shift_reg[7:1]};
                    bit_count <= bit_count + 1'b1;
                    if (bit_count == 3'b111) begin
                        next_state <= STOP;
                    end
                end
                STOP: begin
                    if (in == 1'b1) begin // Detected a stop bit
                        done <= 1'b1;
                    end
                    else begin
                        done <= 1'b0;
                        next_state <= IDLE;
                    end
                end
            endcase
        end
    end

    // Next state logic
    always @(*) begin
        next_state = state;
        case (state)
            IDLE: begin
                done = 1'b0;
                if (in == 1'b0) begin // Detected a start bit
                    next_state = START;
                end
            end
            START: begin
                done = 1'b0;
                if (in == 1'b0) begin // Confirm start bit
                    next_state = DATA;
                end
                else begin
                    next_state = IDLE;
                end
            end
            DATA: begin
                done = 1'b0;
                if (bit_count == 3'b111) begin
                    next_state = STOP;
                end
            end
            STOP: begin
                if (in == 1'b1) begin
                    next_state = IDLE;
                end
                done = 1'b1; // Valid byte received
            end
        endcase
    end

    assign out_byte = (done) ? bit_shift_reg : 8'b0;

endmodule",6.091188,2810
N/A,N/A,-1,6,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// FSM states
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    state_t state, next_state;
    logic [2:0] bit_counter; // To track number of received data bits
    logic [7:0] shift_reg;   // To shift in received data bits

    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_counter <= 3'd0;
            shift_reg <= 8'h00;
        end else begin
            state <= next_state;
            if (state == DATA) begin
                bit_counter <= bit_counter + 3'd1;
                shift_reg <= {in, shift_reg[7:1]}; // Shift in serial data bit
            end else if (state == STOP) begin
                bit_counter <= 3'd0;
            end
        end
    end

    always_comb begin
        next_state = state;
        done = 1'b0;

        case (state)
            IDLE: begin
                if (in == 1'b0) // Start bit detected
                    next_state = START;
            end

            START: begin
                next_state = DATA;
            end

            DATA: begin
                if (bit_counter == 3'd7) // 8 data bits received
                    next_state = STOP;
            end

            STOP: begin
                if (in == 1'b1) begin // Stop bit correct
                    done = 1'b1; // Set done signal
                    next_state = IDLE; // Ready for next byte
                end else begin
                    next_state = IDLE; // Look for start bit again
                end
            end

            default: next_state = IDLE;
        endcase
    end

    assign out_byte = (done) ? shift_reg : 8'hXX; // Valid data if done==1

endmodule",4.807312,3232
N/A,N/A,-1,7,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// FSM states
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    state_t state, next_state;
    logic [2:0] bit_counter; // To track number of received data bits
    logic [7:0] shift_reg;   // To shift in data bits serially

    // State transition logic
    always_ff @(posedge clk or posedge reset) begin
        if (reset)
            state <= IDLE;
        else
            state <= next_state;
    end

    // Next state logic and bit counter/shift register updates
    always_comb begin
        next_state = state;
        case (state)
            IDLE: begin
                if (in == 0) // Detect start bit
                    next_state = START;
            end
            START: begin
                next_state = DATA;
                bit_counter = 0; // Initialize bit counter for data bits
            end
            DATA: begin
                if (bit_counter == 8) // All data bits received
                    next_state = STOP;
            end
            STOP: begin
                if (in == 1) // Correct stop bit
                    next_state = IDLE;
                else
                    next_state = IDLE; // To ensure transition to IDLE even if stop bit is wrong
            end
        endcase
    end

    // Shift register and data count update logic
    always_ff @(posedge clk) begin
        if (state == DATA) begin
            shift_reg <= {in, shift_reg[7:1]}; // Shift in the incoming bit
            bit_counter <= bit_counter + 1;
        end
        else if (state == START || state == STOP) begin
            bit_counter <= 0; // Reset counter when not in DATA state
        end
    end

    // Output logic: done signal and parallel output of received byte
    assign done = (state == STOP && in == 1);
    assign out_byte = done ? shift_reg : 8'bx; // Output valid data on successful byte receipt

endmodule",4.639323,3686
N/A,N/A,-1,8,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// FSM states
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    state_t state, next_state;
    logic [2:0] bit_counter; // To count the received data bits
    logic [7:0] byte_shift_reg; // Shift register to store incoming data bits

    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_counter <= 3'd0;
            byte_shift_reg <= 8'b0;
            done <= 1'b0;
            out_byte <= 8'b0;
        end else begin
            state <= next_state;
            if (state == DATA && in) begin
                // Shift in the data bits
                byte_shift_reg <= {in, byte_shift_reg[7:1]};
                bit_counter <= bit_counter + 3'd1;
            end
        end
    end

    always_comb begin
        next_state = state; // Maintain the current state by default
        done = 1'b0; // Default done signal is 0

        case (state)
            IDLE: begin
                if (!in) begin // Start bit detected
                    next_state = START;
                end
            end

            START: begin
                next_state = DATA;
                bit_counter = 3'd0;
            end

            DATA: begin
                if (bit_counter == 3'd7) begin
                    next_state = STOP;
                end
            end

            STOP: begin
                if (in) begin // Stop bit detected
                    out_byte = byte_shift_reg;
                    done = 1'b1;
                    next_state = IDLE;
                end
            end
        endcase
    end
endmodule",3.761334,4071
N/A,N/A,-1,9,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// FSM states
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    state_t state, next_state;
    logic [2:0] bit_counter; // To count the received data bits
    logic [7:0] shift_reg;   // Shift register to hold the data byte

    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_counter <= 3'd0;
            shift_reg <= 8'h00;
        end else begin
            state <= next_state;
            if (state == DATA) begin
                shift_reg <= {in, shift_reg[7:1]};
                bit_counter <= bit_counter + 1;
            end
        end
    end

    always_comb begin
        next_state = state;
        done = 1'b0;

        case (state)
            IDLE: begin
                if (in == 1'b0) // Start bit detected
                    next_state = START;
            end

            START: begin
                next_state = DATA;
            end

            DATA: begin
                if (bit_counter == 3'd7)
                    next_state = STOP;
            end

            STOP: begin
                if (in == 1'b1) begin  // Stop bit detected
                    done = 1'b1;
                    next_state = IDLE;
                end else begin
                    next_state = STOP; // Stay in STOP state if stop bit not detected
                end
            end

            default: begin
                next_state = IDLE;
            end
        endcase
    end

    assign out_byte = shift_reg;

endmodule",3.786271,4438
N/A,N/A,-1,10,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// FSM states
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;
    
    state_t state, next_state;
    logic [2:0] bit_counter;

    // Register to hold the data bits
    logic [7:0] data_reg;
    
    // Next state logic
    always_ff @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= IDLE;
            bit_counter <= 3'b0;
            data_reg <= 8'b0;
        end else begin
            state <= next_state;
            if (next_state == DATA && state == START) begin
                bit_counter <= 3'b0;
            end else if (state == DATA) begin
                bit_counter <= bit_counter + 1;
                data_reg <= {in, data_reg[7:1]};
            end
        end
    end
    
    // State transition logic
    always_comb begin
        next_state = state;
        done = 1'b0;
        
        case (state)
            IDLE: begin
                if (!in) begin  // Detect start bit (which is 0)
                    next_state = START;
                end
            end
            START: begin
                next_state = DATA;
            end
            DATA: begin
                if (bit_counter == 3'd7) begin
                    next_state = STOP;
                end
            end
            STOP: begin
                if (in) begin  // Detect stop bit (which is 1)
                    done = 1'b1;
                    next_state = IDLE;
                end else begin
                    next_state = IDLE;  // If no valid stop bit, return to IDLE to find new start
                end
            end
        endcase
    end

    // Output logic
    assign out_byte = data_reg;

endmodule",4.245908,4847
N/A,N/A,-1,11,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// FSM states
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;
    
    state_t state, next_state;
    reg [2:0] bit_counter;
    reg [7:0] shift_reg;
    
    // FSM state transition
    always @(posedge clk) begin
        if (reset)
            state <= IDLE;
        else
            state <= next_state;
    end
    
    // Output logic
    always @(posedge clk) begin
        if (reset) begin
            shift_reg <= 8'b0;
            bit_counter <= 3'b0;
        end
        else if (state == DATA) begin
            shift_reg <= {in, shift_reg[7:1]};
            bit_counter <= bit_counter + 3'b1;
        end
    end
    
    always @(*) begin
        next_state = state;
        done = 0;
        
        case(state)
            IDLE: begin
                if (in == 0)
                    next_state = START;
            end
            START: begin
                if (in == 1)
                    next_state = DATA;
            end
            DATA: begin
                if (bit_counter == 3'd7)  // All data bits received
                    next_state = STOP;
            end
            STOP: begin
                if (in == 1) begin
                    done = 1;
                    next_state = IDLE;
                end
                else if (in == 0)  // Wait until true stop bit found
                    next_state = START;
            end
        endcase
    end
    
    assign out_byte = (done) ? shift_reg : 8'bx;
    
endmodule",4.832817,5220
N/A,N/A,-1,12,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// FSM states
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;
    
    state_t state, next_state;
    logic [2:0] bit_counter;

    // Register to hold the data bits
    logic [7:0] data_reg;
    
    // Next state logic
    always_comb begin
        case (state)
            IDLE: begin
                if (in == 1'b0)
                    next_state = START;
                else
                    next_state = IDLE;
            end

            START: begin
                next_state = DATA;
            end

            DATA: begin
                if (bit_counter == 3'd7)
                    next_state = STOP;
                else
                    next_state = DATA;
            end
            
            STOP: begin
                if (in == 1'b1)
                    next_state = IDLE;
                else
                    next_state = DATA; // Wait until stop bit found.
            end
            
            default: next_state = IDLE;
        endcase
    end

    // State update
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_counter <= 3'b0;
        end else begin
            state <= next_state;
            if (state == DATA)
                bit_counter <= bit_counter + 1;
            else
                bit_counter <= 3'b0;
        end
    end

    // Datapath operations
    always_ff @(posedge clk) begin
        if (state == IDLE || reset) begin
            data_reg <= 8'b0;
        end else if (state == DATA && next_state == DATA) begin
            data_reg <= {in, data_reg[7:1]};  // Shift in the bit from LSB to MSB
        end
    end

    assign out_byte = (state == STOP && next_state == IDLE) ? data_reg : 8'b0;
    assign done = (state == STOP && next_state == IDLE);

endmodule",5.687479,5665
N/A,N/A,-1,13,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// FSM states
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;
    
    state_t state, next_state;
    reg [2:0] bit_counter;
    reg [7:0] shift_reg;
    
    // FSM state transition
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_counter <= 0;
            shift_reg <= 8'b0;
        end else begin
            state <= next_state;
            if (state == DATA) begin
                shift_reg <= {in, shift_reg[7:1]};  // Shift in the incoming bit
                bit_counter <= bit_counter + 1;
            end
        end
    end
    
    // FSM next state logic
    always @* begin
        next_state = state;
        done = 0;
        
        case (state)
            IDLE: begin
                if (!in)  // Detect the start bit
                    next_state = START;
            end
            
            START: begin
                next_state = DATA;  // Go to data state after detecting start bit
            end
            
            DATA: begin
                if (bit_counter == 7)  // 8 bits received
                    next_state = STOP;
            end
            
            STOP: begin
                if (in) begin  // Check for the stop bit
                    done = 1;  // Byte received correctly, valid output
                    next_state = IDLE;
                end else begin
                    next_state = IDLE;  // Error, reset to start for new byte
                end
            end
        endcase
    end
    
    // Output logic
    assign out_byte = done ? shift_reg : 8'bX;  // Output valid when done, otherwise don't-care

endmodule",5.187199,6061
N/A,N/A,-1,14,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// FSM states
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    state_t state, next_state;
    logic [3:0] bit_counter; // To count bits, including start and stop
    logic [7:0] shift_reg;   // Shift register to store the received byte

    // State transition logic
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_counter <= 0;
            shift_reg <= 8'b0;
        end else begin
            state <= next_state;
            if (state == DATA) begin
                bit_counter <= bit_counter + 1;
                shift_reg <= {in, shift_reg[7:1]};
            end else if (state == IDLE || state == STOP) begin
                bit_counter <= 0;
            end
        end
    end

    // Next state logic
    always_comb begin
        next_state = state;
        done = 0;

        case (state)
            IDLE: begin
                if (in == 0) next_state = START; // Start bit detected
            end

            START: begin
                next_state = DATA;
            end

            DATA: begin
                if (bit_counter == 8) next_state = STOP; // 8 data bits received
            end

            STOP: begin
                if (in == 1) begin
                    next_state = IDLE;
                    done = 1; // Stop bit correctly detected
                end
            end
        endcase
    end

    // Out_byte assignment
    assign out_byte = (done ? shift_reg : 8'bxxxx_xxxx);

endmodule",4.315278,6438
N/A,N/A,-1,15,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// FSM states
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;
    
    state_t state, next_state;
    reg [2:0] bit_counter;
    reg [7:0] shift_reg;
    
    // FSM state transition
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_counter <= 0;
            shift_reg <= 8'b0;
        end else begin
            state <= next_state;
            if (state == DATA) begin
                shift_reg <= {in, shift_reg[7:1]};  // Shift in the incoming bit
                bit_counter <= bit_counter + 1;
            end
        end
    end
    
    // FSM next state logic
    always @* begin
        next_state = state;
        done = 0;
        
        case (state)
            IDLE: begin
                if (!in)  // Detect the start bit
                    next_state = START;
            end
            
            START: begin
                next_state = DATA;
            end
            
            DATA: begin
                if (bit_counter == 3'd7)
                    next_state = STOP;
            end
            
            STOP: begin
                if (in) begin  // Validate the stop bit
                    done = 1;
                    next_state = IDLE;
                end else begin
                    // Stay in STOP until a valid stop bit is received
                    next_state = STOP;
                end
            end
        endcase
    end
    
    // Output logic
    assign out_byte = shift_reg;
    
endmodule",3.910112,6792
N/A,N/A,-1,16,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// FSM states
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    state_t state, next_state;
    logic [2:0] bit_counter; // To track number of received data bits
    logic [7:0] shift_reg;   // To shift in data bits serially
    logic [7:0] data_byte;   // Latched data byte for output
    logic done_reg;          // Register for done signal

    // State transition logic
    always_ff @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= IDLE;
            bit_counter <= 3'd0;
            shift_reg <= 8'b0;
            data_byte <= 8'b0;
            done_reg <= 1'b0;
        end else begin
            state <= next_state;
            if (state == DATA) begin
                shift_reg <= {in, shift_reg[7:1]}; // Shift in the serial bits
                bit_counter <= bit_counter + 1;
            end
            if (state == STOP && in == 1'b1) begin
                data_byte <= shift_reg; // Latch the byte when stop bit is correct
            end
            done_reg <= (state == STOP && in == 1'b1);
        end
    end

    // Next state logic
    always_comb begin
        next_state = state; // Default to staying in the same state
        case (state)
            IDLE: begin
                if (in == 1'b0) // Detect start bit
                    next_state = START;
            end
            START: begin
                next_state = DATA; // Move to reading data bits
            end
            DATA: begin
                if (bit_counter == 3'd7) // If all 8 data bits have been received
                    next_state = STOP;
            end
            STOP: begin
                if (in == 1'b1) // Check for stop bit
                    next_state = IDLE; // If correct stop bit, return to IDLE
                // Otherwise, remain in STOP state waiting for stop bit
            end
            default: next_state = IDLE;
        endcase
    end

    // Output assignments
    assign out_byte = data_byte;
    assign done = done_reg;

endmodule",4.935892,7301
N/A,N/A,-1,17,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// FSM states
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    state_t state, next_state;
    logic [3:0] bit_counter; // To count number of received bits
    logic [7:0] byte_shift_reg; // Shift register to store incoming data bits

    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_counter <= 0;
            done <= 0;
        end else begin
            state <= next_state;

            if (state == DATA) begin
                byte_shift_reg <= {in, byte_shift_reg[7:1]};
                bit_counter <= bit_counter + 1;
            end

            if (state == STOP) begin
                done <= 1;
            end else begin
                done <= 0;
            end
        end
    end

    always_comb begin
        next_state = state; // Default state transition

        case (state)
            IDLE: begin
                if (!in) begin // Detect start bit (active low)
                    next_state = START;
                end
            end

            START: begin
                next_state = DATA;
            end

            DATA: begin
                if (bit_counter == 7) begin
                    next_state = STOP;
                end
            end
            
            STOP: begin
                if (in) begin // Check if stop bit (active high)
                    next_state = IDLE;
                end
            end
        endcase
    end

    assign out_byte = byte_shift_reg;

endmodule",4.747895,7650
N/A,N/A,-1,18,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// FSM states
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;
    
    state_t state, next_state;
    logic [2:0] bit_counter;
    logic [7:0] shift_reg;
    
    // FSM state transition
    always_ff @(posedge clk) begin
        if (reset)
            state <= IDLE;
        else
            state <= next_state;
    end
    
    // Next state logic
    always_comb begin
        case (state)
            IDLE: begin
                if (in == 0) // Detected start bit
                    next_state = START;
                else
                    next_state = IDLE;
            end
            
            START: begin
                if (in == 0) // Confirm start bit remains low
                    next_state = DATA;
                else
                    next_state = IDLE;
            end
            
            DATA: begin
                if (bit_counter == 3'b111) // All 8 bits received
                    next_state = STOP;
                else
                    next_state = DATA;
            end
            
            STOP: begin
                if (in == 1) // Detected stop bit
                    next_state = IDLE;
                else
                    next_state = STOP; // Wait until stop bit is correct
            end
            
            default: next_state = IDLE;
        endcase
    end
    
    // Bit counter and shift register
    always_ff @(posedge clk) begin
        if (reset) begin
            bit_counter <= 3'b0;
            shift_reg <= 8'b0;
        end
        else if (state == DATA) begin
            shift_reg <= {in, shift_reg[7:1]}; // Shift in LSB first
            bit_counter <= bit_counter + 1;
        end
        else if (state != DATA) begin
            bit_counter <= 3'b0; // Reset counter if not receiving data
        end
    end
    
    // Output logic
    assign out_byte = (state == STOP && in == 1) ? shift_reg : 8'bxxxx_xxxx; // Valid out_byte in STOP state with stop bit detected
    assign done = (state == STOP && in == 1); // done becomes 1 on valid byte reception

endmodule",5.964316,8145
N/A,N/A,-1,19,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// FSM states
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;
    
    state_t state, next_state;
    reg [7:0] bit_shift_reg;
    reg [3:0] bit_counter; // Counts bits from 0 to 7

    // Synchronous logic for state transitions and outputs
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_counter <= 0;
            bit_shift_reg <= 8'd0;
        end else begin
            state <= next_state;

            if (state == DATA) begin
                bit_counter <= bit_counter + 1;
                bit_shift_reg <= {in, bit_shift_reg[7:1]};
            end

            if (state == START) begin
                bit_counter <= 0;
            end
        end
    end

    // Combinatorial logic for next state logic
    always_comb begin
        // Default outputs
        done = 0;
        next_state = state;

        case (state)
            IDLE: begin
                if (!in) // Detect start bit (0)
                    next_state = START;
            end

            START: begin
                if (bit_counter == 0) begin
                    next_state = DATA;
                end
            end

            DATA: begin
                if (bit_counter == 8) begin
                    next_state = STOP;
                end
            end

            STOP: begin
                if (in) begin // Expecting stop bit (1)
                    done = 1;
                    next_state = IDLE;
                end
            end
        endcase
    end

    // Parallel output
    assign out_byte = (done) ? bit_shift_reg : 8'bx;

endmodule",5.63416,8538
N/A,N/A,-1,20,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// FSM states
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    state_t state, next_state;
    logic [2:0] bit_counter; // To track number of received bits
    logic [7:0] shift_reg;   // Shift register to hold received data bits

    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_counter <= 3'd0;
            shift_reg <= 8'h00;
        end else begin
            state <= next_state;
            if (state == DATA) begin
                bit_counter <= bit_counter + 3'd1;
                shift_reg <= {in, shift_reg[7:1]}; // Shift in serial data from LSB to MSB
            end else if (state != DATA) begin
                bit_counter <= 3'd0;
                shift_reg <= 8'h00;
            end
        end
    end

    // Next state logic
    always_comb begin
        next_state = state;
        case (state)
            IDLE: begin
                done = 1'b0;
                if (in == 1'b0) // Detect start bit
                    next_state = START;
            end
            START: begin
                done = 1'b0;
                if (bit_counter == 3'd0) // Wait for first bit
                    next_state = DATA;
            end
            DATA: begin
                done = 1'b0;
                if (bit_counter == 3'd8) // Received all data bits
                    next_state = STOP;
            end
            STOP: begin
                if (in == 1'b1) begin // Verify stop bit
                    done = 1'b1;
                    next_state = IDLE;
                end else begin
                    done = 1'b0;
                    next_state = IDLE; // Wait for correct stop bit (here you might choose to handle it differently)
                end
            end
        endcase
    end

    assign out_byte = (state == STOP && in == 1'b1) ? shift_reg : 8'hXX; // Valid output byte when stop bit is correct

endmodule",5.211257,9020
N/A,N/A,-1,21,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// FSM states
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    state_t state, next_state;
    logic [3:0] bit_counter; // To count up to 10 (1 start, 8 data, 1 stop)
    logic [7:0] shift_reg;   // To hold the 8 data bits

    // State transition logic
    always_ff @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= IDLE;
            bit_counter <= 0;
            shift_reg <= 8'b0;
        end else begin
            state <= next_state;
            if (state == DATA) begin
                shift_reg <= {in, shift_reg[7:1]}; // Shift in each bit
            end
            if (state == DATA || state == START) begin
                bit_counter <= bit_counter + 1;
            end else begin
                bit_counter <= 0;
            end
        end
    end

    // Next state logic
    always_comb begin
        next_state = state;
        done = 0;

        case (state)
            IDLE: begin
                if (in == 0) begin // Start bit detected
                    next_state = START;
                end
            end
            START: begin
                if (bit_counter == 1) begin // Move to data once start bit is verified
                    next_state = DATA;
                end
            end
            DATA: begin
                if (bit_counter == 9) begin // After 8 data bits
                    next_state = STOP;
                end
            end
            STOP: begin
                if (in == 1) begin // Stop bit detected
                    done = 1;
                    next_state = IDLE;
                end else begin
                    next_state = IDLE; // Wait for a stop bit
                end
            end
        endcase
    end

    // Output logic
    assign out_byte = (done) ? shift_reg : 8'bx;

endmodule",4.753935,9470
N/A,N/A,-1,22,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// FSM states
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    state_t state, next_state;
    logic [2:0] bit_counter; // To count the received data bits
    logic [7:0] shift_reg;   // Shift register to hold the data byte

    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_counter <= 3'd0;
            shift_reg <= 8'h00;
        end else begin
            state <= next_state;
            if (state == DATA) begin
                bit_counter <= bit_counter + 3'd1;
                shift_reg <= {in, shift_reg[7:1]}; // Shift in the received bit
            end else if (state == STOP) begin
                bit_counter <= 3'd0;
            end
        end
    end

    always_comb begin
        next_state = state;
        done = 1'b0;

        case (state)
            IDLE: begin
                if (in == 1'b0) begin // Detect start bit (logic 0)
                    next_state = START;
                end
            end
            START: begin
                next_state = DATA;
            end
            DATA: begin
                if (bit_counter == 3'd7) begin // Receive 8 data bits
                    next_state = STOP;
                end
            end
            STOP: begin
                if (in == 1'b1) begin // Detect stop bit (logic 1)
                    done = 1'b1;        // Indicate done
                    next_state = IDLE;  // Go back to idle
                end
            end
            default: begin
                next_state = IDLE;
            end
        endcase
    end

    assign out_byte = (done) ? shift_reg : 8'hxx; // Output the received byte when done

endmodule",4.406792,9897
N/A,N/A,-1,23,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// FSM states
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    state_t state, next_state;
    logic [2:0] bit_counter; // To count the received data bits
    logic [7:0] shift_reg;   // Shift register to hold the data byte

    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_counter <= 3'd0;
            shift_reg <= 8'h00;
        end else begin
            state <= next_state;
            if (state == DATA) begin
                bit_counter <= bit_counter + 3'd1;
                shift_reg <= {in, shift_reg[7:1]}; // Shift in the received bit
            end else if (state == STOP) begin
                bit_counter <= 3'd0;
            end
        end
    end

    always_comb begin
        next_state = state;
        done = 1'b0;

        case (state)
            IDLE: begin
                if (in == 1'b0) // Start bit detected
                    next_state = START;
            end

            START: begin
                next_state = DATA;
            end

            DATA: begin
                if (bit_counter == 3'd7)
                    next_state = STOP;
            end

            STOP: begin
                if (in == 1'b1) begin // Stop bit detected, byte received
                    done = 1'b1;
                    next_state = IDLE;
                end
            end

            default: next_state = IDLE;
        endcase
    end

    assign out_byte = shift_reg; // Parallel output of the shift register

endmodule",4.532448,10276
N/A,N/A,-1,24,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// FSM states
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;
    
    state_t state, next_state;
    reg [7:0] bit_shift_reg;
    reg [3:0] bit_count; // Counts bits from 0 to 7

    // Synchronous logic for state transitions and outputs
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
            bit_shift_reg <= 8'd0;
        end else begin
            state <= next_state;

            if (state == DATA) begin
                bit_shift_reg <= {in, bit_shift_reg[7:1]}; // Shift in the incoming bits
                bit_count <= bit_count + 1;
            end

            if (next_state == IDLE) begin
                bit_count <= 0;
                bit_shift_reg <= 8'd0;
            end
        end
    end

    // Combinational logic for next state
    always_comb begin
        next_state = state; // Default: stay in the current state
        case (state)
            IDLE: begin
                if (in == 0) next_state = START; // Detect start bit
            end
            START: begin
                if (in == 1) next_state = DATA; // Proceed to data collection if start bit is detected
            end
            DATA: begin
                if (bit_count == 4'd8) next_state = STOP; // Check if all 8 bits are collected
            end
            STOP: begin
                if (in == 1) next_state = IDLE; // Verify stop bit and return to idle
                else next_state = STOP; // Remain here if stop bit is not correct
            end
        endcase
    end

    // Output logic
    assign done = (state == STOP) && (in == 1);
    assign out_byte = bit_shift_reg; // Valid only when done is high

endmodule",4.783226,10722
N/A,N/A,-1,25,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// FSM states
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;
    
    state_t state, next_state;
    logic [2:0] bit_counter;
    logic [7:0] shift_reg;
    
    // FSM state transition
    always_ff @(posedge clk) begin
        if (reset)
            state <= IDLE;
        else
            state <= next_state;
    end
    
    // Next state logic
    always_comb begin
        case (state)
            IDLE: begin
                if (in == 0) // Detected start bit
                    next_state = START;
                else
                    next_state = IDLE;
            end
            
            START: begin
                if (in == 0) // Confirm start bit remains low
                    next_state = DATA;
                else
                    next_state = IDLE;
            end
            
            DATA: begin
                if (bit_counter == 3'b111) // All 8 bits received
                    next_state = STOP;
                else
                    next_state = DATA;
            end
            
            STOP: begin
                if (in == 1) // Detected stop bit
                    next_state = IDLE;
                else
                    next_state = STOP; // Wait until stop bit is correct
            end
            
            default: next_state = IDLE;
        endcase
    end
    
    // Bit counter and shift register
    always_ff @(posedge clk) begin
        if (reset) begin
            bit_counter <= 3'b0;
            shift_reg <= 8'b0;
        end
        else if (state == DATA) begin
            shift_reg <= {in, shift_reg[7:1]}; // Shift in LSB first
            bit_counter <= bit_counter + 1;
        end
        else if (state != DATA) begin
            bit_counter <= 3'b0; // Reset counter if not receiving data
        end
    end
    
    // Output logic
    assign done = (state == STOP) && (in == 1);
    assign out_byte = (done) ? shift_reg : 8'bxxxx_xxxx;

endmodule",5.462454,11190
N/A,N/A,-1,26,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// FSM states
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    state_t state, next_state;
    logic [2:0] bit_counter; // To count the received data bits
    logic [7:0] byte_shift_reg; // Shift register to store incoming data bits

    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_counter <= 3'd0;
            byte_shift_reg <= 8'b0;
        end else begin
            state <= next_state;
        end
    end

    always_comb begin
        next_state = state;
        case (state)
            IDLE: begin
                if (!in)  // Start bit detected
                    next_state = START;
            end
            START: begin
                next_state = DATA;
                bit_counter = 3'd0;
            end
            DATA: begin
                if (bit_counter < 3'd7) begin
                    next_state = DATA;
                end else begin
                    next_state = STOP;
                end
            end
            STOP: begin
                if (in)  // Stop bit detected
                    next_state = IDLE;
                else
                    next_state = STOP; // Wait for stop bit
            end
        endcase
    end

    always_ff @(posedge clk) begin
        if (state == DATA) begin
            byte_shift_reg[bit_counter] <= in; // Shift in the data bits
            bit_counter <= bit_counter + 3'd1;
        end
    end

    assign out_byte = (state == STOP && in) ? byte_shift_reg : 8'b0;
    assign done = (state == STOP && in);

endmodule",4.276558,11575
N/A,N/A,-1,27,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// FSM states
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    state_t state, next_state;
    logic [2:0] bit_counter; // To track number of received data bits
    logic [7:0] shift_reg;   // To shift in data bits serially
    logic [7:0] data_byte;   // Latched data byte for output
    logic done_reg;          // Register for done signal

    // State transition logic
    always_ff @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= IDLE;
            bit_counter <= 3'd0;
            shift_reg <= 8'b0;
            data_byte <= 8'b0;
            done_reg <= 1'b0;
        end else begin
            state <= next_state;
            if (state == DATA) begin
                shift_reg <= {in, shift_reg[7:1]}; // Shift in the incoming bit
                bit_counter <= bit_counter + 1;
            end else if (state == STOP) begin
                data_byte <= shift_reg; // Latch the data byte
            end

            if (state == STOP && in) begin
                done_reg <= 1'b1; // Stop bit received correctly
            end else begin
                done_reg <= 1'b0;
            end
        end
    end

    // Next state logic
    always_comb begin
        next_state = state;
        case (state)
            IDLE: begin
                if (in == 1'b0) // Detect start bit
                    next_state = START;
            end
            START: begin
                if (in == 1'b0) // Confirm start bit
                    next_state = DATA;
            end
            DATA: begin
                if (bit_counter == 3'd7) // After 8 data bits received
                    next_state = STOP;
            end
            STOP: begin
                if (in == 1'b1) // Check for stop bit
                    next_state = IDLE;
                else
                    next_state = START; // Incorrect stop bit, look for new start bit
            end
            default: next_state = IDLE;
        endcase
    end

    // Output logic
    assign out_byte = data_byte;
    assign done = done_reg;

endmodule",5.86133,12091
N/A,N/A,-1,28,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// FSM states
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    state_t state, next_state;
    logic [2:0] bit_counter; // To track number of received data bits
    logic [7:0] shift_reg;   // To shift in data bits serially

    // State transition logic
    always_ff @(posedge clk or posedge reset) begin
        if (reset)
            state <= IDLE;
        else
            state <= next_state;
    end

    // Next state logic and bit counter/shift register updates
    always_comb begin
        next_state = state;
        done = 0;

        case (state)
            IDLE: begin
                if (in == 0)  // Detecting start bit
                    next_state = START;
            end
            START: begin
                next_state = DATA;
                bit_counter = 0;
            end
            DATA: begin
                shift_reg = {in, shift_reg[7:1]}; // Shift data in
                if (bit_counter == 7)
                    next_state = STOP;
                bit_counter = bit_counter + 1;
            end
            STOP: begin
                if (in == 1) begin // Correct stop bit
                    done = 1;
                    next_state = IDLE;
                end else begin
                    next_state = DATA; // Incorrect stop bit, resynchronize
                end
            end
        endcase
    end

    // Output logic
    assign out_byte = (done) ? shift_reg : 8'bx;

endmodule",3.913265,12445
N/A,N/A,-1,29,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// FSM states
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;
    
    state_t state, next_state;
    reg [2:0] bit_counter;
    reg [7:0] shift_reg;
    
    // FSM state transition
    always @(posedge clk) begin
        if (reset)
            state <= IDLE;
        else
            state <= next_state;
    end
    
    // Output logic
    always @(posedge clk) begin
        if (reset) begin
            shift_reg <= 8'b0;
            bit_counter <= 3'b0;
        end
        else if (state == DATA) begin
            shift_reg <= {in, shift_reg[7:1]};
            bit_counter <= bit_counter + 3'b1;
        end
    end
    
    always @(*) begin
        next_state = state;
        done = 0;
        
        case(state)
            IDLE: begin
                if (in == 0)
                    next_state = START;
            end
            START: begin
                if (in == 1)
                    next_state = DATA;
            end
            DATA: begin
                if (bit_counter == 3'd7)  // All data bits received
                    next_state = STOP;
            end
            STOP: begin
                if (in == 1) begin
                    done = 1;
                    next_state = IDLE;
                end
                else if (in == 0)  // Wait until true stop bit found
                    next_state = START;
            end
        endcase
    end
    
    assign out_byte = (done) ? shift_reg : 8'bx;
    
endmodule",4.346497,12818
N/A,N/A,-1,30,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// FSM states
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;
    
    state_t state, next_state;
    logic [2:0] bit_counter;
    logic [7:0] shift_reg;
    
    // FSM state transition
    always_ff @(posedge clk) begin
        if (reset)
            state <= IDLE;
        else
            state <= next_state;
    end
    
    // Next state logic
    always_comb begin
        case (state)
            IDLE: begin
                if (in == 0) // Detected start bit
                    next_state = START;
                else
                    next_state = IDLE;
            end
            
            START: begin
                if (bit_counter == 3'd7)
                    next_state = DATA;
                else
                    next_state = START;
            end
            
            DATA: begin
                if (bit_counter == 3'd7)
                    next_state = STOP;
                else
                    next_state = DATA;
            end
            
            STOP: begin
                if (in == 1) // Detecting stop bit
                    next_state = IDLE;
                else
                    next_state = STOP;
            end
            
            default: next_state = IDLE;
        endcase
    end

    // Counter and shift register logic
    always_ff @(posedge clk) begin
        if (reset) begin
            bit_counter <= 3'd0;
            shift_reg <= 8'd0;
        end
        else begin
            case (state)
                IDLE: begin
                    bit_counter <= 3'd0;
                end
                
                START: begin
                    bit_counter <= bit_counter + 3'd1;
                end
                
                DATA: begin
                    shift_reg <= {in, shift_reg[7:1]};
                    bit_counter <= bit_counter + 3'd1;
                end
                
                STOP: begin
                    if (in == 1) begin
                        bit_counter <= 3'd0;
                    end
                end
            endcase
        end
    end

    // Output logic
    assign done = (state == STOP && in == 1);
    assign out_byte = shift_reg;

endmodule",5.992528,13296
N/A,N/A,-1,31,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// FSM states
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;
    
    state_t state, next_state;
    logic [2:0] bit_counter;
    logic [7:0] shift_reg;
    
    // FSM state transition
    always_ff @(posedge clk) begin
        if (reset)
            state <= IDLE;
        else
            state <= next_state;
    end
    
    // Next state logic
    always_comb begin
        case (state)
            IDLE: begin
                if (in == 0) // Detected start bit
                    next_state = START;
                else
                    next_state = IDLE;
            end
            
            START: begin
                if (bit_counter == 3'd7)
                    next_state = DATA;
                else
                    next_state = START;
            end
            
            DATA: begin
                if (bit_counter == 3'd7)
                    next_state = STOP;
                else
                    next_state = DATA;
            end
            
            STOP: begin
                if (in == 1) // Detecting stop bit
                    next_state = IDLE;
                else
                    next_state = STOP;
            end
            
            default: next_state = IDLE;
        endcase
    end

    // Counter and shift register logic
    always_ff @(posedge clk) begin
        if (reset) begin
            bit_counter <= 3'd0;
            shift_reg <= 8'd0;
        end
        else begin
            case (state)
                IDLE: begin
                    bit_counter <= 3'd0;
                end
                
                START: begin
                    bit_counter <= bit_counter + 3'd1;
                end
                
                DATA: begin
                    shift_reg <= {in, shift_reg[7:1]};
                    bit_counter <= bit_counter + 3'd1;
                end
                
                STOP: begin
                    if (in == 1) begin
                        bit_counter <= 3'd0;
                    end
                end
            endcase
        end
    end

    // Output logic
    assign done = (state == STOP && in == 1);
    assign out_byte = shift_reg;

endmodule",4.737139,13774
N/A,N/A,-1,32,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// FSM states
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;
    
    state_t state, next_state;
    logic [2:0] bit_counter;
    logic [7:0] shift_reg;
    
    // FSM state transition
    always_ff @(posedge clk) begin
        if (reset)
            state <= IDLE;
        else
            state <= next_state;
    end
    
    // Next state logic
    always_comb begin
        case (state)
            IDLE: begin
                if (in == 0) // Detect start bit
                    next_state = START;
                else
                    next_state = IDLE;
            end
            START: begin
                next_state = DATA;
            end
            DATA: begin
                if (bit_counter == 3'd7) // All 8 data bits received
                    next_state = STOP;
                else
                    next_state = DATA;
            end
            STOP: begin
                if (in == 1) // Detect stop bit
                    next_state = IDLE;
                else
                    next_state = STOP; // Wait for stop bit if incorrect
            end
            default: next_state = IDLE;
        endcase
    end
    
    // Datapath control logic
    always_ff @(posedge clk) begin
        if (reset) begin
            bit_counter <= 3'd0;
            shift_reg <= 8'd0;
        end else begin
            case (state)
                DATA: begin
                    shift_reg <= {in, shift_reg[7:1]}; // Shift in data bits
                    bit_counter <= bit_counter + 1;
                end
                STOP: begin
                    if (in == 1) begin
                        bit_counter <= 3'd0; // Reset for next byte
                    end
                end
                default: begin
                    // No operation
                end
            endcase
        end
    end
    
    // Output logic
    assign out_byte = shift_reg;
    assign done = (state == STOP) && (in == 1); // Only valid when stop bit is correct

endmodule",5.042965,14241
N/A,N/A,-1,33,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// FSM states
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;
    
    state_t state, next_state;
    logic [2:0] bit_counter;
    logic [7:0] shift_reg;
    
    // FSM state transition
    always_ff @(posedge clk) begin
        if (reset)
            state <= IDLE;
        else
            state <= next_state;
    end
    
    // Next state logic
    always_comb begin
        case (state)
            IDLE: begin
                if (in == 0) // Detect start bit
                    next_state = START;
                else
                    next_state = IDLE;
            end
            START: begin
                next_state = DATA;
            end
            DATA: begin
                if (bit_counter == 3'd7) // All 8 data bits received
                    next_state = STOP;
                else
                    next_state = DATA;
            end
            STOP: begin
                if (in == 1) // Detect stop bit
                    next_state = IDLE;
                else
                    next_state = STOP; // Wait for stop bit if incorrect
            end
            default: next_state = IDLE;
        endcase
    end
    
    // Datapath control logic
    always_ff @(posedge clk) begin
        if (reset) begin
            bit_counter <= 3'd0;
            shift_reg <= 8'd0;
        end else begin
            case (state)
                DATA: begin
                    shift_reg <= {in, shift_reg[7:1]}; // Shift in data bits
                    bit_counter <= bit_counter + 1;
                end
                STOP: begin
                    if (in == 1) begin
                        bit_counter <= 3'd0; // Reset for next byte
                    end
                end
                default: begin
                    // No operation
                end
            endcase
        end
    end
    
    // Output logic
    assign out_byte = shift_reg;
    assign done = (state == STOP) && (in == 1); // Only valid when stop bit is correct

endmodule",4.825799,14708
N/A,N/A,-1,34,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// FSM states
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    state_t state, next_state;
    logic [3:0] bit_counter; // To count bits, including start and stop
    logic [7:0] shift_reg;   // Shift register to store the received byte

    // State transition logic
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_counter <= 0;
        end else begin
            state <= next_state;
            bit_counter <= (state == DATA) ? bit_counter + 1 : 0;
        end
    end

    // Next state and output logic
    always_comb begin
        next_state = state;
        done = 1'b0;
        
        case (state)
            IDLE: begin
                if (in == 1'b0) // Start bit detected
                    next_state = START;
            end
            START: begin
                next_state = DATA;
            end
            DATA: begin
                if (bit_counter == 8) // 8 data bits received
                    next_state = STOP;
            end
            STOP: begin
                if (in == 1'b1) // Stop bit verified
                    done = 1'b1;
                next_state = IDLE;
            end
        endcase
    end

    // Datapath to latch incoming bits
    always_ff @(posedge clk) begin
        if (state == DATA) begin
            shift_reg <= {in, shift_reg[7:1]};
        end
    end

    // Output the byte when done
    assign out_byte = (done) ? shift_reg : 8'bx;

endmodule",7.139533,15092
N/A,N/A,-1,35,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// FSM states
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;
    
    state_t state, next_state;
    reg [7:0] bit_shift_reg;
    reg [2:0] bit_count;

    // FSM state transition
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_shift_reg <= 8'b0;
            bit_count <= 3'd0;
        end else begin
            state <= next_state;
            if (state == DATA) begin
                bit_shift_reg <= {in, bit_shift_reg[7:1]};
                bit_count <= bit_count + 1;
            end else begin
                bit_count <= 3'd0;
            end
        end
    end

    // FSM next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 0) // Start bit detected
                    next_state = START;
                else
                    next_state = IDLE;
            end
            START: begin
                next_state = DATA;
            end
            DATA: begin
                if (bit_count == 3'd7)
                    next_state = STOP;
                else
                    next_state = DATA;
            end
            STOP: begin
                if (in == 1) // Stop bit detected
                    next_state = IDLE;
                else
                    next_state = STOP; // Wait for stop bit if not detected
            end
            default: begin
                next_state = IDLE;
            end
        endcase
    end

    // Output logic
    assign done = (state == STOP && in == 1);
    assign out_byte = (done) ? bit_shift_reg : 8'bx;

endmodule",3.968109,15486
N/A,N/A,-1,36,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// FSM states
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;
    
    state_t state, next_state;
    logic [2:0] bit_counter;
    logic [7:0] shift_reg;
    
    // FSM state transition
    always_ff @(posedge clk) begin
        if (reset)
            state <= IDLE;
        else
            state <= next_state;
    end
    
    // Next state logic
    always_comb begin
        case (state)
            IDLE: begin
                if (in == 0) // Detected start bit
                    next_state = START;
                else
                    next_state = IDLE;
            end
            
            START: begin
                if (bit_counter == 3'd7)
                    next_state = DATA;
                else
                    next_state = START;
            end
            
            DATA: begin
                if (bit_counter == 3'd7)
                    next_state = STOP;
                else
                    next_state = DATA;
            end
            
            STOP: begin
                if (in == 1) // Detecting stop bit
                    next_state = IDLE;
                else
                    next_state = STOP;
            end
            
            default: next_state = IDLE;
        endcase
    end

    // Counter and shift register logic
    always_ff @(posedge clk) begin
        if (reset) begin
            bit_counter <= 3'd0;
            shift_reg <= 8'd0;
        end
        else begin
            case (state)
                IDLE: begin
                    bit_counter <= 3'd0;
                end
                
                START: begin
                    bit_counter <= bit_counter + 3'd1;
                end
                
                DATA: begin
                    shift_reg <= {in, shift_reg[7:1]};
                    bit_counter <= bit_counter + 3'd1;
                end
                
                STOP: begin
                    if (in == 1) begin
                        bit_counter <= 3'd0;
                    end
                end
            endcase
        end
    end

    // Output logic
    assign done = (state == STOP && in == 1);
    assign out_byte = shift_reg;

endmodule",4.869461,15964
N/A,N/A,-1,37,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// FSM states
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;
    
    state_t state, next_state;
    logic [2:0] bit_counter;
    logic [7:0] shift_reg;
    
    // FSM state transition
    always_ff @(posedge clk) begin
        if (reset)
            state <= IDLE;
        else
            state <= next_state;
    end
    
    // Next state logic
    always_comb begin
        case (state)
            IDLE: begin
                if (in == 0) // Detected start bit
                    next_state = START;
                else
                    next_state = IDLE;
            end
            
            START: begin
                if (in == 0) // Confirm start bit remains low
                    next_state = DATA;
                else
                    next_state = IDLE;
            end
            
            DATA: begin
                if (bit_counter == 3'b111) // All 8 bits received
                    next_state = STOP;
                else
                    next_state = DATA;
            end
            
            STOP: begin
                if (in == 1) // Detected stop bit
                    next_state = IDLE;
                else
                    next_state = STOP; // Wait until stop bit is correct
            end
            
            default: next_state = IDLE;
        endcase
    end
    
    // Bit counter and shift register
    always_ff @(posedge clk) begin
        if (reset) begin
            bit_counter <= 3'b0;
            shift_reg <= 8'b0;
        end
        else if (state == DATA) begin
            shift_reg <= {in, shift_reg[7:1]}; // Shift in LSB first
            bit_counter <= bit_counter + 1;
        end
        else if (state != DATA) begin
            bit_counter <= 3'b0; // Reset counter if not receiving data
        end
    end
    
    // Output logic
    assign out_byte = (state == STOP && in == 1) ? shift_reg : 8'bxxxx_xxxx; // Valid out_byte in STOP state with stop bit detected
    assign done = (state == STOP && in == 1); // done becomes 1 on valid byte reception end

endmodule",5.377537,16460
N/A,N/A,-1,38,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// FSM states
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;
    
    state_t state, next_state;
    logic [2:0] bit_counter;
    logic [7:0] shift_reg;
    
    // FSM state transition
    always_ff @(posedge clk) begin
        if (reset)
            state <= IDLE;
        else
            state <= next_state;
    end
    
    // Next state logic
    always_comb begin
        case (state)
            IDLE: begin
                if (in == 0) // Detect start bit
                    next_state = START;
                else
                    next_state = IDLE;
            end
            START: begin
                next_state = DATA;
            end
            DATA: begin
                if (bit_counter == 3'd7) // All 8 data bits received
                    next_state = STOP;
                else
                    next_state = DATA;
            end
            STOP: begin
                if (in == 1) // Detect stop bit
                    next_state = IDLE;
                else
                    next_state = STOP; // Wait for stop bit if incorrect
            end
            default: next_state = IDLE;
        endcase
    end
    
    // Datapath
    always_ff @(posedge clk) begin
        if (reset) begin
            shift_reg <= 8'b0;
            bit_counter <= 3'b0;
        end
        else begin
            case (state)
                DATA: begin
                    shift_reg <= {in, shift_reg[7:1]}; // Shift in data bits
                    bit_counter <= bit_counter + 1;
                end
                STOP: begin
                    if (in == 1) begin
                        bit_counter <= 3'b0; // Reset for next byte
                    end
                end
                default: begin
                    // No operation
                end
            endcase
        end
    end
    
    // Output logic
    assign out_byte = shift_reg;
    assign done = (state == STOP) && (in == 1); // Only valid when stop bit is correct

endmodule",5.544023,16927
N/A,N/A,-1,39,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// FSM states
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;
    
    state_t state, next_state;
    logic [2:0] bit_counter;

    // Register to hold the data byte
    logic [7:0] data_reg;
    logic [7:0] out_byte_reg;

    // Output assignments
    assign out_byte = out_byte_reg;
    assign done = (state == STOP);

    // State transition
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_counter <= 3'd0;
        end
        else begin
            state <= next_state;
            if (state == DATA) begin
                data_reg <= {in, data_reg[7:1]}; // Shift in the incoming bit
                bit_counter <= bit_counter + 3'd1;
            end
        end
    end
    
    // FSM logic
    always_comb begin
        next_state = state;
        case(state)
            IDLE: begin
                if (in == 0) begin  // Start bit detected
                    next_state = START;
                end
            end

            START: begin
                next_state = DATA;
            end

            DATA: begin
                if (bit_counter == 3'd7) begin
                    next_state = STOP;
                end
            end

            STOP: begin
                if (in == 1'b1) begin // Valid stop bit detected
                    next_state = IDLE;
                    out_byte_reg = data_reg; // Output the received byte
                end
            end
        endcase
    end

endmodule",5.290958,17293
N/A,N/A,-1,40,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// FSM states
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;
    
    state_t state, next_state;
    logic [2:0] bit_counter;
    logic [7:0] shift_reg;
    
    // FSM state transition
    always_ff @(posedge clk) begin
        if (reset)
            state <= IDLE;
        else
            state <= next_state;
    end
    
    // Next state logic
    always_comb begin
        case (state)
            IDLE: begin
                if (in == 0) // Detect start bit
                    next_state = START;
                else
                    next_state = IDLE;
            end
            START: begin
                next_state = DATA;
            end
            DATA: begin
                if (bit_counter == 3'd7) // All 8 data bits received
                    next_state = STOP;
                else
                    next_state = DATA;
            end
            STOP: begin
                if (in == 1) // Detect stop bit
                    next_state = IDLE;
                else
                    next_state = STOP; // Wait for stop bit if incorrect
            end
            default: next_state = IDLE;
        endcase
    end
    
    // Datapath
    always_ff @(posedge clk) begin
        if (reset) begin
            shift_reg <= 8'b0;
            bit_counter <= 3'b0;
        end
        else begin
            case (state)
                DATA: begin
                    shift_reg <= {in, shift_reg[7:1]}; // Shift in data bits
                    bit_counter <= bit_counter + 1;
                end
                STOP: begin
                    if (in == 1) begin
                        bit_counter <= 3'b0; // Reset for next byte
                    end
                end
                default: begin
                    // No operation
                end
            endcase
        end
    end
    
    // Output logic
    assign out_byte = shift_reg;
    assign done = (state == STOP) && (in == 1); // Only valid when stop bit is correct

endmodule",5.537957,17760
N/A,N/A,-1,41,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// FSM states
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;
    
    state_t state, next_state;
    logic [2:0] bit_counter;
    logic [7:0] shift_reg;
    
    // FSM State Transition
    always_ff @(posedge clk) begin
        if (reset)
            state <= IDLE;
        else
            state <= next_state;
    end
    
    // Next state logic
    always_comb begin
        case (state)
            IDLE: begin
                if (in == 0) // Detected start bit
                    next_state = START;
                else
                    next_state = IDLE;
            end
            
            START: begin
                next_state = DATA;
            end
            
            DATA: begin
                if (bit_counter == 7)
                    next_state = STOP;
                else
                    next_state = DATA;
            end
            
            STOP: begin
                if (in == 1) // Detected stop bit
                    next_state = IDLE;
                else
                    next_state = STOP; // Wait until stop bit is correct
            end
            
            default: next_state = IDLE;
        endcase
    end
    
    // Output and counter logic
    always_ff @(posedge clk) begin
        if (reset) begin
            bit_counter <= 0;
            shift_reg <= 0;
            done <= 0;
        end else begin
            case (state)
                IDLE: begin
                    done <= 0;
                end
                
                START: begin
                    bit_counter <= 0;
                    shift_reg <= 0;
                    done <= 0;
                end
                
                DATA: begin
                    shift_reg <= {in, shift_reg[7:1]}; // Shift in the bit
                    bit_counter <= bit_counter + 1;
                    done <= 0;
                end
                
                STOP: begin
                    if (in == 1) begin
                        out_byte <= shift_reg;
                        done <= 1;
                    end else begin
                        done <= 0;
                    end
                end
            endcase
        end
    end
endmodule",7.701285,18227
N/A,N/A,-1,42,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// FSM states
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    state_t state, next_state;
    logic [2:0] bit_counter; // Count the number of data bits received (0 to 7)
    logic [7:0] shift_reg; // Shift register to capture the byte

    // Sequential logic for state transitions and output logic
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_counter <= 3'd0;
            shift_reg <= 8'd0;
        end else begin
            state <= next_state;
            if (state == DATA) begin
                shift_reg <= {in, shift_reg[7:1]}; // Shift in the data, LSb first
                bit_counter <= bit_counter + 1;
            end
        end
    end

    // Combinational logic for next state generation and done signal
    always_comb begin
        next_state = state;
        done = 1'b0;
        case (state)
            IDLE: begin
                if (in == 1'b0) // Wait for start bit (assumed to be low)
                    next_state = START;
            end

            START: begin
                next_state = DATA;
                bit_counter = 3'd0;
            end

            DATA: begin
                if (bit_counter == 3'd7) // Collected 8 data bits
                    next_state = STOP;
            end

            STOP: begin
                if (in == 1'b1) begin // Check for stop bit (assumed to be high)
                    next_state = IDLE;
                    done = 1'b1; // Signal that a valid byte has been received
                end else begin
                    next_state = IDLE; // Go to IDLE to wait for a proper start sequence
                end
            end

            default: next_state = IDLE;
        endcase
    end

    // Output logic
    assign out_byte = shift_reg;

endmodule",5.214228,18676
N/A,N/A,-1,43,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// FSM states
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;
    
    state_t state, next_state;
    logic [2:0] bit_counter;
    logic [7:0] shift_reg;
    
    // FSM state transition
    always_ff @(posedge clk) begin
        if (reset)
            state <= IDLE;
        else
            state <= next_state;
    end
    
    // Next state logic
    always_comb begin
        case (state)
            IDLE: begin
                if (in == 0) // Detected start bit
                    next_state = START;
                else
                    next_state = IDLE;
            end
            
            START: begin
                if (bit_counter == 3'd7)
                    next_state = DATA;
                else
                    next_state = START;
            end
            
            DATA: begin
                if (bit_counter == 3'd7)
                    next_state = STOP;
                else
                    next_state = DATA;
            end
            
            STOP: begin
                if (in == 1) // Detecting stop bit
                    next_state = IDLE;
                else
                    next_state = STOP;
            end
            
            default: next_state = IDLE;
        endcase
    end

    // Counter and shift register logic
    always_ff @(posedge clk) begin
        if (reset) begin
            bit_counter <= 3'd0;
            shift_reg <= 8'd0;
        end
        else begin
            case (state)
                IDLE: begin
                    bit_counter <= 3'd0;
                end
                
                START: begin
                    bit_counter <= bit_counter + 3'd1;
                end
                
                DATA: begin
                    shift_reg <= {in, shift_reg[7:1]};
                    bit_counter <= bit_counter + 3'd1;
                end
                
                STOP: begin
                    if (in == 1) begin
                        bit_counter <= 3'd0;
                    end
                end
            endcase
        end
    end

    // Output logic
    assign done = (state == STOP && in == 1);
    assign out_byte = shift_reg;

endmodule",5.773428,19154
N/A,N/A,-1,44,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// FSM states
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    state_t state, next_state;
    logic [2:0] bit_counter; // To count the received data bits
    logic [7:0] shift_reg;   // Shift register to hold the data byte

    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_counter <= 3'd0;
            shift_reg <= 8'h00;
        end else begin
            state <= next_state;
            if (state == DATA) begin
                bit_counter <= bit_counter + 3'd1;
                shift_reg <= {in, shift_reg[7:1]}; // Shift in the received bit
            end else if (state == STOP) begin
                bit_counter <= 3'd0;
            end
        end
    end

    always_comb begin
        next_state = state;
        done = 1'b0;

        case (state)
            IDLE: begin
                if (in == 1'b0) // Start bit detected
                    next_state = START;
            end

            START: begin
                next_state = DATA;
            end

            DATA: begin
                if (bit_counter == 3'd7)
                    next_state = STOP;
            end

            STOP: begin
                if (in == 1'b1) begin // Stop bit detected, byte received
                    done = 1'b1;
                    next_state = IDLE;
                end
            end

            default: next_state = IDLE;
        endcase
    end

    assign out_byte = done ? shift_reg : 8'hXX; // Valid data only when done

endmodule",3.619346,19539
N/A,N/A,-1,45,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// FSM states
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    state_t state, next_state;
    logic [2:0] bit_counter; // To count the received data bits
    logic [7:0] shift_reg;   // Shift register to store incoming data bits

    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_counter <= 3'd0;
            shift_reg <= 8'h00;
        end else begin
            state <= next_state;
            if (state == DATA) begin
                bit_counter <= bit_counter + 3'd1;
                shift_reg <= {in, shift_reg[7:1]}; // Shift in the received bit
            end else if (state == STOP) begin
                bit_counter <= 3'd0;
            end
        end
    end

    always_comb begin
        next_state = state;
        done = 1'b0;

        case (state)
            IDLE: begin
                if (in == 1'b0) // Start bit detected
                    next_state = START;
            end

            START: begin
                next_state = DATA;
            end

            DATA: begin
                if (bit_counter == 3'd7) // 8 data bits received
                    next_state = STOP;
            end

            STOP: begin
                if (in == 1'b1) begin // Stop bit correct
                    done = 1'b1; // Set done signal
                    next_state = IDLE; // Ready for next byte
                end else begin
                    next_state = IDLE; // Look for start bit again
                end
            end

            default: next_state = IDLE;
        endcase
    end

    assign out_byte = (done) ? shift_reg : 8'hXX; // Valid data if done==1

endmodule",3.888261,19961
N/A,N/A,-1,46,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// FSM states
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    state_t state, next_state;
    logic [2:0] bit_counter; // To track number of received data bits
    logic [7:0] shift_reg;   // To shift in data bits serially

    // State transitions
    always_ff @(posedge clk) begin
        if (reset)
            state <= IDLE;
        else
            state <= next_state;
    end

    // Next state logic
    always_comb begin
        next_state = state; // Default no state change
        done = 0;
        case (state)
            IDLE: begin
                if (in == 0) // Detect start bit
                    next_state = START;
            end
            START: begin
                next_state = DATA;
                bit_counter = 0; // Initialize bit counter for data bits
            end
            DATA: begin
                if (bit_counter == 3'd7)
                    next_state = STOP;
            end
            STOP: begin
                if (in == 1) // Stop bit is correct
                    done = 1;
                next_state = IDLE;
            end
            default: next_state = IDLE;
        endcase
    end

    // Datapath operations
    always_ff @(posedge clk) begin
        if (reset) begin
            shift_reg <= 8'b0;
            bit_counter <= 3'd0;
        end
        else begin
            case (state)
                START: begin
                    // Reset shift register, prepare for shifting
                    shift_reg <= 8'b0;
                end
                DATA: begin
                    // Shift in data bits
                    shift_reg <= {in, shift_reg[7:1]};
                    bit_counter <= bit_counter + 1;
                end
            endcase
        end
    end

    // Assign output
    assign out_byte = shift_reg;

endmodule",4.356425,20394
N/A,N/A,-1,47,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// FSM states
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    state_t state, next_state;
    logic [3:0] bit_counter; // To count up to 10 (1 start, 8 data, 1 stop)
    logic [7:0] shift_reg;   // To hold the 8 data bits

    // State transition logic
    always_ff @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= IDLE;
            bit_counter <= 0;
            shift_reg <= 8'b0;
        end else begin
            state <= next_state;
            if (state == DATA) begin
                shift_reg <= {in, shift_reg[7:1]}; // Shift in each bit
            end
            if (state == DATA || state == START) begin
                bit_counter <= bit_counter + 1;
            end else begin
                bit_counter <= 0;
            end
        end
    end

    // Next state logic
    always_comb begin
        next_state = state;
        done = 0;

        case (state)
            IDLE: begin
                if (in == 0) begin // Start bit detected (active low)
                    next_state = START;
                end
            end

            START: begin
                if (bit_counter == 1) begin // Start bit duration is complete
                    next_state = DATA;
                end
            end

            DATA: begin
                if (bit_counter == 9) begin // 8 data bits received
                    next_state = STOP;
                end
            end

            STOP: begin
                if (in == 1) begin // Stop bit detected (active high)
                    done = 1;
                    next_state = IDLE; // Prepare for next byte
                end else begin
                    next_state = IDLE; // Wait for correct stop bit (resynchronize)
                end
            end
        endcase
    end

    // Output assignment
    assign out_byte = shift_reg;

endmodule",4.249977,20847
N/A,N/A,-1,48,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// FSM states
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    state_t state, next_state;
    logic [2:0] bit_counter; // To count the received data bits
    logic [7:0] byte_shift_reg; // Shift register to store incoming data bits

    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_counter <= 3'd0;
            byte_shift_reg <= 8'b0;
            done <= 1'b0;
            out_byte <= 8'b0;
        end else begin
            state <= next_state;
            case (state)
                IDLE: begin
                    done <= 1'b0;
                    if (!in) // Detecting start bit
                        next_state <= START;
                    else
                        next_state <= IDLE;
                end
                START: begin
                    if (bit_counter == 3'd0) begin // upon start bit completion
                        bit_counter <= 3'd0;
                        next_state <= DATA;
                    end else
                        next_state <= START;
                end
                DATA: begin
                    byte_shift_reg <= {in, byte_shift_reg[7:1]}; // shift in LSB first
                    bit_counter <= bit_counter + 1;
                    if (bit_counter == 3'd7) // all 8 bits collected
                        next_state <= STOP;
                    else
                        next_state <= DATA;
                end
                STOP: begin
                    if (in) begin // expecting a stop bit
                        done <= 1'b1;
                        out_byte <= byte_shift_reg;
                        next_state <= IDLE;
                    end else
                        next_state <= STOP;
                end
            endcase
        end
    end
endmodule",3.688291,21240
N/A,N/A,-1,49,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// FSM states
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;
    
    state_t state, next_state;
    logic [2:0] bit_counter;
    logic [7:0] shift_reg;
    
    // FSM State Transition
    always_ff @(posedge clk) begin
        if (reset)
            state <= IDLE;
        else
            state <= next_state;
    end
    
    // Next state logic
    always_comb begin
        case (state)
            IDLE: begin
                if (in == 0) // Detected start bit
                    next_state = START;
                else
                    next_state = IDLE;
            end
            
            START: begin
                if (bit_counter == 3'd7)
                    next_state = DATA;
                else
                    next_state = START;
            end
            
            DATA: begin
                if (bit_counter == 3'd7)
                    next_state = STOP;
                else
                    next_state = DATA;
            end
            
            STOP: begin
                if (in == 1) // Detecting stop bit
                    next_state = IDLE;
                else
                    next_state = STOP;
            end
            
            default: next_state = IDLE;
        endcase
    end

    // Counter and shift register logic
    always_ff @(posedge clk) begin
        if (reset) begin
            bit_counter <= 3'd0;
            shift_reg <= 8'd0;
        end
        else begin
            case (state)
                IDLE: begin
                    bit_counter <= 3'd0;
                end
                
                START: begin
                    bit_counter <= bit_counter + 3'd1;
                end
                
                DATA: begin
                    shift_reg <= {in, shift_reg[7:1]};
                    bit_counter <= bit_counter + 3'd1;
                end
                
                STOP: begin
                    if (in == 1) begin
                        bit_counter <= 3'd0;
                    end
                end
            endcase
        end
    end

    // Output logic
    assign done = (state == STOP && in == 1);
    assign out_byte = shift_reg;

endmodule",5.416337,21718
N/A,N/A,-1,50,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// FSM states
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;
    
    state_t state, next_state;
    reg [7:0] bit_shift_reg;
    reg [2:0] bit_count;

    // FSM state transition
    always @(posedge clk) begin
        if (reset)
            state <= IDLE;
        else
            state <= next_state;
    end

    // Output logic
    always @(posedge clk) begin
        if (reset) begin
            bit_shift_reg <= 8'b0;
            bit_count <= 3'b0;
        end
        else begin
            case (state)
                IDLE: begin
                    bit_shift_reg <= 8'b0;
                    bit_count <= 3'b0;
                end
                START: begin
                    if (in == 1'b0) begin // Detected a start bit
                        next_state <= DATA;
                    end
                end
                DATA: begin
                    bit_shift_reg <= {in, bit_shift_reg[7:1]};
                    bit_count <= bit_count + 1'b1;
                    if (bit_count == 3'b111) begin
                        next_state <= STOP;
                    end
                end
                STOP: begin
                    if (in == 1'b1) begin // Detected a stop bit
                        done <= 1'b1;
                    end
                    else begin
                        done <= 1'b0;
                        next_state <= IDLE;
                    end
                end
            endcase
        end
    end

    // Next state logic
    always @(*) begin
        next_state = state;
        case (state)
            IDLE: begin
                done = 1'b0;
                if (in == 1'b0) begin // Detected a start bit
                    next_state = START;
                end
            end
            START: begin
                done = 1'b0;
                if (in == 1'b0) begin // Confirm start bit
                    next_state = DATA;
                end
                else begin
                    next_state = IDLE;
                end
            end
            DATA: begin
                done = 1'b0;
                if (bit_count == 3'b111) begin
                    next_state = STOP;
                end
            end
            STOP: begin
                if (in == 1'b1) begin
                    done = 1'b1;
                    next_state = IDLE;
                end
                else begin
                    done = 1'b0;
                end
            end
        endcase
    end

    // Output logic
    assign out_byte = (done) ? bit_shift_reg : 8'b0;

endmodule",6.405845,22309
N/A,N/A,-1,51,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// FSM states
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;
    
    state_t state, next_state;
    logic [2:0] bit_counter;
    logic [7:0] shift_reg;
    
    // FSM state transition
    always_ff @(posedge clk) begin
        if (reset)
            state <= IDLE;
        else
            state <= next_state;
    end
    
    // Next state logic
    always_comb begin
        case (state)
            IDLE: begin
                if (in == 0) // Detect start bit
                    next_state = START;
                else
                    next_state = IDLE;
            end
            START: begin
                next_state = DATA;
            end
            DATA: begin
                if (bit_counter == 3'd7) // All 8 data bits received
                    next_state = STOP;
                else
                    next_state = DATA;
            end
            STOP: begin
                if (in == 1) // Detect stop bit
                    next_state = IDLE;
                else
                    next_state = STOP; // Wait for stop bit if incorrect
            end
            default: next_state = IDLE;
        endcase
    end
    
    // Datapath
    always_ff @(posedge clk) begin
        if (reset) begin
            shift_reg <= 8'b0;
            bit_counter <= 3'b0;
        end
        else begin
            case (state)
                DATA: begin
                    shift_reg <= {in, shift_reg[7:1]}; // Shift in data bits
                    bit_counter <= bit_counter + 1;
                end
                STOP: begin
                    if (in == 1) begin
                        bit_counter <= 3'b0; // Reset for next byte
                    end
                end
                default: begin
                    // No operation
                end
            endcase
        end
    end
    
    // Output logic
    assign out_byte = shift_reg;
    assign done = (state == STOP) && (in == 1); // Only valid when stop bit is correct

endmodule",4.938017,22776
N/A,N/A,-1,52,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// FSM states
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    state_t state, next_state;
    logic [2:0] bit_counter; // To track number of received data bits
    logic [7:0] shift_reg;   // To shift in data bits serially

    // State transition logic
    always_ff @(posedge clk or posedge reset) begin
        if (reset)
            state <= IDLE;
        else
            state <= next_state;
    end

    // Next state logic and bit counter/shift register updates
    always_comb begin
        next_state = state;
        case (state)
            IDLE: begin
                if (in == 0) // Detect start bit
                    next_state = START;
            end
            START: begin
                next_state = DATA;
                bit_counter = 0; // Initialize bit counter for data bits
            end
            DATA: begin
                if (bit_counter == 8) // All data bits received
                    next_state = STOP;
            end
            STOP: begin
                if (in == 1) // Correct stop bit
                    next_state = IDLE;
                else
                    next_state = STOP; // Wait until stop bit is correct
            end
        endcase
    end

    // Shift register and bit counter logic
    always_ff @(posedge clk) begin
        if (state == DATA) begin
            shift_reg <= {in, shift_reg[7:1]}; // Shift in serialized bits
            bit_counter <= bit_counter + 1;
        end
    end

    // Output logic
    assign out_byte = shift_reg;
    assign done = (state == STOP && in == 1); // Data valid when in stop state with correct stop bit

endmodule",4.869249,23175
N/A,N/A,-1,53,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// FSM states
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    state_t state, next_state;
    logic [3:0] bit_counter; // To count bits, including start and stop
    logic [7:0] shift_reg;   // Shift register to store the received byte

    // State transition logic
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_counter <= 0;
        end else begin
            state <= next_state;
            bit_counter <= (state == DATA) ? bit_counter + 1 : 0;
        end
    end

    // Next state and output logic
    always_comb begin
        next_state = state;
        done = 1'b0;
        
        case (state)
            IDLE: begin
                if (in == 1'b0) // Start bit detected
                    next_state = START;
            end
            START: begin
                next_state = DATA;
            end
            DATA: begin
                if (bit_counter == 4'd8) // 8 bits received
                    next_state = STOP;
            end
            STOP: begin
                if (in == 1'b1) begin // Stop bit is correct
                    done = 1'b1; // Byte reception done
                    next_state = IDLE;
                end else begin
                    next_state = STOP; // Wait for a valid stop bit
                end
            end
        endcase
    end
    
    // Datapath: Shift register
    always_ff @(posedge clk) begin
        if (reset) begin
            shift_reg <= 8'd0;
        end else if (state == DATA) begin
            shift_reg <= {in, shift_reg[7:1]}; // Shift in each bit
        end
    end

    assign out_byte = (done) ? shift_reg : 8'bx; // Update output byte when done
endmodule",4.231859,23612
N/A,N/A,-1,54,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// FSM states
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;
    
    state_t state, next_state;
    reg [7:0] bit_shift_reg;
    reg [2:0] bit_count;

    // FSM state transition
    always @(posedge clk) begin
        if (reset)
            state <= IDLE;
        else
            state <= next_state;
    end

    // Output logic
    always @(posedge clk) begin
        if (reset) begin
            bit_shift_reg <= 8'b0;
            bit_count <= 3'b0;
        end
        else begin
            case (state)
                IDLE: begin
                    bit_shift_reg <= 8'b0;
                    bit_count <= 3'b0;
                end
                START: begin
                    // Stay in START state until start bit is detected
                    if (in == 0) begin
                        next_state <= DATA;
                    end
                end
                DATA: begin
                    // Shift in 8 bits of data
                    bit_shift_reg <= {in, bit_shift_reg[7:1]};
                    bit_count <= bit_count + 1'b1;
                    if (bit_count == 3'b111)
                        next_state <= STOP;
                end
                STOP: begin
                    // Check for stop bit
                    if (in == 1) begin
                        next_state <= IDLE;
                        done <= 1'b1;
                        out_byte <= bit_shift_reg;
                    end
                    else begin
                        next_state <= START; // Wait for the next start bit
                    end
                end
            endcase
        end
    end

    // Next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 0)
                    next_state = START;
                else
                    next_state = IDLE;
            end
            START: begin
                if (in == 0)
                    next_state = DATA;
                else
                    next_state = START;
            end
            DATA: begin
                if (bit_count == 3'b111)
                    next_state = STOP;
                else
                    next_state = DATA;
            end
            STOP: begin
                if (in == 1)
                    next_state = IDLE;
                else
                    next_state = START;
            end
            default: next_state = IDLE;
        endcase
    end

    // Done signal logic
    assign done = (state == STOP) && (in == 1);
    
    // Output byte logic
    assign out_byte = (done) ? bit_shift_reg : 8'b0;

endmodule",5.852619,24192
N/A,N/A,-1,55,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// FSM states
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    state_t state, next_state;
    logic [3:0] bit_counter; // To count up to 10 (1 start, 8 data, 1 stop)
    logic [7:0] shift_reg;   // To hold the 8 data bits

    // State transition logic
    always_ff @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= IDLE;
            bit_counter <= 0;
            shift_reg <= 8'b0;
        end else begin
            state <= next_state;
            if (state == DATA) begin
                shift_reg <= {in, shift_reg[7:1]}; // Shift in each bit
            end
            if (state == DATA || state == START) begin
                bit_counter <= bit_counter + 1;
            end else begin
                bit_counter <= 0;
            end
        end
    end

    // Next state logic
    always_comb begin
        next_state = state;
        done = 0;

        case (state)
            IDLE: begin
                if (in == 0) begin // Start bit detected
                    next_state = START;
                end
            end
            START: begin
                if (bit_counter == 1) begin // Move to data once start bit is verified
                    next_state = DATA;
                end
            end
            DATA: begin
                if (bit_counter == 9) begin // After 8 data bits
                    next_state = STOP;
                end
            end
            STOP: begin
                if (in == 1) begin // Stop bit detected
                    done = 1;
                    next_state = IDLE;
                end else begin
                    next_state = IDLE; // Wait for a stop bit
                end
            end
        endcase
    end

    // Output logic
    assign out_byte = (done) ? shift_reg : 8'bx;

endmodule",4.441078,24642
N/A,N/A,-1,56,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// FSM states
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    state_t state, next_state;
    logic [3:0] bit_counter; // To count number of received bits
    logic [7:0] byte_shift_reg; // Shift register to store incoming data bits

    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_counter <= 0;
            done <= 0;
        end else begin
            state <= next_state;

            if (state == DATA) begin
                byte_shift_reg <= {in, byte_shift_reg[7:1]};
                bit_counter <= bit_counter + 1;
            end

            if (state == STOP) begin
                done <= 1;
            end else begin
                done <= 0;
            end
        end
    end

    always_comb begin
        next_state = state; // Default state transition

        case (state)
            IDLE: begin
                if (!in) begin // Detect start bit (active low)
                    next_state = START;
                end
            end

            START: begin
                next_state = DATA;
                bit_counter = 0;
            end

            DATA: begin
                if (bit_counter == 8) begin
                    next_state = STOP;
                end
            end

            STOP: begin
                if (in) begin // Stop bit should be high
                    next_state = IDLE;
                end else begin // If stop bit is not high, wait
                    next_state = STOP;
                end
            end
        endcase
    end

    // Assign the parallel output when the FSM indicates done
    assign out_byte = (done) ? byte_shift_reg : 8'bz;

endmodule",4.936799,25037
N/A,N/A,-1,57,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// FSM states
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    state_t state, next_state;
    logic [2:0] bit_counter; // To track number of received data bits
    logic [7:0] shift_reg;   // To shift in data bits serially

    // State transition logic
    always_ff @(posedge clk or posedge reset) begin
        if (reset)
            state <= IDLE;
        else
            state <= next_state;
    end

    // Next state logic and bit counter/shift register updates
    always_comb begin
        next_state = state;
        case (state)
            IDLE: begin
                if (in == 0) // Detect start bit
                    next_state = START;
            end
            START: begin
                next_state = DATA;
                bit_counter = 0; // Initialize bit counter for data bits
            end
            DATA: begin
                if (bit_counter == 8) // All data bits received
                    next_state = STOP;
            end
            STOP: begin
                if (in == 1) // Correct stop bit
                    next_state = IDLE;
                else
                    next_state = IDLE; // To ensure transition to IDLE even if stop bit is wrong
            end
        endcase
    end

    // Shift register and bit count update logic
    always_ff @(posedge clk) begin
        if (state == DATA) begin
            shift_reg <= {in, shift_reg[7:1]}; // Shift in the incoming bit
            bit_counter <= bit_counter + 1;
        end
        else if (state == START || state == STOP) begin
            bit_counter <= 0; // Reset counter when not in DATA state
        end
    end

    // Output logic: done signal and parallel output of received byte
    assign done = (state == STOP && in == 1);
    assign out_byte = done ? shift_reg : 8'bx; // Output valid data on successful byte receipt

endmodule",4.240846,25491
N/A,N/A,-1,58,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// FSM states
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    state_t state, next_state;
    logic [2:0] bit_counter; // To track number of received data bits
    logic [7:0] shift_reg;   // To shift in data bits serially

    // State transition logic
    always_ff @(posedge clk or posedge reset) begin
        if (reset)
            state <= IDLE;
        else
            state <= next_state;
    end

    // Next state logic and bit counter/shift register updates
    always_comb begin
        next_state = state;
        done = 0;

        case (state)
            IDLE: begin
                if (in == 0)  // Detecting start bit
                    next_state = START;
            end
            START: begin
                next_state = DATA;
                bit_counter = 0;
            end
            DATA: begin
                shift_reg = {in, shift_reg[7:1]}; // Shift data in
                if (bit_counter == 7)
                    next_state = STOP;
                bit_counter = bit_counter + 1;
            end
            STOP: begin
                if (in == 1) begin // Check for stop bit
                    done = 1;
                    next_state = IDLE;
                end else begin
                    next_state = STOP; // Wait for stop bit
                end
            end
        endcase
    end

    // Output assignment
    assign out_byte = done ? shift_reg : 8'bz; // Use high impedance for don't-care

endmodule",3.943723,25850
N/A,N/A,-1,59,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// FSM states
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;
    
    state_t state, next_state;
    reg [7:0] bit_shift_reg;
    reg [3:0] bit_count; // Count bits from 0 to 7

    // Synchronous logic for state transitions and outputs
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
            bit_shift_reg <= 8'd0;
        end else begin
            state <= next_state;

            if (state == DATA) begin
                bit_shift_reg <= {in, bit_shift_reg[7:1]}; // Shift in the incoming bits
                bit_count <= bit_count + 1;
            end

            if (next_state == IDLE) begin
                bit_count <= 0;
                bit_shift_reg <= 8'd0;
            end
        end
    end

    // Combinational logic for next state
    always_comb begin
        next_state = state; // Default: stay in the current state
        case (state)
            IDLE: begin
                if (in == 0) next_state = START; // Detect start bit (0)
            end

            START: begin
                next_state = DATA; // Transition to DATA state
            end

            DATA: begin
                if (bit_count == 8) next_state = STOP; // All data bits received
            end

            STOP: begin
                if (in == 1) next_state = IDLE; // Detect STOP bit (1)
                else next_state = START; // If not stop, look for a new start bit
            end

            default: next_state = IDLE; // Default case for safety
        endcase
    end

    // Output logic
    assign done = (state == STOP) && (in == 1);
    assign out_byte = (done) ? bit_shift_reg : 8'bx; // Output valid data on successful STOP bit

endmodule",4.861785,26304
N/A,N/A,-1,60,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// FSM states
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    state_t state, next_state;
    logic [3:0] bit_counter; // To count bits, including start and stop
    logic [7:0] shift_reg;   // Shift register to store the byte

    // State transitions
    always_ff @(posedge clk) begin
        if (reset)
            state <= IDLE;
        else
            state <= next_state;
    end

    // Next state logic
    always_comb begin
        next_state = state; // Default no state change
        done = 0;
        case (state)
            IDLE: begin
                if (in == 0) // Detect start bit
                    next_state = START;
            end
            START: begin
                next_state = DATA;
                bit_counter = 0; // Initialize bit counter for data bits
            end
            DATA: begin
                if (bit_counter == 8) // All data bits received
                    next_state = STOP;
            end
            STOP: begin
                if (in == 1) begin // Detect stop bit
                    done = 1;
                    next_state = IDLE;
                end
            end
            default: next_state = IDLE;
        endcase
    end

    // Data path and bit counting
    always_ff @(posedge clk) begin
        if (state == DATA) begin
            shift_reg <= {in, shift_reg[7:1]}; // Shift in the serial data
            bit_counter <= bit_counter + 1;
        end
    end

    // Output logic
    assign out_byte = (done) ? shift_reg : 8'bx;

endmodule",4.159633,26688
N/A,N/A,-1,61,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// FSM states
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    state_t state, next_state;
    logic [3:0] bit_counter; // To count number of received bits
    logic [7:0] byte_shift_reg; // Shift register to store incoming data bits

    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_counter <= 0;
            done <= 0;
        end else begin
            state <= next_state;

            if (state == DATA) begin
                byte_shift_reg <= {in, byte_shift_reg[7:1]};
                bit_counter <= bit_counter + 1;
            end

            if (state == STOP) begin
                done <= 1;
            end else begin
                done <= 0;
            end
        end
    end

    always_comb begin
        next_state = state; // Default state transition

        case (state)
            IDLE: begin
                if (!in) begin // Detect start bit (active low)
                    next_state = START;
                end
            end

            START: begin
                next_state = DATA;
                bit_counter = 0;
            end

            DATA: begin
                if (bit_counter == 8) begin
                    next_state = STOP;
                end
            end

            STOP: begin
                if (in) begin // Stop bit should be high
                    next_state = IDLE;
                end else begin // If stop bit is not high, wait
                    next_state = STOP;
                end
            end
        endcase
    end

    // Assign the parallel output when the FSM is in done state
    assign out_byte = (done) ? byte_shift_reg : 8'bx;

endmodule",4.001662,27085
N/A,N/A,-1,62,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// FSM states
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;
    
    state_t state, next_state;
    logic [2:0] bit_counter;
    logic [7:0] shift_reg;
    
    // FSM state transition
    always_ff @(posedge clk) begin
        if (reset)
            state <= IDLE;
        else
            state <= next_state;
    end
    
    // Next state logic
    always_comb begin
        case (state)
            IDLE: begin
                if (in == 0) // Detect start bit
                    next_state = START;
                else
                    next_state = IDLE;
            end
            START: begin
                next_state = DATA;
            end
            DATA: begin
                if (bit_counter == 3'd7) // All 8 data bits received
                    next_state = STOP;
                else
                    next_state = DATA;
            end
            STOP: begin
                if (in == 1) // Detect stop bit
                    next_state = IDLE;
                else
                    next_state = STOP; // Wait for stop bit if incorrect
            end
            default: next_state = IDLE;
        endcase
    end
    
    // Datapath control logic
    always_ff @(posedge clk) begin
        if (reset) begin
            bit_counter <= 3'd0;
            shift_reg <= 8'd0;
        end else begin
            case (state)
                DATA: begin
                    shift_reg <= {in, shift_reg[7:1]}; // Shift in data bits
                    bit_counter <= bit_counter + 1;
                end
                STOP: begin
                    if (in == 1) begin
                        bit_counter <= 3'd0; // Reset for next byte
                    end
                end
                default: begin
                    // No operation
                end
            endcase
        end
    end
    
    // Output logic
    assign out_byte = shift_reg;
    assign done = (state == STOP) && (in == 1); // Only valid when stop bit is correct

endmodule",5.011246,27552
N/A,N/A,-1,63,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// FSM states
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;
    
    state_t state, next_state;
    logic [2:0] bit_counter;

    // Register to hold the data bits
    logic [7:0] data_reg;
    
    // Next state logic
    always_comb begin
        case (state)
            IDLE: begin
                if (in == 1'b0)
                    next_state = START;
                else
                    next_state = IDLE;
            end

            START: begin
                next_state = DATA;
            end

            DATA: begin
                if (bit_counter == 3'd7)
                    next_state = STOP;
                else
                    next_state = DATA;
            end
            
            STOP: begin
                if (in == 1'b1)
                    next_state = IDLE;
                else
                    next_state = DATA; // Wait until stop bit found.
            end
            
            default: next_state = IDLE;
        endcase
    end

    // State update
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_counter <= 3'b0;
        end else begin
            state <= next_state;
            if (state == DATA)
                bit_counter <= bit_counter + 1;
            else
                bit_counter <= 3'b0;
        end
    end

    // Datapath operations
    always_ff @(posedge clk) begin
        if (state == IDLE || reset) begin
            data_reg <= 8'b0;
        end else if (state == DATA && next_state == DATA) begin
            data_reg <= {in, data_reg[7:1]};  // Shift in the bit from LSB to MSB
        end
    end

    assign out_byte = (state == STOP && next_state == IDLE) ? data_reg : 8'bx;
    assign done = (state == STOP && next_state == IDLE);

endmodule",4.0222,27996
N/A,N/A,-1,64,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// FSM states
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;
    
    state_t state, next_state;
    logic [2:0] bit_counter;
    logic [7:0] shift_reg;
    
    // FSM state transition
    always_ff @(posedge clk) begin
        if (reset)
            state <= IDLE;
        else
            state <= next_state;
    end
    
    // Next state logic
    always_comb begin
        case (state)
            IDLE: begin
                if (in == 0) // Detect start bit
                    next_state = START;
                else
                    next_state = IDLE;
            end
            START: begin
                next_state = DATA;
            end
            DATA: begin
                if (bit_counter == 3'd7) // All 8 data bits received
                    next_state = STOP;
                else
                    next_state = DATA;
            end
            STOP: begin
                if (in == 1) // Detect stop bit
                    next_state = IDLE;
                else
                    next_state = STOP; // Wait for stop bit if incorrect
            end
            default: next_state = IDLE;
        endcase
    end
    
    // Datapath
    always_ff @(posedge clk) begin
        if (reset) begin
            shift_reg <= 8'b0;
            bit_counter <= 3'b0;
        end
        else begin
            case (state)
                DATA: begin
                    shift_reg <= {in, shift_reg[7:1]}; // Shift in data bits
                    bit_counter <= bit_counter + 1;
                end
                STOP: begin
                    if (in == 1) begin
                        bit_counter <= 3'b0; // Reset for next byte
                    end
                end
                default: begin
                    // No operation
                end
            endcase
        end
    end
    
    // Output logic
    assign out_byte = shift_reg;
    assign done = (state == STOP) && (in == 1); // Only valid when stop bit is correct

endmodule",4.702599,28463
N/A,N/A,-1,65,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// FSM states
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;
    
    state_t state, next_state;
    logic [2:0] bit_counter;

    // Register to hold the data bits
    logic [7:0] data_reg;
    
    // Next state logic
    always_comb begin
        case (state)
            IDLE: begin
                if (in == 1'b0)
                    next_state = START;
                else
                    next_state = IDLE;
            end

            START: begin
                next_state = DATA;
            end

            DATA: begin
                if (bit_counter == 3'd7)
                    next_state = STOP;
                else
                    next_state = DATA;
            end
            
            STOP: begin
                if (in == 1'b1)
                    next_state = IDLE;
                else
                    next_state = DATA; // Wait until stop bit found.
            end
            
            default: next_state = IDLE;
        endcase
    end

    // State update
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_counter <= 3'b0;
        end else begin
            state <= next_state;
            if (state == DATA)
                bit_counter <= bit_counter + 1;
            else
                bit_counter <= 3'b0;
        end
    end

    // Datapath operations
    always_ff @(posedge clk) begin
        if (state == IDLE || reset) begin
            data_reg <= 8'b0;
        end else if (state == DATA && next_state == DATA) begin
            data_reg <= {in, data_reg[7:1]};  // Shift in the bit from LSB to MSB
        end
    end

    assign out_byte = (state == STOP && next_state == IDLE) ? data_reg : 8'b0;
    assign done = (state == STOP && next_state == IDLE);

endmodule",4.514165,28907
N/A,N/A,-1,66,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// FSM states
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;
    
    state_t state, next_state;
    logic [2:0] bit_counter;
    logic [7:0] shift_reg;
    
    // FSM state transition
    always_ff @(posedge clk) begin
        if (reset)
            state <= IDLE;
        else
            state <= next_state;
    end
    
    // Next state logic
    always_comb begin
        case (state)
            IDLE: begin
                if (in == 0) // Detected start bit
                    next_state = START;
                else
                    next_state = IDLE;
            end
            
            START: begin
                if (in == 0) // Confirm start bit remains low
                    next_state = DATA;
                else
                    next_state = IDLE;
            end
            
            DATA: begin
                if (bit_counter == 3'b111) // All 8 bits received
                    next_state = STOP;
                else
                    next_state = DATA;
            end
            
            STOP: begin
                if (in == 1) // Detected stop bit
                    next_state = IDLE;
                else
                    next_state = DATA; // Incorrect stop bit, wait for a proper stop
            end
            
            default: next_state = IDLE;
        endcase
    end
    
    // FSM output logic
    always_ff @(posedge clk) begin
        if (reset) begin
            bit_counter <= 3'b000;
            shift_reg <= 8'b0;
        end
        else begin
            case (state)
                IDLE: begin
                    bit_counter <= 3'b000;
                end
                
                START: begin
                    bit_counter <= 3'b000;
                end
                
                DATA: begin
                    shift_reg <= {in, shift_reg[7:1]};
                    bit_counter <= bit_counter + 1;
                end
                
                STOP: begin
                    // Reset bit_counter here if needed
                end
            endcase
        end
    end
    
    assign out_byte = shift_reg;
    assign done = (state == STOP) && (in == 1);

endmodule",5.499376,29385
N/A,N/A,-1,67,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// FSM states
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;
    
    state_t state, next_state;
    reg [2:0] bit_counter;
    reg [7:0] shift_reg;
    
    // FSM state transition
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_counter <= 0;
            shift_reg <= 8'b0;
        end else begin
            state <= next_state;
            if (state == DATA) begin
                shift_reg <= {in, shift_reg[7:1]};  // Shift in the incoming bit
                bit_counter <= bit_counter + 1;
            end else if (state == STOP) begin
                bit_counter <= 0; // Reset counter after stop bit
            end
        end
    end
    
    // FSM next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 0)  // Start bit detected
                    next_state = START;
                else
                    next_state = IDLE;
            end
            
            START: begin
                next_state = DATA;  // Move to DATA state after start bit
            end
            
            DATA: begin
                if (bit_counter == 7)
                    next_state = STOP;  // Collect 8 bits, then to STOP
                else
                    next_state = DATA;
            end
            
            STOP: begin
                if (in == 1)  // Stop bit detected
                    next_state = IDLE; // Return to IDLE after full byte
                else
                    next_state = START; // Look for start bit again
            end
            
            default: next_state = IDLE;
        endcase
    end

    // Output logic
    assign done = (state == STOP) && (in == 1);  // Done if state is STOP and stop bit is correct
    assign out_byte = (done) ? shift_reg : 8'bx; // Output valid byte on successful reception

endmodule",5.813828,29838
N/A,N/A,-1,68,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// FSM states
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    state_t state, next_state;
    logic [2:0] bit_counter; // To track number of received data bits
    logic [7:0] shift_reg;   // To shift in data bits serially

    // State transitions
    always_ff @(posedge clk) begin
        if (reset)
            state <= IDLE;
        else
            state <= next_state;
    end

    // Next state logic
    always_comb begin
        next_state = state; // Default no state change
        done = 0;
        case (state)
            IDLE: begin
                if (in == 0) // Detect start bit
                    next_state = START;
            end
            START: begin
                next_state = DATA;
                bit_counter = 0; // Initialize bit counter for data bits
            end
            DATA: begin
                if (bit_counter == 3'd7)
                    next_state = STOP;
            end
            STOP: begin
                if (in == 1) begin // Detect stop bit
                    done = 1;
                    next_state = IDLE;
                end else begin
                    // Wait until a stop bit is detected before restarting
                    next_state = STOP;
                end
            end
        endcase
    end

    // Datapath
    always_ff @(posedge clk) begin
        if (reset) begin
            shift_reg <= 8'b0;
            bit_counter <= 3'b0;
        end else if (state == DATA) begin
            shift_reg <= {in, shift_reg[7:1]}; // Shift in data bits
            bit_counter <= bit_counter + 1;
        end
    end

    // Output logic
    assign out_byte = shift_reg; // Output the received byte

endmodule",3.878616,30253
N/A,N/A,-1,69,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// FSM states
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    state_t state, next_state;
    logic [2:0] bit_counter; // To count the received data bits
    logic [7:0] shift_reg;   // Shift register to store incoming data bits

    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_counter <= 3'd0;
            shift_reg <= 8'd0;
        end else begin
            state <= next_state;
            if (state == DATA) begin
                bit_counter <= bit_counter + 3'd1;
                shift_reg <= {in, shift_reg[7:1]}; // Shift in the received bit
            end else if (state == STOP) begin
                bit_counter <= 3'd0;
            end
        end
    end

    always_comb begin
        next_state = state;
        done = 1'b0;

        case (state)
            IDLE: begin
                if (in == 1'b0) // Start bit detected
                    next_state = START;
            end

            START: begin
                next_state = DATA;
            end

            DATA: begin
                if (bit_counter == 3'd7)
                    next_state = STOP;
            end

            STOP: begin
                if (in == 1'b1) begin // Stop bit detected, byte received
                    done = 1'b1;
                    next_state = IDLE;
                end
            end
        endcase
    end
    
    assign out_byte = done ? shift_reg : 8'd0; // Output latch the shift register when done is asserted

endmodule",3.507184,30633
N/A,N/A,-1,70,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// FSM states
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;
    
    state_t state, next_state;
    reg [7:0] bit_shift_reg;
    reg [2:0] bit_count;
    reg stop_bit;

    // State transitions
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
        end else begin
            state <= next_state;
        end
    end
    
    // Next state logic
    always_comb begin
        next_state = state;
        case(state)
            IDLE: begin
                if (in == 0) // Detect the start bit (0)
                    next_state = START;
            end
            
            START: begin
                next_state = DATA;  // Transition to data state
            end
            
            DATA: begin
                if (bit_count == 7) // All 8 bits received
                    next_state = STOP;
            end
            
            STOP: begin
                if (in == 1) // Check for stop bit (1)
                    next_state = IDLE;
            end
        endcase
    end
    
    // Datapath handling
    always_ff @(posedge clk) begin
        if (reset) begin
            bit_shift_reg <= 8'b0;
            bit_count <= 3'b0;
            done <= 1'b0;
            stop_bit <= 1'b0;
        end else begin
            case(state)
                IDLE: begin
                    bit_shift_reg <= 8'b0;
                    bit_count <= 3'b0;
                    done <= 1'b0;
                end
                
                START: begin
                    done <= 1'b0;
                end
                
                DATA: begin
                    bit_shift_reg <= {in, bit_shift_reg[7:1]}; // Shift in the received bit
                    bit_count <= bit_count + 1;
                end
                
                STOP: begin
                    stop_bit <= in;
                    if (in == 1) begin
                        done <= 1'b1;
                        out_byte <= bit_shift_reg; // Output the valid byte
                    end else begin
                        done <= 1'b0;
                    end
                end
            endcase
        end
    end
endmodule",4.689185,31127
N/A,N/A,-1,71,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// FSM states
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    state_t state, next_state;
    logic [3:0] bit_counter; // To count bits, including start and stop
    logic [7:0] shift_reg;   // Shift register to store the received byte

    // State transition logic
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_counter <= 0;
        end else begin
            state <= next_state;
            bit_counter <= (state == DATA) ? bit_counter + 1 : 0;
        end
    end

    // Next state and output logic
    always_comb begin
        next_state = state;
        done = 1'b0;
        
        case (state)
            IDLE: begin
                if (in == 1'b0) // Start bit detected
                    next_state = START;
            end
            START: begin
                next_state = DATA;
            end
            DATA: begin
                if (bit_counter == 4'd8) // 8 bits received
                    next_state = (in == 1'b1) ? STOP : IDLE; // Check for valid stop bit
            end
            STOP: begin
                done = 1'b1;
                next_state = (in == 1'b1) ? IDLE : START; // Stay in stop until in returns to idle
            end
        endcase
    end

    // Shift register logic
    always_ff @(posedge clk) begin
        if (reset) begin
            shift_reg <= 8'b0;
        end else if (state == DATA) begin
            shift_reg <= {in, shift_reg[7:1]};
        end
    end

    // Output logic
    assign out_byte = (done) ? shift_reg : 8'bx;

endmodule",3.554371,31548
N/A,N/A,-1,72,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// FSM states
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;
    
    state_t state, next_state;
    reg [2:0] bit_counter;
    reg [7:0] shift_reg;
    
    // FSM state transition
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_counter <= 0;
            shift_reg <= 8'b0;
        end else begin
            state <= next_state;
            if (state == DATA) begin
                shift_reg <= {in, shift_reg[7:1]};  // Shift in the incoming bit
                bit_counter <= bit_counter + 1;
            end
        end
    end
    
    // FSM next state logic
    always @* begin
        next_state = state;
        done = 0;
        
        case (state)
            IDLE: begin
                if (!in)  // Detect the start bit
                    next_state = START;
            end
            
            START: begin
                next_state = DATA;  // Go to data bit collection
            end
            
            DATA: begin
                if (bit_counter == 7)
                    next_state = STOP;  // Move to stop bit check when all data bits are received
            end
            
            STOP: begin
                if (in) begin  // Check for the stop bit
                    next_state = IDLE;
                    done = 1;  // Set done if the byte is received correctly
                end else begin
                    next_state = START;  // If stop bit is incorrect, wait for the next start bit
                end
            end
        endcase
    end
    
    // Output data byte
    assign out_byte = shift_reg;
    
endmodule",3.936877,31937
N/A,N/A,-1,73,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// FSM states
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    state_t state, next_state;
    logic [2:0] bit_counter; // To count the received data bits
    logic [7:0] shift_reg;   // Shift register to store incoming data bits

    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_counter <= 3'd0;
            shift_reg <= 8'h00;
        end else begin
            state <= next_state;
            if (state == DATA) begin
                bit_counter <= bit_counter + 3'd1;
                shift_reg <= {in, shift_reg[7:1]}; // Shift in the received bit
            end else if (state == STOP) begin
                bit_counter <= 3'd0;
            end
        end
    end

    always_comb begin
        next_state = state;
        done = 1'b0;

        case (state)
            IDLE: begin
                if (in == 1'b0) // Start bit detected
                    next_state = START;
            end

            START: begin
                next_state = DATA;
            end

            DATA: begin
                if (bit_counter == 3'd7) // 8 data bits received
                    next_state = STOP;
            end

            STOP: begin
                if (in == 1'b1) begin // Stop bit detected
                    done = 1'b1; // Set done signal
                    next_state = IDLE; // Ready for next byte
                end
            end
        endcase
    end

    assign out_byte = (done) ? shift_reg : 8'h00;

endmodule",4.698235,32323
N/A,N/A,-1,74,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// FSM states
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    state_t state, next_state;
    logic [2:0] bit_counter; // To count the received data bits
    logic [7:0] byte_shift_reg; // Shift register to store incoming data bits

    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_counter <= 3'd0;
            byte_shift_reg <= 8'b0;
        end else begin
            state <= next_state;
        end
    end

    always_comb begin
        next_state = state;
        case (state)
            IDLE: begin
                if (!in)  // Start bit detected
                    next_state = START;
            end
            START: begin
                next_state = DATA;
                bit_counter = 3'd0;
            end
            DATA: begin
                if (bit_counter < 3'd7)
                    next_state = DATA;
                else
                    next_state = STOP;
            end
            STOP: begin
                if (in) // Stop bit is correct
                    next_state = IDLE;
                else
                    next_state = STOP; // Wait for the valid stop bit
            end
        endcase
    end

    always_ff @(posedge clk) begin
        if (state == DATA) begin
            byte_shift_reg <= {in, byte_shift_reg[7:1]}; // Shift in new bit
            bit_counter <= bit_counter + 3'd1;
        end
    end

    assign out_byte = (state == STOP && in) ? byte_shift_reg : 8'b0;
    assign done = (state == STOP && in);

endmodule",4.686751,32708
N/A,N/A,-1,75,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// FSM states
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;
    
    state_t state, next_state;
    reg [7:0] bit_shift_reg;
    reg [3:0] bit_count; // Counts bits from 0 to 7

    // Synchronous logic for state transitions and outputs
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_count <= 0;
            bit_shift_reg <= 8'd0;
        end else begin
            state <= next_state;

            if (state == DATA) begin
                bit_shift_reg <= {in, bit_shift_reg[7:1]}; // Shift in the incoming bits
                bit_count <= bit_count + 1;
            end

            if (next_state == IDLE) begin
                bit_count <= 0;
                bit_shift_reg <= 8'd0;
            end
        end
    end

    // Combinational logic for next state
    always_comb begin
        next_state = state; // Default: stay in the current state
        case (state)
            IDLE: begin
                if (in == 0) next_state = START; // Detect start bit (0)
            end

            START: begin
                next_state = DATA; // Transition to DATA state
            end

            DATA: begin
                if (bit_count == 8) next_state = STOP; // All data bits received
            end

            STOP: begin
                if (in == 1) next_state = IDLE; // Check for the stop bit (1)
            end
        endcase
    end

    // Output logic
    assign done = (state == STOP) && (in == 1);
    assign out_byte = (done) ? bit_shift_reg : 8'hxx; // Valid when done is high

endmodule",4.200244,33128
N/A,N/A,-1,76,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// FSM states
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;
    
    state_t state, next_state;
    logic [2:0] bit_counter;
    logic [7:0] shift_reg;
    
    // FSM state transition
    always_ff @(posedge clk) begin
        if (reset)
            state <= IDLE;
        else
            state <= next_state;
    end
    
    // Next state logic
    always_comb begin
        case (state)
            IDLE: begin
                if (in == 0) // Detected start bit
                    next_state = START;
                else
                    next_state = IDLE;
            end
            
            START: begin
                if (bit_counter == 3'd7)
                    next_state = DATA;
                else
                    next_state = START;
            end
            
            DATA: begin
                if (bit_counter == 3'd7)
                    next_state = STOP;
                else
                    next_state = DATA;
            end
            
            STOP: begin
                if (in == 1) // Detecting stop bit
                    next_state = IDLE;
                else
                    next_state = STOP;
            end
            
            default: next_state = IDLE;
        endcase
    end

    // Counter and shift register logic
    always_ff @(posedge clk) begin
        if (reset) begin
            bit_counter <= 3'd0;
            shift_reg <= 8'd0;
        end
        else begin
            case (state)
                IDLE: begin
                    bit_counter <= 3'd0;
                end
                
                START: begin
                    bit_counter <= bit_counter + 3'd1;
                end
                
                DATA: begin
                    shift_reg <= {in, shift_reg[7:1]};
                    bit_counter <= bit_counter + 3'd1;
                end
                
                STOP: begin
                    if (in == 1) begin
                        bit_counter <= 3'd0;
                    end
                end
            endcase
        end
    end

    // Output logic
    assign done = (state == STOP && in == 1);
    assign out_byte = shift_reg;

endmodule",4.546332,33606
N/A,N/A,-1,77,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// FSM states
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;
    
    state_t state, next_state;
    reg [7:0] bit_shift_reg;
    reg [2:0] bit_count;

    // FSM state transition
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_shift_reg <= 8'b0;
            bit_count <= 3'd0;
        end else begin
            state <= next_state;
            if (state == DATA) begin
                bit_shift_reg <= {in, bit_shift_reg[7:1]};
                bit_count <= bit_count + 1;
            end else begin
                bit_count <= 3'd0;
            end
        end
    end

    // FSM next state logic
    always @(*) begin
        case (state)
            IDLE: begin
                if (in == 1'b0) // Start bit
                    next_state = START;
                else
                    next_state = IDLE;
            end
            
            START: begin
                next_state = DATA;
            end
            
            DATA: begin
                if (bit_count == 3'd7) // 8 bits received
                    next_state = STOP;
                else
                    next_state = DATA;
            end
            
            STOP: begin
                if (in == 1'b1) // Stop bit
                    next_state = IDLE;
                else
                    next_state = STOP;
            end
            
            default: begin
                next_state = IDLE;
            end
        endcase
    end

    // Output logic
    assign done = (state == STOP) && (in == 1'b1);
    assign out_byte = bit_shift_reg;

endmodule",4.19757,33994
N/A,N/A,-1,78,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// FSM states
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    state_t state, next_state;
    logic [2:0] bit_counter; // To count the received data bits
    logic [7:0] shift_reg;   // Shift register to store incoming data bits

    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_counter <= 3'd0;
            shift_reg <= 8'h00;
        end else begin
            state <= next_state;
            if (state == DATA) begin
                shift_reg <= {in, shift_reg[7:1]};
                bit_counter <= bit_counter + 1;
            end
        end
    end

    always_comb begin
        next_state = state;
        done = 1'b0;

        case (state)
            IDLE: begin
                if (in == 1'b0) // Start bit detected
                    next_state = START;
            end

            START: begin
                next_state = DATA;
            end

            DATA: begin
                if (bit_counter == 3'd7)
                    next_state = STOP;
            end

            STOP: begin
                if (in == 1'b1) begin  // Stop bit detected
                    done = 1'b1;
                    next_state = IDLE;
                end else begin
                    next_state = STOP; // Stay in STOP state if stop bit not detected
                end
            end

            default: begin
                next_state = IDLE;
            end
        endcase
    end

    assign out_byte = shift_reg;

endmodule",3.264335,34361
N/A,N/A,-1,79,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// FSM states
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;
    
    state_t state, next_state;
    logic [2:0] bit_counter;

    // Register to hold the data bits
    logic [7:0] data_reg;
    
    // Next state logic
    always_comb begin
        case (state)
            IDLE: begin
                if (in == 1'b0)
                    next_state = START;
                else
                    next_state = IDLE;
            end

            START: begin
                next_state = DATA;
            end

            DATA: begin
                if (bit_counter == 3'd7)
                    next_state = STOP;
                else
                    next_state = DATA;
            end
            
            STOP: begin
                if (in == 1'b1)
                    next_state = IDLE;
                else
                    next_state = STOP;
            end
        endcase
    end

    // State transition
    always_ff @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= IDLE;
            bit_counter <= 3'd0;
        end else begin
            state <= next_state;
            if (state == DATA) begin
                bit_counter <= bit_counter + 3'd1;
                data_reg <= {in, data_reg[7:1]}; // Shift left, input LSb
            end else if (state == STOP) begin
                bit_counter <= 3'd0;
            end
        end
    end

    // Output logic
    assign out_byte = (state == STOP && in == 1'b1) ? data_reg : 8'bx;
    assign done = (state == STOP && in == 1'b1);

endmodule",3.944463,34751
N/A,N/A,-1,80,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// FSM states
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;
    
    state_t state, next_state;
    logic [2:0] bit_counter;

    // Register to hold the data bits
    logic [7:0] data_reg;
    
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_counter <= 3'd0;
            data_reg <= 8'd0;
        end else begin
            state <= next_state;

            if (state == DATA)
                bit_counter <= bit_counter + 3'd1;
            else
                bit_counter <= 3'd0;

            if (state == DATA)
                data_reg <= {in, data_reg[7:1]};
        end
    end
    
    always_comb begin
        case (state)
            IDLE: next_state = in ? IDLE : START;   // Wait for a start bit (0)
            START: next_state = DATA;               // Move to DATA state once start bit is seen
            DATA: next_state = (bit_counter == 3'd7) ? STOP : DATA;   // Shift 8 bits
            STOP: next_state = in ? IDLE : START;   // Stop bit must be 1, go back to IDLE if true. Else look for start bit.
            default: next_state = IDLE;
        endcase
    end

    assign done = (state == STOP) && in;
    assign out_byte = data_reg;
    
endmodule",3.65717,35094
N/A,N/A,-1,81,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// FSM states
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    state_t state, next_state;
    logic [3:0] bit_counter; // To count up to 10 (1 start, 8 data, 1 stop)
    logic [7:0] shift_reg;   // Data shift register
    
    // State update logic
    always_ff @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= IDLE;
        end else begin
            state <= next_state;
        end
    end

    // Next state logic
    always_comb begin
        next_state = state; // Default to holding state
        case (state)
            IDLE: if (in == 0) next_state = START; // Start bit detected
            START: if (bit_counter == 0) next_state = DATA; // First data bit
            DATA: if (bit_counter == 8) next_state = STOP; // After 8 bits
            STOP: if (in == 1) next_state = IDLE; // Stop bit detected, return to IDLE
        endcase
    end

    // Bit counter and shift register logic
    always_ff @(posedge clk) begin
        if (reset) begin
            bit_counter <= 4'd0;
            shift_reg <= 8'd0;
        end else begin
            case (state)
                IDLE: begin
                    bit_counter <= 4'd0;
                    shift_reg <= 8'd0;
                end
                START: begin
                    if (bit_counter < 4'd1)
                        bit_counter <= bit_counter + 1;
                end
                DATA: begin
                    shift_reg <= {in, shift_reg[7:1]}; // Shift received bit into register
                    bit_counter <= bit_counter + 1;
                end
                STOP: begin
                    bit_counter <= 4'd0;
                end
            endcase
        end
    end

    // Output logic
    assign out_byte = shift_reg;
    assign done = (state == STOP && in == 1); // done when stop bit is detected

endmodule",4.60022,35572
N/A,N/A,-1,82,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// FSM states
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;
    
    state_t state, next_state;
    logic [2:0] bit_counter;
    logic [7:0] shift_reg;
    
    // FSM state transition
    always_ff @(posedge clk) begin
        if (reset)
            state <= IDLE;
        else
            state <= next_state;
    end
    
    // Next state logic
    always_comb begin
        case (state)
            IDLE: begin
                if (in == 0) // Detected start bit
                    next_state = START;
                else
                    next_state = IDLE;
            end
            
            START: begin
                if (in == 0) // Confirm start bit remains low
                    next_state = DATA;
                else
                    next_state = IDLE;
            end
            
            DATA: begin
                if (bit_counter == 3'b111) // All 8 bits received
                    next_state = STOP;
                else
                    next_state = DATA;
            end
            
            STOP: begin
                if (in == 1) // Detected stop bit
                    next_state = IDLE;
                else
                    next_state = STOP; // Wait until stop bit is correct
            end
            
            default: next_state = IDLE;
        endcase
    end
    
    // Bit counter and shift register
    always_ff @(posedge clk) begin
        if (reset) begin
            bit_counter <= 3'b0;
            shift_reg <= 8'b0;
        end
        else if (state == DATA) begin
            shift_reg <= {in, shift_reg[7:1]}; // Shift in LSB first
            bit_counter <= bit_counter + 1;
        end
        else if (state != DATA) begin
            bit_counter <= 3'b0; // Reset counter if not receiving data
        end
    end
    
    // Output logic
    assign done = (state == STOP) && (in == 1);
    assign out_byte = (done) ? shift_reg : 8'bxxxx_xxxx;

endmodule",4.870407,36040
N/A,N/A,-1,83,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// FSM states
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;
    
    state_t state, next_state;
    logic [2:0] bit_counter;
    logic [7:0] shift_reg;
    
    // FSM State Transition
    always_ff @(posedge clk) begin
        if (reset)
            state <= IDLE;
        else
            state <= next_state;
    end
    
    // Next state logic
    always_comb begin
        case (state)
            IDLE: begin
                if (in == 0) // Detected start bit
                    next_state = START;
                else
                    next_state = IDLE;
            end
            
            START: begin
                if (in == 0) // Confirm start bit remains low
                    next_state = DATA;
                else
                    next_state = IDLE;
            end
            
            DATA: begin
                if (bit_counter == 3'b111) // All 8 bits received
                    next_state = STOP;
                else
                    next_state = DATA;
            end
            
            STOP: begin
                if (in == 1) // Detected stop bit
                    next_state = IDLE;
                else
                    next_state = STOP; // Wait until stop bit is correct
            end
            
            default: next_state = IDLE;
        endcase
    end
    
    // Bit counter and shift register
    always_ff @(posedge clk) begin
        if (reset) begin
            bit_counter <= 3'b0;
            shift_reg <= 8'b0;
        end
        else if (state == DATA) begin
            shift_reg <= {in, shift_reg[7:1]}; // Shift in LSB first
            bit_counter <= bit_counter + 1;
        end
        else if (state != DATA) begin
            bit_counter <= 3'b0; // Reset counter if not receiving data
        end
    end
    
    // Output logic
    assign done = (state == STOP) && (in == 1);
    assign out_byte = (done) ? shift_reg : 8'bxxxx_xxxx; // Valid only when 'done' is high

endmodule",5.035392,36518
N/A,N/A,-1,84,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// FSM states
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    state_t state, next_state;
    logic [3:0] bit_counter; // To count up to 10 (1 start, 8 data, 1 stop)
    logic [7:0] shift_reg;   // To hold the 8 data bits

    // State transition logic
    always_ff @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= IDLE;
            bit_counter <= 0;
            shift_reg <= 8'b0;
        end else begin
            state <= next_state;
            if (state == DATA) begin
                shift_reg <= {in, shift_reg[7:1]}; // Shift in each bit
            end
            if (state == DATA || state == START) begin
                bit_counter <= bit_counter + 1;
            end else begin
                bit_counter <= 0;
            end
        end
    end

    // Next state logic
    always_comb begin
        next_state = state;
        done = 0;

        case (state)
            IDLE: begin
                if (in == 0) begin // Start bit detected (active low)
                    next_state = START;
                end
            end

            START: begin
                if (bit_counter == 1) begin // Start bit duration is complete
                    next_state = DATA;
                end
            end

            DATA: begin
                if (bit_counter == 9) begin // 8 data bits received
                    next_state = STOP;
                end
            end

            STOP: begin
                if (in == 1) begin // Stop bit detected (active high)
                    done = 1;
                    next_state = IDLE; // Prepare for the next byte
                end else begin
                    next_state = IDLE; // Error state; wait for the next valid start bit
                end
            end

            default: next_state = IDLE; // Default to a known state
        endcase
    end

    // Output logic
    assign out_byte = (done) ? shift_reg : 8'bx; // Output valid data only when done

endmodule",6.383593,37007
N/A,N/A,-1,85,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// FSM states
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;
    
    state_t state, next_state;
    reg [2:0] bit_counter;
    reg [7:0] shift_reg;
    
    // FSM state transition
    always @(posedge clk) begin
        if (reset)
            state <= IDLE;
        else
            state <= next_state;
    end
    
    // Output logic
    always @(posedge clk) begin
        if (reset) begin
            shift_reg <= 8'b0;
            bit_counter <= 3'b0;
        end
        else if (state == DATA) begin
            shift_reg <= {in, shift_reg[7:1]};
            bit_counter <= bit_counter + 3'b1;
        end
    end
    
    always @(*) begin
        next_state = state;
        done = 0;
        
        case(state)
            IDLE: begin
                if (in == 0)
                    next_state = START;
            end
            START: begin
                if (in == 1)
                    next_state = DATA;
            end
            DATA: begin
                if (bit_counter == 3'd7)  // All data bits received
                    next_state = STOP;
            end
            STOP: begin
                if (in == 1) begin
                    done = 1;
                    next_state = IDLE;
                end
                else if (in == 0)  // Wait until true stop bit found
                    next_state = START;
            end
        endcase
    end
    
    assign out_byte = (done) ? shift_reg : 8'bx;
    
endmodule",6.494359,37380
N/A,N/A,-1,86,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// FSM states
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    state_t state, next_state;
    logic [2:0] bit_counter; // To count the received data bits
    logic [7:0] shift_reg;   // Shift register to store incoming data bits

    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_counter <= 3'd0;
            shift_reg <= 8'h00;
        end else begin
            state <= next_state;
            if (state == DATA) begin
                bit_counter <= bit_counter + 3'd1;
                shift_reg <= {in, shift_reg[7:1]}; // Shift in the received bit
            end else if (state == STOP) begin
                bit_counter <= 3'd0;
            end
        end
    end

    always_comb begin
        next_state = state;
        done = 1'b0;

        case (state)
            IDLE: begin
                if (in == 1'b0) // Start bit detected
                    next_state = START;
            end

            START: begin
                next_state = DATA;
            end

            DATA: begin
                if (bit_counter == 3'd7) // 8 data bits received
                    next_state = STOP;
            end

            STOP: begin
                if (in == 1'b1) begin // Stop bit detected
                    done = 1'b1; // Set done signal
                    next_state = IDLE; // Ready for next byte
                end
            end
        endcase
    end

    assign out_byte = (done) ? shift_reg : 8'h00;

endmodule",3.710392,37766
N/A,N/A,-1,87,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// FSM states
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;
    
    state_t state, next_state;
    logic [2:0] bit_counter;

    // Register to hold the data bits
    logic [7:0] data_reg;
    
    // Next state logic
    always_comb begin
        case (state)
            IDLE: begin
                if (in == 1'b0)
                    next_state = START;
                else
                    next_state = IDLE;
            end

            START: begin
                next_state = DATA;
            end

            DATA: begin
                if (bit_counter == 3'd7)
                    next_state = STOP;
                else
                    next_state = DATA;
            end
            
            STOP: begin
                if (in == 1'b1)
                    next_state = IDLE;
                else
                    next_state = STOP;
            end
        endcase
    end

    // State transition
    always_ff @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= IDLE;
            bit_counter <= 3'd0;
            data_reg <= 8'b0;
        end
        else begin
            state <= next_state;
            
            case (state)
                DATA: begin
                    data_reg <= {in, data_reg[7:1]}; // Shift in data bit
                    bit_counter <= bit_counter + 1'b1;
                end
                
                STOP: begin
                    bit_counter <= 3'd0;
                end
            endcase
        end
    end

    // Output logic
    assign out_byte = data_reg;
    assign done = (state == STOP) && (in == 1'b1);

endmodule",3.797377,38152
N/A,N/A,-1,88,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// FSM states
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;
    
    state_t state, next_state;
    logic [2:0] bit_counter;
    logic [7:0] shift_reg;
    
    // FSM state transition
    always_ff @(posedge clk) begin
        if (reset)
            state <= IDLE;
        else
            state <= next_state;
    end
    
    // Next state logic
    always_comb begin
        case (state)
            IDLE: begin
                if (in == 0) // Detect start bit
                    next_state = START;
                else
                    next_state = IDLE;
            end
            START: begin
                next_state = DATA;
            end
            DATA: begin
                if (bit_counter == 3'd7) // All 8 data bits received
                    next_state = STOP;
                else
                    next_state = DATA;
            end
            STOP: begin
                if (in == 1) // Detect stop bit
                    next_state = IDLE;
                else
                    next_state = STOP; // Wait for stop bit if incorrect
            end
            default: next_state = IDLE;
        endcase
    end
    
    // Datapath
    always_ff @(posedge clk) begin
        if (reset) begin
            shift_reg <= 8'b0;
            bit_counter <= 3'b0;
        end
        else begin
            case (state)
                DATA: begin
                    shift_reg <= {in, shift_reg[7:1]}; // Shift in data bits
                    bit_counter <= bit_counter + 1;
                end
                STOP: begin
                    if (in == 1) begin
                        bit_counter <= 3'b0; // Reset for next byte
                    end
                end
                default: begin
                    // No operation
                end
            endcase
        end
    end
    
    // Output logic
    assign out_byte = shift_reg;
    assign done = (state == STOP) && (in == 1); // Only valid when stop bit is correct

endmodule",5.812181,38619
N/A,N/A,-1,89,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// FSM states
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    state_t state, next_state;
    logic [2:0] bit_counter; // To count the received data bits
    logic [7:0] shift_reg;   // Shift register to store incoming data bits

    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_counter <= 3'd0;
            shift_reg <= 8'h00;
        end else begin
            state <= next_state;
            if (state == DATA) begin
                bit_counter <= bit_counter + 3'd1;
                shift_reg <= {in, shift_reg[7:1]}; // Shift in the received bit
            end else if (state == STOP) begin
                bit_counter <= 3'd0;
            end
        end
    end

    always_comb begin
        next_state = state;
        done = 1'b0;

        case (state)
            IDLE: begin
                if (in == 1'b0) begin // Detect start bit (logic 0)
                    next_state = START;
                end
            end
            START: begin
                next_state = DATA;
            end
            DATA: begin
                if (bit_counter == 3'd7) begin // Receive 8 data bits
                    next_state = STOP;
                end
            end
            STOP: begin
                if (in == 1'b1) begin // Detect stop bit (logic 1)
                    done = 1'b1;        // Indicate done
                    next_state = IDLE;  // Go back to idle to receive next byte
                end else begin
                    next_state = IDLE;  // Error recovery if no stop bit received
                end
            end
        endcase
    end

    assign out_byte = (done) ? shift_reg : 8'hXX; // Update output byte when done
endmodule",4.498377,39056
N/A,N/A,-1,90,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// FSM states
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    state_t state, next_state;
    logic [2:0] bit_counter; // To count the received data bits
    logic [7:0] byte_shift_reg; // Shift register to store incoming data bits

    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_counter <= 3'd0;
            byte_shift_reg <= 8'b0;
        end else begin
            state <= next_state;
        end
    end

    always_comb begin
        next_state = state;
        case (state)
            IDLE: begin
                if (!in)  // Start bit detected
                    next_state = START;
            end
            START: begin
                next_state = DATA;
                bit_counter = 3'd0;
            end
            DATA: begin
                if (bit_counter < 3'd7) begin
                    bit_counter = bit_counter + 1;
                    next_state = DATA;
                end else begin
                    next_state = STOP;
                end
            end
            STOP: begin
                if (in)  // Stop bit detected
                    next_state = IDLE;
                else // If stop bit not detected, stay in STOP until detected
                    next_state = STOP;
            end
            default: next_state = IDLE;
        endcase
    end

    always_ff @(posedge clk) begin
        if (state == DATA) begin
            byte_shift_reg <= {in, byte_shift_reg[7:1]}; // Shift in the bits from LSB
        end
    end

    assign done = (state == STOP) && in;  // Done is high when a full byte is correctly received
    assign out_byte = (done) ? byte_shift_reg : 8'b0;  // Output byte is valid only when done is high

endmodule",4.180133,39484
N/A,N/A,-1,91,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// FSM states
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    state_t state, next_state;
    logic [2:0] bit_counter; // To track number of received data bits
    logic [7:0] shift_reg;   // To shift in data bits serially

    // State transition logic
    always_ff @(posedge clk or posedge reset) begin
        if (reset)
            state <= IDLE;
        else
            state <= next_state;
    end

    // Next state logic and bit counter/shift register updates
    always_comb begin
        next_state = state;
        case (state)
            IDLE: begin
                if (in == 0) // Detect start bit
                    next_state = START;
            end
            START: begin
                next_state = DATA;
                bit_counter = 0; // Initialize bit counter for data bits
            end
            DATA: begin
                if (bit_counter == 8) // All data bits received
                    next_state = STOP;
            end
            STOP: begin
                if (in == 1) // Correct stop bit
                    next_state = IDLE;
                else
                    next_state = IDLE; // To ensure transition to IDLE even if stop bit is wrong
            end
        endcase
    end

    // Shift register and bit count update logic
    always_ff @(posedge clk) begin
        if (state == DATA) begin
            shift_reg <= {in, shift_reg[7:1]}; // Shift in the incoming bit
            bit_counter <= bit_counter + 1;
        end
        else if (state == START || state == STOP) begin
            bit_counter <= 0; // Reset counter when not in DATA state
        end
    end

    // Output logic: done signal and parallel output of received byte
    assign done = (state == STOP && in == 1);
    assign out_byte = done ? shift_reg : 8'bx; // Output valid data on successful byte receipt

endmodule",7.572032,39938
N/A,N/A,-1,92,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// FSM states
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    state_t state, next_state;
    logic [3:0] bit_counter; // To count up to 8 data bits
    logic [7:0] shift_reg;   // Shift register to store the received byte

    // State transition logic
    always_ff @(posedge clk) begin
        if (reset)
            state <= IDLE;
        else
            state <= next_state;
    end

    // Next state logic
    always_comb begin
        next_state = state; // Default to hold state
        case (state)
            IDLE: begin
                if (in == 0) // Start bit detected
                    next_state = START;
            end
            START: begin
                next_state = DATA;
            end
            DATA: begin
                if (bit_counter == 8)
                    next_state = STOP;
            end
            STOP: begin
                if (in == 1) // Correct stop bit
                    next_state = IDLE;
            end
        endcase
    end

    // Output and data path updates
    always_ff @(posedge clk) begin
        if (reset) begin
            bit_counter <= 0;
            shift_reg  <= 8'b0;
        end
        else begin
            case (state)
                IDLE: begin
                    bit_counter <= 0;
                    done <= 0;
                end
                START: begin
                    bit_counter <= 0;
                end
                DATA: begin
                    shift_reg <= {in, shift_reg[7:1]}; // Shift in LSB first
                    bit_counter <= bit_counter + 1;
                end
                STOP: begin
                    if (in == 1) begin
                        out_byte <= shift_reg;
                        done <= 1;
                    end
                    else begin
                        done <= 0; // Next start bit expected
                    end
                end
            endcase
        end
    end
endmodule",5.951477,40385
N/A,N/A,-1,93,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// FSM states
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    state_t state, next_state;
    logic [2:0] bit_counter; // To track number of received data bits
    logic [7:0] shift_reg;   // To shift in data bits serially

    // State transition logic
    always_ff @(posedge clk or posedge reset) begin
        if (reset)
            state <= IDLE;
        else
            state <= next_state;
    end

    // Next state logic and bit counter/shift register updates
    always_comb begin
        next_state = state;
        done = 0;

        case (state)
            IDLE: begin
                if (in == 0)  // Detecting start bit
                    next_state = START;
            end
            START: next_state = DATA;
            DATA: begin
                if (bit_counter == 3'b111)  // Received all 8 bits
                    next_state = STOP;
            end
            STOP: begin
                if (in == 1) begin  // Detecting stop bit
                    done = 1;
                    next_state = IDLE;
                end
                else  // If stop bit not detected, look for next start bit
                    next_state = IDLE;
            end
        endcase
    end

    // Bit counter, shift register, and output logic
    always_ff @(posedge clk) begin
        if (state == START || state == STOP) begin
            bit_counter <= 3'b0;
        end
        else if (state == DATA) begin
            bit_counter <= bit_counter + 1;
            shift_reg <= {in, shift_reg[7:1]};  // Shift in the bit
        end

        if (done)
            out_byte <= shift_reg;  // Latch the received byte when done
    end

endmodule",4.079014,40806
N/A,N/A,-1,94,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// FSM states
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;
    
    state_t state, next_state;
    reg [2:0] bit_counter;
    reg [7:0] shift_reg;
    
    // FSM state transition
    always @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_counter <= 0;
            shift_reg <= 8'b0;
        end else begin
            state <= next_state;
            if (state == DATA) begin
                shift_reg <= {in, shift_reg[7:1]};  // Shift in the incoming bit
                bit_counter <= bit_counter + 1;
            end else if (state == STOP) begin
                bit_counter <= 0; // Reset counter after stop
            end
        end
    end

    // FSM next state logic
    always @(*) begin
        next_state = state;  // Default to hold state
        done = 0;

        case (state)
            IDLE: begin
                if (in == 0) next_state = START;  // Start bit detected
            end
            START: begin
                next_state = DATA;  // Move to data receiving state
            end
            DATA: begin
                if (bit_counter == 8) next_state = STOP;  // Collected 8 bits
            end
            STOP: begin
                if (in == 1) begin  // Stop bit check
                    done = 1;
                    next_state = IDLE;  // Return to idle, byte is done
                end
            end
        endcase
    end

    // Output the byte received on the done signal
    assign out_byte = (done) ? shift_reg : 8'bx;  // Don't care outside the done signal

endmodule",5.380152,41215
N/A,N/A,-1,95,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// FSM states
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    state_t state, next_state;
    logic [2:0] bit_counter; // To track number of received data bits
    logic [7:0] shift_reg;   // To shift in data bits serially

    // State transition logic
    always_ff @(posedge clk or posedge reset) begin
        if (reset)
            state <= IDLE;
        else
            state <= next_state;
    end

    // Next state logic
    always_comb begin
        case (state)
            IDLE: if (!in) next_state = START; else next_state = IDLE;
            START: next_state = DATA;
            DATA: if (bit_counter == 3'd7) next_state = STOP; else next_state = DATA;
            STOP: if (in) next_state = IDLE; else next_state = DATA; // Wait for stop bit
            default: next_state = IDLE;
        endcase
    end

    // Output logic and datapath
    always_ff @(posedge clk or posedge reset) begin
        if (reset) begin
            bit_counter <= 3'd0;
            shift_reg <= 8'd0;
            out_byte <= 8'd0;
            done <= 1'b0;
        end else begin
            done <= 1'b0; // Default to not done, set to 1 when stop bit is correct
            case (state)
                START: begin
                    bit_counter <= 3'd0;
                    shift_reg <= 8'd0;
                end
                DATA: begin
                    shift_reg <= {in, shift_reg[7:1]}; // Shift in data bit
                    bit_counter <= bit_counter + 3'd1;
                end
                STOP: begin
                    if (in) begin // Check stop bit
                        out_byte <= shift_reg; // Output the received byte
                        done <= 1'b1;
                    end
                end
            endcase
        end
    end

endmodule",4.671427,41670
N/A,N/A,-1,96,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// FSM states
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;
    
    state_t state, next_state;
    logic [2:0] bit_counter;
    logic [7:0] shift_reg;
    
    // FSM state transition
    always_ff @(posedge clk) begin
        if (reset)
            state <= IDLE;
        else
            state <= next_state;
    end
    
    // Next state logic
    always_comb begin
        case (state)
            IDLE: begin
                if (in == 0) // Detect start bit
                    next_state = START;
                else
                    next_state = IDLE;
            end
            START: begin
                next_state = DATA;
            end
            DATA: begin
                if (bit_counter == 3'd7) // All 8 data bits received
                    next_state = STOP;
                else
                    next_state = DATA;
            end
            STOP: begin
                if (in == 1) // Detect stop bit
                    next_state = IDLE;
                else
                    next_state = STOP; // Wait for stop bit if incorrect
            end
            default: next_state = IDLE;
        endcase
    end
    
    // Datapath control logic
    always_ff @(posedge clk) begin
        if (reset) begin
            bit_counter <= 3'd0;
            shift_reg <= 8'd0;
        end else begin
            case (state)
                DATA: begin
                    shift_reg <= {in, shift_reg[7:1]}; // Shift in data bits
                    bit_counter <= bit_counter + 1;
                end
                STOP: begin
                    if (in == 1) begin
                        bit_counter <= 3'd0; // Reset for next byte
                    end
                end
                default: begin
                    // No operation
                end
            endcase
        end
    end
    
    // Output logic
    assign out_byte = shift_reg;
    assign done = (state == STOP) && (in == 1); // Only valid when stop bit is correct

endmodule",4.375246,42137
N/A,N/A,-1,97,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// FSM states
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;
    
    state_t state, next_state;
    logic [2:0] bit_counter;
    logic [7:0] shift_reg;
    
    // FSM state transition
    always_ff @(posedge clk) begin
        if (reset)
            state <= IDLE;
        else
            state <= next_state;
    end
    
    // Next state logic
    always_comb begin
        case (state)
            IDLE: begin
                if (in == 0) // Detected start bit
                    next_state = START;
                else
                    next_state = IDLE;
            end
            
            START: begin
                if (bit_counter == 3'd7)
                    next_state = DATA;
                else
                    next_state = START;
            end
            
            DATA: begin
                if (bit_counter == 3'd7)
                    next_state = STOP;
                else
                    next_state = DATA;
            end
            
            STOP: begin
                if (in == 1) // Detecting stop bit
                    next_state = IDLE;
                else
                    next_state = STOP;
            end
            
            default: next_state = IDLE;
        endcase
    end

    // Counter and shift register logic
    always_ff @(posedge clk) begin
        if (reset) begin
            bit_counter <= 3'd0;
            shift_reg <= 8'd0;
        end
        else begin
            case (state)
                IDLE: begin
                    bit_counter <= 3'd0;
                end
                
                START: begin
                    bit_counter <= bit_counter + 3'd1;
                end
                
                DATA: begin
                    shift_reg <= {in, shift_reg[7:1]};
                    bit_counter <= bit_counter + 3'd1;
                end
                
                STOP: begin
                    if (in == 1) begin
                        bit_counter <= 3'd0;
                    end
                end
            endcase
        end
    end

    // Output logic
    assign done = (state == STOP && in == 1);
    assign out_byte = shift_reg;

endmodule",7.003261,42615
N/A,N/A,-1,98,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// FSM states
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;

    state_t state, next_state;
    logic [3:0] bit_counter; // To count up to 10 (1 start, 8 data, 1 stop)
    logic [7:0] shift_reg;   // Data shift register
    
    // State update logic
    always_ff @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= IDLE;
        end else begin
            state <= next_state;
        end
    end

    // Next state logic
    always_comb begin
        next_state = state; // Default to holding state
        case (state)
            IDLE: if (in == 0) next_state = START; // Start bit detected
            START: if (bit_counter == 0) next_state = DATA; // First data bit
            DATA: if (bit_counter == 8) next_state = STOP; // After 8 bits
            STOP: if (in == 1) next_state = IDLE; // Stop bit detected, return to IDLE
        endcase
    end

    // Bit counter and shift register logic
    always_ff @(posedge clk) begin
        if (reset) begin
            bit_counter <= 4'd0;
            shift_reg <= 8'd0;
            done <= 1'b0;
        end else begin
            case (state)
                IDLE: begin
                    bit_counter <= 4'd0;
                    done <= 1'b0;
                end
                START: begin
                    if (bit_counter < 4'd1) begin
                        bit_counter <= bit_counter + 1;
                    end
                end
                DATA: begin
                    if (bit_counter < 4'd9) begin
                        shift_reg <= {in, shift_reg[7:1]};
                        bit_counter <= bit_counter + 1;
                    end
                end
                STOP: begin
                    if (in == 1) begin // Verify stop bit
                        done <= 1'b1;
                        out_byte <= shift_reg; // Capture the byte
                    end
                    bit_counter <= 4'd0; // Reset counter on completion
                end
            endcase
        end
    end

endmodule",4.523271,43121
N/A,N/A,-1,99,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// FSM states
    typedef enum logic [2:0] {
        IDLE,
        START,
        DATA,
        STOP
    } state_t;
    
    state_t state, next_state;
    logic [2:0] bit_counter;

    // Register to hold the data byte
    logic [7:0] data_reg;
    
    always_ff @(posedge clk) begin
        if (reset) begin
            state <= IDLE;
            bit_counter <= 3'd0;
            data_reg <= 8'd0;
        end else begin
            state <= next_state;

            if (state == DATA)
                bit_counter <= bit_counter + 3'd1;
            else
                bit_counter <= 3'd0;

            if (state == DATA)
                data_reg <= {in, data_reg[7:1]};
        end
    end
    
    always_comb begin
        case (state)
            IDLE: next_state = in ? IDLE : START;   // Wait for a falling edge (start bit)
            START: next_state = in ? IDLE : DATA;  // Verify start bit and move to DATA state
            DATA: next_state = (bit_counter == 3'd7) ? STOP : DATA;  // Collect 8 data bits
            STOP: next_state = in ? IDLE : START;  // Validate stop bit and go to IDLE. Else look for start bit
            default: next_state = IDLE;
        endcase
    end
    
    assign done = (state == STOP) && in;
    assign out_byte = data_reg;
    
endmodule",3.291196,43464
