Area,Delay,Score,Current Run,Episode,Verilog
N/A,N/A,-1,0,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serial
    // New: Datapath to latch input bits.
    
    reg [2:0] state, next_state;
    reg [7:0] out_byte_reg;
    
    parameter idle = 3'b000, start = 3'b001, trans0 = 3'b010, trans1 = 3'b011, trans2 = 3'b100, trans3 = 3'b101;
    
    always @(*) begin
        state <= next_state;
    end
    
    always @(posedge clk) begin
        if(reset)
            out_byte_reg <= 8'b0;
        else begin
            case(state)
                idle: begin
                    if(~in)
                        next_state <= start;
                    else
                        next_state <= idle;
                end
                start: begin
                    if(in)
                        next_state <= trans0;
                    else
                        next_state <= idle;
                end
                trans0: begin
                    if(in)
                        next_state <= trans1;
                    else
                        next_state <= idle;
                end
                trans1: begin
                    if(in)
                        next_state <= trans2;
                    else
                        next_state <= idle;
                end
                trans2: begin
                    if(in)
                        next_state <= trans3;
                    else
                        next_state <= idle;
                end
                trans3: begin
                    if(in)
                        next_state <= trans0;
                    else
                        next_state <= idle;
                end
            endcase
        end
    end
    
    assign done = (state == trans3);
    
    assign out_byte = out_byte_reg;
    
endmodule"
N/A,N/A,-1,1,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serial
    // New: Datapath to latch input bits.
    
    reg [3:0] state, next_state;
    reg [7:0] out_byte_reg;
    reg done_reg;
    
    localparam  IDLE = 4'd0,
                GET_BYTE = 4'd1,
                WAIT_STOP = 4'd2,
                INCREMENT = 4'd3,
                DONE = 4'd4;
    
    always @(*) begin
        case (state)
            IDLE: begin
                if(~in)
                    next_state = GET_BYTE;
                else
                    next_state = IDLE;
            end
            
            GET_BYTE: begin
                if(in)
                    next_state = WAIT_STOP;
                else
                    next_state = GET_BYTE;
            end
            
            WAIT_STOP: begin
                if(in)
                    next_state = INCREMENT;
                else
                    next_state = WAIT_STOP;
            end
            
            INCREMENT: begin
                next_state = DONE;
            end
            
            DONE: begin
                if(in)
                    next_state = IDLE;
                else
                    next_state = DONE;
            end
            
            default: begin
                next_state = IDLE;
            end
        endcase
    end
    
    always @(posedge clk) begin
        if(reset) begin
            state <= IDLE;
            out_byte_reg <= 0;
            done_reg <= 0;
        end
        else begin
            state <= next_state;
            out_byte_reg <= out_byte;
            done_reg <= done;
        end
    end
    
    assign out_byte = out_byte_reg;
    assign done = done_reg;
    
endmodule"
N/A,N/A,-1,2,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serial
    // New: Datapath to latch input bits.
    
    reg [3:0] state, next_state;
    reg [7:0] out_byte_reg;
    reg done_reg;
    
    always @(*) begin
        state <= next_state;
    end
    
    always @(posedge clk) begin
        if(reset) begin
            out_byte_reg <= 0;
            done_reg <= 0;
        end
        else begin
            if(next_state == 4'd1) begin
                out_byte_reg[7:0] <= in;
            end
            else if(next_state == 4'd2) begin
                out_byte_reg[7:0] <= out_byte_reg[7:0] + 1;
            end
            else if(next_state == 4'd3) begin
                done_reg <= 1;
            end
        end
    end
    
    always @(*) begin
        next_state = state;
        case (state)
            4'd0: begin
                if(in)
                    next_state = 4'd1;
                else
                    next_state = 4'd0;
            end
            4'd1: begin
                if(~in)
                    next_state = 4'd2;
                else
                    next_state = 4'd1;
            end
            4'd2: begin
                if(in)
                    next_state = 4'd3;
                else
                    next_state = 4'd0;
            end
            4'd3: begin
                if(~in)
                    next_state = 4'd2;
                else
                    next_state = 4'd1;
            end
            default: begin
                next_state = 4'd0;
            end
        endcase
    end
    
    assign done = done_reg;
    assign out_byte = out_byte_reg;
    
endmodule"
N/A,N/A,-1,3,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Use FSM from Fsm_serial

// New: Datapath to latch input bits.

endmodule"
N/A,N/A,-1,4,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Use FSM from Fsm_serial

// New: Datapath to latch input bits.

endmodule"
N/A,N/A,-1,5,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serial
    
    // New: Datapath to latch input bits.
    
    reg [7:0] out_byte_reg;
    
    always @(posedge clk) begin
        if(reset) begin
            out_byte_reg <= 0;
        end
        else begin
            out_byte_reg <= {out_byte_reg[6:0], in};
        end
    end
    
    assign done = (out_byte_reg == ""done"");
    assign out_byte = done? out_byte_reg : 8'bz;
    
endmodule"
N/A,N/A,-1,6,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serial
    
    // New: Datapath to latch input bits.
    
    reg [3:0] state, next_state;
    reg [7:0] out;
    reg [2:0] n;
    reg out_bit;
    
    always @(posedge clk) begin
        if(reset)
            state <= 0;
        else
            state <= next_state;
    end
    
    always @(*) begin
        case(state)
            0: begin
                if(~in)
                    next_state = 0;
                else
                    next_state = 1;
            end
            1: begin
                if(in)
                    next_state = 1;
                else
                    next_state = 0;
            end
            default: next_state = 0;
        endcase
    end
    
    always @(posedge clk) begin
        if(reset) begin
            out_bit <= 0;
            n <= 0;
        end
        else begin
            if(state == 0) begin
                out_bit <= in;
                n <= n + 1;
            end
            else begin
                if(n == 7) begin
                    out_bit <= ~out_bit;
                    n <= 0;
                end
            end
        end
    end
    
    always @(posedge clk) begin
        if(reset)
            out <= 0;
        else if(state == 1) begin
            if(n == 0)
                out <= {out, out_bit};
        end
    end
    
    assign done = (state == 1) && (n == 0);
    assign out_byte = out;
    
endmodule"
N/A,N/A,-1,7,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

reg [2:0] state, next_state;
reg [7:0] out_byte;
reg done;

always @(posedge clk) begin
    if(reset)
        state <= 3'b000;
    else
        state <= next_state;
end

always @(*) begin
    case(state)
        3'b000: begin
            if(~in)
                next_state = 3'b001;
            else
                next_state = 3'b000;
        end
        3'b001: begin
            if(in)
                next_state = 3'b010;
            else
                next_state = 3'b001;
        end
        3'b010: begin
            if(~in)
                next_state = 3'b011;
            else
                next_state = 3'b010;
        end
        3'b011: begin
            if(in)
                next_state = 3'b000;
            else
                next_state = 3'b011;
        end
        default: next_state = 3'b000;
    endcase
end

always @(posedge clk) begin
    if(state == 3'b010 && in)
        out_byte[7:0] <= {out_byte[6:0], 1'b0};
end

always @(posedge clk) begin
    if(state == 3'b011)
        done <= 1'b1;
    else
        done <= 1'b0;
end

endmodule"
N/A,N/A,-1,8,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

reg [7:0] out_byte;
reg done;

always @(posedge clk) begin
    if(reset) begin
        out_byte <= 0;
        done <= 0;
    end
    else begin
        out_byte <= {out_byte[6:0], in};
        if(out_byte[7] == 1'b1)
            done <= 1;
        else
            done <= 0;
    end
end

endmodule"
N/A,N/A,-1,9,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Use FSM from Fsm_serial

// New: Datapath to latch input bits.

endmodule"
N/A,N/A,-1,10,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

// Define states
localparam
    idle = 2'b00,
    read = 2'b01,
    wait = 2'b10,
    stop = 2'b11;

// State register
reg [1:0] state;

// FSM next-state logic and output logic
always @(*) begin
    case (state)
        idle: begin
            if (in) state <= read;
            else state <= idle;
        end
        read: begin
            if (in) state <= wait;
            else state <= idle;
        end
        wait: begin
            if (in) state <= stop;
            else state <= idle;
        end
        stop: begin
            if (in) state <= stop;
            else state <= idle;
        end
        default: state <= idle;
    endcase
end

// FSM output logic
assign done = (state == stop);

// Datapath to latch input bits.
reg [7:0] out_byte_reg;

always @(posedge clk) begin
    if (reset) begin
        out_byte_reg <= 0;
    end
    else begin
        if (state == read) begin
            out_byte_reg <= {out_byte_reg[6:0], in};
        end
    end
end

assign out_byte = out_byte_reg;

endmodule"
N/A,N/A,-1,11,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

// Define states
localparam
    idle = 2'b00,
    read = 2'b01,
    wait = 2'b10,
    stop = 2'b11;

// State register
reg [1:0] state;

// FSM next-state logic and output logic
always @(*) begin
    case (state)
        idle: begin
            if (in) state <= read;
            else state <= idle;
        end
        read: begin
            if (in) state <= wait;
            else state <= idle;
        end
        wait: begin
            if (in) state <= stop;
            else state <= idle;
        end
        stop: begin
            if (in) state <= stop;
            else state <= idle;
        end
        default: state <= idle;
    endcase
end

// FSM output logic
assign done = (state == stop);

// Datapath to latch input bits.
reg [7:0] out_byte_reg;

always @(posedge clk) begin
    if (reset) begin
        out_byte_reg <= 0;
    end
    else begin
        if (state == read) begin
            out_byte_reg <= {out_byte_reg[6:0], in};
        end
    end
end

assign out_byte = out_byte_reg;

endmodule"
N/A,N/A,-1,12,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

// Define states
localparam
    idle = 2'b00,
    read = 2'b01,
    wait = 2'b10,
    stop = 2'b11;

// State register
reg [1:0] state;

// FSM next-state logic and output logic
always @(*) begin
    case (state)
        idle: begin
            if (in) state <= read;
            else state <= idle;
        end
        read: begin
            if (in) state <= wait;
            else state <= idle;
        end
        wait: begin
            if (in) state <= stop;
            else state <= idle;
        end
        stop: begin
            if (in) state <= stop;
            else state <= idle;
        end
        default: state <= idle;
    endcase
end

// FSM output logic
assign done = (state == stop);

// Datapath to latch input bits.
reg [7:0] out_byte_reg;

always @(posedge clk) begin
    if (reset) begin
        out_byte_reg <= 0;
    end
    else begin
        if (state == read) begin
            out_byte_reg <= {out_byte_reg[6:0], in};
        end
    end
end

assign out_byte = out_byte_reg;

endmodule"
N/A,N/A,-1,13,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serial
    
    parameter idle = 0, rec_data = 1, stop_bit = 2;
    reg [1:0] state, next_state;
    reg [3:0] counter;
    reg out;
    
    always @(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    always @(*) begin
        case (state)
            idle: begin
                if(~in)
                    next_state = rec_data;
                else
                    next_state = idle;
            end
            
            rec_data: begin
                if(counter == 8)
                    next_state = stop_bit;
                else
                    next_state = rec_data;
            end
            
            stop_bit: begin
                if(in)
                    next_state = idle;
                else
                    next_state = rec_data;
            end
            
            default: next_state = idle;
        endcase
    end
    
    always @(posedge clk) begin
        if(state == rec_data && counter < 8)
            counter <= counter + 1;
        else
            counter <= 0;
    end
    
    always @(posedge clk) begin
        if(state == stop_bit && in)
            out <= 1;
        else
            out <= 0;
    end
    
    assign done = (state == stop_bit)? out : 0;
    
    assign out_byte = (state == rec_data)? counter : 4'b0;
    
endmodule"
N/A,N/A,-1,14,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serial
    
    parameter idle = 0, rec_data = 1, stop_bit = 2;
    reg [1:0] state, next_state;
    reg [3:0] counter;
    reg out;
    
    always @(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    always @(*) begin
        case (state)
            idle: begin
                if(~in)
                    next_state = rec_data;
                else
                    next_state = idle;
            end
            
            rec_data: begin
                if(counter == 8)
                    next_state = stop_bit;
                else
                    next_state = rec_data;
            end
            
            stop_bit: begin
                if(in)
                    next_state = idle;
                else
                    next_state = rec_data;
            end
            
            default: next_state = idle;
        endcase
    end
    
    always @(posedge clk) begin
        if(state == rec_data && counter < 8)
            counter <= counter + 1;
        else
            counter <= 0;
    end
    
    always @(posedge clk) begin
        if(state == stop_bit && in)
            out <= 1;
        else
            out <= 0;
    end
    
    assign done = (state == stop_bit)? out : 0;
    
    assign out_byte = (state == rec_data)? counter : 4'b0;
    
endmodule"
N/A,N/A,-1,15,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serial
    // New: Datapath to latch input bits.
    
    reg [3:0] state, next_state;
    reg [7:0] out_byte_reg;
    
    localparam IDLE = 4'd0,
               GET_BYTE = 4'd1,
               WAIT_STOP = 4'd2,
               INCREMENT = 4'd3,
               DONE = 4'd4;
               
    always @(*) begin
        case (state)
            IDLE: begin
                if(~in)
                    next_state = GET_BYTE;
                else
                    next_state = IDLE;
            end
            
            GET_BYTE: begin
                if(in)
                    next_state = WAIT_STOP;
                else
                    next_state = GET_BYTE;
            end
            
            WAIT_STOP: begin
                if(in)
                    next_state = INCREMENT;
                else
                    next_state = WAIT_STOP;
            end
            
            INCREMENT: begin
                if(count == 4'd8)
                    next_state = DONE;
                else
                    next_state = INCREMENT;
            end
            
            DONE: begin
                if(in)
                    next_state = IDLE;
                else
                    next_state = DONE;
            end
            
            default: next_state = IDLE;
        endcase
    end
    
    always @(posedge clk) begin
        if(reset)
            state <= IDLE;
        else
            state <= next_state;
    end
    
    always @(posedge clk) begin
        if(state == WAIT_STOP && next_state == INCREMENT)
            out_byte_reg[count] <= in;
    end
    
    assign done = (state == DONE)? 1 : 0;
    assign out_byte = out_byte_reg;
    
endmodule"
N/A,N/A,-1,16,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Use FSM from Fsm_serial

endmodule"
N/A,N/A,-1,17,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serial
    // New: Latch input bits
    
    reg [2:0] state, next_state;
    reg [3:0] count;
    reg out;
    
    localparam IDLE = 3'd0,
               GET_BYTE = 3'd1,
               WAIT = 3'd2,
               INCREMENT = 3'd3,
               DONE = 3'd4;
    
    always @(*) begin
        case (state)
            IDLE: begin
                if(~in)
                    next_state = GET_BYTE;
                else
                    next_state = IDLE;
            end
            
            GET_BYTE: begin
                if(count == 4'd8)
                    next_state = WAIT;
                else
                    next_state = GET_BYTE;
            end
            
            WAIT: begin
                if(in)
                    next_state = INCREMENT;
                else
                    next_state = WAIT;
            end
            
            INCREMENT: begin
                next_state = DONE;
            end
            
            DONE: begin
                if(in)
                    next_state = IDLE;
                else
                    next_state = DONE;
            end
            
            default: next_state = IDLE;
        endcase
    end
    
    always @(posedge clk) begin
        if(reset)
            state <= IDLE;
        else
            state <= next_state;
    end
    
    always @(posedge clk) begin
        if(state == GET_BYTE)
            count <= count + 4'd1;
        else
            count <= 4'd0;
    end
    
    always @(posedge clk) begin
        if(state == INCREMENT)
            out <= 1'b1;
        else
            out <= 1'b0;
    end
    
    assign done = (state == DONE)? 1'b1 : 1'b0;
    assign out_byte = out? count : 4'd0;
    
endmodule"
N/A,N/A,-1,18,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serial
    // New: Datapath to latch input bits.
    
    parameter idle = 0, rec_data = 1, stop_bit = 2;
    reg [1:0] state, next_state;
    reg [7:0] data;
    reg out;
    
    always @(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    always @(*) begin
        case(state)
            idle: begin
                if(~in)
                    next_state = rec_data;
                else
                    next_state = idle;
            end
            
            rec_data: begin
                if(in)
                    next_state = rec_data;
                else
                    next_state = stop_bit;
            end
            
            stop_bit: begin
                if(in)
                    next_state = idle;
                else
                    next_state = rec_data;
            end
            
            default: next_state = idle;
        endcase
    end
    
    always @(posedge clk) begin
        if(state == rec_data && in)
            data <= {data[6:0], 1'b0};
        else if(state == stop_bit && ~in)
            data <= {data[6:0], 1'b1};
    end
    
    assign done = (state == stop_bit) && (next_state == idle);
    
    assign out_byte = data;
    
endmodule"
N/A,N/A,-1,19,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    // Use FSM from Fsm_serial
    // New: Datapath to latch input bits.
    
    parameter idle = 0, rec_data = 1, stop_bit = 2;
    reg [1:0] state, next_state;
    reg [7:0] data;
    reg out;
    
    always @(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    always @(*) begin
        case(state)
            idle:
                if(~in)
                    next_state = rec_data;
                else
                    next_state = idle;
            rec_data:
                if(~in)
                    next_state = stop_bit;
                else
                    next_state = rec_data;
            stop_bit:
                if(~in)
                    next_state = idle;
                else
                    next_state = rec_data;
            default:
                next_state = idle;
        endcase
    end
    
    always @(posedge clk) begin
        if(state == rec_data && in)
            data <= data << 1;
        else if(state == stop_bit && ~in)
            out <= data[7];
    end
    
    assign done = (state == stop_bit);
    assign out_byte = out? data[7:1] : data[6:0];
    
endmodule"
N/A,N/A,-1,20,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serial
    // New: Latch input bits.
    
    reg [2:0] state, next_state;
    reg [7:0] out;
    reg done_reg;
    
    always @(*) begin
        state <= next_state;
    end
    
    always @(posedge clk) begin
        if(reset) begin
            done_reg <= 0;
            out <= 0;
        end
        else begin
            if(next_state == 3)
                out <= in;
            else
                out <= out;
        end
    end
    
    always @(posedge clk) begin
        if(state == 3)
            done_reg <= 1;
        else
            done_reg <= 0;
    end
    
    always @(*) begin
        next_state = state;
        case (state)
            0: begin
                if(in)
                    next_state = 1;
                else
                    next_state = 0;
            end
            1: begin
                if(in)
                    next_state = 2;
                else
                    next_state = 0;
            end
            2: begin
                if(~in)
                    next_state = 3;
                else
                    next_state = 0;
            end
            3: begin
                if(in)
                    next_state = 3;
                else
                    next_state = 0;
            end
            default: begin
                next_state = 0;
            end
        endcase
    end
    
    assign done = done_reg;
    assign out_byte = out;
    
endmodule"
N/A,N/A,-1,21,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Modify FSM and datapath from Fsm_serial
    
    parameter idle = 0, rec_data = 1, stop_bit = 2, error = 3;
    reg [2:0] state, next_state;
    reg [3:0] counter;
    reg out;
    
    always @(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    always @(*) begin
        case (state)
            idle: begin
                if(~in)
                    next_state = rec_data;
                else
                    next_state = idle;
            end
            rec_data: begin
                if(counter == 8)
                    next_state = stop_bit;
                else
                    next_state = rec_data;
            end
            stop_bit: begin
                if(~in)
                    next_state = idle;
                else
                    next_state = error;
            end
            error: begin
                if(counter == 8)
                    next_state = idle;
                else
                    next_state = error;
            end
            default: next_state = idle;
        endcase
    end
    
    always @(posedge clk) begin
        if(state == rec_data && counter < 8)
            counter <= counter + 1;
        else
            counter <= 0;
    end
    
    always @(posedge clk) begin
        if(state == rec_data && counter == 8)
            out <= in;
        else
            out <= 0;
    end
    
    assign done = (state == stop_bit)? (out == 1) : 0;
    
    assign out_byte = (state == rec_data)? {out, out_byte[7:1]} : 8'b0;
    
endmodule"
N/A,N/A,-1,22,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// You can use this counter to verify that the gap and width are as expected.
reg [4:0] counter = 1'b0;
always @(posedge clk) begin
    if(reset)
        counter <= 1'b0;
    else
        counter <= counter + 1'b1;
end

// Define the states of the finite state machine
parameter
    IDLE = 4'd0,
    START_BIT = 4'd1,
    DATA = 4'd2,
    STOP_BIT = 4'd3,
    DONE = 4'd4;

reg [3:0] state = IDLE, next_state = IDLE;

always @(*) begin
    case(state)
        IDLE: begin
            if(~in)
                next_state = START_BIT;
            else
                next_state = IDLE;
        end
        START_BIT: begin
            if(counter == 5)
                next_state = DATA;
            else
                next_state = START_BIT;
        end
        DATA: begin
            if(counter == 8)
                next_state = STOP_BIT;
            else
                next_state = DATA;
        end
        STOP_BIT: begin
            if(counter == 9)
                next_state = DONE;
            else
                next_state = STOP_BIT;
        end
        DONE: begin
            if(~in)
                next_state = START_BIT;
            else
                next_state = DONE;
        end
        default: next_state = IDLE;
    endcase
end

always @(posedge clk) begin
    if(reset)
        state <= IDLE;
    else
        state <= next_state;
end

// Outputs
assign done = (state == DONE)? 1'b1 : 1'b0;
assign out_byte = (state == DATA)? {in, in, in, in, in, in, in, in} : 8'b0;

endmodule"
N/A,N/A,-1,23,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// You can use this counter to verify that the gap and width are as expected.
reg [4:0] counter = 1'b0;
always @(posedge clk) begin
    if(reset)
        counter <= 1'b0;
    else
        counter <= counter + 1'b1;
end

// Define the states of the finite state machine
parameter
    IDLE = 4'd0,
    START_BIT = 4'd1,
    DATA = 4'd2,
    STOP_BIT = 4'd3,
    DONE = 4'd4;

reg [3:0] state = IDLE, next_state = IDLE;

always @(*) begin
    case(state)
        IDLE: begin
            if(~in)
                next_state = START_BIT;
            else
                next_state = IDLE;
        end
        START_BIT: begin
            if(counter == 5)
                next_state = DATA;
            else
                next_state = START_BIT;
        end
        DATA: begin
            if(counter == 8)
                next_state = STOP_BIT;
            else
                next_state = DATA;
        end
        STOP_BIT: begin
            if(counter == 9)
                next_state = DONE;
            else
                next_state = STOP_BIT;
        end
        DONE: begin
            if(~in)
                next_state = START_BIT;
            else
                next_state = DONE;
        end
        default: next_state = IDLE;
    endcase
end

always @(posedge clk) begin
    if(reset)
        state <= IDLE;
    else
        state <= next_state;
end

// Outputs
assign done = (state == DONE)? 1'b1 : 1'b0;
assign out_byte = (state == DATA)? {in, in, in, in, in, in, in, in} : 8'b0;

endmodule"
N/A,N/A,-1,24,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// You can use this counter to verify that the gap and width are as expected.
reg [4:0] counter = 1'b0;
always @(posedge clk) begin
    if(reset)
        counter <= 1'b0;
    else
        counter <= counter + 1'b1;
end

// Define the states of the finite state machine
parameter
    IDLE = 4'd0,
    START_BIT = 4'd1,
    DATA = 4'd2,
    STOP_BIT = 4'd3,
    DONE = 4'd4;

reg [3:0] state = IDLE, next_state = IDLE;

always @(*) begin
    case(state)
        IDLE: begin
            if(~in)
                next_state = START_BIT;
            else
                next_state = IDLE;
        end
        START_BIT: begin
            if(counter == 5)
                next_state = DATA;
            else
                next_state = START_BIT;
        end
        DATA: begin
            if(counter == 8)
                next_state = STOP_BIT;
            else
                next_state = DATA;
        end
        STOP_BIT: begin
            if(counter == 9)
                next_state = DONE;
            else
                next_state = STOP_BIT;
        end
        DONE: begin
            if(~in)
                next_state = START_BIT;
            else
                next_state = DONE;
        end
        default: next_state = IDLE;
    endcase
end

always @(posedge clk) begin
    if(reset)
        state <= IDLE;
    else
        state <= next_state;
end

// Outputs
assign done = (state == DONE)? 1'b1 : 1'b0;
assign out_byte = (state == DATA)? {in, in, in, in, in, in, in, in} : 8'b0;

endmodule"
N/A,N/A,-1,25,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Modify FSM and datapath from Fsm_serial

endmodule"
N/A,N/A,-1,26,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serial
    // New: Datapath to latch input bits.
    
    reg [3:0] state, next_state;
    reg [7:0] out_byte_reg;
    reg done_reg;
    
    parameter idle = 4'd0, start = 4'd1, trans0 = 4'd2, trans1 = 4'd3, trans2 = 4'd4, trans3 = 4'd5;
    parameter trans4 = 4'd6, trans5 = 4'd7, trans6 = 4'd8, trans7 = 4'd9, stop = 4'd10, error = 4'd11, pari = 4'd12;
    
    always @(*) begin
        case (state)
            idle: begin
                if(~in)
                    next_state = start;
                else
                    next_state = idle;
            end
            start: 
                if(in)
                    next_state = trans0;
                else
                    next_state = idle;
            trans0:
                if(in)
                    next_state = trans1;
                else
                    next_state = idle;
            trans1:
                if(in)
                    next_state = trans2;
                else
                    next_state = idle;
            trans2:
                if(in)
                    next_state = trans3;
                else
                    next_state = idle;
            trans3:
                if(in)
                    next_state = trans4;
                else
                    next_state = idle;
            trans4:
                if(in)
                    next_state = trans5;
                else
                    next_state = idle;
            trans5:
                if(in)
                    next_state = trans6;
                else
                    next_state = idle;
            trans6:
                if(in)
                    next_state = trans7;
                else
                    next_state = idle;
            trans7:
                if(in)
                    next_state = stop;
                else
                    next_state = idle;
            stop:
                if(in)
                    next_state = idle;
            error:
                if(in)
                    next_state = idle;
            pari:
                if(in)
                    next_state = idle;
            default:
                next_state = idle;
        endcase
    end
    
    always @(posedge clk) begin
        if(reset) begin
            state <= idle;
            out_byte_reg <= 8'b0;
            done_reg <= 1'b0;
        end
        else begin
            state <= next_state;
            out_byte_reg <= out_byte;
            done_reg <= done;
        end
    end
    
    assign out_byte = out_byte_reg;
    assign done = done_reg;
    
endmodule"
N/A,N/A,-1,27,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Use FSM from Fsm_serial

endmodule"
N/A,N/A,-1,28,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Use FSM from Fsm_serial

endmodule"
N/A,N/A,-1,29,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Use FSM from Fsm_serial

endmodule"
N/A,N/A,-1,30,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serial
    // New: Datapath to latch input bits.
    
    reg [3:0] state, next_state;
    reg [7:0] out_byte_reg;
    reg done_reg;
    
    always @(*) begin
        state <= next_state;
    end
    
    always @(posedge clk) begin
        if(reset) begin
            out_byte_reg <= 0;
            done_reg <= 0;
        end
        else begin
            out_byte_reg <= out_byte;
            done_reg <= done;
        end
    end
    
    always @(*) begin
        next_state = state;
        case (state)
            4'b0000: begin
                if(in) next_state = 4'b0001;
            end
            4'b0001: begin
                if(in) next_state = 4'b0010;
            end
            4'b0010: begin
                if(in) next_state = 4'b0011;
            end
            4'b0011: begin
                if(in) next_state = 4'b0100;
            end
            4'b0100: begin
                if(in) next_state = 4'b0101;
            end
            4'b0101: begin
                if(in) next_state = 4'b0110;
            end
            4'b0110: begin
                if(in) next_state = 4'b0111;
            end
            4'b0111: begin
                if(in) next_state = 4'b1000;
            end
            4'b1000: begin
                if(in) next_state = 4'b1001;
            end
            4'b1001: begin
                if(in) next_state = 4'b1010;
            end
            4'b1010: begin
                if(in) next_state = 4'b1011;
            end
            4'b1011: begin
                if(in) next_state = 4'b1100;
            end
            4'b1100: begin
                if(in) next_state = 4'b1101;
            end
            4'b1101: begin
                if(in) next_state = 4'b1110;
            end
            4'b1110: begin
                if(in) next_state = 4'b1111;
            end
            4'b1111: begin
                if(in) next_state = 4'b0000;
            end
            default: begin
                next_state = 4'b0000;
            end
        endcase
    end
    
    assign done = done_reg;
    assign out_byte = out_byte_reg;
    
endmodule"
N/A,N/A,-1,31,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Modify FSM and datapath from Fsm_serial
    
    parameter idle = 4'd0, start = 4'd1, trans0 = 4'd2, trans1 = 4'd3, trans2 = 4'd4, trans3 = 4'd5;
    parameter trans4 = 4'd6, trans5 = 4'd7, trans6 = 4'd8, trans7 = 4'd9, stop = 4'd10, error = 4'd11, pari = 4'd12;
    reg [3:0] state, next_state;
    
    always @(*) begin
        case (state)
            idle: begin
                if(~in)
                    next_state = start;
                else
                    next_state = idle;
            end
            start: 
                if(in)
                    next_state = trans0;
                else
                    next_state = idle;
            trans0:
                if(in)
                    next_state = trans1;
                else
                    next_state = trans0;
            trans1:
                if(in)
                    next_state = trans2;
                else
                    next_state = trans0;
            trans2:
                if(in)
                    next_state = trans3;
                else
                    next_state = trans0;
            trans3:
                if(in)
                    next_state = trans4;
                else
                    next_state = trans0;
            trans4:
                if(in)
                    next_state = trans5;
                else
                    next_state = trans0;
            trans5:
                if(in)
                    next_state = trans6;
                else
                    next_state = trans0;
            trans6:
                if(in)
                    next_state = trans7;
                else
                    next_state = trans0;
            trans7:
                if(in)
                    next_state = stop;
                else
                    next_state = trans0;
            stop:
                if(in)
                    next_state = idle;
                else
                    next_state = start;
            error:
                if(in)
                    next_state = idle;
                else
                    next_state = error;
            pari:
                if(in)
                    next_state = idle;
                else
                    next_state = pari;
        endcase
    end
    
    always @(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    assign done = (state == stop);
    
    // New: Datapath to latch input bits.
    reg [7:0] out;
    always @(posedge clk) begin
        if(state == trans0 || state == trans1 || state == trans2 || state == trans3 || state == trans4 || state == trans5 || state == trans6 || state == trans7)
            out <= {in, out[7:1]};
        else
            out <= out;
    end
    
    assign out_byte = out;
    
endmodule"
N/A,N/A,-1,32,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serial
    // New: Datapath to latch input bits.
    
    parameter idle = 0, rec_data = 1, stop_bit = 2;
    reg [1:0] state, next_state;
    reg [3:0] counter;
    reg out;
    
    always @(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    always @(*) begin
        case(state)
            idle: begin
                if(~in)
                    next_state = rec_data;
                else
                    next_state = idle;
            end
            
            rec_data: begin
                if(counter == 8)
                    next_state = stop_bit;
                else
                    next_state = rec_data;
            end
            
            stop_bit: begin
                if(in)
                    next_state = idle;
                else
                    next_state = rec_data;
            end
            
            default: next_state = idle;
        endcase
    end
    
    always @(posedge clk) begin
        if(state == rec_data && counter < 8)
            counter <= counter + 1;
        else
            counter <= 0;
    end
    
    always @(posedge clk) begin
        if(state == stop_bit)
            out <= in;
    end
    
    assign done = (state == stop_bit)? 1 : 0;
    
    assign out_byte = (state == rec_data)? {out, out, out, out, out, out, out, out} : 8'bx;
    
endmodule"
N/A,N/A,-1,33,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Use FSM from Fsm_serial

endmodule"
N/A,N/A,-1,34,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serial
    
    // New: Datapath to latch input bits.
    
    reg [7:0] out;
    
    always @(posedge clk) begin
        if(reset) begin
            out <= 0;
        end
        else begin
            out <= {out[6:0], in};
        end
    end
    
    assign done = (out == 8'h1b)? 1'b1:1'b0;
    assign out_byte = out;
    
endmodule"
N/A,N/A,-1,35,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Use FSM from Fsm_serial

endmodule"
N/A,N/A,-1,36,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Use FSM from Fsm_serial

endmodule"
N/A,N/A,-1,37,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serial
    
    parameter idle = 0, rec_data = 1, stop_bit = 2, overflow = 3;
    reg [1:0] state, next_state;
    reg [3:0] counter;
    reg [7:0] rec_data_byte;
    
    always @(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    always @(*) begin
        case(state)
            idle:
                begin
                    if(~in)
                        next_state = rec_data;
                    else
                        next_state = idle;
                end
            rec_data:
                begin
                    if(counter == 8)
                        next_state = stop_bit;
                    else
                        next_state = rec_data;
                end
            stop_bit:
                begin
                    if(~in)
                        next_state = overflow;
                    else
                        next_state = idle;
                end
            overflow:
                begin
                    next_state = idle;
                end
            default:
                begin
                    next_state = idle;
                end
        endcase
    end
    
    always @(posedge clk) begin
        if(state == rec_data && counter < 8)
            rec_data_byte[7-counter] <= in;
    end
    
    assign done = (state == stop_bit)? (rec_data_byte == ""01010101"") : 1'b0;
    
    assign out_byte = rec_data_byte;
    
    always @(posedge clk) begin
        if(state == rec_data && counter == 8)
            counter <= 0;
        else if(state == stop_bit)
            counter <= counter + 1;
    end
    
endmodule"
N/A,N/A,-1,38,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

// Define states
parameter START = 0, DATA = 1, STOP = 2, DELAY = 3;

reg [1:0] state, next_state;
reg [7:0] data;
reg out;

always @(posedge clk) begin
    if(reset)
        state <= START;
    else
        state <= next_state;
end

always @(*) begin
    case(state)
        START: begin
            if(~in)
                next_state = DATA;
            else
                next_state = START;
        end
        DATA: begin
            if(~in)
                next_state = STOP;
            else
                next_state = DATA;
        end
        STOP: begin
            if(in)
                next_state = DELAY;
            else
                next_state = START;
        end
        DELAY: begin
            if(in)
                next_state = DELAY;
            else
                next_state = START;
        end
    endcase
end

always @(posedge clk) begin
    if(state == DATA)
        data <= {data[6:0], in};
end

always @(posedge clk) begin
    if(state == STOP) begin
        out <= data[7];
        data <= 8'b0;
    end
end

assign done = (state == DELAY)? 1:0;
assign out_byte = out? 8'b11011111 : 8'b00000000;

endmodule"
N/A,N/A,-1,39,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Use FSM from Fsm_serial

// New: Datapath to latch input bits.

endmodule"
N/A,N/A,-1,40,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Use FSM from Fsm_serial

// New: Datapath to latch input bits.

endmodule"
N/A,N/A,-1,41,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Use FSM from Fsm_serial

endmodule"
N/A,N/A,-1,42,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    // Use FSM from Fsm_serial
    // New: Datapath to latch input bits.
    
    parameter idle = 0, rec_data = 1, stop_bit = 2;
    reg [1:0] state, next_state;
    reg [7:0] rec_data_reg;
    reg [3:0] counter;
    
    always @(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    always @(*) begin
        case(state)
            idle: begin
                if(~in)
                    next_state = rec_data;
                else
                    next_state = idle;
            end
            
            rec_data: begin
                if(counter == 8)
                    next_state = stop_bit;
                else
                    next_state = rec_data;
            end
            
            stop_bit: begin
                if(in)
                    next_state = idle;
                else
                    next_state = rec_data;
            end
            
            default: next_state = idle;
        endcase
    end
    
    always @(posedge clk) begin
        if(state == rec_data && reset)
            rec_data_reg <= {rec_data_reg[6:0], 1'b0};
        else if(state == stop_bit && reset)
            rec_data_reg <= {rec_data_reg[6:0], 1'b1};
    end
    
    assign done = (state == stop_bit) && (counter == 8);
    
    assign out_byte = rec_data_reg;
    
    always @(posedge clk) begin
        if(state == rec_data && reset)
            counter <= 4'b0;
        else if(state == stop_bit && reset)
            counter <= 4'b0;
        else if(state == rec_data)
            counter <= counter + 4'b1;
    end
    
    // New: Datapath to latch input bits.
    
    // New: Parallel load of rec_data_reg
    
endmodule"
N/A,N/A,-1,43,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serial
    // New: Datapath to latch input bits.
    
    reg [3:0] state, next_state;
    reg [7:0] out;
    reg out_bit;
    
    always @(*) begin
        state <= next_state;
    end
    
    always @(posedge clk) begin
        if(reset) begin
            out <= 0;
            out_bit <= 0;
            state <= 0;
            next_state <= 0;
        end
        else begin
            case(state)
                0: begin
                    if(in)
                        next_state <= 1;
                end
                1: begin
                    if(~in)
                        next_state <= 2;
                end
                2: begin
                    if(in)
                        next_state <= 3;
                end
                3: begin
                    if(~in)
                        next_state <= 0;
                end
            endcase
            
            case(next_state)
                0: begin
                    out_bit <= 0;
                end
                1: begin
                    out[0] <= in;
                    out_bit <= 1;
                end
                2: begin
                    out[1] <= in;
                    out_bit <= 1;
                end
                3: begin
                    out[2] <= in;
                    out_bit <= 1;
                end
                default: begin
                    out_bit <= 0;
                end
            endcase
        end
    end
    
    assign done = (state == 3)? 1:0;
    assign out_byte = out;
    
endmodule"
N/A,N/A,-1,44,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serial
    
    parameter idle = 0, rec_data = 1, stop_bit = 2, overflow = 3;
    reg [2:0] state, next_state;
    
    always @(*) begin
        case (state)
            idle: begin
                if(~in)
                    next_state = rec_data;
                else
                    next_state = idle;
            end
            rec_data: begin
                if(~in)
                    next_state = stop_bit;
                else
                    next_state = rec_data;
            end
            stop_bit: begin
                if(~in)
                    next_state = overflow;
                else
                    next_state = idle;
            end
            overflow: begin
                if(~in)
                    next_state = idle;
                else
                    next_state = overflow;
            end
        endcase
    end
    
    always @(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    // New: Datapath to latch input bits.
    reg [7:0] out;
    always @(posedge clk) begin
        if(state == rec_data)
            out <= {out, in};
    end
    
    assign done = (state == overflow)? 1:0;
    assign out_byte = done? out:8'bzzzz_zzzz;
    
endmodule"
N/A,N/A,-1,45,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Use FSM from Fsm_serial

// New: Datapath to latch input bits.

// New: Add parity checking.

endmodule"
N/A,N/A,-1,46,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Use FSM from Fsm_serial

endmodule"
N/A,N/A,-1,47,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    // Use FSM from Fsm_serial
    // New: Latch input bits.
    
    reg [2:0] state;
    reg [7:0] out_byte_reg;
    reg done_reg;
    
    always @(posedge clk) begin
        if(reset) begin
            state <= 3'b000;
            out_byte_reg <= 0;
            done_reg <= 0;
        end
        else begin
            case(state)
                3'b000: begin
                    if(~in)
                        state <= 3'b001;
                    else
                        state <= 3'b000;
                end
                3'b001: begin
                    if(in)
                        state <= 3'b010;
                    else
                        state <= 3'b000;
                end
                3'b010: begin
                    if(~in)
                        state <= 3'b011;
                    else
                        state <= 3'b000;
                end
                3'b011: begin
                    if(in)
                        state <= 3'b100;
                    else
                        state <= 3'b000;
                end
                3'b100: begin
                    if(~in)
                        state <= 3'b101;
                    else
                        state <= 3'b000;
                end
                3'b101: begin
                    if(in)
                        state <= 3'b110;
                    else
                        state <= 3'b000;
                end
                3'b110: begin
                    if(~in)
                        state <= 3'b111;
                    else
                        state <= 3'b000;
                end
                3'b111: begin
                    if(in)
                        state <= 3'b000;
                    else
                        state <= 3'b000;
                end
                default: begin
                    state <= 3'b000;
                end
            endcase
            
            case(state)
                3'b000: begin
                    out_byte_reg <= 0;
                end
                3'b001: begin
                    out_byte_reg[0] <= in;
                end
                3'b010: begin
                    out_byte_reg[1] <= in;
                end
                3'b011: begin
                    out_byte_reg[2] <= in;
                end
                3'b100: begin
                    out_byte_reg[3] <= in;
                end
                3'b101: begin
                    out_byte_reg[4] <= in;
                end
                3'b110: begin
                    out_byte_reg[5] <= in;
                end
                3'b111: begin
                    out_byte_reg[6] <= in;
                end
            endcase
            
            done_reg <= 0;
        end
    end
    
    assign out_byte = out_byte_reg;
    assign done = done_reg;
    
endmodule"
N/A,N/A,-1,48,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    // Use FSM from Fsm_serial
    // New: Latch input bits.
    
    reg [2:0] state;
    reg [7:0] out_byte_reg;
    reg done_reg;
    
    always @(posedge clk) begin
        if(reset) begin
            state <= 3'b000;
            out_byte_reg <= 0;
            done_reg <= 0;
        end
        else begin
            case(state)
                3'b000: begin
                    if(~in)
                        state <= 3'b001;
                    else
                        state <= 3'b000;
                end
                3'b001: begin
                    if(in)
                        state <= 3'b010;
                    else
                        state <= 3'b000;
                end
                3'b010: begin
                    if(~in)
                        state <= 3'b011;
                    else
                        state <= 3'b000;
                end
                3'b011: begin
                    if(in)
                        state <= 3'b100;
                    else
                        state <= 3'b000;
                end
                3'b100: begin
                    if(~in)
                        state <= 3'b101;
                    else
                        state <= 3'b000;
                end
                3'b101: begin
                    if(in)
                        state <= 3'b110;
                    else
                        state <= 3'b000;
                end
                3'b110: begin
                    if(~in)
                        state <= 3'b111;
                    else
                        state <= 3'b000;
                end
                3'b111: begin
                    if(in)
                        state <= 3'b000;
                    else
                        state <= 3'b000;
                end
                default: begin
                    state <= 3'b000;
                end
            endcase
            
            case(state)
                3'b000: begin
                    out_byte_reg <= 0;
                end
                3'b001: begin
                    out_byte_reg[0] <= in;
                end
                3'b010: begin
                    out_byte_reg[1] <= in;
                end
                3'b011: begin
                    out_byte_reg[2] <= in;
                end
                3'b100: begin
                    out_byte_reg[3] <= in;
                end
                3'b101: begin
                    out_byte_reg[4] <= in;
                end
                3'b110: begin
                    out_byte_reg[5] <= in;
                end
                3'b111: begin
                    out_byte_reg[6] <= in;
                end
            endcase
            
            done_reg <= 0;
        end
    end
    
    assign out_byte = out_byte_reg;
    assign done = done_reg;
    
endmodule"
N/A,N/A,-1,49,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    // Use FSM from Fsm_serial
    // New: Latch input bits.
    
    reg [2:0] state;
    reg [7:0] out_byte_reg;
    reg done_reg;
    
    always @(posedge clk) begin
        if(reset) begin
            state <= 3'b000;
            out_byte_reg <= 0;
            done_reg <= 0;
        end
        else begin
            case(state)
                3'b000: begin
                    if(~in)
                        state <= 3'b001;
                    else
                        state <= 3'b000;
                end
                3'b001: begin
                    if(in)
                        state <= 3'b010;
                    else
                        state <= 3'b000;
                end
                3'b010: begin
                    if(~in)
                        state <= 3'b011;
                    else
                        state <= 3'b000;
                end
                3'b011: begin
                    if(in)
                        state <= 3'b100;
                    else
                        state <= 3'b000;
                end
                3'b100: begin
                    if(~in)
                        state <= 3'b101;
                    else
                        state <= 3'b000;
                end
                3'b101: begin
                    if(in)
                        state <= 3'b110;
                    else
                        state <= 3'b000;
                end
                3'b110: begin
                    if(~in)
                        state <= 3'b111;
                    else
                        state <= 3'b000;
                end
                3'b111: begin
                    if(in)
                        state <= 3'b000;
                    else
                        state <= 3'b000;
                end
                default: begin
                    state <= 3'b000;
                end
            endcase
            
            case(state)
                3'b000: begin
                    out_byte_reg <= 0;
                end
                3'b001: begin
                    out_byte_reg[0] <= in;
                end
                3'b010: begin
                    out_byte_reg[1] <= in;
                end
                3'b011: begin
                    out_byte_reg[2] <= in;
                end
                3'b100: begin
                    out_byte_reg[3] <= in;
                end
                3'b101: begin
                    out_byte_reg[4] <= in;
                end
                3'b110: begin
                    out_byte_reg[5] <= in;
                end
                3'b111: begin
                    out_byte_reg[6] <= in;
                end
            endcase
            
            done_reg <= 0;
        end
    end
    
    assign out_byte = out_byte_reg;
    assign done = done_reg;
    
endmodule"
N/A,N/A,-1,50,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    // Use FSM from Fsm_serial
    // New: Latch input bits.
    
    reg [2:0] state;
    reg [7:0] out_byte_reg;
    reg done_reg;
    
    always @(posedge clk) begin
        if(reset) begin
            state <= 3'b000;
            out_byte_reg <= 0;
            done_reg <= 0;
        end
        else begin
            case(state)
                3'b000: begin
                    if(~in)
                        state <= 3'b001;
                    else
                        state <= 3'b000;
                end
                3'b001: begin
                    if(in)
                        state <= 3'b010;
                    else
                        state <= 3'b000;
                end
                3'b010: begin
                    if(~in)
                        state <= 3'b011;
                    else
                        state <= 3'b000;
                end
                3'b011: begin
                    if(in)
                        state <= 3'b100;
                    else
                        state <= 3'b000;
                end
                3'b100: begin
                    if(~in)
                        state <= 3'b101;
                    else
                        state <= 3'b000;
                end
                3'b101: begin
                    if(in)
                        state <= 3'b110;
                    else
                        state <= 3'b000;
                end
                3'b110: begin
                    if(~in)
                        state <= 3'b111;
                    else
                        state <= 3'b000;
                end
                3'b111: begin
                    if(in)
                        state <= 3'b000;
                    else
                        state <= 3'b000;
                end
                default: begin
                    state <= 3'b000;
                end
            endcase
            
            case(state)
                3'b000: begin
                    out_byte_reg <= 0;
                end
                3'b001: begin
                    out_byte_reg[0] <= in;
                end
                3'b010: begin
                    out_byte_reg[1] <= in;
                end
                3'b011: begin
                    out_byte_reg[2] <= in;
                end
                3'b100: begin
                    out_byte_reg[3] <= in;
                end
                3'b101: begin
                    out_byte_reg[4] <= in;
                end
                3'b110: begin
                    out_byte_reg[5] <= in;
                end
                3'b111: begin
                    out_byte_reg[6] <= in;
                end
            endcase
            
            done_reg <= 0;
        end
    end
    
    assign out_byte = out_byte_reg;
    assign done = done_reg;
    
endmodule"
N/A,N/A,-1,51,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serial
    // New: Datapath to latch input bits.
    
    parameter idle = 0, rec_data = 1, stop_bit = 2, error = 3;
    reg [1:0] state, next_state;
    reg [3:0] counter;
    reg [7:0] rec_data_byte;
    
    always @(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    always @(*) begin
        case(state)
            idle:
                begin
                    if(~in)
                        next_state = rec_data;
                    else
                        next_state = idle;
                end
            rec_data:
                begin
                    if(counter == 8)
                        next_state = stop_bit;
                    else
                        next_state = rec_data;
                end
            stop_bit:
                begin
                    if(in)
                        next_state = idle;
                    else
                        next_state = error;
                end
            error:
                begin
                    if(counter == 8)
                        next_state = idle;
                    else
                        next_state = error;
                end
            default:
                next_state = idle;
        endcase
    end
    
    always @(posedge clk) begin
        if(state == rec_data && counter < 8)
            rec_data_byte[7-counter] <= in;
    end
    
    assign done = (state == stop_bit)? 1 : 0;
    
    assign out_byte = rec_data_byte;
    
    always @(posedge clk) begin
        if(state == rec_data && counter == 8)
            counter <= 0;
        else if(state == stop_bit)
            counter <= counter + 1;
    end
    
endmodule"
N/A,N/A,-1,52,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Use FSM from Fsm_serial

// New: Datapath to latch input bits.

endmodule"
N/A,N/A,-1,53,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serial
    
    // New: Latch input bits.
    
    reg [2:0] state, next_state;
    reg [7:0] out;
    reg done_reg;
    
    always @(*) begin
        case (state)
            3'b000: begin
                if(~in)
                    next_state = 3'b001;
                else
                    next_state = 3'b000;
            end
            3'b001: begin
                if(in)
                    next_state = 3'b010;
                else
                    next_state = 3'b000;
            end
            3'b010: begin
                if(~in)
                    next_state = 3'b011;
                else
                    next_state = 3'b000;
            end
            3'b011: begin
                if(in)
                    next_state = 3'b100;
                else
                    next_state = 3'b000;
            end
            3'b100: begin
                if(~in)
                    next_state = 3'b101;
                else
                    next_state = 3'b000;
            end
            3'b101: begin
                if(in)
                    next_state = 3'b110;
                else
                    next_state = 3'b000;
            end
            3'b110: begin
                if(~in)
                    next_state = 3'b111;
                else
                    next_state = 3'b000;
            end
            3'b111: begin
                if(in)
                    next_state = 3'b000;
                else
                    next_state = 3'b000;
            end
            default: next_state = 3'b000;
        endcase
    end
    
    always @(posedge clk) begin
        if(reset) begin
            state <= 3'b000;
            out <= 8'b0;
            done_reg <= 1'b0;
        end
        else begin
            state <= next_state;
            out <= next_state;
            done_reg <= 1'b0;
            if(next_state == 3'b111)
                done_reg <= 1'b1;
        end
    end
    
    assign done = done_reg;
    assign out_byte = out;
    
endmodule"
N/A,N/A,-1,54,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serial
    
    parameter idle = 0, rec_data = 1, stop_bit = 2, error = 3;
    reg [2:0] state, next_state;
    reg [3:0] counter;
    reg out;
    reg [7:0] rec_data_byte;
    
    always @(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    always @(*) begin
        case(state)
            idle: begin
                if(~in)
                    next_state = rec_data;
                else
                    next_state = idle;
            end
            
            rec_data: begin
                if(counter == 8)
                    next_state = stop_bit;
                else
                    next_state = rec_data;
            end
            
            stop_bit: begin
                if(in)
                    next_state = idle;
                else
                    next_state = error;
            end
            
            error: begin
                if(counter == 8)
                    next_state = idle;
                else
                    next_state = error;
            end
        endcase
    end
    
    always @(posedge clk) begin
        if(state == rec_data && counter < 8) begin
            rec_data_byte[7:0] <= rec_data_byte[6:0];
            rec_data_byte[6:0] <= in;
            counter <= counter + 1;
        end
    end
    
    assign done = (state == stop_bit)? 1:0;
    assign out_byte = rec_data_byte;
    
endmodule"
N/A,N/A,-1,55,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serial
    
    parameter idle = 0, rec_data = 1, stop_bit = 2, error = 3;
    reg [2:0] state, next_state;
    reg [3:0] counter;
    reg out;
    reg [7:0] rec_data_byte;
    
    always @(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    always @(*) begin
        case(state)
            idle: begin
                if(~in)
                    next_state = rec_data;
                else
                    next_state = idle;
            end
            
            rec_data: begin
                if(counter == 8)
                    next_state = stop_bit;
                else
                    next_state = rec_data;
            end
            
            stop_bit: begin
                if(in)
                    next_state = idle;
                else
                    next_state = error;
            end
            
            error: begin
                if(counter == 8)
                    next_state = idle;
                else
                    next_state = error;
            end
        endcase
    end
    
    always @(posedge clk) begin
        if(state == rec_data && counter < 8) begin
            rec_data_byte[7:0] <= rec_data_byte[6:0];
            rec_data_byte[6:0] <= in;
            counter <= counter + 1;
        end
    end
    
    assign done = (state == stop_bit)? 1:0;
    assign out_byte = rec_data_byte;
    
endmodule"
N/A,N/A,-1,56,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serial
    
    parameter idle = 0, rec_data = 1, stop_bit = 2, error = 3;
    reg [2:0] state, next_state;
    reg [3:0] counter;
    reg out;
    
    always @(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    always @(*) begin
        case (state)
            idle: begin
                if(~in)
                    next_state = rec_data;
                else
                    next_state = idle;
            end
            
            rec_data: begin
                if(counter == 8)
                    next_state = stop_bit;
                else
                    next_state = rec_data;
            end
            
            stop_bit: begin
                if(in)
                    next_state = idle;
                else
                    next_state = error;
            end
            
            error: begin
                if(counter == 8)
                    next_state = idle;
                else
                    next_state = error;
            end
            
            default: next_state = idle;
        endcase
    end
    
    always @(posedge clk) begin
        if(state == rec_data && counter < 8)
            counter <= counter + 1;
        else
            counter <= 0;
    end
    
    always @(*) begin
        case (state)
            idle: begin
                out_byte = 8'b0;
                done = 0;
            end
            
            rec_data: begin
                out_byte = {out, out_byte[7:1]};
                done = 0;
            end
            
            stop_bit: begin
                done = 1;
            end
            
            error: begin
                out_byte = 8'b0;
                done = 0;
            end
            
            default: begin
                out_byte = 8'b0;
                done = 0;
            end
        endcase
    end
    
    always @(posedge clk) begin
        if(state == rec_data)
            out <= in;
        else
            out <= 0;
    end
    
endmodule"
N/A,N/A,-1,57,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serial
    // New: Latch input bits.
    
    reg [2:0] state, next_state;
    reg [7:0] out_byte_reg;
    reg done_reg;
    
    localparam IDLE = 3'd0;
    localparam GET_BYTE = 3'd1;
    localparam GET_BYTE2 = 3'd2;
    localparam WAIT = 3'd3;
    
    always @(*) begin
        case (state)
            IDLE: begin
                if(~in)
                    next_state = GET_BYTE;
                else
                    next_state = IDLE;
            end
            GET_BYTE: begin
                if(in)
                    next_state = GET_BYTE2;
                else
                    next_state = IDLE;
            end
            GET_BYTE2: begin
                if(in)
                    next_state = WAIT;
                else
                    next_state = IDLE;
            end
            WAIT: begin
                if(in)
                    next_state = GET_BYTE;
                else
                    next_state = IDLE;
            end
            default: next_state = IDLE;
        endcase
    end
    
    always @(posedge clk) begin
        if(reset) begin
            state <= IDLE;
            out_byte_reg <= 0;
            done_reg <= 0;
        end
        else begin
            state <= next_state;
            case(next_state)
                IDLE: begin
                    out_byte_reg <= 0;
                    done_reg <= 0;
                end
                GET_BYTE: begin
                    out_byte_reg[0] <= in;
                end
                GET_BYTE2: begin
                    out_byte_reg[7:1] <= in;
                end
                WAIT: begin
                    done_reg <= 0;
                end
            endcase
        end
    end
    
    assign done = done_reg;
    assign out_byte = out_byte_reg;
    
endmodule"
N/A,N/A,-1,58,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Use FSM from Fsm_serial

// New: Datapath to latch input bits.

endmodule"
N/A,N/A,-1,59,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serial
    
    parameter idle = 0, rec_data = 1, stop_bit = 2, error = 3;
    reg [2:0] state, next_state;
    reg [3:0] counter;
    reg out;
    
    always @(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    always @(*) begin
        case (state)
            idle: begin
                if(~in)
                    next_state = rec_data;
                else
                    next_state = idle;
            end
            
            rec_data: begin
                if(counter == 8)
                    next_state = stop_bit;
                else
                    next_state = rec_data;
            end
            
            stop_bit: begin
                if(in)
                    next_state = idle;
                else
                    next_state = error;
            end
            
            error: begin
                if(in)
                    next_state = idle;
                else
                    next_state = error;
            end
            
            default: next_state = idle;
        endcase
    end
    
    always @(posedge clk) begin
        if(state == rec_data && in)
            counter <= counter + 1;
        else
            counter <= 0;
    end
    
    assign done = (state == stop_bit) && (counter == 8);
    
    always @(*) begin
        case (state)
            idle: begin
                out_byte = 8'b0;
            end
            
            rec_data: begin
                out_byte = {out, out_byte[7:1]};
            end
            
            stop_bit: begin
                out_byte = {out_byte[6:0], out};
            end
            
            error: begin
                out_byte = 8'b0;
            end
        endcase
    end
    
    always @(posedge clk) begin
        if(state == rec_data)
            out <= in;
        else
            out <= 1'b0;
    end
    
endmodule"
N/A,N/A,-1,60,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Modify FSM and datapath from Fsm_serial

reg [2:0] state, next_state;
reg [7:0] out_byte;
reg done;

always @(posedge clk) begin
    if(reset)
        state <= 3'b000;
    else
        state <= next_state;
end

always @(*) begin
    case(state)
        3'b000: begin
            if(~in)
                next_state = 3'b001;
            else
                next_state = 3'b000;
        end
        3'b001: begin
            if(in)
                next_state = 3'b010;
            else
                next_state = 3'b001;
        end
        3'b010: begin
            if(~in)
                next_state = 3'b011;
            else
                next_state = 3'b010;
        end
        3'b011: begin
            if(in)
                next_state = 3'b100;
            else
                next_state = 3'b011;
        end
        3'b100: begin
            if(~in)
                next_state = 3'b101;
            else
                next_state = 3'b100;
        end
        3'b101: begin
            if(in)
                next_state = 3'b110;
            else
                next_state = 3'b101;
        end
        3'b110: begin
            if(~in)
                next_state = 3'b111;
            else
                next_state = 3'b110;
        end
        3'b111: begin
            if(in)
                next_state = 3'b000;
            else
                next_state = 3'b111;
        end
    endcase
end

always @(posedge clk) begin
    if(state == 3'b100) begin
        out_byte[0] <= in;
        out_byte[1] <= out_byte[0];
        out_byte[2] <= out_byte[1];
        out_byte[3] <= out_byte[2];
        out_byte[4] <= out_byte[3];
        out_byte[5] <= out_byte[4];
        out_byte[6] <= out_byte[5];
        out_byte[7] <= out_byte[6];
    end
end

always @(posedge clk) begin
    if(state == 3'b110) begin
        done <= in;
    end
end

endmodule"
N/A,N/A,-1,61,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serial
    // New: Datapath to latch input bits.
    
    reg [2:0] state, next_state;
    reg [7:0] out_byte_reg;
    reg done_reg;
    
    parameter idle = 3'b000;
    parameter rec_start = 3'b001;
    parameter rec_data = 3'b010;
    parameter rec_stop = 3'b011;
    parameter rec_error = 3'b100;
    
    always @(*) begin
        case (state)
            idle: begin
                if(~in)
                    next_state = rec_start;
                else
                    next_state = idle;
                done_reg = 1'b0;
            end
            
            rec_start: begin
                next_state = rec_data;
                done_reg = 1'b0;
            end
            
            rec_data: begin
                if(~in)
                    next_state = rec_stop;
                else
                    next_state = rec_data;
                done_reg = 1'b0;
            end
            
            rec_stop: begin
                if(in)
                    next_state = rec_error;
                else
                    next_state = idle;
                done_reg = 1'b1;
            end
            
            rec_error: begin
                next_state = idle;
                done_reg = 1'b0;
            end
            
            default: begin
                next_state = idle;
                done_reg = 1'b0;
            end
        endcase
    end
    
    always @(posedge clk) begin
        if(reset) begin
            state <= idle;
            out_byte_reg <= 8'b0;
            done <= 1'b0;
        end
        else begin
            state <= next_state;
            out_byte_reg <= out_byte;
            done <= done_reg;
        end
    end
    
    assign out_byte = out_byte_reg;
    
endmodule"
N/A,N/A,-1,62,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Use FSM from Fsm_serial

// New: Datapath to latch input bits.

endmodule"
N/A,N/A,-1,63,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Use FSM from Fsm_serial

// New: Datapath to latch input bits.

endmodule"
N/A,N/A,-1,64,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serial
    
    parameter idle = 0, rec_data = 1, stop_bit = 2, error = 3;
    reg [2:0] state, next_state;
    reg [3:0] counter;
    reg out;
    
    always @(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    always @(*) begin
        case(state)
            idle: begin
                if(~in)
                    next_state = rec_data;
                else
                    next_state = idle;
            end
            rec_data: begin
                if(counter == 8)
                    next_state = stop_bit;
                else
                    next_state = rec_data;
            end
            stop_bit: begin
                if(in)
                    next_state = idle;
                else
                    next_state = error;
            end
            error: begin
                if(counter == 8)
                    next_state = idle;
                else
                    next_state = error;
            end
        endcase
    end
    
    always @(posedge clk) begin
        if(state == rec_data && counter < 8)
            counter <= counter + 1;
        else
            counter <= 0;
    end
    
    always @(posedge clk) begin
        if(state == rec_data && counter == 8)
            out <= in;
        else
            out <= 1'b1;
    end
    
    assign done = (state == stop_bit)? 1 : 0;
    
    assign out_byte = (state == rec_data)? {out, out, out, out, out, out, out, out} : 8'b0;
    
endmodule"
N/A,N/A,-1,65,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serial
    
    parameter idle = 0, rec_data = 1, stop_bit = 2, overflow = 3;
    reg [2:0] state, next_state;
    reg [7:0] rec_data_reg;
    reg [3:0] counter;
    reg done_reg;
    
    always @(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    always @(*) begin
        case (state)
            idle: begin
                if(~in)
                    next_state = rec_data;
                else
                    next_state = idle;
            end
            
            rec_data: begin
                if(counter == 7)
                    next_state = stop_bit;
                else
                    next_state = rec_data;
            end
            
            stop_bit: begin
                if(in)
                    next_state = overflow;
                else
                    next_state = idle;
            end
            
            overflow: begin
                next_state = idle;
            end
            
            default: next_state = idle;
        endcase
    end
    
    always @(posedge clk) begin
        if(state == rec_data && in)
            rec_data_reg <= rec_data_reg << 1;
        else if(state == stop_bit)
            rec_data_reg <= rec_data_reg << 1;
    end
    
    always @(posedge clk) begin
        if(state == rec_data && in)
            counter <= counter + 1;
        else if(state == stop_bit)
            counter <= 0;
        else
            counter <= 0;
    end
    
    always @(posedge clk) begin
        if(state == overflow)
            done_reg <= 1;
        else
            done_reg <= 0;
    end
    
    assign done = done_reg;
    assign out_byte = rec_data_reg;
    
endmodule"
N/A,N/A,-1,66,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serial
    
    parameter idle = 0, rec_data = 1, stop_bit = 2, overflow = 3;
    reg [2:0] state, next_state;
    reg [7:0] rec_data_reg;
    reg [3:0] counter;
    reg done_reg;
    
    always @(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    always @(*) begin
        case (state)
            idle: begin
                if(~in)
                    next_state = rec_data;
                else
                    next_state = idle;
            end
            
            rec_data: begin
                if(counter == 7)
                    next_state = stop_bit;
                else
                    next_state = rec_data;
            end
            
            stop_bit: begin
                if(in)
                    next_state = overflow;
                else
                    next_state = idle;
            end
            
            overflow: begin
                next_state = idle;
            end
            
            default: next_state = idle;
        endcase
    end
    
    always @(posedge clk) begin
        if(state == rec_data && in)
            rec_data_reg <= rec_data_reg << 1;
        else if(state == stop_bit)
            rec_data_reg <= rec_data_reg << 1;
    end
    
    always @(posedge clk) begin
        if(state == rec_data && in)
            counter <= counter + 1;
        else if(state == stop_bit)
            counter <= 0;
        else
            counter <= 0;
    end
    
    always @(posedge clk) begin
        if(state == overflow)
            done_reg <= 1;
        else
            done_reg <= 0;
    end
    
    assign done = done_reg;
    assign out_byte = rec_data_reg;
    
endmodule"
N/A,N/A,-1,67,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Use FSM from Fsm_serial

// New: Datapath to latch input bits.

endmodule"
N/A,N/A,-1,68,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serial
    // New: Datapath to latch input bits.
    
    parameter idle = 0, rec_data = 1, stop_bit = 2, error = 3;
    reg [2:0] state, next_state;
    reg [3:0] counter;
    reg out;
    
    always @(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    always @(*) begin
        case(state)
            idle: begin
                if(~in)
                    next_state = rec_data;
                else
                    next_state = idle;
            end
            rec_data: begin
                if(counter == 8)
                    next_state = stop_bit;
                else
                    next_state = rec_data;
            end
            stop_bit: begin
                if(~in)
                    next_state = idle;
                else
                    next_state = error;
            end
            error: begin
                if(counter == 8)
                    next_state = idle;
                else
                    next_state = error;
            end
            default: next_state = idle;
        endcase
    end
    
    always @(posedge clk) begin
        if(state == rec_data && counter < 8)
            counter <= counter + 1;
        else
            counter <= 0;
    end
    
    always @(posedge clk) begin
        if(state == rec_data && counter == 8)
            out_byte[7:0] <= {in, out_byte[7:1]};
        else
            out_byte <= 8'b0;
    end
    
    always @(posedge clk) begin
        if(state == stop_bit && in)
            done <= 1;
        else
            done <= 0;
    end
    
    always @(posedge clk) begin
        if(state == rec_data)
            out <= in;
        else
            out <= 0;
    end
    
endmodule"
N/A,N/A,-1,69,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Use FSM from Fsm_serial

// New: Datapath to latch input bits.

endmodule"
N/A,N/A,-1,70,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Use FSM from Fsm_serial

// New: Datapath to latch input bits.

endmodule"
N/A,N/A,-1,71,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Use FSM from Fsm_serial

// New: Datapath to latch input bits.

endmodule"
N/A,N/A,-1,72,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Use FSM from Fsm_serial

reg [2:0] state, next_state;
reg [7:0] out_byte_reg;
reg done_reg;

always @(*) begin
    next_state = state;
    case (state)
        3'b000: begin
            if (in)
                next_state = 3'b001;
        end
        3'b001: begin
            if (!in)
                next_state = 3'b010;
        end
        3'b010: begin
            if (in)
                next_state = 3'b011;
        end
        3'b011: begin
            if (!in)
                next_state = 3'b100;
        end
        3'b100: begin
            if (in)
                next_state = 3'b101;
        end
        3'b101: begin
            if (!in)
                next_state = 3'b110;
        end
        3'b110: begin
            if (in)
                next_state = 3'b111;
        end
        3'b111: begin
            if (!in)
                next_state = 3'b000;
        end
    endcase
end

always @(posedge clk) begin
    if (reset) begin
        state <= 3'b000;
    end else begin
        state <= next_state;
    end
end

always @(posedge clk) begin
    if (reset) begin
        out_byte_reg <= 8'b0;
        done_reg <= 1'b0;
    end else begin
        case (state)
            3'b000: begin
                out_byte_reg <= 8'b0;
                done_reg <= 1'b0;
            end
            3'b001: begin
                out_byte_reg[0] <= in;
                done_reg <= 1'b0;
            end
            3'b010: begin
                out_byte_reg[0] <= in;
                done_reg <= 1'b0;
            end
            3'b011: begin
                out_byte_reg[1] <= in;
                done_reg <= 1'b0;
            end
            3'b100: begin
                out_byte_reg[1] <= in;
                done_reg <= 1'b0;
            end
            3'b101: begin
                out_byte_reg[2] <= in;
                done_reg <= 1'b0;
            end
            3'b110: begin
                out_byte_reg[2] <= in;
                done_reg <= 1'b0;
            end
            3'b111: begin
                out_byte_reg[3] <= in;
                done_reg <= 1'b0;
            end
        endcase
    end
end

assign out_byte = out_byte_reg;
assign done = done_reg;

endmodule"
N/A,N/A,-1,73,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Use FSM from Fsm_serial

reg [2:0] state, next_state;
reg [7:0] out_byte_reg;
reg done_reg;

always @(*) begin
    next_state = state;
    case (state)
        3'b000: begin
            if (in)
                next_state = 3'b001;
        end
        3'b001: begin
            if (!in)
                next_state = 3'b010;
        end
        3'b010: begin
            if (in)
                next_state = 3'b011;
        end
        3'b011: begin
            if (!in)
                next_state = 3'b100;
        end
        3'b100: begin
            if (in)
                next_state = 3'b101;
        end
        3'b101: begin
            if (!in)
                next_state = 3'b110;
        end
        3'b110: begin
            if (in)
                next_state = 3'b111;
        end
        3'b111: begin
            if (!in)
                next_state = 3'b000;
        end
    endcase
end

always @(posedge clk) begin
    if (reset) begin
        state <= 3'b000;
    end else begin
        state <= next_state;
    end
end

always @(posedge clk) begin
    if (reset) begin
        out_byte_reg <= 8'b0;
        done_reg <= 1'b0;
    end else begin
        case (state)
            3'b000: begin
                out_byte_reg <= 8'b0;
                done_reg <= 1'b0;
            end
            3'b001: begin
                out_byte_reg[0] <= in;
                done_reg <= 1'b0;
            end
            3'b010: begin
                out_byte_reg[0] <= in;
                done_reg <= 1'b0;
            end
            3'b011: begin
                out_byte_reg[1] <= in;
                done_reg <= 1'b0;
            end
            3'b100: begin
                out_byte_reg[1] <= in;
                done_reg <= 1'b0;
            end
            3'b101: begin
                out_byte_reg[2] <= in;
                done_reg <= 1'b0;
            end
            3'b110: begin
                out_byte_reg[2] <= in;
                done_reg <= 1'b0;
            end
            3'b111: begin
                out_byte_reg[3] <= in;
                done_reg <= 1'b0;
            end
        endcase
    end
end

assign out_byte = out_byte_reg;
assign done = done_reg;

endmodule"
N/A,N/A,-1,74,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// You may use these parameters to access the RAM
parameter RAM_WIDTH = 8; // Specify RAM data width
parameter RAM_ADDR_BITS = 5; // Specify RAM address width

// Declare the RAM variable
reg [RAM_WIDTH-1:0] ram[2**RAM_ADDR_BITS-1:0];

// Variable to hold the registered read address
reg [RAM_ADDR_BITS-1:0] addr_reg;

// Specify the byte size. This is a power of 2 to speed up the FSM.
// You may change this parameter to fit your RAM.
parameter BYTE_SIZE = 1; // Specify the byte size.

// Declare a byte counter
reg [BYTE_SIZE*8-1:0] byte_count;

// Declare a byte counter for output
reg [BYTE_SIZE-1:0] out_byte_count;

// Declare done signal for output
reg done_reg;

// Register the input
always @(posedge clk)
begin
    if (reset)
        addr_reg <= 0;
    else
        addr_reg <= addr_reg + 1;
end

// RAM read
always @(posedge clk)
begin
    if (!reset)
        ram[addr_reg] <= 0;
    else
        ram[addr_reg] <= ram[addr_reg] + 1;
end

// Update the byte counter
always @(posedge clk)
begin
    if (reset)
        byte_count <= 0;
    else
        byte_count <= byte_count + 1;
end

// Update the output byte counter
always @(posedge clk)
begin
    if (!reset)
        out_byte_count <= 0;
    else if (done_reg)
        out_byte_count <= out_byte_count + 1;
end

// Update the done signal
always @(posedge clk)
begin
    if (reset)
        done_reg <= 0;
    else if (byte_count == BYTE_SIZE - 1)
        done_reg <= 1;
    else
        done_reg <= 0;
end

// Output the byte
assign out_byte = ram[addr_reg][BYTE_SIZE-1:0];

// Done signal
assign done = done_reg;

endmodule"
N/A,N/A,-1,75,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Modify FSM and datapath from Fsm_serial
    
    // New: Latch input bits.
    reg [3:0] state;
    reg [3:0] next_state;
    reg [7:0] out_byte;
    reg done;
    
    always @(*) begin
        state <= next_state;
    end
    
    always @(posedge clk) begin
        if(reset) begin
            state <= 0;
            out_byte <= 0;
            done <= 0;
        end
        else begin
            case (state)
                0: begin
                    if(in)
                        next_state <= 1;
                    else
                        next_state <= 0;
                end
                1: begin
                    if(in)
                        next_state <= 1;
                    else
                        next_state <= 0;
                end
                default: begin
                    if(in)
                        next_state <= 1;
                    else
                        next_state <= 0;
                end
            endcase
            
            case (state)
                0: begin
                    out_byte <= 0;
                end
                1: begin
                    out_byte <= {in, out_byte[7:1]};
                end
            endcase
            
            if(state == 3)
                done <= 1;
            else
                done <= 0;
        end
    end
    
endmodule"
N/A,N/A,-1,76,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// You can use this counter to verify that the gap and width are as expected.
reg [4:0] counter = 1'b0;
always @(posedge clk) begin
    if(reset)
        counter <= 1'b0;
    else
        counter <= counter + 1'b1;
end

// Define states as usual
parameter idle = 4'd0;
parameter start = 4'd1;
parameter bit = 4'd2;
parameter stop = 4'd3;

reg [3:0] state = idle;
reg [3:0] next_state = idle;

// New: Datapath to latch input bits.
reg [3:0] bit_count = 4'd0;
reg [7:0] out = 8'd0;

always @(posedge clk) begin
    if(reset) begin
        state <= idle;
        bit_count <= 4'd0;
        out <= 8'd0;
    end
    else begin
        // State transition logic
        state <= next_state;
        // New: Datapath to latch input bits.
        bit_count <= bit_count + 4'd1;
        out <= out << 1;
        out[0] <= in;
    end
end

// Output logic
assign done = (state == stop);

// New: Datapath to latch input bits.
assign out_byte = out;

always @(state) begin
    case(state)
        idle: begin
            if(counter == 5'd8)
                next_state = start;
            else
                next_state = idle;
        end
        start: begin
            if(counter == 5'd24)
                next_state = bit;
            else
                next_state = start;
        end
        bit: begin
            if(counter == 5'd24) begin
                if(in)
                    next_state = stop;
                else
                    next_state = idle;
            end
            else
                next_state = bit;
        end
        stop: begin
            next_state = idle;
        end
    endcase
end

endmodule"
N/A,N/A,-1,77,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

// Define states
parameter idle = 0, rec_data = 1, stop_bit = 2;

reg [1:0] state, next_state;
reg [7:0] rec_data_reg;
reg [2:0] counter;

// New: Latch input bits.
reg [7:0] in_byte;

// New: Output byte
wire [7:0] out_byte_reg;

// New: Done output
wire done_reg;

// New: Counter for rec_data state
wire [2:0] counter_next;

// New: Output byte
assign out_byte = out_byte_reg;

// New: Done output
assign done = done_reg;

// New: Counter for rec_data state
assign counter_next = (state == rec_data)? counter + 3'd1 : counter;

// New: Output byte
assign out_byte_reg = (state == rec_data)? rec_data_reg : 8'bz;

// New: Done output
assign done_reg = (state == stop_bit) && (counter == 3'd7);

// FSMD next-state logic
always @(*) begin
    case (state)
        idle: begin
            if(~in)
                next_state = idle;
            else
                next_state = rec_data;
        end
        rec_data: begin
            if(counter == 3'd7)
                next_state = stop_bit;
            else
                next_state = rec_data;
        end
        stop_bit: begin
            if(in)
                next_state = idle;
            else
                next_state = rec_data;
        end
        default:
            next_state = idle;
    endcase
end

// FSMD state-transition logic
always @(posedge clk) begin
    if(reset)
        state <= idle;
    else
        state <= next_state;
end

// FSMD output logic
always @(*) begin
    case (state)
        idle: begin
            out_byte_reg = 8'bz;
            done_reg = 1'b0;
        end
        rec_data: begin
            rec_data_reg = in_byte;
            done_reg = 1'b0;
        end
        stop_bit: begin
            done_reg = 1'b1;
        end
        default: begin
            out_byte_reg = 8'bz;
            done_reg = 1'b0;
        end
    endcase
end

// New: Latch input bits.
always @(posedge clk) begin
    if(reset)
        in_byte <= 8'bz;
    else if(next_state == rec_data)
        in_byte <= in;
end

// New: Counter for rec_data state
always @(posedge clk) begin
    if(reset)
        counter <= 3'd0;
    else if(state == rec_data)
        counter <= counter_next;
    else
        counter <= 3'd0;
end

endmodule"
N/A,N/A,-1,78,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

// Define states
parameter idle = 0, rec_data = 1, stop_bit = 2;

reg [1:0] state, next_state;
reg [7:0] rec_data_reg;
reg [2:0] counter;

// New: Latch input bits.
reg [7:0] in_byte;

// New: Output byte
wire [7:0] out_byte_reg;

// New: Done output
wire done_reg;

// New: Counter for rec_data state
wire [2:0] counter_next;

// New: Output byte
assign out_byte = out_byte_reg;

// New: Done output
assign done = done_reg;

// New: Counter for rec_data state
assign counter_next = (state == rec_data)? counter + 3'd1 : counter;

// New: Output byte
assign out_byte_reg = (state == rec_data)? rec_data_reg : 8'bz;

// New: Done output
assign done_reg = (state == stop_bit) && (counter == 3'd7);

// FSMD next-state logic
always @(*) begin
    case (state)
        idle: begin
            if(~in)
                next_state = idle;
            else
                next_state = rec_data;
        end
        rec_data: begin
            if(counter == 3'd7)
                next_state = stop_bit;
            else
                next_state = rec_data;
        end
        stop_bit: begin
            if(in)
                next_state = idle;
            else
                next_state = rec_data;
        end
        default:
            next_state = idle;
    endcase
end

// FSMD state-transition logic
always @(posedge clk) begin
    if(reset)
        state <= idle;
    else
        state <= next_state;
end

// FSMD output logic
always @(*) begin
    case (state)
        idle: begin
            out_byte_reg = 8'bz;
            done_reg = 1'b0;
        end
        rec_data: begin
            rec_data_reg = in_byte;
            done_reg = 1'b0;
        end
        stop_bit: begin
            done_reg = 1'b1;
        end
        default: begin
            out_byte_reg = 8'bz;
            done_reg = 1'b0;
        end
    endcase
end

// New: Latch input bits.
always @(posedge clk) begin
    if(reset)
        in_byte <= 8'bz;
    else if(next_state == rec_data)
        in_byte <= in;
end

// New: Counter for rec_data state
always @(posedge clk) begin
    if(reset)
        counter <= 3'd0;
    else if(state == rec_data)
        counter <= counter_next;
    else
        counter <= 3'd0;
end

endmodule"
N/A,N/A,-1,79,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Use FSM from Fsm_serial

endmodule"
N/A,N/A,-1,80,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serial
    // New: Datapath to latch input bits.
    
    reg [2:0] state, next_state;
    reg [7:0] out_byte_reg;
    reg done_reg;
    
    parameter idle = 3'b000;
    parameter start = 3'b001;
    parameter trans0 = 3'b010;
    parameter trans1 = 3'b011;
    parameter trans2 = 3'b100;
    parameter trans3 = 3'b101;
    parameter trans4 = 3'b110;
    parameter trans5 = 3'b111;
    parameter trans6 = 3'bx00;
    parameter trans7 = 3'bx01;
    parameter trans8 = 3'bx10;
    parameter trans9 = 3'bx11;
    
    always @(*) begin
        state <= next_state;
    end
    
    always @(posedge clk) begin
        if(reset) begin
            done_reg <= 1'b0;
            out_byte_reg <= 8'b0;
        end
        else begin
            done_reg <= done;
            out_byte_reg <= out_byte;
        end
    end
    
    always @(*) begin
        next_state = state;
        case (state)
            idle: begin
                if(~in) begin
                    next_state = start;
                end
            end
            start: begin
                if(in) begin
                    next_state = trans0;
                end
            end
            trans0: begin
                if(~in) begin
                    next_state = trans1;
                end
            end
            trans1: begin
                if(~in) begin
                    next_state = trans2;
                end
            end
            trans2: begin
                if(~in) begin
                    next_state = trans3;
                end
            end
            trans3: begin
                if(~in) begin
                    next_state = trans4;
                end
            end
            trans4: begin
                if(~in) begin
                    next_state = trans5;
                end
            end
            trans5: begin
                if(~in) begin
                    next_state = trans6;
                end
            end
            trans6: begin
                if(~in) begin
                    next_state = trans7;
                end
            end
            trans7: begin
                if(~in) begin
                    next_state = trans8;
                end
            end
            trans8: begin
                if(~in) begin
                    next_state = trans9;
                end
            end
            trans9: begin
                if(~in) begin
                    next_state = idle;
                end
            end
            default: begin
                next_state = idle;
            end
        endcase
    end
    
    assign done = (state == trans9 && in == 1'b0)? 1'b1: 1'b0;
    assign out_byte = (state == trans9)? out_byte_reg: 8'b0;
    
endmodule"
N/A,N/A,-1,81,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serial
    // New: Datapath to latch input bits.
    
    reg [2:0] state, next_state;
    reg [7:0] out_byte_reg;
    reg done_reg;
    
    parameter idle = 3'b000;
    parameter start = 3'b001;
    parameter trans0 = 3'b010;
    parameter trans1 = 3'b011;
    parameter trans2 = 3'b100;
    parameter trans3 = 3'b101;
    parameter trans4 = 3'b110;
    parameter trans5 = 3'b111;
    parameter trans6 = 3'bx00;
    parameter trans7 = 3'bx01;
    parameter trans8 = 3'bx10;
    parameter trans9 = 3'bx11;
    
    always @(*) begin
        state <= next_state;
    end
    
    always @(posedge clk) begin
        if(reset) begin
            done_reg <= 1'b0;
            out_byte_reg <= 8'b0;
        end
        else begin
            done_reg <= done;
            out_byte_reg <= out_byte;
        end
    end
    
    always @(*) begin
        next_state = state;
        case (state)
            idle: begin
                if(~in) begin
                    next_state = start;
                end
            end
            start: begin
                if(in) begin
                    next_state = trans0;
                end
            end
            trans0: begin
                if(~in) begin
                    next_state = trans1;
                end
            end
            trans1: begin
                if(~in) begin
                    next_state = trans2;
                end
            end
            trans2: begin
                if(~in) begin
                    next_state = trans3;
                end
            end
            trans3: begin
                if(~in) begin
                    next_state = trans4;
                end
            end
            trans4: begin
                if(~in) begin
                    next_state = trans5;
                end
            end
            trans5: begin
                if(~in) begin
                    next_state = trans6;
                end
            end
            trans6: begin
                if(~in) begin
                    next_state = trans7;
                end
            end
            trans7: begin
                if(~in) begin
                    next_state = trans8;
                end
            end
            trans8: begin
                if(~in) begin
                    next_state = trans9;
                end
            end
            trans9: begin
                if(~in) begin
                    next_state = idle;
                end
            end
            default: begin
                next_state = idle;
            end
        endcase
    end
    
    assign done = (state == trans9 && in == 1'b0)? 1'b1: 1'b0;
    assign out_byte = (state == trans9)? out_byte_reg: 8'b0;
    
endmodule"
N/A,N/A,-1,82,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serial
    
    parameter idle = 0, rec_data = 1, stop_bit = 2;
    reg [1:0] state, next_state;
    reg [3:0] counter;
    reg out;
    
    always @(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    always @(*) begin
        case(state)
            idle: begin
                if(~in)
                    next_state = rec_data;
                else
                    next_state = idle;
            end
            rec_data: begin
                if(counter == 8)
                    next_state = stop_bit;
                else
                    next_state = rec_data;
            end
            stop_bit: begin
                if(in)
                    next_state = idle;
                else
                    next_state = rec_data;
            end
            default: next_state = idle;
        endcase
    end
    
    always @(posedge clk) begin
        if(state == rec_data && counter < 8)
            counter <= counter + 1;
        else
            counter <= 0;
    end
    
    always @(posedge clk) begin
        if(state == stop_bit)
            out <= in;
    end
    
    assign done = (state == stop_bit) && (counter == 8);
    
    assign out_byte = out? {out, out, out, out, out, out, out, out} : 8'bz;
    
endmodule"
N/A,N/A,-1,83,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serial
    
    parameter idle = 0, rec_data = 1, stop_bit = 2;
    reg [1:0] state, next_state;
    reg [3:0] counter;
    reg out;
    
    always @(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    always @(*) begin
        case(state)
            idle: begin
                if(~in)
                    next_state = rec_data;
                else
                    next_state = idle;
            end
            rec_data: begin
                if(counter == 8)
                    next_state = stop_bit;
                else
                    next_state = rec_data;
            end
            stop_bit: begin
                if(in)
                    next_state = idle;
                else
                    next_state = rec_data;
            end
            default: next_state = idle;
        endcase
    end
    
    always @(posedge clk) begin
        if(state == rec_data && counter < 8)
            counter <= counter + 1;
        else
            counter <= 0;
    end
    
    always @(posedge clk) begin
        if(state == stop_bit)
            out <= in;
    end
    
    assign done = (state == stop_bit) && (counter == 8);
    
    assign out_byte = out? {out, out, out, out, out, out, out, out} : 8'bz;
    
endmodule"
N/A,N/A,-1,84,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serial
    
    parameter idle = 0, rec_data = 1, stop_bit = 2;
    reg [1:0] state, next_state;
    reg [3:0] counter;
    reg out;
    
    always @(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    always @(*) begin
        case(state)
            idle: begin
                if(~in)
                    next_state = rec_data;
                else
                    next_state = idle;
            end
            rec_data: begin
                if(counter == 8)
                    next_state = stop_bit;
                else
                    next_state = rec_data;
            end
            stop_bit: begin
                if(in)
                    next_state = idle;
                else
                    next_state = rec_data;
            end
            default: next_state = idle;
        endcase
    end
    
    always @(posedge clk) begin
        if(state == rec_data && counter < 8)
            counter <= counter + 1;
        else
            counter <= 0;
    end
    
    always @(posedge clk) begin
        if(state == stop_bit)
            out <= in;
    end
    
    assign done = (state == stop_bit) && (counter == 8);
    
    assign out_byte = out? {out, out, out, out, out, out, out, out} : 8'bz;
    
endmodule"
N/A,N/A,-1,85,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serial
    // New: Datapath to latch input bits.
    
    parameter idle = 0, rec_data = 1, stop_bit = 2, error = 3;
    reg [2:0] state, next_state;
    
    always @(*) begin
        case (state)
            idle: begin
                if(~in)
                    next_state = rec_data;
                else
                    next_state = idle;
            end
            rec_data: begin
                if(~in)
                    next_state = idle;
                else
                    next_state = rec_data;
            end
            stop_bit: begin
                if(~in)
                    next_state = error;
                else
                    next_state = stop_bit;
            end
            error: begin
                if(~in)
                    next_state = idle;
                else
                    next_state = error;
            end
        endcase
    end
    
    always @(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    assign done = (state == stop_bit);
    
    // New: Datapath to latch input bits.
    reg [7:0] out_byte_reg;
    always @(posedge clk) begin
        if(state == rec_data)
            out_byte_reg <= {out_byte_reg[6:0], in};
    end
    assign out_byte = out_byte_reg;
    
endmodule"
N/A,N/A,-1,86,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serial
    // New: Datapath to latch input bits.
    
    parameter idle = 0, rec_data = 1, stop_bit = 2, error = 3;
    reg [2:0] state, next_state;
    
    always @(*) begin
        case (state)
            idle: begin
                if(~in)
                    next_state = rec_data;
                else
                    next_state = idle;
            end
            rec_data: begin
                if(~in)
                    next_state = idle;
                else
                    next_state = rec_data;
            end
            stop_bit: begin
                if(~in)
                    next_state = error;
                else
                    next_state = stop_bit;
            end
            error: begin
                if(~in)
                    next_state = idle;
                else
                    next_state = error;
            end
        endcase
    end
    
    always @(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    assign done = (state == stop_bit);
    
    // New: Datapath to latch input bits.
    reg [7:0] out_byte_reg;
    always @(posedge clk) begin
        if(state == rec_data)
            out_byte_reg <= {out_byte_reg[6:0], in};
    end
    assign out_byte = out_byte_reg;
    
endmodule"
N/A,N/A,-1,87,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Use FSM from Fsm_serial

reg [2:0] state, next_state;
reg [7:0] out;
reg done_reg;

always @(*) begin
    next_state = state;
    done_reg = 1'b0;
    case (state)
        3'b000: begin
            if (in)
                next_state = 3'b001;
        end
        3'b001: begin
            if (in)
                next_state = 3'b010;
            else
                next_state = 3'b000;
        end
        3'b010: begin
            if (in)
                next_state = 3'b011;
            else
                next_state = 3'b000;
        end
        3'b011: begin
            if (in)
                next_state = 3'b100;
            else
                next_state = 3'b000;
        end
        3'b100: begin
            if (in)
                next_state = 3'b101;
            else
                next_state = 3'b000;
        end
        3'b101: begin
            if (in)
                next_state = 3'b110;
            else
                next_state = 3'b000;
        end
        3'b110: begin
            if (in)
                next_state = 3'b111;
            else
                next_state = 3'b000;
        end
        3'b111: begin
            if (in)
                next_state = 3'b000;
            else
                next_state = 3'b000;
        end
        default: begin
            next_state = 3'b000;
        end
    endcase
end

always @(posedge clk) begin
    if (reset) begin
        state <= 3'b000;
        out <= 8'b0;
    end
    else begin
        state <= next_state;
        case (next_state)
            3'b000: begin
                out <= 8'b0;
            end
            3'b001: begin
                out <= 8'b0;
            end
            3'b010: begin
                out <= 8'b0;
            end
            3'b011: begin
                out <= 8'b0;
            end
            3'b100: begin
                out <= 8'b0;
            end
            3'b101: begin
                out <= 8'b0;
            end
            3'b110: begin
                out <= 8'b0;
            end
            3'b111: begin
                out <= {in, out[7:1]};
            end
            default: begin
                out <= 8'b0;
            end
        endcase
    end
end

assign done = done_reg;
assign out_byte = out;

always @(posedge clk) begin
    if (reset)
        done_reg <= 1'b0;
    else if (next_state == 3'b111)
        done_reg <= 1'b1;
end

endmodule"
N/A,N/A,-1,88,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Use FSM from Fsm_serial

endmodule"
N/A,N/A,-1,89,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serial
    
    parameter idle = 0, rec_data = 1, stop_bit = 2, overflow = 3;
    reg [2:0] state, next_state;
    reg [3:0] counter;
    reg out;
    reg [7:0] rec_data_byte;
    
    always @(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    always @(*) begin
        case (state)
            idle: begin
                if(~in)
                    next_state = rec_data;
                else
                    next_state = idle;
            end
            
            rec_data: begin
                if(counter == 8)
                    next_state = stop_bit;
                else
                    next_state = rec_data;
            end
            
            stop_bit: begin
                if(in)
                    next_state = overflow;
                else
                    next_state = idle;
            end
            
            overflow: begin
                if(counter == 255)
                    next_state = idle;
                else
                    next_state = rec_data;
            end
            
            default: next_state = idle;
        endcase
    end
    
    always @(posedge clk) begin
        if(state == rec_data && counter < 8) begin
            rec_data_byte[7:0] <= rec_data_byte[6:0];
            rec_data_byte[6:0] <= in;
            counter <= counter + 1;
        end
        
        if(state == stop_bit) begin
            out <= rec_data_byte[7];
        end
    end
    
    assign done = (state == overflow);
    
    assign out_byte = done?out:8'bzzzz_zzzz;
    
endmodule"
N/A,N/A,-1,90,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serial
    
    parameter idle = 0, rec_data = 1, stop_bit = 2, overflow = 3;
    reg [2:0] state, next_state;
    reg [3:0] counter;
    reg out;
    reg [7:0] rec_data_byte;
    
    always @(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    always @(*) begin
        case (state)
            idle: begin
                if(~in)
                    next_state = rec_data;
                else
                    next_state = idle;
            end
            
            rec_data: begin
                if(counter == 8)
                    next_state = stop_bit;
                else
                    next_state = rec_data;
            end
            
            stop_bit: begin
                if(in)
                    next_state = overflow;
                else
                    next_state = idle;
            end
            
            overflow: begin
                if(counter == 255)
                    next_state = idle;
                else
                    next_state = rec_data;
            end
            
            default: next_state = idle;
        endcase
    end
    
    always @(posedge clk) begin
        if(state == rec_data && counter < 8) begin
            rec_data_byte[7:0] <= rec_data_byte[6:0];
            rec_data_byte[6:0] <= in;
            counter <= counter + 1;
        end
        
        if(state == stop_bit) begin
            out <= rec_data_byte[7];
        end
    end
    
    assign done = (state == overflow);
    
    assign out_byte = done?out:8'bzzzz_zzzz;
    
endmodule"
N/A,N/A,-1,91,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Use FSM from Fsm_serial

// New: Datapath to latch input bits.

endmodule"
N/A,N/A,-1,92,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

reg [7:0] out_byte_reg;
reg done_reg;

always @(posedge clk) begin
    if(reset) begin
        out_byte_reg <= 0;
        done_reg <= 0;
    end
    else begin
        out_byte_reg <= out_byte_next;
        done_reg <= done_next;
    end
end

assign out_byte = out_byte_reg;
assign done = done_reg;

// New: Datapath to latch input bits.

reg [3:0] in_reg, in_next;

always @(posedge clk) begin
    if(reset) begin
        in_reg <= 0;
    end
    else begin
        in_reg <= in_next;
    end
end

always @(*) begin
    in_next = in_reg;
    if(in)
        in_next = in_reg + 1;
end

// New: Datapath to latch input bits.

endmodule"
N/A,N/A,-1,93,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Modify FSM and datapath from Fsm_serial
    
    parameter idle = 0, rec_data = 1, stop_bit = 2, error = 3;
    reg [2:0] state, next_state;
    reg [3:0] counter;
    reg out;
    
    always @(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    always @(*) begin
        case(state)
            idle: begin
                if(~in)
                    next_state = rec_data;
                else
                    next_state = idle;
            end
            rec_data: begin
                if(counter == 8)
                    next_state = stop_bit;
                else
                    next_state = rec_data;
            end
            stop_bit: begin
                if(~in)
                    next_state = idle;
                else
                    next_state = error;
            end
            error: begin
                if(~in)
                    next_state = idle;
                else
                    next_state = error;
            end
            default: next_state = idle;
        endcase
    end
    
    always @(posedge clk) begin
        if(state == rec_data && counter < 8)
            counter <= counter + 1;
        else
            counter <= 0;
    end
    
    always @(posedge clk) begin
        if(state == rec_data && counter == 8)
            out_byte[7:0] <= {in, out_byte[7:1]};
        else
            out_byte <= 8'b0;
    end
    
    always @(posedge clk) begin
        if(state == stop_bit && in)
            out <= 1;
        else
            out <= 0;
    end
    
    assign done = (state == stop_bit) && (next_state == idle);
    
endmodule"
N/A,N/A,-1,94,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serial
    // New: Datapath to latch input bits.
    
    reg [2:0] state, next_state;
    reg [7:0] out_byte_reg;
    reg done_reg;
    
    always @(*) begin
        state <= next_state;
    end
    
    always @(posedge clk) begin
        if(reset) begin
            done_reg <= 0;
            out_byte_reg <= 0;
        end
        else begin
            done_reg <= done_reg;
            out_byte_reg <= out_byte_reg;
        end
    end
    
    always @(*) begin
        next_state = state;
        case (state)
            3'b000: begin
                if(~in)
                    next_state = 3'b001;
                else
                    next_state = 3'b000;
            end
            3'b001: begin
                if(in)
                    next_state = 3'b010;
                else
                    next_state = 3'b001;
            end
            3'b010: begin
                if(in)
                    next_state = 3'b011;
                else
                    next_state = 3'b010;
            end
            3'b011: begin
                if(~in)
                    next_state = 3'b100;
                else
                    next_state = 3'b011;
            end
            3'b100: begin
                if(in)
                    next_state = 3'b101;
                else
                    next_state = 3'b100;
            end
            3'b101: begin
                if(~in)
                    next_state = 3'b110;
                else
                    next_state = 3'b101;
            end
            3'b110: begin
                if(in)
                    next_state = 3'b110;
                else
                    next_state = 3'b110;
            end
            3'b110: begin
                if(~in)
                    next_state = 3'b000;
                else
                    next_state = 3'b110;
            end
            default: begin
                next_state = 3'b000;
            end
        endcase
    end
    
    assign done = done_reg;
    assign out_byte = out_byte_reg;
    
endmodule"
N/A,N/A,-1,95,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serial
    // New: Datapath to latch input bits.
    
    reg [2:0] state, next_state;
    reg [7:0] out_byte_reg;
    reg done_reg;
    
    always @(*) begin
        state <= next_state;
    end
    
    always @(posedge clk) begin
        if(reset) begin
            done_reg <= 0;
            out_byte_reg <= 0;
        end
        else begin
            done_reg <= done_reg;
            out_byte_reg <= out_byte_reg;
        end
    end
    
    always @(*) begin
        next_state = state;
        case (state)
            3'b000: begin
                if(~in)
                    next_state = 3'b001;
                else
                    next_state = 3'b000;
            end
            3'b001: begin
                if(in)
                    next_state = 3'b010;
                else
                    next_state = 3'b001;
            end
            3'b010: begin
                if(in)
                    next_state = 3'b011;
                else
                    next_state = 3'b010;
            end
            3'b011: begin
                if(~in)
                    next_state = 3'b100;
                else
                    next_state = 3'b011;
            end
            3'b100: begin
                if(in)
                    next_state = 3'b101;
                else
                    next_state = 3'b100;
            end
            3'b101: begin
                if(~in)
                    next_state = 3'b110;
                else
                    next_state = 3'b101;
            end
            3'b110: begin
                if(in)
                    next_state = 3'b110;
                else
                    next_state = 3'b110;
            end
            3'b110: begin
                if(~in)
                    next_state = 3'b000;
                else
                    next_state = 3'b110;
            end
            default: begin
                next_state = 3'b000;
            end
        endcase
    end
    
    assign done = done_reg;
    assign out_byte = out_byte_reg;
    
endmodule"
N/A,N/A,-1,96,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Use FSM from Fsm_serial

// New: Datapath to latch input bits.

endmodule"
N/A,N/A,-1,97,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Use FSM from Fsm_serial

// New: Datapath to latch input bits.

endmodule"
N/A,N/A,-1,98,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    // Use FSM from Fsm_serial
    // New: Datapath to latch input bits.
    
    parameter idle = 0, rec_data = 1, stop_bit = 2;
    reg [1:0] state, next_state;
    reg [3:0] counter;
    reg out;
    
    always @(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    always @(*) begin
        case(state)
            idle:
                begin
                    if(~in)
                        next_state = rec_data;
                    else
                        next_state = idle;
                end
            rec_data:
                begin
                    if(counter == 8)
                        next_state = stop_bit;
                    else
                        next_state = rec_data;
                end
            stop_bit:
                begin
                    if(in)
                        next_state = idle;
                    else
                        next_state = rec_data;
                end
            default:
                next_state = idle;
        endcase
    end
    
    always @(posedge clk) begin
        if(state == rec_data && counter < 8)
            counter <= counter + 1;
        else
            counter <= 0;
    end
    
    always @(posedge clk) begin
        if(state == rec_data && counter == 8)
            out <= in;
        else
            out <= 1'b0;
    end
    
    assign done = (state == stop_bit)? 1 : 0;
    assign out_byte = (state == rec_data)? {out, out, out, out, out, out, out, out} : 8'h00;
    
endmodule"
N/A,N/A,-1,99,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Modify FSM and datapath from Fsm_serial
    
    parameter idle = 0, rec_data = 1, stop_bit = 2, overflow = 3;
    reg [1:0] state, next_state;
    reg [3:0] counter;
    reg [7:0] rec_data_byte;
    
    always @(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    always @(*) begin
        case(state)
            idle:
                begin
                    if(~in)
                        next_state = rec_data;
                    else
                        next_state = idle;
                end
            rec_data:
                begin
                    if(counter == 7)
                        next_state = stop_bit;
                    else
                        next_state = rec_data;
                end
            stop_bit:
                begin
                    if(in)
                        next_state = overflow;
                    else
                        next_state = idle;
                end
            overflow:
                begin
                    next_state = idle;
                end
            default:
                next_state = idle;
        endcase
    end
    
    always @(posedge clk) begin
        if(state == rec_data && counter < 7)
            rec_data_byte[7-counter] <= in;
    end
    
    assign done = (state == overflow)? 1:0;
    assign out_byte = rec_data_byte;
    
    always @(posedge clk) begin
        if(state == stop_bit)
            counter <= counter + 1;
        else
            counter <= 0;
    end
    
endmodule"
