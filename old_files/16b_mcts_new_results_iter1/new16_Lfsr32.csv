Area,Delay,Score,Current Run,Episode,Verilog
N/A,N/A,-1,2.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    wire [31:0] q_next, q_reg;
    
    assign q_next = q_reg + 1;
    
    always @(posedge clk)
        if(reset)
            q_reg <= 32'h1;
    	else
            q_reg <= q_next;
    
    assign q = q_reg;
    
endmodule"
N/A,N/A,-1,3.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31]? {q[30:0], 1'b0} : q[30:0];
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end

endmodule"
N/A,N/A,-1,4.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31] ^ q[0] ^ q[1] ^ q[2] ^ q[3] ^ q[4] ^ q[5] ^ q[6] ^ q[7] ^ q[8] ^ q[9] ^ q[10] ^ q[11] ^ q[12] ^ q[13] ^ q[14] ^ q[15] ^ q[16] ^ q[17] ^ q[18] ^ q[19] ^ q[20] ^ q[21] ^ q[22] ^ q[23] ^ q[24] ^ q[25] ^ q[26] ^ q[27] ^ q[28] ^ q[29] ^ q[30] ^ q[31];
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end
    
endmodule"
N/A,N/A,-1,5.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31] ^ q[0] ^ q[1] ^ q[2] ^ q[3] ^ q[4] ^ q[5] ^ q[6] ^ q[7] ^ q[8] ^ q[9] ^ q[10] ^ q[11] ^ q[12] ^ q[13] ^ q[14] ^ q[15] ^ q[16] ^ q[17] ^ q[18] ^ q[19] ^ q[20] ^ q[21] ^ q[22] ^ q[23] ^ q[24] ^ q[25] ^ q[26] ^ q[27] ^ q[28] ^ q[29] ^ q[30] ^ q[31];
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end
    
endmodule"
N/A,N/A,-1,6.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31] ^ q[0];
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end
    
endmodule"
N/A,N/A,-1,7.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    wire [31:0] q_bar, q_next;
    
    assign q_bar = ~q;
    
    assign q_next = q_bar ^ q[31];
    
    always @(posedge clk)
        if(reset)
            q <= 32'h1;
    	else
            q <= q_next;

endmodule"
N/A,N/A,-1,8.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    wire [31:0] q_bar, q_next;
    
    assign q_bar = ~q;
    
    assign q_next = q_bar ^ q[31];
    
    always @(posedge clk)
        if(reset)
            q <= 32'h1;
    	else
            q <= q_next;

endmodule"
N/A,N/A,-1,9.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31]? {q[30:0], 1'b0} : q_next;
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end
    
endmodule"
N/A,N/A,-1,10.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31]? {q[30:0], 1'b0} : q[31:0];
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end
    
endmodule"
N/A,N/A,-1,11.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 
    
    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31]? {q[30:0], 1'b0} : q[30:0];
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end
    
endmodule"
N/A,N/A,-1,12.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    wire [31:0] q_next, q_reg;
    
    assign q_next = q_reg + 1;
    
    always @(posedge clk) begin
        if(reset)
            q_reg <= 32'h1;
        else
            q_reg <= q_next;
    end
    
    assign q = q_reg;
    
endmodule"
N/A,N/A,-1,13.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31] ^ q[0] ^ q[1] ^ q[2] ^ q[3] ^ q[4] ^ q[5] ^ q[6] ^ q[7] ^ q[8] ^ q[9] ^ q[10] ^ q[11] ^ q[12] ^ q[13] ^ q[14] ^ q[15] ^ q[16] ^ q[17] ^ q[18] ^ q[19] ^ q[20] ^ q[21] ^ q[22] ^ q[23] ^ q[24] ^ q[25] ^ q[26] ^ q[27] ^ q[28] ^ q[29] ^ q[30] ^ q[31];
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end
    
endmodule"
N/A,N/A,-1,14.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31] ^ q[0];
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end

endmodule"
N/A,N/A,-1,15.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31] ^ q[0] ^ q[1] ^ q[2] ^ q[3];
        q_next[31] = q[0][31] ^ q[0][0] ^ q[0][1] ^ q[0][2] ^ q[0][3];
        q_next[30:0] = q[31:0];
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end
    
endmodule"
N/A,N/A,-1,16.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31] ^ q[30] ^ q[29] ^ q[28] ^ q[27] ^ q[26] ^ q[25] ^ q[24] ^ q[23] ^ q[22] ^ q[21] ^ q[20] ^ q[19] ^ q[18] ^ q[17] ^ q[16] ^ q[15] ^ q[14] ^ q[13] ^ q[12] ^ q[11] ^ q[10] ^ q[9] ^ q[8] ^ q[7] ^ q[6] ^ q[5] ^ q[4] ^ q[3] ^ q[2] ^ q[1] ^ q[0];
        q_next[31] = q[31] ^ q[31] ^ q[30] ^ q[29] ^ q[28] ^ q[27] ^ q[26] ^ q[25] ^ q[24] ^ q[23] ^ q[22] ^ q[21] ^ q[20] ^ q[19] ^ q[18] ^ q[17] ^ q[16] ^ q[15] ^ q[14] ^ q[13] ^ q[12] ^ q[11] ^ q[10] ^ q[9] ^ q[8] ^ q[7] ^ q[6] ^ q[5] ^ q[4] ^ q[3] ^ q[2] ^ q[1] ^ q[0];
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end
    
endmodule"
N/A,N/A,-1,17.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    wire [31:0] q_wire;
    
    assign q = q_wire;
    
    assign q_wire[31] = q_wire[30] ^ q_wire[31];
    assign q_wire[30:0] = q_wire[29:0] ^ q_wire[30:1];
    
    always @(posedge clk)
        if(reset)
            q_wire <= 32'h1;
        else
            q_wire <= q_wire >> 1;
endmodule"
N/A,N/A,-1,18.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 
    
    // Use a standard cell from the library (or your own design)
    // Instantiate the Galois LFSR
    // Connect the taps to the standard cell inputs
    // Connect the standard cell outputs to the wires going out of this module
    
    // Use the '*' operator to connect the module outputs to the wires going to the outside
    
    assign q = {reset, clk};
    
endmodule"
N/A,N/A,-1,19.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31] ^ q[0] ^ q[1] ^ q[2] ^ q[3];
        q_next[31] = q[0][31] ^ q[0][0] ^ q[0][1] ^ q[0][2] ^ q[0][3];
        q_next[30:0] = q[31:0];
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end
    
endmodule"
N/A,N/A,-1,20.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31] ^ q[0] ^ q[1] ^ q[2] ^ q[3];
        q_next[31] = q[0][31] ^ q[0][0] ^ q[0][1] ^ q[0][2] ^ q[0][3];
        q_next[30:0] = q[31:1];
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end

endmodule"
N/A,N/A,-1,21.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 
    
    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31] ^ q[0] ^ q[1] ^ q[2] ^ q[3] ^ q[4] ^ q[5] ^ q[6] ^ q[7] ^ q[8] ^ q[9] ^ q[10] ^ q[11] ^ q[12] ^ q[13] ^ q[14] ^ q[15] ^ q[16] ^ q[17] ^ q[18] ^ q[19] ^ q[20] ^ q[21] ^ q[22] ^ q[23] ^ q[24] ^ q[25] ^ q[26] ^ q[27] ^ q[28] ^ q[29] ^ q[30] ^ q[31];
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end
    
endmodule"
N/A,N/A,-1,22.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    wire [31:0] q_bar, q_next;
    
    assign q_bar = ~q;
    
    assign q_next = q_bar ^ q[31:1];
    
    always @(posedge clk)
        if(reset)
            q <= 32'h1;
    	else
            q <= q_next;
endmodule"
N/A,N/A,-1,23.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31] ^ q[0] ^ q[1] ^ q[2] ^ q[3] ^ q[4] ^ q[5] ^ q[6] ^ q[7] ^ q[8] ^ q[9] ^ q[10] ^ q[11] ^ q[12] ^ q[13] ^ q[14] ^ q[15] ^ q[16] ^ q[17] ^ q[18] ^ q[19] ^ q[20] ^ q[21] ^ q[22] ^ q[23] ^ q[24] ^ q[25] ^ q[26] ^ q[27] ^ q[28] ^ q[29] ^ q[30] ^ q[31];
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end
    
endmodule"
N/A,N/A,-1,24.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31]? {q[30:0], 1'b0} : q_next;
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end
    
endmodule"
N/A,N/A,-1,25.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31] ^ q[0] ^ q[1] ^ q[2] ^ q[3] ^ q[4] ^ q[5] ^ q[6] ^ q[7] ^ q[8] ^ q[9] ^ q[10] ^ q[11] ^ q[12] ^ q[13] ^ q[14] ^ q[15] ^ q[16] ^ q[17] ^ q[18] ^ q[19] ^ q[20] ^ q[21] ^ q[22] ^ q[23] ^ q[24] ^ q[25] ^ q[26] ^ q[27] ^ q[28] ^ q[29] ^ q[30] ^ q[31];
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end
    
endmodule"
N/A,N/A,-1,26.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31] ^ q[0];
        q_next[31] = q[0] ^ q[1] ^ q[2] ^ q[3];
        q_next[30:0] = q[30:0] >> 1;
        q_next[31] = q[31] ^ q[0];
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end

endmodule"
N/A,N/A,-1,27.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    wire [31:0] q_bar, q_next;
    
    assign q_bar = ~q;
    
    assign q_next = q_bar ^ q[31];
    
    always @(posedge clk)
        if(reset)
            q <= 32'h1;
    	else
            q <= q_next;

endmodule"
N/A,N/A,-1,28.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    wire [31:0] q_bar, q_next;
    
    assign q_bar = ~q;
    
    assign q_next = q_bar ^ q[31];
    
    always @(posedge clk)
        if(reset)
            q <= 32'h1;
    	else
            q <= q_next;

endmodule"
N/A,N/A,-1,29.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31]? {q[30:0], 1'b0} : q_next;
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end
    
endmodule"
N/A,N/A,-1,30.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31] ^ q[0];
        q_next[31] = q[0];
        q_next[22] = q[0];
        q_next[2] = q[0];
        q_next[1] = q[0];
        q_next[0] = q[0];
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end

endmodule"
N/A,N/A,-1,31.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 
    
    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31] ^ q[0] ^ q[1] ^ q[2] ^ q[3] ^ q[4] ^ q[5] ^ q[6] ^ q[7] ^ q[8] ^ q[9] ^ q[10] ^ q[11] ^ q[12] ^ q[13] ^ q[14] ^ q[15] ^ q[16] ^ q[17] ^ q[18] ^ q[19] ^ q[20] ^ q[21] ^ q[22] ^ q[23] ^ q[24] ^ q[25] ^ q[26] ^ q[27] ^ q[28] ^ q[29] ^ q[30] ^ q[31];
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end
    
endmodule"
N/A,N/A,-1,32.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    wire [31:0] q_bar, q_next;
    assign q_bar = ~q;
    
    assign q_next = q_bar ^ q[0];
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end

endmodule"
N/A,N/A,-1,33.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31]? {q[30:0], 1'b0} : q[31:0];
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end

endmodule"
N/A,N/A,-1,34.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31] ^ q[0] ^ q[1] ^ q[2] ^ q[3] ^ q[4] ^ q[5] ^ q[6] ^ q[7] ^ q[8] ^ q[9] ^ q[10] ^ q[11] ^ q[12] ^ q[13] ^ q[14] ^ q[15] ^ q[16] ^ q[17] ^ q[18] ^ q[19] ^ q[20] ^ q[21] ^ q[22] ^ q[23] ^ q[24] ^ q[25] ^ q[26] ^ q[27] ^ q[28] ^ q[29] ^ q[30] ^ q[31];
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end
    
endmodule"
N/A,N/A,-1,35.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31]? {q[30:0], 1'b0} : q_next;
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end
    
endmodule"
N/A,N/A,-1,36.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31]? {q[30:0], 1'b0} : q_next;
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end
    
endmodule"
N/A,N/A,-1,37.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    wire [31:0] q_bar, q_next;
    
    assign q_bar = ~q;
    
    assign q_next = q_bar ^ q[31];
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end
    
endmodule"
N/A,N/A,-1,38.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 
    
    // Use a standard cell from the library (or your own design)
    // Instantiate the Galois LFSR
    // Connect the output to the register that will store the LFSR output
    // Connect the register to the output that will be driving the output
    // Wire the input to the register to the input of the LFSR
    
    // Use the standard Verilog code to implement a DFF
    
    // Use the standard Verilog code to implement a register
    
    // Use the standard Verilog code to implement a LFSR
    
    // Use the standard Verilog code to implement a 32-bit LFSR
    
endmodule"
N/A,N/A,-1,39.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31] ^ q[0];
        q_next[31] = q[0];
        q_next[22] = q[0];
        q_next[2] = q[0];
        q_next[1] = q[0];
        q_next[0] = q[0];
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end
    
endmodule"
N/A,N/A,-1,40.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31] ^ q[0] ^ q[1] ^ q[2] ^ q[3] ^ q[4] ^ q[5] ^ q[6] ^ q[7] ^ q[8] ^ q[9] ^ q[10] ^ q[11] ^ q[12] ^ q[13] ^ q[14] ^ q[15] ^ q[16] ^ q[17] ^ q[18] ^ q[19] ^ q[20] ^ q[21] ^ q[22] ^ q[23] ^ q[24] ^ q[25] ^ q[26] ^ q[27] ^ q[28] ^ q[29] ^ q[30] ^ q[31];
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end
    
endmodule"
N/A,N/A,-1,41.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 
    
    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31] ^ q[0] ^ q[1] ^ q[2] ^ q[3];
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end
    
endmodule"
N/A,N/A,-1,42.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    wire [31:0] q_wire;
    
    assign q = q_wire;
    
    always @ (posedge clk)
        if (reset)
            q_wire <= 32'h1;
        else
            q_wire <= {q_wire[30:0], q_wire[31] ^ q_wire[30]};

endmodule"
N/A,N/A,-1,43.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31] ^ q[30] ^ q[29] ^ q[28] ^ q[27] ^ q[26] ^ q[25] ^ q[24] ^ q[23] ^ q[22] ^ q[21] ^ q[20] ^ q[19] ^ q[18] ^ q[17] ^ q[16] ^ q[15] ^ q[14] ^ q[13] ^ q[12] ^ q[11] ^ q[10] ^ q[9] ^ q[8] ^ q[7] ^ q[6] ^ q[5] ^ q[4] ^ q[3] ^ q[2] ^ q[1] ^ q[0];
        q_next[31] = q_next[0];
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end
    
endmodule"
N/A,N/A,-1,44.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31]? {q[30:0], 1'b0} : q[30:0] ^ q[31];
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end
    
endmodule"
N/A,N/A,-1,45.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31] ^ q[0] ^ q[1] ^ q[2] ^ q[3] ^ q[4] ^ q[5] ^ q[6] ^ q[7] ^ q[8] ^ q[9] ^ q[10] ^ q[11] ^ q[12] ^ q[13] ^ q[14] ^ q[15] ^ q[16] ^ q[17] ^ q[18] ^ q[19] ^ q[20] ^ q[21] ^ q[22] ^ q[23] ^ q[24] ^ q[25] ^ q[26] ^ q[27] ^ q[28] ^ q[29] ^ q[30] ^ q[31];
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end
    
endmodule"
N/A,N/A,-1,46.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31] ^ q[30] ^ q[29] ^ q[28] ^ q[27] ^ q[26] ^ q[25] ^ q[24] ^ q[23] ^ q[22] ^ q[21] ^ q[20] ^ q[19] ^ q[18] ^ q[17] ^ q[16] ^ q[15] ^ q[14] ^ q[13] ^ q[12] ^ q[11] ^ q[10] ^ q[9] ^ q[8] ^ q[7] ^ q[6] ^ q[5] ^ q[4] ^ q[3] ^ q[2] ^ q[1] ^ q[0];
        q_next[31] = q[31] ^ q[30] ^ q[29] ^ q[28] ^ q[27] ^ q[26] ^ q[25] ^ q[24] ^ q[23] ^ q[22] ^ q[21] ^ q[20] ^ q[19] ^ q[18] ^ q[17] ^ q[16] ^ q[15] ^ q[14] ^ q[13] ^ q[12] ^ q[11] ^ q[10] ^ q[9] ^ q[8] ^ q[7] ^ q[6] ^ q[5] ^ q[4] ^ q[3] ^ q[2] ^ q[1] ^ q[0];
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end
    
endmodule"
N/A,N/A,-1,47.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31] ^ q[30] ^ q[29] ^ q[28] ^ q[27] ^ q[26] ^ q[25] ^ q[24] ^ q[23] ^ q[22] ^ q[21] ^ q[20] ^ q[19] ^ q[18] ^ q[17] ^ q[16] ^ q[15] ^ q[14] ^ q[13] ^ q[12] ^ q[11] ^ q[10] ^ q[9] ^ q[8] ^ q[7] ^ q[6] ^ q[5] ^ q[4] ^ q[3] ^ q[2] ^ q[1] ^ q[0];
        q_next[31] = q[31] ^ q[30] ^ q[29] ^ q[28] ^ q[27] ^ q[26] ^ q[25] ^ q[24] ^ q[23] ^ q[22] ^ q[21] ^ q[20] ^ q[19] ^ q[18] ^ q[17] ^ q[16] ^ q[15] ^ q[14] ^ q[13] ^ q[12] ^ q[11] ^ q[10] ^ q[9] ^ q[8] ^ q[7] ^ q[6] ^ q[5] ^ q[4] ^ q[3] ^ q[2] ^ q[1] ^ q[0];
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end
    
endmodule"
N/A,N/A,-1,48.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 
    
    // Use a standard cell from the library (or your own design)
    // Instantiate the Galois LFSR
    // Connect the taps to the standard cell inputs
    // Connect the standard cell outputs to the wires going out of this module
    
    assign q = {
        32'h1,
        32'h1,
        clk,
        reset
    };
    
endmodule"
N/A,N/A,-1,49.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31]? {q[30:0], 1'b0} : q_next;
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end

endmodule"
N/A,N/A,-1,50.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31]? {q[30:0], 1'b0} : q_next;
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end
    
endmodule"
N/A,N/A,-1,51.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 
    
    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31] ^ q[0] ^ q[1] ^ q[2] ^ q[3] ^ q[4] ^ q[5] ^ q[6] ^ q[7] ^ q[8] ^ q[9] ^ q[10] ^ q[11] ^ q[12] ^ q[13] ^ q[14] ^ q[15] ^ q[16] ^ q[17] ^ q[18] ^ q[19] ^ q[20] ^ q[21] ^ q[22] ^ q[23] ^ q[24] ^ q[25] ^ q[26] ^ q[27] ^ q[28] ^ q[29] ^ q[30] ^ q[31];
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end
    
endmodule"
N/A,N/A,-1,52.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    wire [31:0] q_bar, q_next;
    
    assign q_bar = ~q;
    
    assign q_next = q_bar ^ q[31];
    
    always @(posedge clk)
        if(reset)
            q <= 32'h1;
    	else
            q <= q_next;
endmodule"
N/A,N/A,-1,53.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31]? {q[30:0], 1'b0} : q_next;
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end
    
endmodule"
N/A,N/A,-1,54.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31] ^ q[0] ^ q[1] ^ q[2] ^ q[3] ^ q[4] ^ q[5] ^ q[6] ^ q[7] ^ q[8] ^ q[9] ^ q[10] ^ q[11] ^ q[12] ^ q[13] ^ q[14] ^ q[15] ^ q[16] ^ q[17] ^ q[18] ^ q[19] ^ q[20] ^ q[21] ^ q[22] ^ q[23] ^ q[24] ^ q[25] ^ q[26] ^ q[27] ^ q[28] ^ q[29] ^ q[30] ^ q[31];
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end
    
endmodule"
N/A,N/A,-1,55.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31]? {q[30:0], 1'b0} : q_next;
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end
    
endmodule"
N/A,N/A,-1,56.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31]? {q[30:0], 1'b0} : q_next;
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end
    
endmodule"
N/A,N/A,-1,57.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    wire [31:0] q_bar, q_next;
    
    assign q_bar = ~q;
    
    assign q_next = q_bar ^ q[0];
    
    always @(posedge clk)
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;

endmodule"
N/A,N/A,-1,58.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    wire [31:0] q_bar, q_next;
    
    assign q_bar = ~q;
    
    assign q_next = q_bar ^ q[0];
    
    always @(posedge clk)
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;

endmodule"
N/A,N/A,-1,59.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31]? {q[30:0], 1'b0} : q[31:0];
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end

endmodule"
N/A,N/A,-1,60.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31]? {q[30:0], 1'b0} : q_next;
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end

endmodule"
N/A,N/A,-1,61.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 
    
    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31] ^ q[0] ^ q[1] ^ q[2] ^ q[3];
        q_next[31] = q[0][31] ^ q[0][0] ^ q[0][1] ^ q[0][2] ^ q[0][3];
        q_next[30:0] = q[31:0];
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end
    
endmodule"
N/A,N/A,-1,62.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    wire [31:0] q_bar, q_next;
    assign q_bar = ~q;
    
    assign q_next = q_bar ^ {q[31], q[23], q[15], q[7]};
    
    always @(posedge clk)
        if(reset)
            q <= 32'h1;
    	else
            q <= q_next;
endmodule"
N/A,N/A,-1,63.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31] ^ q[30] ^ q[29] ^ q[28] ^ q[27] ^ q[26] ^ q[25] ^ q[24] ^ q[23] ^ q[22] ^ q[21] ^ q[20] ^ q[19] ^ q[18] ^ q[17] ^ q[16] ^ q[15] ^ q[14] ^ q[13] ^ q[12] ^ q[11] ^ q[10] ^ q[9] ^ q[8] ^ q[7] ^ q[6] ^ q[5] ^ q[4] ^ q[3] ^ q[2] ^ q[1] ^ q[0];
        q_next[31] = q_next[30] ^ q_next[29] ^ q_next[28] ^ q_next[27] ^ q_next[26] ^ q_next[25] ^ q_next[24] ^ q_next[23] ^ q_next[22] ^ q_next[21] ^ q_next[20] ^ q_next[19] ^ q_next[18] ^ q_next[17] ^ q_next[16] ^ q_next[15] ^ q_next[14] ^ q_next[13] ^ q_next[12] ^ q_next[11] ^ q_next[10] ^ q_next[9] ^ q_next[8] ^ q_next[7] ^ q_next[6] ^ q_next[5] ^ q_next[4] ^ q_next[3] ^ q_next[2] ^ q_next[1] ^ q_next[0];
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end
    
endmodule"
N/A,N/A,-1,64.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31] ^ q[30] ^ q[29] ^ q[28] ^ q[27] ^ q[26] ^ q[25] ^ q[24] ^ q[23] ^ q[22] ^ q[21] ^ q[20] ^ q[19] ^ q[18] ^ q[17] ^ q[16] ^ q[15] ^ q[14] ^ q[13] ^ q[12] ^ q[11] ^ q[10] ^ q[9] ^ q[8] ^ q[7] ^ q[6] ^ q[5] ^ q[4] ^ q[3] ^ q[2] ^ q[1] ^ q[0];
        q_next[31] = q[31] ^ q[30] ^ q[29] ^ q[28] ^ q[27] ^ q[26] ^ q[25] ^ q[24] ^ q[23] ^ q[22] ^ q[21] ^ q[20] ^ q[19] ^ q[18] ^ q[17] ^ q[16] ^ q[15] ^ q[14] ^ q[13] ^ q[12] ^ q[11] ^ q[10] ^ q[9] ^ q[8] ^ q[7] ^ q[6] ^ q[5] ^ q[4] ^ q[3] ^ q[2] ^ q[1] ^ q[0];
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end
    
endmodule"
N/A,N/A,-1,65.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31] ^ q[0] ^ q[1] ^ q[2] ^ q[3] ^ q[4] ^ q[5] ^ q[6] ^ q[7] ^ q[8] ^ q[9] ^ q[10] ^ q[11] ^ q[12] ^ q[13] ^ q[14] ^ q[15] ^ q[16] ^ q[17] ^ q[18] ^ q[19] ^ q[20] ^ q[21] ^ q[22] ^ q[23] ^ q[24] ^ q[25] ^ q[26] ^ q[27] ^ q[28] ^ q[29] ^ q[30] ^ q[31];
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end
    
endmodule"
N/A,N/A,-1,66.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31] ^ q[0];
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end
    
endmodule"
N/A,N/A,-1,67.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    wire [31:0] q_bar;
    
    assign q_bar = ~q + 1;
    
    always @(posedge clk)
        if(reset)
            q <= 32'h1;
    	else
            q <= q_bar;
endmodule"
N/A,N/A,-1,68.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    wire [31:0] q_bar;
    
    assign q_bar = ~q + 1;
    
    always @(posedge clk)
        if(reset)
            q <= 32'h1;
    	else
            q <= q_bar;
endmodule"
N/A,N/A,-1,69.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31]? {q[30:0], 1'b0} : q_next;
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end
    
endmodule"
N/A,N/A,-1,70.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31] ^ q[0] ^ q[1] ^ q[2] ^ q[3];
        q_next[31] = q[0][31] ^ q[0][0] ^ q[0][1] ^ q[0][2] ^ q[0][3];
        q_next[30:0] = q[31:0];
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end
    
endmodule"
N/A,N/A,-1,71.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 
    
    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31]? {q[30:0], 1'b0} : q_next;
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end
    
endmodule"
N/A,N/A,-1,72.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    wire [31:0] q_bar, q_next;
    
    assign q_bar = ~q;
    
    assign q_next = q_bar ^ q[31:1];
    
    always @(posedge clk)
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;

endmodule"
N/A,N/A,-1,73.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31] ^ q[0];
        q_next[31] = q[0] ^ q[31];
        q_next[30:0] = q[31:1];
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end

endmodule"
N/A,N/A,-1,74.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31]? {q[30:0], 1'b0} : q[31:0];
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end
    
endmodule"
N/A,N/A,-1,75.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31] ^ q[0] ^ q[1] ^ q[2] ^ q[3] ^ q[4] ^ q[5] ^ q[6] ^ q[7] ^ q[8] ^ q[9] ^ q[10] ^ q[11] ^ q[12] ^ q[13] ^ q[14] ^ q[15] ^ q[16] ^ q[17] ^ q[18] ^ q[19] ^ q[20] ^ q[21] ^ q[22] ^ q[23] ^ q[24] ^ q[25] ^ q[26] ^ q[27] ^ q[28] ^ q[29] ^ q[30] ^ q[31];
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end

endmodule"
N/A,N/A,-1,76.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31] ^ q[0] ^ q[1] ^ q[2] ^ q[3] ^ q[4] ^ q[5] ^ q[6] ^ q[7] ^ q[8] ^ q[9] ^ q[10] ^ q[11] ^ q[12] ^ q[13] ^ q[14] ^ q[15] ^ q[16] ^ q[17] ^ q[18] ^ q[19] ^ q[20] ^ q[21] ^ q[22] ^ q[23] ^ q[24] ^ q[25] ^ q[26] ^ q[27] ^ q[28] ^ q[29] ^ q[30] ^ q[31];
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end

endmodule"
N/A,N/A,-1,77.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31] ^ q[0] ^ q[1] ^ q[2] ^ q[3] ^ q[4] ^ q[5] ^ q[6] ^ q[7] ^ q[8] ^ q[9] ^ q[10] ^ q[11] ^ q[12] ^ q[13] ^ q[14] ^ q[15] ^ q[16] ^ q[17] ^ q[18] ^ q[19] ^ q[20] ^ q[21] ^ q[22] ^ q[23] ^ q[24] ^ q[25] ^ q[26] ^ q[27] ^ q[28] ^ q[29] ^ q[30] ^ q[31];
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end

endmodule"
N/A,N/A,-1,78.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31] ^ q[0] ^ q[1] ^ q[2] ^ q[3] ^ q[4] ^ q[5] ^ q[6] ^ q[7] ^ q[8] ^ q[9] ^ q[10] ^ q[11] ^ q[12] ^ q[13] ^ q[14] ^ q[15] ^ q[16] ^ q[17] ^ q[18] ^ q[19] ^ q[20] ^ q[21] ^ q[22] ^ q[23] ^ q[24] ^ q[25] ^ q[26] ^ q[27] ^ q[28] ^ q[29] ^ q[30] ^ q[31];
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end

endmodule"
N/A,N/A,-1,79.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31] ^ q[30] ^ q[29] ^ q[28] ^ q[27] ^ q[26] ^ q[25] ^ q[24] ^ q[23] ^ q[22] ^ q[21] ^ q[20] ^ q[19] ^ q[18] ^ q[17] ^ q[16] ^ q[15] ^ q[14] ^ q[13] ^ q[12] ^ q[11] ^ q[10] ^ q[9] ^ q[8] ^ q[7] ^ q[6] ^ q[5] ^ q[4] ^ q[3] ^ q[2] ^ q[1] ^ q[0];
        q_next[31] = q[31] ^ q[30] ^ q[29] ^ q[28] ^ q[27] ^ q[26] ^ q[25] ^ q[24] ^ q[23] ^ q[22] ^ q[21] ^ q[20] ^ q[19] ^ q[18] ^ q[17] ^ q[16] ^ q[15] ^ q[14] ^ q[13] ^ q[12] ^ q[11] ^ q[10] ^ q[9] ^ q[8] ^ q[7] ^ q[6] ^ q[5] ^ q[4] ^ q[3] ^ q[2] ^ q[1] ^ q[0];
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end
    
endmodule"
N/A,N/A,-1,80.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31] ^ q[0] ^ q[1] ^ q[2] ^ q[3];
        q_next[31] = q[0] ^ q[1] ^ q[2] ^ q[3];
        q_next[30:0] = q[30:0] >> 1;
        q_next[30:0] ^= q[31:1];
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end
    
endmodule"
N/A,N/A,-1,81.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 
    
    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31] ^ q[0] ^ q[1] ^ q[2] ^ q[3];
        q_next[31] = q[0] ^ q[1] ^ q[2] ^ q[3];
        q_next[30:0] = q[30:0];
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end
    
endmodule"
N/A,N/A,-1,82.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    wire [31:0] q_bar, q_next;
    
    assign q_bar = ~q;
    
    assign q_next = q_bar ^ q[31];
    
    always @(posedge clk)
        if(reset)
            q <= 32'h1;
    	else
            q <= q_next;
endmodule"
N/A,N/A,-1,83.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31]? {q[30:0], 1'b0} : q[31:0];
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end
    
endmodule"
N/A,N/A,-1,84.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31]? {q[30:0], 1'b0} : q_next;
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end

endmodule"
N/A,N/A,-1,85.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31]? {q[30:0], 1'b0} : q_next;
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end

endmodule"
N/A,N/A,-1,86.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31] ^ q[0] ^ q[1] ^ q[2] ^ q[3];
        q_next[31] = q[0][31] ^ q[0][0] ^ q[0][1] ^ q[0][2] ^ q[0][3];
        q_next[30:0] = q[31:0];
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end

endmodule"
N/A,N/A,-1,87.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    wire [31:0] q_wire;
    
    assign q = q_wire;
    
    always @(posedge clk)
        if(reset)
            q_wire <= 32'h1;
        else
            q_wire <= {q_wire[30:0], q_wire[31] ^ q_wire[30]};

endmodule"
N/A,N/A,-1,88.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    wire [31:0] q_wire;
    
    assign q = q_wire;
    
    always @(posedge clk)
        if(reset)
            q_wire <= 32'h1;
        else
            q_wire <= {q_wire[30:0], q_wire[31] ^ q_wire[30]};

endmodule"
N/A,N/A,-1,89.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31] ^ q[0] ^ q[1] ^ q[2] ^ q[3] ^ q[4] ^ q[5] ^ q[6] ^ q[7] ^ q[8] ^ q[9] ^ q[10] ^ q[11] ^ q[12] ^ q[13] ^ q[14] ^ q[15] ^ q[16] ^ q[17] ^ q[18] ^ q[19] ^ q[20] ^ q[21] ^ q[22] ^ q[23] ^ q[24] ^ q[25] ^ q[26] ^ q[27] ^ q[28] ^ q[29] ^ q[30] ^ q[31];
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end
    
endmodule"
N/A,N/A,-1,90.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31]? {q[30:0], 1'b0} : q_next;
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end
endmodule"
N/A,N/A,-1,91.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 
    
    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31] ^ q[0] ^ q[1] ^ q[2] ^ q[3];
        q_next[31] = q[0] ^ q[1] ^ q[2] ^ q[3];
        q_next[30:0] = q[30:0] >> 1;
        q_next[30:0] ^= q[31:1];
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end
    
endmodule"
N/A,N/A,-1,92.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    wire [31:0] q_next;
    
    assign q_next = (q[31] ^ q[23]) ^ q[0] ^ q[1] ^ q[2] ^ q[3] ^ q[4] ^ q[5] ^ q[6] ^ q[7] ^ q[8] ^ q[9] ^ q[10] ^ q[11] ^ q[12] ^ q[13] ^ q[14] ^ q[15] ^ q[16] ^ q[17] ^ q[18] ^ q[19] ^ q[20] ^ q[21] ^ q[22] ^ q[24] ^ q[25] ^ q[26] ^ q[27] ^ q[28] ^ q[29] ^ q[30] ^ q[31];
    
    always @(posedge clk)
        if(reset)
            q <= 32'h1;
    	else
            q <= q_next;

endmodule"
N/A,N/A,-1,93.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31] ^ q[0] ^ q[1] ^ q[2] ^ q[3];
        q_next[31] = q[0][31] ^ q[0][0] ^ q[0][1] ^ q[0][2] ^ q[0][3];
        q_next[30:0] = q[31:0];
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end
    
endmodule"
N/A,N/A,-1,94.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31] ^ q[30] ^ q[29] ^ q[28] ^ q[27] ^ q[26] ^ q[25] ^ q[24] ^ q[23] ^ q[22] ^ q[21] ^ q[20] ^ q[19] ^ q[18] ^ q[17] ^ q[16] ^ q[15] ^ q[14] ^ q[13] ^ q[12] ^ q[11] ^ q[10] ^ q[9] ^ q[8] ^ q[7] ^ q[6] ^ q[5] ^ q[4] ^ q[3] ^ q[2] ^ q[1] ^ q[0];
        q_next[31] = q[31] ^ q[30] ^ q[29] ^ q[28] ^ q[27] ^ q[26] ^ q[25] ^ q[24] ^ q[23] ^ q[22] ^ q[21] ^ q[20] ^ q[19] ^ q[18] ^ q[17] ^ q[16] ^ q[15] ^ q[14] ^ q[13] ^ q[12] ^ q[11] ^ q[10] ^ q[9] ^ q[8] ^ q[7] ^ q[6] ^ q[5] ^ q[4] ^ q[3] ^ q[2] ^ q[1] ^ q[0];
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end
    
endmodule"
N/A,N/A,-1,95.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31] ^ q[0] ^ q[1] ^ q[2] ^ q[3] ^ q[4] ^ q[5] ^ q[6] ^ q[7] ^ q[8] ^ q[9] ^ q[10] ^ q[11] ^ q[12] ^ q[13] ^ q[14] ^ q[15] ^ q[16] ^ q[17] ^ q[18] ^ q[19] ^ q[20] ^ q[21] ^ q[22] ^ q[23] ^ q[24] ^ q[25] ^ q[26] ^ q[27] ^ q[28] ^ q[29] ^ q[30] ^ q[31];
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end
    
endmodule"
N/A,N/A,-1,96.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31] ^ q[0] ^ q[1] ^ q[2] ^ q[3] ^ q[4] ^ q[5] ^ q[6] ^ q[7] ^ q[8] ^ q[9] ^ q[10] ^ q[11] ^ q[12] ^ q[13] ^ q[14] ^ q[15] ^ q[16] ^ q[17] ^ q[18] ^ q[19] ^ q[20] ^ q[21] ^ q[22] ^ q[23] ^ q[24] ^ q[25] ^ q[26] ^ q[27] ^ q[28] ^ q[29] ^ q[30] ^ q[31];
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end
    
endmodule"
N/A,N/A,-1,97.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31] ^ q[0] ^ q[1] ^ q[2] ^ q[3] ^ q[4] ^ q[5] ^ q[6] ^ q[7] ^ q[8] ^ q[9] ^ q[10] ^ q[11] ^ q[12] ^ q[13] ^ q[14] ^ q[15] ^ q[16] ^ q[17] ^ q[18] ^ q[19] ^ q[20] ^ q[21] ^ q[22] ^ q[23] ^ q[24] ^ q[25] ^ q[26] ^ q[27] ^ q[28] ^ q[29] ^ q[30] ^ q[31];
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end
    
endmodule"
N/A,N/A,-1,98.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31] ^ q[0] ^ q[1] ^ q[2] ^ q[3] ^ q[4] ^ q[5] ^ q[6] ^ q[7] ^ q[8] ^ q[9] ^ q[10] ^ q[11] ^ q[12] ^ q[13] ^ q[14] ^ q[15] ^ q[16] ^ q[17] ^ q[18] ^ q[19] ^ q[20] ^ q[21] ^ q[22] ^ q[23] ^ q[24] ^ q[25] ^ q[26] ^ q[27] ^ q[28] ^ q[29] ^ q[30] ^ q[31];
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end
    
endmodule"
N/A,N/A,-1,99.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31] ^ q[30] ^ q[29] ^ q[28] ^ q[27] ^ q[26] ^ q[25] ^ q[24] ^ q[23] ^ q[22] ^ q[21] ^ q[20] ^ q[19] ^ q[18] ^ q[17] ^ q[16] ^ q[15] ^ q[14] ^ q[13] ^ q[12] ^ q[11] ^ q[10] ^ q[9] ^ q[8] ^ q[7] ^ q[6] ^ q[5] ^ q[4] ^ q[3] ^ q[2] ^ q[1] ^ q[0];
        q_next[31] = q[31] ^ q[30] ^ q[29] ^ q[28] ^ q[27] ^ q[26] ^ q[25] ^ q[24] ^ q[23] ^ q[22] ^ q[21] ^ q[20] ^ q[19] ^ q[18] ^ q[17] ^ q[16] ^ q[15] ^ q[14] ^ q[13] ^ q[12] ^ q[11] ^ q[10] ^ q[9] ^ q[8] ^ q[7] ^ q[6] ^ q[5] ^ q[4] ^ q[3] ^ q[2] ^ q[1] ^ q[0];
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end
    
endmodule"
N/A,N/A,-1,100.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31]? {q[30:0], 1'b0} : q_next;
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end
    
endmodule"
N/A,N/A,-1,101.0,1,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 
    
    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31] ^ q[0] ^ q[1] ^ q[2] ^ q[3] ^ q[4] ^ q[5] ^ q[6] ^ q[7] ^ q[8] ^ q[9] ^ q[10] ^ q[11] ^ q[12] ^ q[13] ^ q[14] ^ q[15] ^ q[16] ^ q[17] ^ q[18] ^ q[19] ^ q[20] ^ q[21] ^ q[22] ^ q[23] ^ q[24] ^ q[25] ^ q[26] ^ q[27] ^ q[28] ^ q[29] ^ q[30] ^ q[31];
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end
    
endmodule"
