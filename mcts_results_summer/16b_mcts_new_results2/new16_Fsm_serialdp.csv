Area,Delay,Score,Current Run,Episode,Verilog
N/A,N/A,-1,0,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    // Use FSM from Fsm_serialdata
    // New: Add parity checking.
    
    parameter idle = 0, rec_data = 1, stop_bit = 2;
    reg [1:0] state, next_state;
    reg [3:0] counter;
    reg odd;
    
    always @(posedge clk)
        if (reset)
            state <= idle;
        else
            state <= next_state;
    
    always @(*)
        case (state)
            idle:
                if (in)
                    next_state = rec_data;
                else
                    next_state = idle;
            rec_data:
                if (counter == 8)
                    next_state = stop_bit;
                else
                    next_state = rec_data;
            stop_bit:
                if (in)
                    next_state = idle;
                else
                    next_state = idle;
            default:
                next_state = idle;
        endcase
    
    always @(posedge clk)
        if (reset)
            counter <= 4'b0;
        else if (state == rec_data && in)
            counter <= counter + 4'b1;
    
    assign done = (state == stop_bit) && (counter == 8);
    
    assign out_byte = {in, odd};
    
    always @(posedge clk)
        if (reset)
            odd <= 0;
        else if (state == rec_data && in)
            odd <= ~odd;

endmodule"
N/A,N/A,-1,1,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.
    
    parameter idle = 3'b000;
    parameter start = 3'b001;
    parameter data = 3'b010;
    parameter stop = 3'b011;
    parameter end = 3'b100;
    
    reg [2:0] state, next_state;
    reg [8:0] counter;
    reg odd;
    reg out;
    
    always @(posedge clk)
        if (reset)
            state <= idle;
        else
            state <= next_state;
    
    always @(*)
        case (state)
            idle:
                if (in)
                    next_state = start;
                else
                    next_state = idle;
            start:
                if (counter == 9'd254)
                    next_state = data;
                else
                    next_state = start;
            data:
                if (counter == 9'd254)
                    next_state = stop;
                else
                    next_state = data;
            stop:
                if (counter == 9'd255)
                    next_state = end;
                else
                    next_state = stop;
            endcase
    
    always @(posedge clk)
        if (reset)
            counter <= 0;
        else if (state == data)
            counter <= counter + 1;
        else
            counter <= 0;
    
    always @(posedge clk)
        if (reset)
            out_byte <= 0;
        else if (state == data)
            if (counter[0])
                out_byte[7:0] <= in;
            else
                out_byte[7:0] <= out_byte[7:0];
    
    always @(posedge clk)
        if (reset)
            done <= 0;
        else if (state == end)
            done <= 1;
        else
            done <= 0;
    
    always @(posedge clk)
        if (reset)
            odd <= 0;
        else if (state == data)
            if (counter[0])
                odd <= odd ^ in;
            else
                odd <= odd;
    
    always @(*)
        case (state)
            idle:
                out = 0;
            start:
                out = 0;
            data:
                out = in;
            stop:
                out = odd;
            endcase

endmodule"
N/A,N/A,-1,2,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.
    
    parameter idle = 3'b000;
    parameter start = 3'b001;
    parameter data = 3'b010;
    parameter stop = 3'b011;
    parameter end = 3'b100;
    
    reg [2:0] state, next_state;
    reg [8:0] counter;
    reg odd;
    reg out;
    
    always @(posedge clk)
        if (reset)
            state <= idle;
        else
            state <= next_state;
    
    always @(*)
        case (state)
            idle:
                if (in)
                    next_state = start;
                else
                    next_state = idle;
            start:
                if (counter == 9'd254)
                    next_state = data;
                else
                    next_state = start;
            data:
                if (counter == 9'd254)
                    next_state = stop;
                else
                    next_state = data;
            stop:
                if (counter == 9'd255)
                    next_state = end;
                else
                    next_state = stop;
            endcase
    
    always @(posedge clk)
        if (reset)
            counter <= 0;
        else if (state == data)
            counter <= counter + 1;
        else
            counter <= 0;
    
    always @(posedge clk)
        if (reset)
            out_byte <= 0;
        else if (state == data)
            if (counter[0])
                out_byte[7:0] <= in;
            else
                out_byte[7:0] <= out_byte[7:0];
    
    always @(posedge clk)
        if (reset)
            done <= 0;
        else if (state == end)
            done <= 1;
        else
            done <= 0;
    
    always @(posedge clk)
        if (reset)
            odd <= 0;
        else if (state == data)
            if (counter[0])
                odd <= odd ^ in;
            else
                odd <= odd;
    
    always @(*)
        case (state)
            idle:
                out = 0;
            start:
                out = 0;
            data:
                out = in;
            stop:
                out = odd;
            endcase

endmodule"
N/A,N/A,-1,3,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.
    
    parameter idle = 3'b000;
    parameter start = 3'b001;
    parameter data = 3'b010;
    parameter stop = 3'b011;
    parameter end = 3'b100;
    
    reg [2:0] state, next_state;
    reg [8:0] counter;
    reg odd;
    reg out;
    
    always @(posedge clk)
        if (reset)
            state <= idle;
        else
            state <= next_state;
    
    always @(*)
        case (state)
            idle:
                if (in)
                    next_state = start;
                else
                    next_state = idle;
            start:
                if (counter == 9'd254)
                    next_state = data;
                else
                    next_state = start;
            data:
                if (counter == 9'd254)
                    next_state = stop;
                else
                    next_state = data;
            stop:
                if (counter == 9'd255)
                    next_state = end;
                else
                    next_state = stop;
            endcase
    
    always @(posedge clk)
        if (reset)
            counter <= 0;
        else if (state == data)
            counter <= counter + 1;
        else
            counter <= 0;
    
    always @(posedge clk)
        if (reset)
            out_byte <= 0;
        else if (state == data)
            if (counter[0])
                out_byte[7:0] <= in;
            else
                out_byte[7:0] <= out_byte[7:0];
    
    always @(posedge clk)
        if (reset)
            done <= 0;
        else if (state == end)
            done <= 1;
        else
            done <= 0;
    
    always @(posedge clk)
        if (reset)
            odd <= 0;
        else if (state == data)
            if (counter[0])
                odd <= odd ^ in;
            else
                odd <= odd;
    
    always @(*)
        case (state)
            idle:
                out = 0;
            start:
                out = 0;
            data:
                out = in;
            stop:
                out = odd;
            endcase

endmodule"
N/A,N/A,-1,4,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    parameter START = 3'd0, DATA = 3'd1, PARITY = 3'd2, STOP = 3'd3, DELAY = 3'd4;
    reg [2:0] state, next_state;
    reg [8:0] counter;
    reg odd;
    
    always @(posedge clk)
        if (reset)
            state <= START;
        else
            state <= next_state;
    
    always @(*)
        case (state)
            START: begin
                done = 0;
                next_state = DATA;
                counter = 9'd0;
                odd = 0;
            end
            DATA: begin
                done = 0;
                if(in)
                    next_state = DATA;
                else
                    next_state = PARITY;
            end
            PARITY: begin
                done = 0;
                next_state = STOP;
            end
            STOP: begin
                done = 1;
                next_state = DELAY;
            end
            DELAY: begin
                done = 0;
                if(counter > 9'd5)
                    next_state = START;
                else
                    next_state = DATA;
            end
            default: next_state = START;
        endcase
    
    always @(posedge clk)
        if(reset)
            counter <= 9'd0;
        else if(state == DATA)
            counter <= counter + 9'd1;
        else
            counter <= 9'd0;
    
    assign out_byte = {in, odd};

endmodule"
N/A,N/A,-1,5,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serialdata
    // New: Add parity checking.
    
    parity p1(clk, reset, in, odd);
    
    // New: Add serial output byte stream.
    
    serialdata s1(clk, reset, odd, in, out_byte, done);
    
endmodule"
N/A,N/A,-1,6,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    parameter START = 3'd0, DATA = 3'd1, PARITY = 3'd2, STOP = 3'd3, DELAY = 3'd4;
    reg [2:0] state, next_state;
    reg [8:0] counter;
    reg odd;
    reg [7:0] out;
    
    always @(posedge clk)
        if(reset)
            state <= START;
        else
            state <= next_state;
            
    always @(*)
        case (state)
            START: begin
                if(in)
                    next_state = DATA;
                else
                    next_state = START;
            end
            DATA: begin
                if(counter == 9'd255)
                    next_state = PARITY;
                else
                    next_state = DATA;
            end
            PARITY: begin
                if(counter == 9'd255)
                    next_state = STOP;
                else
                    next_state = PARITY;
            end
            STOP: begin
                if(counter == 9'd255)
                    next_state = DELAY;
                else
                    next_state = STOP;
            end
            DELAY: begin
                if(counter == 9'd255)
                    next_state = START;
                else
                    next_state = DELAY;
            end
            default: next_state = START;
        endcase
        
    always @(posedge clk)
        if(reset)
            counter <= 0;
        else if(next_state == DATA)
            counter <= counter + 1;
        else
            counter <= 0;
            
    always @(posedge clk)
        if(reset)
            out_byte <= 0;
        else if(next_state == PARITY)
            out_byte <= {out, odd};
        else
            out_byte <= out_byte;
            
    always @(posedge clk)
        if(reset)
            done <= 0;
        else if(next_state == DELAY)
            done <= 1;
        else
            done <= 0;
            
    always @(posedge clk)
        if(reset)
            odd <= 0;
        else if(next_state == PARITY)
            odd <= odd ^ in;
        else
            odd <= 0;

endmodule"
N/A,N/A,-1,7,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    // Use FSM from Fsm_serialdata
    // New: Add parity checking.
    
    parameter idle = 0, rec_data = 1, stop_bit = 2;
    reg [1:0] state, next_state;
    reg [3:0] counter;
    reg odd;
    
    always @(posedge clk)
        if (reset)
            state <= idle;
        else
            state <= next_state;
    
    always @(*)
        case (state)
            idle:
                if (in)
                    next_state = rec_data;
                else
                    next_state = idle;
            rec_data:
                if (counter < 9)
                    next_state = rec_data;
                else
                    next_state = stop_bit;
            stop_bit:
                if (counter < 9)
                    next_state = idle;
                else
                    next_state = idle;
            default:
                next_state = idle;
        endcase
    
    always @(posedge clk)
        if (reset)
            counter <= 0;
        else if (state == rec_data && in)
            counter <= counter + 1;
        else if (state == stop_bit)
            counter <= 0;
    
    assign done = (state == stop_bit) && (counter < 9);
    
    // New: Add parity checking.
    parity p1(clk, reset, in, odd);
    
    always @(posedge clk)
        if (reset)
            out_byte <= 8'h0;
        else if (state == rec_data)
            out_byte[counter] <= in ^ odd;

endmodule"
N/A,N/A,-1,8,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    // Use FSM from Fsm_serialdata
    // New: Add parity checking.
    
    parameter idle = 0, rec_data = 1, stop_bit = 2, rec_stop_bit = 3;
    reg [1:0] state, next_state;
    
    parity checker(clk, reset, in, odd);
    
    always @(posedge clk)
        if (reset) state <= idle;
        else state <= next_state;
    
    always @(*)
        case (state)
            idle:
                if (in) next_state = rec_data;
                else next_state = idle;
            rec_data:
                if (odd) next_state = stop_bit;
                else next_state = rec_data;
            stop_bit:
                if (in) next_state = rec_stop_bit;
                else next_state = idle;
            rec_stop_bit:
                next_state = idle;
            default:
                next_state = idle;
        endcase
    
    // New: Add parity checking.
    assign done = (state == rec_stop_bit);
    
    // New: Add parity checking.
    assign out_byte = (state == rec_data)? {in, odd} : 8'b0;
    
endmodule"
N/A,N/A,-1,9,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    // Use FSM from Fsm_serialdata
    // New: Add parity checking.
    
    parameter idle = 0, rec_data = 1, stop_bit = 2;
    reg [1:0] state, next_state;
    reg odd;
    
    always @(posedge clk)
        if (reset) state <= idle;
        else state <= next_state;
    
    always @(*)
        case (state)
            idle:
                if (in) next_state = rec_data;
                else next_state = idle;
            rec_data:
                if (in) next_state = rec_data;
                else next_state = stop_bit;
            stop_bit:
                if (in) next_state = idle;
                else next_state = idle;
            default: next_state = idle;
        endcase
    
    assign done = (state == stop_bit);
    
    // New: Add parity checking.
    
    always @(posedge clk)
        if (reset) odd <= 1;
        else if (state == rec_data) odd <= in;
    
    assign out_byte = {in, odd};
    
endmodule"
N/A,N/A,-1,10,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    // Use FSM from Fsm_serialdata
    // New: Add parity checking.
    
    parameter idle = 0, rec_data = 1, stop_bit = 2;
    reg [1:0] state, next_state;
    reg odd;
    
    always @(posedge clk)
        if (reset) state <= idle;
        else state <= next_state;
    
    always @(*)
        case (state)
            idle:
                if (in) next_state = rec_data;
                else next_state = idle;
            rec_data:
                if (in) next_state = rec_data;
                else next_state = stop_bit;
            stop_bit:
                if (in) next_state = idle;
                else next_state = idle;
            default: next_state = idle;
        endcase
    
    assign done = (state == stop_bit);
    
    // New: Add parity checking.
    
    always @(posedge clk)
        if (reset) odd <= 1;
        else if (state == rec_data) odd <= in;
    
    assign out_byte = {in, odd};
    
endmodule"
N/A,N/A,-1,11,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    // Use FSM from Fsm_serialdata
    // New: Add parity checking.
    
    parameter idle = 0, rec_data = 1, stop_bit = 2;
    reg [1:0] state, next_state;
    reg odd;
    
    always @(posedge clk)
        if (reset) state <= idle;
        else state <= next_state;
    
    always @(*)
        case (state)
            idle:
                if (in) next_state = rec_data;
                else next_state = idle;
            rec_data:
                if (in) next_state = rec_data;
                else next_state = stop_bit;
            stop_bit:
                if (in) next_state = idle;
                else next_state = idle;
            default: next_state = idle;
        endcase
    
    assign done = (state == stop_bit);
    
    // New: Add parity checking.
    
    always @(posedge clk)
        if (reset) odd <= 1;
        else if (state == rec_data) odd <= in;
    
    assign out_byte = {in, odd};
    
endmodule"
N/A,N/A,-1,12,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.
    
    wire clk_en;
    wire parity_error;
    wire stop_bit;
    wire [7:0] byte;
    
    clk_divider divider(clk, reset, clk_en);
    serial_receiver receiver(clk_en, in, byte, parity_error, stop_bit);
    parity_checker checker(clk, reset, byte, parity_error);
    
    // New: Add parity checking.
    
    assign done = parity_error & stop_bit;
    
    assign out_byte = byte;
    
endmodule"
N/A,N/A,-1,13,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    parameter START = 3'd0, DATA = 3'd1, PARITY = 3'd2, STOP = 3'd3, DELAY = 3'd4;
    reg [2:0] state, next_state;
    reg [8:0] counter;
    reg odd;
    reg [7:0] out;
    reg done_reg;
    
    always @(posedge clk)
        if (reset)
            state <= START;
        else
            state <= next_state;
    
    always @(*)
        case (state)
            START: begin
                if (in)
                    next_state = DATA;
                else
                    next_state = START;
            end
            DATA: begin
                if (counter < 9'd255)
                    next_state = DATA;
                else
                    next_state = PARITY;
            end
            PARITY: begin
                if (counter < 9'd255)
                    next_state = PARITY;
                else
                    next_state = STOP;
            end
            STOP: begin
                if (counter < 9'd255)
                    next_state = DELAY;
                else
                    next_state = START;
            end
            DELAY: next_state = START;
            default: next_state = START;
        endcase
    
    always @(posedge clk)
        if (reset)
            counter <= 0;
        else if (next_state == DATA)
            counter <= counter + 1;
        else if (next_state == PARITY)
            counter <= counter + 1;
        else if (next_state == STOP)
            counter <= counter + 1;
        else
            counter <= 0;
    
    always @(posedge clk)
        if (reset)
            done_reg <= 0;
        else if (next_state == DELAY)
            done_reg <= 0;
        else if (next_state == START)
            done_reg <= 1;
    
    assign done = done_reg;
    
    always @(posedge clk)
        if (reset)
            out <= 0;
        else if (next_state == DATA)
            out <= {in, out[7:1]};
        else if (next_state == PARITY)
            out <= {odd, out[7:1]};
    
    assign out_byte = out;
    
    always @(posedge clk)
        if (reset)
            odd <= 0;
        else if (next_state == PARITY)
            odd <= in;

endmodule"
N/A,N/A,-1,14,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    parameter BYTE_SIZE = 8;
    parameter NUM_STATES = BYTE_SIZE + 1;
    parameter IDLE = 0, DATA = 1, STOP = 2;
    reg [NUM_STATES-1:0] state, next_state;
    reg [BYTE_SIZE-1:0] byte_out;
    reg [3:0] num_bits;
    reg odd;
    
    always @(posedge clk)
        if (reset)
            state <= IDLE;
    	else
            state <= next_state;
    
    always @(*)
        case (state)
            IDLE:
                begin
                    next_state = IDLE;
                    num_bits = 4'b0;
                    byte_out = 8'b0;
                    if (in)
                        next_state = DATA;
                end
            DATA:
                begin
                    next_state = (num_bits == 4'b1111)? IDLE : DATA;
                    num_bits = num_bits + 1'b1;
                    byte_out = {in, byte_out[7:1]};
                end
            STOP:
                begin
                    next_state = (in)? DATA : STOP;
                    num_bits = 4'b0;
                    byte_out = 8'b0;
                end
        endcase
    
    assign done = (state == STOP);
    assign out_byte = byte_out;
    
    always @(posedge clk)
        if (reset)
            odd <= 0;
    	else
            if (state == DATA)
                odd <= (num_bits[0] ^ num_bits[1] ^ num_bits[2] ^ num_bits[3]);
            else
                odd <= odd;

endmodule"
N/A,N/A,-1,15,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.
    
    parity p1(clk, reset, in, odd);
    
    // New: Add shift register to hold the data bytes.
    
    reg [7:0] data_out;
    
    always @(posedge clk)
        if (reset) data_out <= 0;
        else if (odd) data_out <= {data_out[6:0], in};
    
    // New: Add a shift register to hold the output byte.
    
    reg [7:0] out_byte_sr;
    
    always @(posedge clk)
        if (reset) out_byte_sr <= 0;
        else if (odd) out_byte_sr <= data_out;
    
    // New: Add a 2-bit counter to count the number of bits received.
    
    reg [1:0] bit_cnt;
    
    always @(posedge clk)
        if (reset) bit_cnt <= 0;
        else if (in) bit_cnt <= bit_cnt + 1;
    
    // New: Add a 2-bit counter to count the number of bytes received.
    
    reg [1:0] byte_cnt;
    
    always @(posedge clk)
        if (reset) byte_cnt <= 0;
        else if (in) byte_cnt <= byte_cnt + 1;
    
    // New: Add a flag to signal done
    
    reg done_sr;
    
    always @(posedge clk)
        if (reset) done_sr <= 0;
        else if (in && (bit_cnt == 3) && (byte_cnt == 3))
            done_sr <= 1;
    
    assign done = done_sr;
    
    // New: Add output byte
    
    assign out_byte = out_byte_sr;
    
endmodule"
N/A,N/A,-1,16,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    parameter START = 0, DATA = 1, STOP = 2, DELAY = 3;
    reg [1:0] state, next_state;
    reg [9:0] count;
    reg out;
    
    always @(posedge clk)
        if(reset)
            state <= START;
    	else
            state <= next_state;
    
    always @(*)
        case(state)
            START: begin
                done = 0;
                next_state = DATA;
                count = 10'd0;
                out = 1'b0;
            end
            DATA: begin
                done = 0;
                if(count < 10'd8)
                    next_state = DATA;
                else
                    next_state = STOP;
                count = 10'd0;
            end
            STOP: begin
                done = 1;
                next_state = DELAY;
                count = 10'd0;
                out = 1'b1;
            end
            DELAY: begin
                done = 0;
                next_state = START;
                count = 10'd0;
                out = 1'b0;
            end
        endcase
    
    assign out_byte = out? {in, in, in, in, in, in, in, in, in} : {in, in, in, in, in, in, in, in, in};

endmodule"
N/A,N/A,-1,17,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    parameter START = 0, DATA = 1, STOP = 2, DELAY = 3;
    reg [1:0] state, next_state;
    reg [9:0] count;
    reg out;
    
    always @(posedge clk)
        if(reset)
            state <= START;
    	else
            state <= next_state;
    
    always @(*)
        case(state)
            START: begin
                done = 0;
                next_state = DATA;
                count = 10'd0;
                out = 1'b0;
            end
            DATA: begin
                done = 0;
                if(count < 10'd8)
                    next_state = DATA;
                else
                    next_state = STOP;
                count = 10'd0;
            end
            STOP: begin
                done = 1;
                next_state = DELAY;
                count = 10'd0;
                out = 1'b1;
            end
            DELAY: begin
                done = 0;
                next_state = START;
                count = 10'd0;
                out = 1'b0;
            end
        endcase
    
    assign out_byte = out? {in, in, in, in, in, in, in, in, in} : {in, in, in, in, in, in, in, in, in};

endmodule"
N/A,N/A,-1,18,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    parameter START = 0, DATA = 1, STOP = 2, DELAY = 3;
    reg [1:0] state, next_state;
    reg [9:0] count;
    reg out;
    
    always @(posedge clk)
        if(reset)
            state <= START;
    	else
            state <= next_state;
    
    always @(*)
        case(state)
            START: begin
                done = 0;
                next_state = DATA;
                count = 10'd0;
                out = 1'b0;
            end
            DATA: begin
                done = 0;
                if(count < 10'd8)
                    next_state = DATA;
                else
                    next_state = STOP;
                count = 10'd0;
            end
            STOP: begin
                done = 1;
                next_state = DELAY;
                count = 10'd0;
                out = 1'b1;
            end
            DELAY: begin
                done = 0;
                next_state = START;
                count = 10'd0;
                out = 1'b0;
            end
        endcase
    
    assign out_byte = out? {in, in, in, in, in, in, in, in, in} : {in, in, in, in, in, in, in, in, in};

endmodule"
N/A,N/A,-1,19,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    parameter START = 0, DATA = 1, STOP = 2, DELAY = 3;
    reg [1:0] state, next_state;
    reg [9:0] count;
    reg out;
    
    always @(posedge clk)
        if(reset)
            state <= START;
    	else
            state <= next_state;
    
    always @(*)
        case(state)
            START: begin
                done = 0;
                next_state = DATA;
                count = 10'd0;
                out = 1'b0;
            end
            DATA: begin
                done = 0;
                if(count < 10'd8)
                    next_state = DATA;
                else
                    next_state = STOP;
                count = 10'd0;
            end
            STOP: begin
                done = 1;
                next_state = DELAY;
                count = 10'd0;
                out = 1'b1;
            end
            DELAY: begin
                done = 0;
                next_state = START;
                count = 10'd0;
                out = 1'b0;
            end
        endcase
    
    assign out_byte = out? {in, in, in, in, in, in, in, in, in} : {in, in, in, in, in, in, in, in, in};

endmodule"
N/A,N/A,-1,20,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    parameter START = 0, DATA = 1, STOP = 2, DELAY = 3;
    reg [1:0] state, next_state;
    reg [9:0] count;
    reg out;
    
    always @(posedge clk)
        if(reset)
            state <= START;
    	else
            state <= next_state;
    
    always @(*)
        case(state)
            START: begin
                done = 0;
                next_state = DATA;
                count = 10'd0;
                out = 1'b0;
            end
            DATA: begin
                done = 0;
                if(count < 10'd8)
                    next_state = DATA;
                else
                    next_state = STOP;
                count = 10'd0;
            end
            STOP: begin
                done = 1;
                next_state = DELAY;
                count = 10'd0;
                out = 1'b1;
            end
            DELAY: begin
                done = 0;
                next_state = START;
                count = 10'd0;
                out = 1'b0;
            end
        endcase
    
    assign out_byte = out? {in, in, in, in, in, in, in, in, in} : {in, in, in, in, in, in, in, in, in};

endmodule"
N/A,N/A,-1,21,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    parameter START = 0, DATA = 1, STOP = 2, DELAY = 3;
    reg [1:0] state, next_state;
    reg [9:0] count;
    reg out;
    
    always @(posedge clk)
        if(reset)
            state <= START;
    	else
            state <= next_state;
    
    always @(*)
        case(state)
            START: begin
                done = 0;
                next_state = DATA;
                count = 10'd0;
                out = 1'b0;
            end
            DATA: begin
                done = 0;
                if(count < 10'd8)
                    next_state = DATA;
                else
                    next_state = STOP;
                count = 10'd0;
            end
            STOP: begin
                done = 1;
                next_state = DELAY;
                count = 10'd0;
                out = 1'b1;
            end
            DELAY: begin
                done = 0;
                next_state = START;
                count = 10'd0;
                out = 1'b0;
            end
        endcase
    
    assign out_byte = out? {in, in, in, in, in, in, in, in, in} : {in, in, in, in, in, in, in, in, in};

endmodule"
N/A,N/A,-1,22,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    parameter START = 3'd0, DATA = 3'd1, PARITY = 3'd2, STOP = 3'd3, DELAY = 3'd4;
    reg [2:0] state, next_state;
    reg odd;
    reg [8:0] shift_reg;
    reg [7:0] out_byte_reg;
    reg done_reg;
    assign out_byte = out_byte_reg;
    assign done = done_reg;
    always @(*) begin
        case (state)
            START: begin
                if (in) next_state = DATA;
                else next_state = START;
            end
            DATA: begin
                if (shift_reg[8]) next_state = PARITY;
                else next_state = DATA;
            end
            PARITY: begin
                if (shift_reg[8] ^ odd) next_state = STOP;
                else next_state = PARITY;
            end
            STOP: begin
                if (in) next_state = DELAY;
                else next_state = START;
            end
            DELAY: begin
                if (done_reg) next_state = START;
                else next_state = DELAY;
            end
            default: next_state = START;
        endcase
    end
    always @(posedge clk) begin
        if (reset) begin
            state <= START;
            done_reg <= 1'b0;
        end
        else begin
            state <= next_state;
            if (next_state == DATA)
                shift_reg <= {shift_reg[6:0], in};
            else if (next_state == PARITY)
                shift_reg <= {shift_reg[6:0], odd};
            else if (next_state == STOP) begin
                shift_reg <= {shift_reg[6:0], 1'b0};
                done_reg <= 1'b1;
            end
            else if (next_state == DELAY)
                done_reg <= 1'b0;
        end
    end
    always @(posedge clk) begin
        if (reset) begin
            out_byte_reg <= 8'b0;
            odd <= 1'b0;
        end
        else begin
            if (state == DATA)
                out_byte_reg <= {out_byte_reg[6:0], shift_reg[7]};
            else if (state == PARITY)
                out_byte_reg <= {out_byte_reg[6:0], ^out_byte_reg[7:0]};
        end
    end
endmodule"
N/A,N/A,-1,23,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    parameter START = 3'd0, DATA = 3'd1, PARITY = 3'd2, STOP = 3'd3, DELAY = 3'd4;
    reg [2:0] state, next_state;
    reg odd;
    reg [8:0] shift_reg;
    reg [7:0] out_byte_reg;
    reg done_reg;
    assign out_byte = out_byte_reg;
    assign done = done_reg;
    always @(*) begin
        case (state)
            START: begin
                if (in) next_state = DATA;
                else next_state = START;
            end
            DATA: begin
                if (shift_reg[8]) next_state = PARITY;
                else next_state = DATA;
            end
            PARITY: begin
                if (shift_reg[8] ^ odd) next_state = STOP;
                else next_state = PARITY;
            end
            STOP: begin
                if (in) next_state = DELAY;
                else next_state = START;
            end
            DELAY: begin
                if (done_reg) next_state = START;
                else next_state = DELAY;
            end
            default: next_state = START;
        endcase
    end
    always @(posedge clk) begin
        if (reset) begin
            state <= START;
            done_reg <= 1'b0;
        end
        else begin
            state <= next_state;
            if (next_state == DATA)
                shift_reg <= {shift_reg[6:0], in};
            else if (next_state == PARITY)
                shift_reg <= {shift_reg[6:0], odd};
            else if (next_state == STOP) begin
                shift_reg <= {shift_reg[6:0], 1'b0};
                done_reg <= 1'b1;
            end
            else if (next_state == DELAY)
                done_reg <= 1'b0;
        end
    end
    always @(posedge clk) begin
        if (reset) begin
            out_byte_reg <= 8'b0;
            odd <= 1'b0;
        end
        else begin
            if (state == DATA)
                out_byte_reg <= {out_byte_reg[6:0], shift_reg[7]};
            else if (state == PARITY)
                out_byte_reg <= {out_byte_reg[6:0], ^out_byte_reg[7:0]};
        end
    end
endmodule"
N/A,N/A,-1,24,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.
    
    parameter idle = 0, rec_data = 1, stop_bit = 2;
    reg [1:0] state, next_state;
    reg [9:0] counter;
    reg odd;
    
    always @(posedge clk)
        if (reset) state <= idle;
        else state <= next_state;
    
    always @(*)
        case (state)
            idle:
                if (in) next_state = rec_data;
                else next_state = idle;
            rec_data:
                if (counter == 1023) next_state = stop_bit;
                else next_state = rec_data;
            stop_bit:
                if (in) next_state = idle;
                else next_state = rec_data;
            default:
                next_state = idle;
        endcase
    
    always @(posedge clk)
        if (reset) counter <= 0;
        else if (state == rec_data && in) counter <= counter + 1;
    
    assign done = (state == stop_bit) && (counter == 1023);
    
    assign out_byte = {in, odd};
    
    parity p1(clk, reset, in, odd);
    
endmodule"
N/A,N/A,-1,25,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    // Use FSM from Fsm_serialdata
    // New: Add parity checking.
    
    parameter idle = 0, rec_data = 1, stop_bit = 2;
    reg [1:0] state, next_state;
    
    // New: Add parity checking.
    wire parity_ok;
    parity p1(clk, reset, in, parity_ok);
    
    always @(posedge clk)
        if (reset) state <= idle;
        else state <= next_state;
    
    always @(*)
        case (state)
            idle:
                begin
                    if (in) next_state = rec_data;
                    else next_state = idle;
                end
            rec_data:
                begin
                    if (in) next_state = rec_data;
                    else next_state = stop_bit;
                end
            stop_bit:
                begin
                    if (in) next_state = idle;
                    else next_state = idle;
                end
        endcase
    
    // New: Add parity checking.
    assign parity_ok = (state == rec_data) && (parity_ok == ^out_byte[7:0]);
    
    assign done = (state == stop_bit);
    
    // New: Add parity checking.
    assign out_byte = (state == rec_data)? {in, out_byte[7:1]} : 8'b0;
    
endmodule"
N/A,N/A,-1,26,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    // Use FSM from Fsm_serialdata
    // New: Add parity checking.
    
    parameter idle = 0, rec_data = 1, stop_bit = 2;
    reg [1:0] state, next_state;
    
    // New: Add parity checking.
    wire parity_ok;
    parity p1(clk, reset, in, parity_ok);
    
    always @(posedge clk)
        if (reset) state <= idle;
        else state <= next_state;
    
    always @(*)
        case (state)
            idle:
                begin
                    if (in) next_state = rec_data;
                    else next_state = idle;
                end
            rec_data:
                begin
                    if (in) next_state = rec_data;
                    else next_state = stop_bit;
                end
            stop_bit:
                begin
                    if (in) next_state = idle;
                    else next_state = idle;
                end
        endcase
    
    // New: Add parity checking.
    assign parity_ok = (state == rec_data) && (parity_ok == ^out_byte[7:0]);
    
    assign done = (state == stop_bit);
    
    // New: Add parity checking.
    assign out_byte = (state == rec_data)? {in, out_byte[7:1]} : 8'b0;
    
endmodule"
N/A,N/A,-1,27,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serialdata
    // New: Add parity checking.
    
    parameter idle = 0, rec_data = 1, stop_bit = 2;
    reg [1:0] state, next_state;
    reg odd;
    reg [8:0] rec_data_bits;
    reg [7:0] out_byte_bits;
    
    always @(posedge clk)
        if (reset) state <= idle;
        else state <= next_state;
        
    always @(*)
        case (state)
            idle:
                if (in) next_state = rec_data;
                else next_state = idle;
            rec_data:
                if (rec_data_bits[8])
                    next_state = stop_bit;
                else next_state = rec_data;
            stop_bit:
                if (in)
                    next_state = idle;
                else
                    next_state = rec_data;
            default:
                next_state = idle;
        endcase
    
    always @(posedge clk)
        if (reset) begin
            rec_data_bits <= 0;
            out_byte_bits <= 0;
        end
        else begin
            // New: Add parity checking.
            if (state == rec_data)
                rec_data_bits <= {rec_data_bits[6:0], in};
            if (state == stop_bit)
                out_byte_bits <= {out_byte_bits[6:0], rec_data_bits[8]};
        end
    
    assign done = (state == stop_bit) && (rec_data_bits[8] == 1);
    
    assign out_byte = out_byte_bits;
    
endmodule"
N/A,N/A,-1,28,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    parameter START = 3'd0, DATA = 3'd1, PARITY = 3'd2, STOP = 3'd3, DELAY = 3'd4;
    reg [2:0] state, next_state;
    reg [8:0] shift_reg;
    reg odd;
    reg out;
    reg [7:0] out_byte_reg;
    reg done_reg;
    assign out_byte = out_byte_reg;
    assign done = done_reg;

    always @(posedge clk) begin
        if (reset)
            state <= START;
        else
            state <= next_state;
    end

    always @(*) begin
        case (state)
            START: begin
                if (in)
                    next_state = DATA;
                else
                    next_state = START;
            end
            DATA: begin
                if (in)
                    next_state = DATA;
                else
                    next_state = PARITY;
            end
            PARITY: begin
                if (in)
                    next_state = STOP;
                else
                    next_state = DELAY;
            end
            DELAY: begin
                if (in)
                    next_state = DELAY;
                else
                    next_state = START;
            end
            STOP: begin
                if (in)
                    next_state = START;
                else
                    next_state = DELAY;
            end
            default: next_state = START;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            shift_reg <= 9'b0;
            done_reg <= 1'b0;
        end
        else begin
            shift_reg <= {shift_reg[7:0], in};
            if (state == DATA)
                out_byte_reg <= {shift_reg[8], odd};
            else if (state == PARITY)
                out_byte_reg <= {shift_reg[8], odd ^ shift_reg[7]};
            done_reg <= 1'b0;
        end
    end

    always @(posedge clk) begin
        if (state == DATA)
            out <= shift_reg[8];
        else if (state == PARITY)
            out <= odd ^ shift_reg[7];
        else
            out <= 1'b0;
    end

    parity p1(clk, reset, out, odd);

endmodule"
N/A,N/A,-1,29,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    parameter START = 3'd0, DATA = 3'd1, PARITY = 3'd2, STOP = 3'd3, DELAY = 3'd4;
    reg [2:0] state, next_state;
    reg [8:0] shift_reg;
    reg odd;
    reg out;
    reg [7:0] out_byte_reg;
    reg done_reg;
    assign out_byte = out_byte_reg;
    assign done = done_reg;

    always @(posedge clk) begin
        if (reset)
            state <= START;
        else
            state <= next_state;
    end

    always @(*) begin
        case (state)
            START: begin
                if (in)
                    next_state = DATA;
                else
                    next_state = START;
            end
            DATA: begin
                if (in)
                    next_state = DATA;
                else
                    next_state = PARITY;
            end
            PARITY: begin
                if (in)
                    next_state = STOP;
                else
                    next_state = DELAY;
            end
            DELAY: begin
                if (in)
                    next_state = DELAY;
                else
                    next_state = START;
            end
            STOP: begin
                if (in)
                    next_state = START;
                else
                    next_state = DELAY;
            end
            default: next_state = START;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            shift_reg <= 9'b0;
            done_reg <= 1'b0;
        end
        else begin
            shift_reg <= {shift_reg[7:0], in};
            if (state == DATA)
                out_byte_reg <= {shift_reg[8], odd};
            else if (state == PARITY)
                out_byte_reg <= {shift_reg[8], odd ^ shift_reg[7]};
            done_reg <= 1'b0;
        end
    end

    always @(posedge clk) begin
        if (state == DATA)
            out <= shift_reg[8];
        else if (state == PARITY)
            out <= odd ^ shift_reg[7];
        else
            out <= 1'b0;
    end

    parity p1(clk, reset, out, odd);

endmodule"
N/A,N/A,-1,30,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serialdata
    // New: Add parity checking.
    
    parameter idle = 0, rec_data = 1, stop_bit = 2;
    reg [1:0] state, next_state;
    reg [9:0] counter;
    reg odd;
    
    always @(posedge clk)
        if (reset)
            state <= idle;
        else
            state <= next_state;
    
    always @(*)
        case (state)
            idle:
                if (in)
                    next_state = rec_data;
                else
                    next_state = idle;
            rec_data:
                if (counter == 1023)
                    next_state = stop_bit;
                else
                    next_state = rec_data;
            stop_bit:
                if (in)
                    next_state = idle;
                else
                    next_state = idle;
            default:
                next_state = idle;
        endcase
    
    always @(posedge clk)
        if (reset)
            counter <= 0;
        else if (state == rec_data && next_state == stop_bit)
            counter <= counter + 1;
    
    always @(posedge clk)
        if (reset)
            done <= 0;
        else if (state == stop_bit && next_state == idle)
            done <= 1;
    
    always @(posedge clk)
        if (reset)
            out_byte <= 0;
        else if (state == rec_data && next_state == rec_data && counter == 1023)
            out_byte <= {in, odd};
    
    parity p1(clk, reset, in, odd);

endmodule"
N/A,N/A,-1,31,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    // Use FSM from Fsm_serialdata
    // New: Add parity checking.
    
    parameter idle = 0, rec_data = 1, stop_bit = 2;
    reg [1:0] state, next_state;
    reg [8:0] rec_data_bits;
    reg odd;
    
    always @(posedge clk)
        if (reset) state <= idle;
        else state <= next_state;
    
    always @(*)
        case (state)
            idle:
                if (in) next_state = rec_data;
                else next_state = idle;
            rec_data:
                if (rec_data_bits[8])
                    next_state = stop_bit;
                else next_state = rec_data;
            stop_bit:
                if (in)
                    next_state = idle;
                else
                    next_state = rec_data;
            default:
                next_state = idle;
        endcase
    
    // New: Add parity checking.
    
    always @(posedge clk)
        if (reset) odd <= 1;
        else if (state == rec_data)
            if (rec_data_bits[8]) odd <= ~odd;
    
    // New: Add parity checking.
    
    always @(posedge clk)
        if (reset) out_byte <= 8'b0;
        else if (state == rec_data)
            if (rec_data_bits[8]) out_byte <= {in, odd};
            else out_byte <= rec_data_bits;
    
    assign done = (state == stop_bit);
    
endmodule"
N/A,N/A,-1,32,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    // Use FSM from Fsm_serialdata
    // New: Add parity checking.
    
    parameter idle = 0, rec_data = 1, stop_bit = 2;
    reg [1:0] state, next_state;
    reg [8:0] rec_data_bits;
    reg odd;
    
    always @(posedge clk)
        if (reset) state <= idle;
        else state <= next_state;
    
    always @(*)
        case (state)
            idle:
                if (in) next_state = rec_data;
                else next_state = idle;
            rec_data:
                if (rec_data_bits[8])
                    next_state = stop_bit;
                else next_state = rec_data;
            stop_bit:
                if (in)
                    next_state = idle;
                else
                    next_state = rec_data;
            default:
                next_state = idle;
        endcase
    
    // New: Add parity checking.
    
    always @(posedge clk)
        if (reset) odd <= 1;
        else if (state == rec_data)
            if (rec_data_bits[8]) odd <= ~odd;
    
    // New: Add parity checking.
    
    always @(posedge clk)
        if (reset) out_byte <= 8'b0;
        else if (state == rec_data)
            if (rec_data_bits[8]) out_byte <= {in, odd};
            else out_byte <= rec_data_bits;
    
    assign done = (state == stop_bit);
    
endmodule"
N/A,N/A,-1,33,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    parameter START = 0, DATA = 1, STOP = 2, DELAY = 3;
    reg [1:0] state, next_state;
    reg [7:0] data;
    reg odd;
    reg out;
    
    always @(posedge clk)
        if (reset) state <= START;
        else state <= next_state;
    
    always @(*)
        case (state)
            START:
                if (in) next_state <= DATA;
                else next_state <= START;
            DATA:
                if (in) next_state <= DATA;
                else next_state <= STOP;
            STOP:
                if (in) next_state <= START;
                else next_state <= DELAY;
            DELAY:
                next_state <= START;
            default:
                next_state <= START;
        endcase
    
    always @(posedge clk)
        if (reset) begin
            data <= 8'b0;
            out <= 0;
        end
        else begin
            data <= next_state == DATA? data + 1 : 8'b0;
            out <= next_state == STOP? ~odd : out;
        end
    
    assign done = (next_state == DELAY) && (state == DATA);
    assign out_byte = out? data : 8'b0;
    
    always @(posedge clk)
        if (reset) odd <= 0;
        else odd <= (data[0] ^ data[1]) ^ (data[1] ^ data[2]) ^ (data[2] ^ data[3]) ^ (data[3] ^ data[4]) ^ (data[4] ^ data[5]) ^ (data[5] ^ data[6]) ^ (data[6] ^ data[7]);
    
endmodule"
N/A,N/A,-1,34,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.
    
    parameter idle = 0, rec_data = 1, stop_bit = 2;
    reg [1:0] state, next_state;
    reg [9:0] counter;
    reg odd;
    
    always @(posedge clk)
        if (reset) state <= idle;
        else state <= next_state;
    
    always @(*)
        case (state)
            idle:
                if (in) next_state <= rec_data;
                else next_state <= idle;
            rec_data:
                if (counter == 1023) next_state <= stop_bit;
                else next_state <= rec_data;
            stop_bit:
                if (in) next_state <= idle;
                else next_state <= rec_data;
            default:
                next_state <= idle;
        endcase
    
    always @(posedge clk)
        if (reset) counter <= 0;
        else if (next_state == rec_data) counter <= counter + 1;
        else counter <= 0;
    
    assign odd = (counter[0] ^ counter[1] ^ counter[2] ^ counter[3] ^ counter[4] ^ counter[5] ^ counter[6] ^ counter[7] ^ counter[8]);
    
    assign done = (state == stop_bit);
    
    assign out_byte = (state == rec_data)? {in, odd} : 8'b0;

endmodule"
N/A,N/A,-1,35,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serialdata
    // New: Add parity checking.
    
    parameter idle = 0, rec_data = 1, stop_bit = 2;
    reg [1:0] state, next_state;
    
    always @(posedge clk)
        if (reset) state <= idle;
        else state <= next_state;
    
    always @(*)
        case (state)
            idle:
                if (in) next_state = rec_data;
                else next_state = idle;
            rec_data:
                if (in) next_state = rec_data;
                else next_state = stop_bit;
            stop_bit:
                if (in) next_state = idle;
                else next_state = idle;
            default:
                next_state = idle;
        endcase
    
    assign done = (state == stop_bit);
    
    // New: Add parity checking.
    
    parity pff(.clk(clk),.reset(reset),.in(in),.odd(out_byte[7]));
    
    always @(posedge clk)
        out_byte[0] <= in;

endmodule"
N/A,N/A,-1,36,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    parameter START = 0, DATA = 1, STOP = 2, DELAY = 3;
    reg [1:0] state, next_state;
    reg [3:0] count;
    reg out;
    
    always @(*) begin
        case (state)
            START: begin
                if(in)
                    next_state = DATA;
                else
                    next_state = START;
            end
            DATA: begin
                if(count == 8)
                    next_state = STOP;
                else if(in)
                    next_state = DATA;
                else
                    next_state = START;
            end
            STOP: begin
                if(in) begin
                    next_state = DELAY;
                    out_byte = count;
                end
                else
                    next_state = START;
            end
            DELAY: begin
                if(count == 255)
                    next_state = START;
                else
                    next_state = DELAY;
            end
        endcase
    end
    
    always @(posedge clk) begin
        if(reset)
            state <= START;
        else
            state <= next_state;
    end
    
    always @(posedge clk) begin
        if(state == DATA)
            count <= count + 1;
        else
            count <= 0;
    end
    
    always @(posedge clk) begin
        if(state == STOP)
            out <= 1;
        else
            out <= 0;
    end
    
    assign done = (state == DELAY);
    
endmodule"
N/A,N/A,-1,37,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    parameter START = 0, DATA = 1, STOP = 2, DELAY = 3;
    reg [1:0] state, next_state;
    reg [3:0] count;
    reg out;
    
    always @(*) begin
        case (state)
            START: begin
                if(in)
                    next_state = DATA;
                else
                    next_state = START;
            end
            DATA: begin
                if(count == 8)
                    next_state = STOP;
                else if(in)
                    next_state = DATA;
                else
                    next_state = START;
            end
            STOP: begin
                if(in) begin
                    next_state = DELAY;
                    out_byte = count;
                end
                else
                    next_state = START;
            end
            DELAY: begin
                if(count == 255)
                    next_state = START;
                else
                    next_state = DELAY;
            end
        endcase
    end
    
    always @(posedge clk) begin
        if(reset)
            state <= START;
        else
            state <= next_state;
    end
    
    always @(posedge clk) begin
        if(state == DATA)
            count <= count + 1;
        else
            count <= 0;
    end
    
    always @(posedge clk) begin
        if(state == STOP)
            out <= 1;
        else
            out <= 0;
    end
    
    assign done = (state == DELAY);
    
endmodule"
N/A,N/A,-1,38,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serialdata
    // New: Add parity checking.
    
    parameter idle = 0, rec_data = 1, stop_bit = 2;
    reg [1:0] state, next_state;
    
    always @(*) begin
        state <= next_state;
    end
    
    always @(posedge clk) begin
        if (reset)
            next_state <= idle;
        else
            begin
                case (state)
                    idle:
                        if (in)
                            next_state <= rec_data;
                    rec_data:
                        if (in)
                            next_state <= rec_data;
                        else
                            next_state <= stop_bit;
                    stop_bit:
                        if (in)
                            next_state <= idle;
                        else
                            next_state <= idle;
                    default:
                        next_state <= idle;
                endcase
            end
    end
    
    assign done = (state == stop_bit);
    
    // New: Add parity checking.
    
    parity p1(clk, reset, in, odd);
    
    always @(*) begin
        case (state)
            idle:
                out_byte = 8'b0;
            rec_data:
                out_byte = {in, odd};
            stop_bit:
                out_byte = {in, odd};
        endcase
    end
    
endmodule"
N/A,N/A,-1,39,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    // Use FSM from Fsm_serialdata
    // New: Add parity checking.
    
    parameter idle = 0, rec_data = 1, stop_bit = 2;
    reg [1:0] state, next_state;
    reg [9:0] counter;
    reg odd;
    
    always @(posedge clk)
        if (reset)
            state <= idle;
        else
            state <= next_state;
    
    always @(*)
        case (state)
            idle:
                if (in)
                    next_state = rec_data;
                else
                    next_state = idle;
            rec_data:
                if (counter == 1023)
                    next_state = stop_bit;
                else
                    next_state = rec_data;
            stop_bit:
                if (in)
                    next_state = idle;
                else
                    next_state = idle;
            default:
                next_state = idle;
        endcase
    
    always @(posedge clk)
        if (reset)
            counter <= 0;
        else if (state == rec_data && next_state == rec_data)
            counter <= counter + 1;
        else
            counter <= 0;
    
    // New: Add parity checking.
    always @(posedge clk)
        if (reset)
            odd <= 0;
        else if (state == rec_data && next_state == stop_bit)
            odd <= in;
    
    assign done = (state == stop_bit) && (next_state == stop_bit);
    assign out_byte = (state == rec_data)? {in, odd} : 8'h00;

endmodule"
N/A,N/A,-1,40,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    // Use FSM from Fsm_serialdata
    // New: Add parity checking.
    
    parameter idle = 0, rec_data = 1, stop_bit = 2;
    reg [1:0] state, next_state;
    reg [9:0] counter;
    reg odd;
    
    always @(posedge clk)
        if (reset)
            state <= idle;
        else
            state <= next_state;
    
    always @(*)
        case (state)
            idle:
                if (in)
                    next_state = rec_data;
                else
                    next_state = idle;
            rec_data:
                if (counter == 1023)
                    next_state = stop_bit;
                else
                    next_state = rec_data;
            stop_bit:
                if (in)
                    next_state = idle;
                else
                    next_state = idle;
            default:
                next_state = idle;
        endcase
    
    always @(posedge clk)
        if (reset)
            counter <= 0;
        else if (state == rec_data && next_state == rec_data)
            counter <= counter + 1;
        else
            counter <= 0;
    
    // New: Add parity checking.
    always @(posedge clk)
        if (reset)
            odd <= 0;
        else if (state == rec_data && next_state == stop_bit)
            odd <= in;
    
    assign done = (state == stop_bit) && (next_state == stop_bit);
    assign out_byte = (state == rec_data)? {in, odd} : 8'h00;

endmodule"
N/A,N/A,-1,41,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serialdata
    // New: Add parity checking.
    
    parameter idle = 0, rec_data = 1, stop_bit = 2;
    reg [1:0] state, next_state;
    
    always @(posedge clk)
        if (reset) state <= idle;
        else state <= next_state;
    
    always @(*)
        case (state)
            idle:
                if (in) next_state = rec_data;
                else next_state = idle;
            rec_data:
                if (in) next_state = rec_data;
                else next_state = stop_bit;
            stop_bit:
                if (in) next_state = idle;
                else next_state = idle;
            default: next_state = idle;
        endcase
    
    assign done = (state == stop_bit)? 1'b1 : 1'b0;
    
    // New: Add parity checking.
    parity pff(clk, reset, in, odd);
    
    always @(posedge clk)
        if (reset) out_byte <= 8'b0;
        else if (state == rec_data) out_byte <= {in, odd};

endmodule"
N/A,N/A,-1,42,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.
    
    parameter idle = 0, rec_data = 1, stop_bit = 2, rec_stop_bit = 3;
    reg [1:0] state, next_state;
    reg [3:0] counter;
    reg odd;
    reg [7:0] rec_data_byte;
    
    always @(posedge clk)
        if (reset) state <= idle;
        else state <= next_state;
    
    always @(*)
        case (state)
            idle:
                if (in) next_state = rec_data;
                else next_state = idle;
            rec_data:
                if (counter == 7) next_state = stop_bit;
                else next_state = rec_data;
            stop_bit:
                if (in) next_state = rec_stop_bit;
                else next_state = idle;
            rec_stop_bit:
                if (in) next_state = idle;
                else next_state = idle;
            default:
                next_state = idle;
        endcase
    
    always @(posedge clk)
        if (reset) counter <= 0;
        else if (next_state == rec_data) counter <= counter + 1;
        else if (next_state == stop_bit) counter <= 0;
    
    always @(posedge clk)
        if (reset) odd <= 0;
        else if (next_state == rec_stop_bit) odd <= ~odd;
    
    assign done = (state == stop_bit) && (next_state == rec_stop_bit);
    
    assign out_byte = rec_data_byte;
    
    always @(posedge clk)
        if (reset) begin
            rec_data_byte <= 0;
            odd <= 0;
        end
        else if (next_state == rec_data) begin
            rec_data_byte[7] <= in;
            rec_data_byte[6:0] <= rec_data_byte[7:1];
            odd <= odd ^ rec_data_byte[7];
        end
        else if (next_state == stop_bit) begin
            rec_data_byte[7:0] <= {1'b0, odd};
        end

endmodule"
N/A,N/A,-1,43,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    parameter START = 3'd0, DATA = 3'd1, PARITY = 3'd2, STOP = 3'd3, DELAY = 3'd4;
    reg [2:0] state, next_state;
    reg [8:0] counter;
    reg odd;
    reg [7:0] out;
    assign done = (state == DATA) && (counter == 9'd255);
    always @(posedge clk)
        if (reset)
            state <= START;
    	else
            state <= next_state;
    always @(*)
        case (state)
            START:
                begin
                    if(in)
                        next_state = START;
                    else
                        next_state = DATA;
                end
            DATA:
                begin
                    if(counter < 9'd255)
                        next_state = DATA;
                    else
                        next_state = PARITY;
                end
            PARITY:
                begin
                    if(counter < 9'd255)
                        next_state = PARITY;
                    else
                        next_state = STOP;
                end
            STOP:
                begin
                    if(in)
                        next_state = START;
                    else
                        next_state = DELAY;
                end
            DELAY:
                begin
                    if(in)
                        next_state = DELAY;
                    else
                        next_state = START;
                end
            default:
                begin
                    next_state = START;
                end
        endcase
    always @(posedge clk)
        if (reset)
            counter <= 0;
    	else if (state == DATA)
            counter <= counter + 1;
    	else
            counter <= 0;
    always @(posedge clk)
        if (reset)
            out_byte <= 0;
    	else if (state == DATA)
            out_byte <= out;
    	else if (state == PARITY)
            out_byte <= {out, odd};
    always @(posedge clk)
        if (reset)
            odd <= 0;
    	else if (state == PARITY)
            odd <= in;
    	else
            odd <= odd;
    always @(posedge clk)
        if (reset)
            out <= 0;
    	else if (state == START)
            out <= in;
    	else if (state == PARITY)
            out <= {out, in};
endmodule"
N/A,N/A,-1,44,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    parameter START = 3'd0, DATA = 3'd1, PARITY = 3'd2, STOP = 3'd3, DELAY = 3'd4;
    reg [2:0] state, next_state;
    reg [8:0] counter;
    reg odd;
    reg [7:0] out;
    assign done = (state == DATA) && (counter == 9'd255);
    always @(posedge clk)
        if (reset)
            state <= START;
    	else
            state <= next_state;
    always @(*)
        case (state)
            START:
                begin
                    if(in)
                        next_state = START;
                    else
                        next_state = DATA;
                end
            DATA:
                begin
                    if(counter < 9'd255)
                        next_state = DATA;
                    else
                        next_state = PARITY;
                end
            PARITY:
                begin
                    if(counter < 9'd255)
                        next_state = PARITY;
                    else
                        next_state = STOP;
                end
            STOP:
                begin
                    if(in)
                        next_state = START;
                    else
                        next_state = DELAY;
                end
            DELAY:
                begin
                    if(in)
                        next_state = DELAY;
                    else
                        next_state = START;
                end
            default:
                begin
                    next_state = START;
                end
        endcase
    always @(posedge clk)
        if (reset)
            counter <= 0;
    	else if (state == DATA)
            counter <= counter + 1;
    	else
            counter <= 0;
    always @(posedge clk)
        if (reset)
            out_byte <= 0;
    	else if (state == DATA)
            out_byte <= out;
    	else if (state == PARITY)
            out_byte <= {out, odd};
    always @(posedge clk)
        if (reset)
            odd <= 0;
    	else if (state == PARITY)
            odd <= in;
    	else
            odd <= odd;
    always @(posedge clk)
        if (reset)
            out <= 0;
    	else if (state == START)
            out <= in;
    	else if (state == PARITY)
            out <= {out, in};
endmodule"
N/A,N/A,-1,45,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.
    
    parameter idle = 0, rec_data = 1, stop_bit = 2;
    reg [1:0] state, next_state;
    reg [8:0] rec_data_reg;
    reg [3:0] counter;
    reg odd;
    
    always @(posedge clk)
        if (reset) state <= idle;
        else state <= next_state;
    
    always @(*)
        case (state)
            idle:
                if (in) next_state = rec_data;
                else next_state = idle;
            rec_data:
                if (counter == 7) next_state = stop_bit;
                else next_state = rec_data;
            stop_bit:
                if (in) next_state = idle;
                else next_state = rec_data;
            default:
                next_state = idle;
        endcase
    
    always @(posedge clk)
        if (reset) begin
            rec_data_reg <= 0;
            counter <= 0;
        end
        else begin
            case (state)
                rec_data:
                    rec_data_reg[8] <= in;
                    counter <= counter + 1;
                stop_bit:
                    if (in)
                        done <= 1;
                    else
                        done <= 0;
            endcase
        end
    
    assign out_byte = rec_data_reg;
    
    // New: Add parity checking.
    parity pff(clk, reset, rec_data_reg[8], odd);
    
    // New: Add parity checking.
    assign odd = rec_data_reg[8] ^ rec_data_reg[7] ^ rec_data_reg[6] ^ rec_data_reg[5] ^ rec_data_reg[4] ^ rec_data_reg[3] ^ rec_data_reg[2] ^ rec_data_reg[1];
    
endmodule"
N/A,N/A,-1,46,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.
    
    parameter idle = 0, rec_data = 1, stop_bit = 2;
    reg [1:0] state, next_state;
    reg [8:0] rec_data_reg;
    reg [3:0] counter;
    reg odd;
    
    always @(posedge clk)
        if (reset) state <= idle;
        else state <= next_state;
    
    always @(*)
        case (state)
            idle:
                if (in) next_state = rec_data;
                else next_state = idle;
            rec_data:
                if (counter == 7) next_state = stop_bit;
                else next_state = rec_data;
            stop_bit:
                if (in) next_state = idle;
                else next_state = rec_data;
            default:
                next_state = idle;
        endcase
    
    always @(posedge clk)
        if (reset) begin
            rec_data_reg <= 0;
            counter <= 0;
        end
        else begin
            case (state)
                rec_data:
                    rec_data_reg[8] <= in;
                    counter <= counter + 1;
                stop_bit:
                    if (in)
                        done <= 1;
                    else
                        done <= 0;
            endcase
        end
    
    assign out_byte = rec_data_reg;
    
    // New: Add parity checking.
    parity pff(clk, reset, rec_data_reg[8], odd);
    
    // New: Add parity checking.
    assign odd = rec_data_reg[8] ^ rec_data_reg[7] ^ rec_data_reg[6] ^ rec_data_reg[5] ^ rec_data_reg[4] ^ rec_data_reg[3] ^ rec_data_reg[2] ^ rec_data_reg[1];
    
endmodule"
N/A,N/A,-1,47,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.
    
    parity p1(clk, reset, in, odd);
    
    // New: Add shift register to hold the data.
    reg [7:0] data_shift = 8'b0;
    
    always @(posedge clk)
        if (reset) data_shift <= 8'b0;
        else if (odd) data_shift <= {data_shift[6:0], in};
    
    // New: Add output byte
    assign out_byte = data_shift;
    
    // New: Add done signal
    assign done = (in == 1'b1);
    
endmodule"
N/A,N/A,-1,48,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.
    
    parity p1(clk, reset, in, odd);
    
    // New: Add shift register to hold the data.
    reg [7:0] data_shift = 8'b0;
    
    always @(posedge clk)
        if (reset) data_shift <= 8'b0;
        else if (odd) data_shift <= {data_shift[6:0], in};
    
    // New: Add output byte
    assign out_byte = data_shift;
    
    // New: Add done signal
    assign done = (in == 1'b1);
    
endmodule"
N/A,N/A,-1,49,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.
    
    parity p1(clk, reset, in, odd);
    
    // New: Add shift register to hold the data.
    reg [7:0] data_shift = 8'b0;
    
    always @(posedge clk)
        if (reset) data_shift <= 8'b0;
        else if (odd) data_shift <= {data_shift[6:0], in};
    
    // New: Add output byte
    assign out_byte = data_shift;
    
    // New: Add done signal
    assign done = (in == 1'b1);
    
endmodule"
N/A,N/A,-1,50,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    // Use FSM from Fsm_serialdata
    // New: Add parity checking.
    
    parameter idle = 0, rec_data = 1, stop_bit = 2;
    reg [1:0] state, next_state;
    reg [9:0] counter;
    reg odd;
    
    always @(posedge clk)
        if (reset)
            state <= idle;
        else
            state <= next_state;
    
    always @(*)
        case (state)
            idle:
                if (in)
                    next_state = rec_data;
                else
                    next_state = idle;
            rec_data:
                if (counter == 1023)
                    next_state = stop_bit;
                else
                    next_state = rec_data;
            stop_bit:
                if (in)
                    next_state = idle;
                else
                    next_state = idle;
            default:
                next_state = idle;
        endcase
    
    always @(posedge clk)
        if (reset)
            counter <= 0;
        else if (state == rec_data)
            counter <= counter + 1;
    
    assign done = (state == stop_bit) && (counter == 1023);
    
    assign out_byte = {in, odd};
    
    // New: Add parity checking.
    parity pff(clk, reset, in, odd);

endmodule"
N/A,N/A,-1,51,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    parameter START = 3'd0, DATA = 3'd1, PARITY = 3'd2, STOP = 3'd3, DELAY = 3'd4;
    reg [2:0] state, next_state;
    reg odd;
    reg [7:0] out;
    reg [2:0] count;
    
    always @(posedge clk)
        if (reset)
            state <= START;
        else
            state <= next_state;
    
    always @(*)
        case (state)
            START:
                if (in)
                    next_state = DATA;
                else
                    next_state = START;
            DATA:
                if (count == 7)
                    next_state = PARITY;
                else
                    next_state = DATA;
            PARITY:
                if (count == 7)
                    next_state = STOP;
                else
                    next_state = PARITY;
            STOP:
                if (in)
                    next_state = DELAY;
                else
                    next_state = START;
            DELAY:
                if (count == 3)
                    next_state = START;
                else
                    next_state = DELAY;
            default:
                next_state = START;
        endcase
    
    always @(posedge clk)
        if (reset) begin
            count <= 0;
            out <= 0;
        end
        else begin
            if (state == DATA || state == PARITY)
                count <= count + 1;
            else
                count <= 0;
            if (state == STOP)
                out_byte <= out;
            if (state == DELAY)
                out <= in;
        end
    
    assign done = (state == DELAY) && (count == 3);
    
    always @(posedge clk)
        if (reset)
            odd <= 0;
        else
            if (state == PARITY)
                odd <= ~(in ^ odd);

endmodule"
N/A,N/A,-1,52,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serialdata
    // New: Add parity checking.
    
    parameter idle = 0, rec_data = 1, stop_bit = 2;
    reg [1:0] state, next_state;
    
    always @(posedge clk) begin
        if (reset) state <= idle;
        else state <= next_state;
    end
    
    always @(state) begin
        case (state)
            idle: begin
                if (in) next_state = rec_data;
                else next_state = idle;
            end
            
            rec_data: begin
                if (in) next_state = rec_data;
                else next_state = stop_bit;
            end
            
            stop_bit: begin
                if (in) next_state = idle;
                else next_state = idle;
            end
            
            default: next_state = idle;
        endcase
    end
    
    assign done = (state == stop_bit);
    
    // New: Add parity checking.
    parity p1(clk, reset, in, odd);
    
    always @(posedge clk) begin
        if (reset) out_byte <= 8'b0;
        else if (state == rec_data) out_byte <= {in, odd};
    end
    
endmodule"
N/A,N/A,-1,53,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.
    
    parameter idle = 0, rec_data = 1, stop_bit = 2;
    reg [1:0] state, next_state;
    reg [8:0] rec_data_bits;
    reg odd;
    
    always @(posedge clk)
        if (reset) state <= idle;
        else state <= next_state;
    
    always @(*)
        case (state)
            idle:
                if (in) next_state = rec_data;
                else next_state = idle;
            rec_data:
                if (rec_data_bits[8]) next_state = stop_bit;
                else next_state = rec_data;
            stop_bit:
                next_state = idle;
            default:
                next_state = idle;
        endcase
    
    always @(posedge clk)
        if (reset) begin
            rec_data_bits <= 0;
            odd <= 0;
        end
        else begin
            rec_data_bits <= {rec_data_bits[6:0], in};
            odd <= rec_data_bits[8] ^ rec_data_bits[7];
        end
    
    assign done = (state == stop_bit);
    
    assign out_byte = rec_data_bits[7:0];

endmodule"
N/A,N/A,-1,54,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.
    
    parameter idle = 0, rec_data = 1, stop_bit = 2;
    reg [1:0] state, next_state;
    reg [8:0] rec_data_bits;
    reg odd;
    
    always @(posedge clk)
        if (reset) state <= idle;
        else state <= next_state;
    
    always @(*)
        case (state)
            idle:
                if (in) next_state = rec_data;
                else next_state = idle;
            rec_data:
                if (rec_data_bits[8]) next_state = stop_bit;
                else next_state = rec_data;
            stop_bit:
                next_state = idle;
            default:
                next_state = idle;
        endcase
    
    always @(posedge clk)
        if (reset) begin
            rec_data_bits <= 0;
            odd <= 0;
        end
        else begin
            rec_data_bits <= {rec_data_bits[6:0], in};
            odd <= rec_data_bits[8] ^ rec_data_bits[7];
        end
    
    assign done = (state == stop_bit);
    
    assign out_byte = rec_data_bits[7:0];

endmodule"
N/A,N/A,-1,55,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.
    
    wire parity_error;
    wire [8:0] data;
    
    parity p1(.clk(clk),.reset(reset),.in(in),.odd(parity_error));
    serial_detect s1(.clk(clk),.in(in),.reset(reset),.done(done));
    shift_reg_serial s2(.clk(clk),.reset(reset),.in(in),.data(data));
    
    assign out_byte = data[7:0];
    
    // New: Add parity checking.
    assign parity_error = parity_error_reg;
    
    always @(posedge clk)
        parity_error_reg <= parity_error;
    
endmodule"
N/A,N/A,-1,56,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    parameter START = 0, DATA = 1, STOP = 2, DELAY = 3;
    reg [1:0] state, next_state;
    reg [3:0] count;
    reg out;
    
    always @(*) begin
        case (state)
            START: begin
                if(in)
                    next_state = DATA;
                else
                    next_state = START;
                out = 1'b0;
            end
            DATA: begin
                out = 1'b1;
                if (count == 8)
                    next_state = STOP;
                else if(in)
                    next_state = DATA;
                else
                    next_state = START;
            end
            STOP: begin
                out = 1'b1;
                if (in)
                    next_state = DELAY;
                else
                    next_state = START;
            end
            DELAY: begin
                out = 1'b0;
                if (count == 4)
                    next_state = START;
                else
                    next_state = DELAY;
            end
            default: next_state = START;
        endcase
    end
    
    always @(posedge clk) begin
        if(reset)
            state <= START;
        else
            state <= next_state;
    end
    
    always @(posedge clk) begin
        if(state == DATA)
            count <= count + 4'd1;
        else
            count <= 4'd0;
    end
    
    assign done = (state == DELAY)? 1:0;
    assign out_byte = out? 8'b11111111:8'b00000000;
    
endmodule"
N/A,N/A,-1,57,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    parameter START = 0, DATA = 1, STOP = 2, DELAY = 3;
    reg [1:0] state, next_state;
    reg [3:0] count;
    reg out;
    
    always @(*) begin
        case (state)
            START: begin
                if(in)
                    next_state = DATA;
                else
                    next_state = START;
                out = 1'b0;
            end
            DATA: begin
                out = 1'b1;
                if (count == 8)
                    next_state = STOP;
                else if(in)
                    next_state = DATA;
                else
                    next_state = START;
            end
            STOP: begin
                out = 1'b1;
                if (in)
                    next_state = DELAY;
                else
                    next_state = START;
            end
            DELAY: begin
                out = 1'b0;
                if (count == 4)
                    next_state = START;
                else
                    next_state = DELAY;
            end
            default: next_state = START;
        endcase
    end
    
    always @(posedge clk) begin
        if(reset)
            state <= START;
        else
            state <= next_state;
    end
    
    always @(posedge clk) begin
        if(state == DATA)
            count <= count + 4'd1;
        else
            count <= 4'd0;
    end
    
    assign done = (state == DELAY)? 1:0;
    assign out_byte = out? 8'b11111111:8'b00000000;
    
endmodule"
N/A,N/A,-1,58,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    parameter START = 0, DATA = 1, STOP = 2, DELAY = 3;
    reg [1:0] state, next_state;
    reg [3:0] count;
    reg out;
    
    always @(*) begin
        case (state)
            START: begin
                if(in)
                    next_state = DATA;
                else
                    next_state = START;
                out = 1'b0;
            end
            DATA: begin
                out = 1'b1;
                if (count == 8)
                    next_state = STOP;
                else if(in)
                    next_state = DATA;
                else
                    next_state = START;
            end
            STOP: begin
                out = 1'b1;
                if (in)
                    next_state = DELAY;
                else
                    next_state = START;
            end
            DELAY: begin
                out = 1'b0;
                if (count == 4)
                    next_state = START;
                else
                    next_state = DELAY;
            end
            default: next_state = START;
        endcase
    end
    
    always @(posedge clk) begin
        if(reset)
            state <= START;
        else
            state <= next_state;
    end
    
    always @(posedge clk) begin
        if(state == DATA)
            count <= count + 4'd1;
        else
            count <= 4'd0;
    end
    
    assign done = (state == DELAY)? 1:0;
    assign out_byte = out? 8'b11111111:8'b00000000;
    
endmodule"
N/A,N/A,-1,59,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serialdata
    // New: Add parity checking.
    
    parameter idle = 0, rec_data = 1, stop_bit = 2, error = 3;
    reg [1:0] state, next_state;
    
    always @(*) begin
        state <= next_state;
    end
    
    always @(posedge clk) begin
        if (reset)
            next_state <= idle;
        else
            begin
                case (state)
                    idle:
                        if (in)
                            next_state <= rec_data;
                    rec_data:
                        if (in)
                            next_state <= rec_data;
                        else if (done)
                            next_state <= stop_bit;
                    stop_bit:
                        if (in)
                            next_state <= error;
                    error:
                        if (in)
                            next_state <= error;
                        else if (done)
                            next_state <= idle;
                    default:
                        next_state <= idle;
                endcase
            end
    end
    
    assign done = (state == stop_bit);
    
    // New: Add parity checking.
    parity p1(clk, reset, in, odd);
    
    always @(*) begin
        case (state)
            idle:
                out_byte = 8'b0;
            rec_data:
                out_byte = {in, odd};
            stop_bit:
                out_byte = {in, odd};
            error:
                out_byte = 8'b0;
        endcase
    end
    
endmodule"
N/A,N/A,-1,60,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serialdata
    // New: Add parity checking.
    
    parameter idle = 0, rec_data = 1, stop_bit = 2, error = 3;
    reg [1:0] state, next_state;
    
    always @(*) begin
        state <= next_state;
    end
    
    always @(posedge clk) begin
        if (reset)
            next_state <= idle;
        else
            begin
                case (state)
                    idle:
                        if (in)
                            next_state <= rec_data;
                    rec_data:
                        if (in)
                            next_state <= rec_data;
                        else if (done)
                            next_state <= stop_bit;
                    stop_bit:
                        if (in)
                            next_state <= error;
                    error:
                        if (in)
                            next_state <= error;
                        else if (done)
                            next_state <= idle;
                    default:
                        next_state <= idle;
                endcase
            end
    end
    
    assign done = (state == stop_bit);
    
    // New: Add parity checking.
    parity p1(clk, reset, in, odd);
    
    always @(*) begin
        case (state)
            idle:
                out_byte = 8'b0;
            rec_data:
                out_byte = {in, odd};
            stop_bit:
                out_byte = {in, odd};
            error:
                out_byte = 8'b0;
        endcase
    end
    
endmodule"
N/A,N/A,-1,61,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serialdata
    // New: Add parity checking.
    
    parity p1(clk, reset, in, odd);
    
    // New: Add serial output byte stream.
    
    serial_data sd1(clk, reset, in, odd, out_byte, done);
    
endmodule"
N/A,N/A,-1,62,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serialdata
    // New: Add parity checking.
    
    parity p1(clk, reset, in, odd);
    
    // New: Add serial output byte stream.
    
    serial_data sd1(clk, reset, in, odd, out_byte, done);
    
endmodule"
N/A,N/A,-1,63,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    parameter START = 3'd0, DATA = 3'd1, PARITY = 3'd2, STOP = 3'd3, DELAY = 3'd4;
    reg [2:0] state, next_state;
    reg [7:0] data;
    reg odd;
    
    always @(posedge clk)
        if (reset) state <= START;
        else state <= next_state;
    
    always @(*)
        case (state)
            START: begin
                if (in)
                    next_state <= DATA;
                else
                    next_state <= START;
            end
            DATA: next_state <= parity(in)? DATA : DELAY;
            DELAY: next_state <= parity(in)? DATA : DELAY;
            PARITY: next_state <= parity(in)? STOP : DELAY;
            STOP: next_state <= START;
            default: next_state <= START;
        endcase
    
    assign odd = data[0] ^ data[1] ^ data[2] ^ data[3] ^ data[4] ^ data[5] ^ data[6] ^ data[7];
    
    always @(posedge clk)
        if (reset) data <= 8'b0;
        else if (state == DATA) data <= {in, data[7:1]};
    
    assign out_byte = odd? {in, data[7:1]} : {data[6:0], in};
    
    assign done = (state == STOP);
    
endmodule"
N/A,N/A,-1,64,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    parameter START = 3'd0, DATA = 3'd1, PARITY = 3'd2, STOP = 3'd3, DELAY = 3'd4;
    reg [2:0] state, next_state;
    reg [7:0] data;
    reg odd;
    
    always @(posedge clk)
        if (reset) state <= START;
        else state <= next_state;
    
    always @(*)
        case (state)
            START: begin
                if (in)
                    next_state <= DATA;
                else
                    next_state <= START;
            end
            DATA: next_state <= parity(in)? DATA : DELAY;
            DELAY: next_state <= parity(in)? DATA : DELAY;
            PARITY: next_state <= parity(in)? STOP : DELAY;
            STOP: next_state <= START;
            default: next_state <= START;
        endcase
    
    assign odd = data[0] ^ data[1] ^ data[2] ^ data[3] ^ data[4] ^ data[5] ^ data[6] ^ data[7];
    
    always @(posedge clk)
        if (reset) data <= 8'b0;
        else if (state == DATA) data <= {in, data[7:1]};
    
    assign out_byte = odd? {in, data[7:1]} : {data[6:0], in};
    
    assign done = (state == STOP);
    
endmodule"
N/A,N/A,-1,65,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    parameter START = 3'd0, DATA = 3'd1, PARITY = 3'd2, STOP = 3'd3, DELAY = 3'd4;
    reg [2:0] state, next_state;
    reg [7:0] data;
    reg odd;
    
    always @(posedge clk)
        if (reset) state <= START;
        else state <= next_state;
    
    always @(*)
        case (state)
            START: begin
                if (in)
                    next_state <= DATA;
                else
                    next_state <= START;
            end
            DATA: next_state <= parity(in)? DATA : DELAY;
            DELAY: next_state <= parity(in)? DATA : DELAY;
            PARITY: next_state <= parity(in)? STOP : DELAY;
            STOP: next_state <= START;
            default: next_state <= START;
        endcase
    
    assign odd = data[0] ^ data[1] ^ data[2] ^ data[3] ^ data[4] ^ data[5] ^ data[6] ^ data[7];
    
    always @(posedge clk)
        if (reset) data <= 8'b0;
        else if (state == DATA) data <= {in, data[7:1]};
    
    assign out_byte = odd? {in, data[7:1]} : {data[6:0], in};
    
    assign done = (state == STOP);
    
endmodule"
N/A,N/A,-1,66,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serialdata
    // New: Add parity checking.
    
    parameter idle = 0, rec_data = 1, stop_bit = 2;
    reg [1:0] state, next_state;
    reg odd;
    reg [8:0] rec_data_bits;
    reg [3:0] rec_counter;
    
    always @(posedge clk)
        if (reset) state <= idle;
        else state <= next_state;
        
    always @(*)
        case (state)
            idle:
                begin
                    if (in) next_state = rec_data;
                    else next_state = idle;
                end
            rec_data:
                begin
                    if (rec_counter == 9) next_state = stop_bit;
                    else next_state = rec_data;
                end
            stop_bit:
                begin
                    if (in) next_state = idle;
                    else next_state = idle;
                end
            default:
                next_state = idle;
        endcase
        
    always @(posedge clk)
        if (reset)
            rec_data_bits <= 0;
        else if (state == rec_data)
            rec_data_bits <= {in, rec_data_bits[8:1]};
    
    always @(posedge clk)
        if (reset)
            rec_counter <= 0;
        else if (state == rec_data && rec_counter < 9)
            rec_counter <= rec_counter + 1;
    
    assign odd = rec_data_bits[0] ^ rec_data_bits[1];
    
    assign done = (state == stop_bit);
    
    assign out_byte = rec_data_bits[7:0];
    
endmodule"
N/A,N/A,-1,67,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    parameter START = 3'd0, DATA = 3'd1, PARITY = 3'd2, STOP = 3'd3, DELAY = 3'd4;
    reg [2:0] state, next_state;
    reg [8:0] counter;
    reg odd;
    reg out;
    reg [7:0] byte;
    assign done = (state == STOP);
    
    always @(*) begin
        case (state)
            START: begin
                if(~in)
                    next_state = DATA;
                else
                    next_state = START;
            end
            DATA: begin
                if(counter == 9'd255)
                    next_state = PARITY;
                else
                    next_state = DATA;
            end
            PARITY: begin
                if(counter == 9'd255)
                    next_state = STOP;
                else
                    next_state = PARITY;
            end
            STOP: begin
                if(counter == 9'd255)
                    next_state = DELAY;
                else
                    next_state = STOP;
            end
            DELAY: begin
                if(counter == 9'd255)
                    next_state = START;
                else
                    next_state = DELAY;
            end
            default: next_state = START;
        endcase
    end
    
    always @(posedge clk) begin
        if(reset)
            state <= START;
        else
            state <= next_state;
    end
    
    always @(posedge clk) begin
        if(state == DATA)
            byte[7:0] <= {in, byte[7:1]};
        else if(state == PARITY)
            byte[7:0] <= {in, odd};
    end
    
    always @(posedge clk) begin
        if(state == STOP) begin
            out_byte <= byte;
            out <= 1;
        end
        else begin
            out_byte <= 8'b0;
            out <= 0;
        end
    end
    
    always @(posedge clk) begin
        if(state == DELAY)
            counter <= 9'd0;
        else if(state == PARITY)
            counter <= 9'd1;
        else
            counter <= counter + 1;
    end
    
    always @(*) begin
        case (state)
            START: odd <= 0;
            DATA: odd <= byte[0];
            PARITY: odd <= ^byte;
            STOP: odd <= 0;
            DELAY: ;
            default: odd <= 0;
        endcase
    end
    
endmodule"
N/A,N/A,-1,68,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    parameter START = 3'd0, DATA = 3'd1, PARITY = 3'd2, STOP = 3'd3, DELAY = 3'd4;
    reg [2:0] state, next_state;
    reg [8:0] counter;
    reg odd;
    reg out;
    reg [7:0] byte;
    assign done = (state == STOP);
    
    always @(*) begin
        case (state)
            START: begin
                if(~in)
                    next_state = DATA;
                else
                    next_state = START;
            end
            DATA: begin
                if(counter == 9'd255)
                    next_state = PARITY;
                else
                    next_state = DATA;
            end
            PARITY: begin
                if(counter == 9'd255)
                    next_state = STOP;
                else
                    next_state = PARITY;
            end
            STOP: begin
                if(counter == 9'd255)
                    next_state = DELAY;
                else
                    next_state = STOP;
            end
            DELAY: begin
                if(counter == 9'd255)
                    next_state = START;
                else
                    next_state = DELAY;
            end
            default: next_state = START;
        endcase
    end
    
    always @(posedge clk) begin
        if(reset)
            state <= START;
        else
            state <= next_state;
    end
    
    always @(posedge clk) begin
        if(state == DATA)
            byte[7:0] <= {in, byte[7:1]};
        else if(state == PARITY)
            byte[7:0] <= {in, odd};
    end
    
    always @(posedge clk) begin
        if(state == STOP) begin
            out_byte <= byte;
            out <= 1;
        end
        else begin
            out_byte <= 8'b0;
            out <= 0;
        end
    end
    
    always @(posedge clk) begin
        if(state == DELAY)
            counter <= 9'd0;
        else if(state == PARITY)
            counter <= 9'd1;
        else
            counter <= counter + 1;
    end
    
    always @(*) begin
        case (state)
            START: odd <= 0;
            DATA: odd <= byte[0];
            PARITY: odd <= ^byte;
            STOP: odd <= 0;
            DELAY: ;
            default: odd <= 0;
        endcase
    end
    
endmodule"
N/A,N/A,-1,69,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    parameter START = 3'd0, DATA = 3'd1, PARITY = 3'd2, STOP = 3'd3, DELAY = 3'd4;
    reg [2:0] state, next_state;
    reg [8:0] counter;
    reg odd;
    reg out;
    reg [7:0] byte;
    assign done = (state == STOP);
    
    always @(*) begin
        case (state)
            START: begin
                if(~in)
                    next_state = DATA;
                else
                    next_state = START;
            end
            DATA: begin
                if(counter == 9'd255)
                    next_state = PARITY;
                else
                    next_state = DATA;
            end
            PARITY: begin
                if(counter == 9'd255)
                    next_state = STOP;
                else
                    next_state = PARITY;
            end
            STOP: begin
                if(counter == 9'd255)
                    next_state = DELAY;
                else
                    next_state = STOP;
            end
            DELAY: begin
                if(counter == 9'd255)
                    next_state = START;
                else
                    next_state = DELAY;
            end
            default: next_state = START;
        endcase
    end
    
    always @(posedge clk) begin
        if(reset)
            state <= START;
        else
            state <= next_state;
    end
    
    always @(posedge clk) begin
        if(state == DATA)
            byte[7:0] <= {in, byte[7:1]};
        else if(state == PARITY)
            byte[7:0] <= {in, odd};
    end
    
    always @(posedge clk) begin
        if(state == STOP) begin
            out_byte <= byte;
            out <= 1;
        end
        else begin
            out_byte <= 8'b0;
            out <= 0;
        end
    end
    
    always @(posedge clk) begin
        if(state == DELAY)
            counter <= 9'd0;
        else if(state == PARITY)
            counter <= 9'd1;
        else
            counter <= counter + 1;
    end
    
    always @(*) begin
        case (state)
            START: odd <= 0;
            DATA: odd <= byte[0];
            PARITY: odd <= ^byte;
            STOP: odd <= 0;
            DELAY: ;
            default: odd <= 0;
        endcase
    end
    
endmodule"
N/A,N/A,-1,70,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serialdata
    // New: Add parity checking.
    
    parameter idle = 0, rec_data = 1, stop_bit = 2;
    reg [1:0] state, next_state;
    
    always @(*) begin
        case (state)
            idle: begin
                if (in) next_state <= rec_data;
                else next_state <= idle;
            end
            rec_data: begin
                if (in) next_state <= rec_data;
                else next_state <= stop_bit;
            end
            stop_bit: begin
                if (in) next_state <= idle;
                else next_state <= idle;
            end
            default: next_state <= idle;
        endcase
    end
    
    always @(posedge clk) begin
        if (reset) state <= idle;
        else state <= next_state;
    end
    
    assign done = (state == stop_bit)? 1 : 0;
    
    // New: Add parity checking.
    parity p1(clk, reset, in, odd);
    
    // New: Add byte output.
    assign out_byte = (state == rec_data)? {in, odd} : 0;
    
endmodule"
N/A,N/A,-1,71,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serialdata
    // New: Add parity checking.
    
    parameter idle = 0, rec_data = 1, stop_bit = 2;
    reg [1:0] state, next_state;
    reg [7:0] rec_data_reg;
    reg odd_bit;
    
    always @(posedge clk)
        if (reset) state <= idle;
        else state <= next_state;
    
    always @(*)
        case (state)
            idle:
                if (in) next_state = rec_data;
                else next_state = idle;
            rec_data:
                if (rec_data_reg[7]) next_state = stop_bit;
                else next_state = rec_data;
            stop_bit:
                next_state = idle;
            default:
                next_state = idle;
        endcase
    
    always @(posedge clk)
        if (reset) begin
            rec_data_reg <= 0;
            odd_bit <= 0;
        end
        else begin
            rec_data_reg <= rec_data_reg << 1;
            rec_data_reg[0] <= in;
            if (state == rec_data) odd_bit <= odd_bit ^ in;
        end
    
    assign done = (state == stop_bit) && (rec_data_reg[7] == 0);
    assign out_byte = {rec_data_reg[6:0], odd_bit};
    
endmodule"
N/A,N/A,-1,72,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serialdata
    // New: Add parity checking.
    
    parameter idle = 0, rec_data = 1, stop_bit = 2;
    reg [1:0] state, next_state;
    
    always @(posedge clk)
        if (reset) state <= idle;
        else state <= next_state;
    
    always @(*)
        case (state)
            idle:
                begin
                    if (in) next_state = rec_data;
                    else next_state = idle;
                end
            rec_data:
                begin
                    if (in) next_state = rec_data; // Wait for 9th bit
                    else next_state = stop_bit;
                end
            stop_bit:
                begin
                    if (in) next_state = idle;
                    else next_state = idle; // Wait for stop bit to finish
                end
            default:
                next_state = idle;
        endcase
    
    // New: Add parity checking.
    parity p1(clk, reset, in, odd);
    
    // New: Add parity checking.
    assign done = (state == stop_bit) && (in == 1'b1);
    
    // New: Add parity checking.
    assign out_byte = {in, odd};
    
endmodule"
N/A,N/A,-1,73,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serialdata
    // New: Add parity checking.
    
    parameter idle = 0, rec_data = 1, stop_bit = 2;
    reg [1:0] state, next_state;
    
    always @(posedge clk)
        if (reset) state <= idle;
        else state <= next_state;
    
    always @(*)
        case (state)
            idle:
                begin
                    if (in) next_state = rec_data;
                    else next_state = idle;
                end
            rec_data:
                begin
                    if (in) next_state = rec_data; // Wait for 9th bit
                    else next_state = stop_bit;
                end
            stop_bit:
                begin
                    if (in) next_state = idle;
                    else next_state = idle; // Wait for stop bit to finish
                end
            default:
                next_state = idle;
        endcase
    
    // New: Add parity checking.
    parity p1(clk, reset, in, odd);
    
    // New: Add parity checking.
    assign done = (state == stop_bit) && (in == 1'b1);
    
    // New: Add parity checking.
    assign out_byte = {in, odd};
    
endmodule"
N/A,N/A,-1,74,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serialdata
    // New: Add parity checking.
    
    parity p1(clk, reset, in, odd);
    
    // New: Add serial output byte stream.
    
    serialdata s1(clk, reset, odd, in, out_byte, done);
    
endmodule"
N/A,N/A,-1,75,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serialdata
    // New: Add parity checking.
    
    parity p(.clk(clk),.reset(reset),.in(in),.odd(odd));
    
    // New: Add serial output byte stream
    
    serial_out byte_serial(.clk(clk),.reset(reset),.in(in),.odd(odd),.out_byte(out_byte),.done(done));
    
endmodule"
N/A,N/A,-1,76,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    // Use FSM from Fsm_serialdata
    // New: Add parity checking.
    
    parameter idle = 0, rec_data = 1, stop_bit = 2;
    reg [1:0] state, next_state;
    
    always @(posedge clk)
        if (reset) state <= idle;
        else state <= next_state;
    
    always @(*)
        case (state)
            idle:
                if (in) next_state = rec_data;
                else next_state = idle;
            rec_data:
                if (in) next_state = rec_data;
                else next_state = stop_bit;
            stop_bit:
                if (in) next_state = idle;
                else next_state = idle;
            default: next_state = idle;
        endcase
    
    assign done = (state == stop_bit)? 1 : 0;
    
    // New: Add parity checking.
    parity pff(clk, reset, in, odd);
    
    // New: Add byte output.
    assign out_byte = (state == rec_data)? {in, odd} : 8'b0;
    
endmodule"
N/A,N/A,-1,77,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    // Use FSM from Fsm_serialdata
    // New: Add parity checking.
    
    parameter idle = 0, rec_data = 1, stop_bit = 2;
    reg [1:0] state, next_state;
    
    always @(posedge clk)
        if (reset) state <= idle;
        else state <= next_state;
    
    always @(*)
        case (state)
            idle:
                if (in) next_state = rec_data;
                else next_state = idle;
            rec_data:
                if (in) next_state = rec_data;
                else next_state = stop_bit;
            stop_bit:
                if (in) next_state = idle;
                else next_state = idle;
            default: next_state = idle;
        endcase
    
    assign done = (state == stop_bit)? 1 : 0;
    
    // New: Add parity checking.
    parity pff(clk, reset, in, odd);
    
    // New: Add byte output.
    assign out_byte = (state == rec_data)? {in, odd} : 8'b0;
    
endmodule"
N/A,N/A,-1,78,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serialdata
    // New: Add parity checking.
    
    parameter idle = 0, rec_data = 1, stop_bit = 2;
    reg [1:0] state, next_state;
    
    always @(posedge clk)
        if (reset) state <= idle;
        else state <= next_state;
    
    always @(*)
        case (state)
            idle:
                begin
                    if (in) next_state = rec_data;
                    else next_state = idle;
                end
            rec_data:
                begin
                    if (in) next_state = rec_data; // Wait for 9th bit
                    else next_state = stop_bit;
                end
            stop_bit:
                begin
                    if (in) next_state = idle;
                    else next_state = idle; // Wait for stop bit to end transmission
                end
            default:
                next_state = idle;
        endcase
    
    // New: Add parity checking.
    parity pff(clk, reset, in, odd);
    
    // New: Add parity checking.
    always @(posedge clk)
        if (reset) out_byte <= 0;
        else if (state == rec_data) out_byte <= {in, odd};

endmodule"
N/A,N/A,-1,79,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    parameter START = 3'd0, DATA = 3'd1, PARITY = 3'd2, STOP = 3'd3, DELAY = 3'd4;
    reg [2:0] state, next_state;
    reg odd;
    reg [8:0] shift_reg;
    reg [7:0] out_byte_reg;
    reg out_bit;
    reg done_reg;
    
    always @(posedge clk) begin
        if (reset)
            state <= START;
        else
            state <= next_state;
    end
    
    always @(*) begin
        case (state)
            START: begin
                if (in)
                    next_state = DATA;
                else
                    next_state = START;
            end
            DATA: begin
                if (in)
                    next_state = DATA;
                else
                    next_state = PARITY;
            end
            PARITY: begin
                if (in)
                    next_state = STOP;
                else
                    next_state = DELAY;
            end
            DELAY: begin
                if (in)
                    next_state = DELAY;
                else
                    next_state = START;
            end
            STOP: begin
                if (in)
                    next_state = START;
                else
                    next_state = DELAY;
            end
            default: next_state = START;
        endcase
    end
    
    always @(posedge clk) begin
        if (reset) begin
            shift_reg <= 9'b0;
            out_byte_reg <= 8'b0;
            done_reg <= 1'b0;
        end
        else begin
            shift_reg <= {shift_reg[7:0], in};
            out_byte_reg <= out_byte_reg;
            done_reg <= done_reg;
        end
    end
    
    assign out_byte = out_byte_reg;
    assign done = done_reg;
    
    always @(posedge clk) begin
        if (state == DATA) begin
            out_bit = shift_reg[8];
            shift_reg = shift_reg >> 1;
        end
        else begin
            out_bit = 1'b0;
        end
    end
    
    always @(posedge clk) begin
        if (state == PARITY)
            odd = shift_reg[8] ^ shift_reg[7];
        else
            odd = 1'b0;
    end
    
endmodule"
N/A,N/A,-1,80,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.
    
    wire parity_bit;
    parity p1(clk, reset, in, parity_bit);
    
    wire [8:0] data_bits;
    serial_receiver s1(clk, in, data_bits, parity_bit, reset, done);
    
    assign out_byte = data_bits[7:0];
    
endmodule"
N/A,N/A,-1,81,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.
    
    wire parity_bit;
    parity p1(clk, reset, in, parity_bit);
    
    wire [8:0] data_bits;
    serial_receiver s1(clk, in, data_bits, parity_bit, reset, done);
    
    assign out_byte = data_bits[7:0];
    
endmodule"
N/A,N/A,-1,82,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    parameter START = 0, DATA = 1, STOP = 2, DELAY = 3;
    reg [1:0] state, next_state;
    reg [9:0] count;
    reg out;
    reg [7:0] byte;
    
    always @(*) begin
        case (state)
            START: begin
                if(~in)
                    next_state = DATA;
                else
                    next_state = START;
            end
            DATA: begin
                if(count == 1023)
                    next_state = DELAY;
                else if(~in)
                    next_state = DATA;
                else
                    next_state = START;
            end
            DELAY: begin
                if(count == 1023)
                    next_state = STOP;
                else
                    next_state = DELAY;
            end
            STOP: begin
                if(in)
                    next_state = START;
                else
                    next_state = STOP;
            end
            default: next_state = START;
        endcase
    end
    
    always @(posedge clk) begin
        if(reset)
            state <= START;
        else
            state <= next_state;
    end
    
    always @(posedge clk) begin
        if(state == DATA)
            count <= count + 1;
        else
            count <= 0;
    end
    
    always @(posedge clk) begin
        if(state == DELAY) begin
            out <= 1;
            byte <= byte + 1;
        end
        else begin
            out <= 0;
            byte <= byte;
        end
    end
    
    assign done = (state == STOP);
    assign out_byte = byte;
endmodule"
N/A,N/A,-1,83,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.
    
    parameter idle = 0, rec_data = 1, stop_bit = 2, rec_stop_bit = 3;
    reg [1:0] state, next_state;
    reg [9:0] counter;
    reg odd;
    reg [7:0] out_byte_reg;
    
    always @(posedge clk)
        if (reset) state <= idle;
        else state <= next_state;
    
    always @(*)
        case (state)
            idle:
                begin
                    if (in)
                        next_state = rec_data;
                    else
                        next_state = idle;
                end
            rec_data:
                begin
                    if (counter == 1023)
                        next_state = stop_bit;
                    else
                        next_state = rec_data;
                end
            stop_bit:
                begin
                    if (in)
                        next_state = rec_stop_bit;
                    else
                        next_state = idle;
                end
            rec_stop_bit:
                begin
                    if (counter == 9)
                        next_state = idle;
                    else
                        next_state = rec_stop_bit;
                end
            default:
                next_state = idle;
        endcase
    
    always @(posedge clk)
        if (reset)
            counter <= 0;
        else if (next_state == rec_data)
            counter <= counter + 1;
        else
            counter <= 0;
    
    always @(posedge clk)
        if (reset)
            out_byte_reg <= 0;
        else if (next_state == stop_bit)
            out_byte_reg <= {out_byte_reg[6:0], in};
    
    assign done = (state == rec_stop_bit)? 1 : 0;
    assign out_byte = out_byte_reg;
    
    // New: Add parity checking.
    parity pff(clk, reset, in, odd);
    
    always @(posedge clk)
        if (reset)
            odd <= 0;
        else if (next_state == rec_data)
            if (counter[0] ^ counter[1] ^ counter[2] ^ counter[3] ^ counter[4] ^ counter[5] ^ counter[6] ^ counter[7] ^ counter[8] ^ counter[9])
                odd <= 1;
            else
                odd <= 0;

endmodule"
N/A,N/A,-1,84,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    parameter START = 3'd0, DATA = 3'd1, PARITY = 3'd2, STOP = 3'd3, DELAY = 3'd4;
    reg [2:0] state, next_state;
    reg [7:0] data;
    reg odd;
    reg out;
    reg [1:0] count;
    
    always @(posedge clk) begin
        if (reset)
            state <= START;
        else
            state <= next_state;
    end
    
    always @(*) begin
        case (state)
            START: begin
                if (in)
                    next_state = DATA;
                else
                    next_state = START;
            end
            DATA: begin
                next_state = PARITY;
                data <= {in, data[7:1]};
            end
            PARITY: begin
                next_state = STOP;
                odd = in ^ data[0];
            end
            STOP: begin
                if (count == 2)
                    next_state = DELAY;
                else
                    next_state = START;
            end
            DELAY: begin
                if (count == 2)
                    next_state = DATA;
                else
                    next_state = START;
            end
            default: next_state = START;
        endcase
    end
    
    always @(posedge clk) begin
        if (reset) begin
            count <= 2'd0;
            out <= 0;
        end
        else if (next_state == DATA)
            count <= count + 2'd1;
        else if (next_state == PARITY)
            count <= count + 2'd1;
        else if (next_state == STOP)
            count <= count + 2'd1;
        else if (next_state == DELAY)
            out <= odd;
    end
    
    assign done = (state == DELAY) && (count == 2);
    
    assign out_byte = data;
    
endmodule"
N/A,N/A,-1,85,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    parameter START = 3'd0, DATA = 3'd1, PARITY = 3'd2, STOP = 3'd3, DELAY = 3'd4;
    reg [2:0] state, next_state;
    reg [7:0] data;
    reg odd;
    reg out;
    reg [1:0] count;
    
    always @(posedge clk) begin
        if (reset)
            state <= START;
        else
            state <= next_state;
    end
    
    always @(*) begin
        case (state)
            START: begin
                if (in)
                    next_state = DATA;
                else
                    next_state = START;
            end
            DATA: begin
                next_state = PARITY;
                data <= {in, data[7:1]};
            end
            PARITY: begin
                next_state = STOP;
                odd = in ^ data[0];
            end
            STOP: begin
                if (count == 2)
                    next_state = DELAY;
                else
                    next_state = START;
            end
            DELAY: begin
                if (count == 2)
                    next_state = DATA;
                else
                    next_state = START;
            end
            default: next_state = START;
        endcase
    end
    
    always @(posedge clk) begin
        if (reset) begin
            count <= 2'd0;
            out <= 0;
        end
        else if (next_state == DATA)
            count <= count + 2'd1;
        else if (next_state == PARITY)
            count <= count + 2'd1;
        else if (next_state == STOP)
            count <= count + 2'd1;
        else if (next_state == DELAY)
            out <= odd;
    end
    
    assign done = (state == DELAY) && (count == 2);
    
    assign out_byte = data;
    
endmodule"
N/A,N/A,-1,86,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serialdata
    // New: Add parity checking.
    
    parameter idle = 0, rec_data = 1, stop_bit = 2;
    reg [1:0] state, next_state;
    
    always @(posedge clk)
        if (reset) state <= idle;
        else state <= next_state;
    
    always @(*)
        case (state)
            idle:
                if (in) next_state = rec_data;
                else next_state = idle;
            rec_data:
                if (in) next_state = rec_data;
                else next_state = stop_bit;
            stop_bit:
                if (in) next_state = idle;
                else next_state = idle;
            default: next_state = idle;
        endcase
    
    assign done = (state == stop_bit);
    
    // New: Add parity checking.
    
    parity pff(clk, reset, in, odd);
    
    // Change FSM and datapath from Fsm_serialdata
    // New: Add parity checking.
    
    always @(posedge clk)
        if (reset) out_byte <= 8'h0;
        else if (state == rec_data) out_byte <= {in, odd};

endmodule"
N/A,N/A,-1,87,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serialdata
    // New: Add parity checking.
    
    parameter idle = 0, rec_data = 1, stop_bit = 2;
    reg [1:0] state, next_state;
    
    always @(posedge clk)
        if (reset) state <= idle;
        else state <= next_state;
    
    always @(*)
        case (state)
            idle:
                begin
                    if (in) next_state = rec_data;
                    else next_state = idle;
                end
            rec_data:
                begin
                    if (in) next_state = rec_data; // Wait for 9th bit
                    else next_state = stop_bit;
                end
            stop_bit:
                begin
                    if (in) next_state = idle;
                    else next_state = idle; // Wait for stop bit to finish
                end
            default:
                next_state = idle;
        endcase
    
    assign done = (state == stop_bit);
    
    // New: Add parity checking.
    parity pff(.clk(clk),.reset(reset),.in(in),.odd(out_byte[0]));
    
    always @(posedge clk)
        out_byte[7:1] <= out_byte[6:0];
    
    assign out_byte[0] = (state == rec_data)? in : 1'bz;
    
endmodule"
N/A,N/A,-1,88,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    // Use FSM from Fsm_serialdata
    // New: Add parity checking.
    
    parameter idle = 0, rec_data = 1, stop_bit = 2;
    reg [1:0] state, next_state;
    
    always @(*) begin
        case (state)
            idle: begin
                if (in) next_state = rec_data;
                else next_state = idle;
            end
            rec_data: begin
                if (in) next_state = rec_data;
                else next_state = stop_bit;
            end
            stop_bit: begin
                if (in) next_state = idle;
                else next_state = idle;
            end
            default: next_state = idle;
        endcase
    end
    
    always @(posedge clk) begin
        if (reset) state <= idle;
        else state <= next_state;
    end
    
    assign done = (state == stop_bit);
    
    // New: Add parity checking.
    parity pff(clk, reset, in, odd);
    
    // New: Add byte output.
    assign out_byte = (state == rec_data)? {in, odd} : 8'b0;
    
endmodule"
N/A,N/A,-1,89,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serialdata
    // New: Add parity checking.
    
    parameter idle = 0, rec_data = 1, stop_bit = 2;
    reg [1:0] state, next_state;
    reg odd;
    reg [8:0] rec_data_bits;
    reg [7:0] out_byte_bits;
    
    always @(posedge clk)
        if (state == rec_data) rec_data_bits <= {rec_data_bits[7:0], in};
        else if (state == stop_bit) rec_data_bits <= {8'b0, in};
    
    always @(*)
        case (state)
            idle:
                if (in) next_state <= rec_data;
                else next_state <= idle;
            rec_data:
                if (rec_data_bits[8]) next_state <= stop_bit;
                else next_state <= rec_data;
            stop_bit:
                if (in) next_state <= idle;
                else next_state <= idle;
            default: next_state <= idle;
        endcase
    
    always @(posedge clk)
        if (state == rec_data) out_byte_bits <= rec_data_bits[7:0];
        else out_byte_bits <= 8'b0;
    
    assign done = (state == stop_bit) && (in == 0);
    
    always @(posedge clk)
        if (state == rec_data) odd <= rec_data_bits[8];
        else if (state == stop_bit) odd <= 0;
    
    assign out_byte = out_byte_bits;
    
    always @(posedge clk)
        if (state == rec_data) state <= next_state;
        else if (next_state == idle) state <= idle;
        else state <= next_state;

endmodule"
N/A,N/A,-1,90,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    parameter START = 3'd0, DATA = 3'd1, PARITY = 3'd2, STOP = 3'd3, DELAY = 3'd4;
    reg [2:0] state, next_state;
    reg [8:0] counter;
    reg odd;
    
    always @(posedge clk)
        if (reset)
            state <= START;
        else
            state <= next_state;
    
    always @(*)
        case (state)
            START:
                begin
                    if (in)
                        next_state = DATA;
                    else
                        next_state = START;
                end
            DATA:
                begin
                    if (counter < 9'd249)
                        next_state = DATA;
                    else
                        next_state = PARITY;
                end
            PARITY:
                begin
                    if (counter < 9'd249)
                        next_state = PARITY;
                    else
                        next_state = STOP;
                end
            STOP:
                begin
                    if (in)
                        next_state = DELAY;
                    else
                        next_state = START;
                end
            DELAY:
                begin
                    if (counter < 9'd250)
                        next_state = DELAY;
                    else
                        next_state = START;
                end
            default:
                next_state = START;
        endcase
    
    always @(posedge clk)
        if (reset)
            counter <= 9'd0;
        else if (next_state == DATA)
            counter <= counter + 9'd1;
        else if (next_state == PARITY)
            counter <= counter + 9'd249;
        else if (next_state == STOP)
            counter <= counter + 9'd250;
    
    assign done = (state == DELAY) && (counter == 9'd250);
    
    always @(posedge clk)
        if (reset)
            odd <= 0;
        else if (next_state == PARITY)
            odd <= ~odd;
    
    assign out_byte = {in, odd};

endmodule"
N/A,N/A,-1,91,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    parameter START = 3'd0, DATA = 3'd1, PARITY = 3'd2, STOP = 3'd3, DELAY = 3'd4;
    reg [2:0] state, next_state;
    reg [8:0] counter;
    reg odd;
    
    always @(posedge clk)
        if (reset)
            state <= START;
        else
            state <= next_state;
    
    always @(*)
        case (state)
            START:
                begin
                    if (in)
                        next_state = DATA;
                    else
                        next_state = START;
                end
            DATA:
                begin
                    if (counter < 9'd249)
                        next_state = DATA;
                    else
                        next_state = PARITY;
                end
            PARITY:
                begin
                    if (counter < 9'd249)
                        next_state = PARITY;
                    else
                        next_state = STOP;
                end
            STOP:
                begin
                    if (in)
                        next_state = DELAY;
                    else
                        next_state = START;
                end
            DELAY:
                begin
                    if (counter < 9'd250)
                        next_state = DELAY;
                    else
                        next_state = START;
                end
            default:
                next_state = START;
        endcase
    
    always @(posedge clk)
        if (reset)
            counter <= 9'd0;
        else if (next_state == DATA)
            counter <= counter + 9'd1;
        else if (next_state == PARITY)
            counter <= counter + 9'd249;
        else if (next_state == STOP)
            counter <= counter + 9'd250;
    
    assign done = (state == DELAY) && (counter == 9'd250);
    
    always @(posedge clk)
        if (reset)
            odd <= 0;
        else if (next_state == PARITY)
            odd <= ~odd;
    
    assign out_byte = {in, odd};

endmodule"
N/A,N/A,-1,92,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    parameter START = 0, DATA = 1, STOP = 2, DELAY = 3;
    reg [1:0] state, next_state;
    reg [9:0] count;
    reg out;
    
    always @(*) begin
        case (state)
            START: begin
                if(in)
                    next_state = DATA;
                else
                    next_state = START;
            end
            DATA: begin
                if(count == 1023)
                    next_state = STOP;
                else
                    next_state = DATA;
            end
            STOP: begin
                if(in)
                    next_state = START;
                else
                    next_state = DELAY;
            end
            DELAY: begin
                if(count == 1023)
                    next_state = DELAY;
                else
                    next_state = START;
            end
            default: next_state = START;
        endcase
    end
    
    always @(posedge clk) begin
        if(reset)
            state <= START;
        else
            state <= next_state;
    end
    
    always @(posedge clk) begin
        if(state == DATA)
            count <= count + 1;
        else
            count <= 0;
    end
    
    always @(posedge clk) begin
        if(state == DATA)
            out <= in;
        else
            out <= out;
    end
    
    assign done = (state == STOP);
    assign out_byte = out;
    
endmodule"
N/A,N/A,-1,93,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    parameter START = 0, DATA = 1, STOP = 2, DELAY = 3;
    reg [1:0] state, next_state;
    reg [8:0] counter;
    reg odd;
    
    always @(posedge clk) begin
        if (reset)
            state <= START;
        else
            state <= next_state;
    end
    
    always @(*) begin
        case (state)
            START: begin
                if (in)
                    next_state = DATA;
                else
                    next_state = START;
            end
            DATA: begin
                if (counter == 9'd255)
                    next_state = STOP;
                else if (in)
                    next_state = DATA;
                else
                    next_state = START;
            end
            STOP: begin
                if (in)
                    next_state = START;
                else
                    next_state = DELAY;
            end
            DELAY: begin
                if (in)
                    next_state = START;
                else
                    next_state = DELAY;
            end
            default: next_state = START;
        endcase
    end
    
    always @(posedge clk) begin
        if (reset) begin
            state <= START;
            counter <= 0;
        end
        else begin
            case (state)
                START: begin
                    counter <= 0;
                    odd <= 0;
                end
                DATA: begin
                    if (counter < 9'd255)
                        counter <= counter + 1;
                    else
                        counter <= 0;
                end
                STOP: begin
                    if (in)
                        done <= 1;
                    else
                        done <= 0;
                end
            endcase
        end
    end
    
    assign out_byte = done? {odd, counter} : 8'bz;
    
endmodule"
N/A,N/A,-1,94,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.
    
    parameter idle = 3'b000, start = 3'b001, trans0 = 3'b010, trans1 = 3'b011, trans2 = 3'b100, trans3 = 3'b101;
    reg [2:0] state, next_state;
    reg [8:0] counter;
    reg odd;
    
    always @(posedge clk)
        if (reset) state <= idle;
        else state <= next_state;
    
    always @(*)
        case (state)
            idle:
                if (in)
                    next_state = start;
                else
                    next_state = idle;
            start:
                if (counter == 9'd249)
                    next_state = trans0;
                else
                    next_state = start;
            trans0:
                if (counter == 9'd499)
                    next_state = trans1;
                else
                    next_state = trans0;
            trans1:
                if (counter == 9'd999)
                    next_state = trans2;
                else
                    next_state = trans1;
            trans2:
                if (counter == 9'd1999)
                    next_state = trans3;
                else
                    next_state = trans2;
            trans3:
                if (counter == 9'd2999)
                    next_state = idle;
                else
                    next_state = trans3;
            default:
                next_state = idle;
        endcase
    
    always @(posedge clk)
        if (reset) counter <= 0;
        else if (next_state == trans0 || next_state == trans1 || next_state == trans2 || next_state == trans3)
            counter <= counter + 1'b1;
        else
            counter <= 0;
    
    always @(posedge clk)
        if (reset) odd <= 0;
        else if (next_state == trans0 || next_state == trans1 || next_state == trans2 || next_state == trans3)
            odd <= in;
    
    assign done = (state == trans3);
    
    assign out_byte = (state == trans0)? {in, odd} : 8'b0;
    
endmodule"
N/A,N/A,-1,95,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.
    
    parameter idle = 3'b000, start = 3'b001, trans0 = 3'b010, trans1 = 3'b011, trans2 = 3'b100, trans3 = 3'b101;
    reg [2:0] state, next_state;
    reg [8:0] counter;
    reg odd;
    
    always @(posedge clk)
        if (reset) state <= idle;
        else state <= next_state;
    
    always @(*)
        case (state)
            idle:
                if (in)
                    next_state = start;
                else
                    next_state = idle;
            start:
                if (counter == 9'd249)
                    next_state = trans0;
                else
                    next_state = start;
            trans0:
                if (counter == 9'd499)
                    next_state = trans1;
                else
                    next_state = trans0;
            trans1:
                if (counter == 9'd999)
                    next_state = trans2;
                else
                    next_state = trans1;
            trans2:
                if (counter == 9'd1999)
                    next_state = trans3;
                else
                    next_state = trans2;
            trans3:
                if (counter == 9'd2999)
                    next_state = idle;
                else
                    next_state = trans3;
            default:
                next_state = idle;
        endcase
    
    always @(posedge clk)
        if (reset) counter <= 0;
        else if (next_state == trans0 || next_state == trans1 || next_state == trans2 || next_state == trans3)
            counter <= counter + 1'b1;
        else
            counter <= 0;
    
    always @(posedge clk)
        if (reset) odd <= 0;
        else if (next_state == trans0 || next_state == trans1 || next_state == trans2 || next_state == trans3)
            odd <= in;
    
    assign done = (state == trans3);
    
    assign out_byte = (state == trans0)? {in, odd} : 8'b0;
    
endmodule"
N/A,N/A,-1,96,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    parameter BYTE_SIZE = 8;
    
    // State Machine Variables
    parameter START = 0, DATA = 1, STOP = 2, DELAY = 3;
    reg [1:0] state, next_state;
    
    // Local variables
    reg [BYTE_SIZE-1:0] out;
    reg [3:0] i;
    
    // State Machine
    always @(posedge clk)
        if(reset)
            state <= START;
        else
            state <= next_state;
    
    // Datapath
    // New: Datapath to send out a byte
    always @(posedge clk)
        begin
            case(state)
                START:
                    begin
                        out <= 0;
                        i <= 0;
                        next_state <= DATA;
                    end
                DATA:
                    begin
                        if(i < BYTE_SIZE)
                            begin
                                out[i] <= in;
                                i <= i + 1;
                            end
                        else
                            next_state <= STOP;
                    end
                STOP:
                    begin
                        done <= 1;
                        next_state <= DELAY;
                    end
                DELAY:
                    begin
                        done <= 0;
                        next_state <= START;
                    end
                default:
                    next_state <= START;
            endcase
        end
    
    // Output
    assign out_byte = out;
    
endmodule"
N/A,N/A,-1,97,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serialdata
    // New: Add parity checking.
    
    parity p1(clk, reset, in, odd);
    
    // New: Add serial output byte stream.
    
    serialdata s1(clk, reset, in, odd, out_byte, done);
    
endmodule"
N/A,N/A,-1,98,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    parameter START = 3'd0, DATA = 3'd1, PARITY = 3'd2, STOP = 3'd3, DELAY = 3'd4;
    reg [2:0] state, next_state;
    reg [7:0] data;
    reg odd;
    reg [1:0] count;
    
    always @(posedge clk)
        if (reset) state <= START;
        else state <= next_state;
    
    always @(*)
        case (state)
            START: begin
                if (in) next_state <= DATA;
                else next_state <= START;
            end
            DATA: begin
                if (count == 7) next_state <= PARITY;
                else next_state <= DATA;
            end
            PARITY: begin
                if (count == 7) next_state <= STOP;
                else next_state <= PARITY;
            end
            STOP: begin
                if (count == 2) next_state <= DELAY;
                else next_state <= STOP;
            end
            DELAY: begin
                if (count == 2) next_state <= START;
                else next_state <= DELAY;
            end
            default: next_state <= START;
        endcase
    
    always @(posedge clk)
        if (reset) begin
            data <= 8'b0;
            count <= 2'b0;
        end
        else begin
            if (state == DATA) data[7] <= in;
            if (state == PARITY) odd <= in ^ data[7];
            if (state == STOP) begin
                if (count == 2) count <= 2'b0;
                else count <= count + 1'b1;
            end
        end
    
    assign done = (state == DELAY) && (count == 2);
    
    assign out_byte = odd? {data[6:0], 1'b0} : {data[6:0], 1'b1};
    
endmodule"
N/A,N/A,-1,99,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    parameter START = 3'd0, DATA = 3'd1, PARITY = 3'd2, STOP = 3'd3, DELAY = 3'd4;
    reg [2:0] state, next_state;
    reg [7:0] data;
    reg odd;
    reg [1:0] count;
    
    always @(posedge clk)
        if (reset) state <= START;
        else state <= next_state;
    
    always @(*)
        case (state)
            START: begin
                if (in) next_state <= DATA;
                else next_state <= START;
            end
            DATA: begin
                if (count == 7) next_state <= PARITY;
                else next_state <= DATA;
            end
            PARITY: begin
                if (count == 7) next_state <= STOP;
                else next_state <= PARITY;
            end
            STOP: begin
                if (count == 2) next_state <= DELAY;
                else next_state <= STOP;
            end
            DELAY: begin
                if (count == 2) next_state <= START;
                else next_state <= DELAY;
            end
            default: next_state <= START;
        endcase
    
    always @(posedge clk)
        if (reset) begin
            data <= 8'b0;
            count <= 2'b0;
        end
        else begin
            if (state == DATA) data[7] <= in;
            if (state == PARITY) odd <= in ^ data[7];
            if (state == STOP) begin
                if (count == 2) count <= 2'b0;
                else count <= count + 1'b1;
            end
        end
    
    assign done = (state == DELAY) && (count == 2);
    
    assign out_byte = odd? {data[6:0], 1'b0} : {data[6:0], 1'b1};
    
endmodule"
