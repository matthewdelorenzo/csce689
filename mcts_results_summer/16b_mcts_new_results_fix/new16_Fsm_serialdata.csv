Area,Delay,Score,Current Run,Episode,Verilog
N/A,N/A,-0.1,2.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Use FSM from Fsm_serial

// New: Datapath to latch input bits.

endmodule"
N/A,N/A,-0.1,3.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    // Use FSM from Fsm_serial
    // New: Datapath to latch input bits.
    
    parameter idle = 4'd0, start = 4'd1, trans0 = 4'd2, trans1 = 4'd3, trans2 = 4'd4, trans3 = 4'd5;
    parameter trans4 = 4'd6, trans5 = 4'd7, trans6 = 4'd8, trans7 = 4'd9, stop = 4'd10, error = 4'd11, pari = 4'd12;
    reg [3:0] state, next_state;
    
    always @(*) begin
        state <= next_state;
    end
    
    always @(posedge clk) begin
        if(reset)
            next_state <= idle;
        else
            case(state)
                idle:
                    if(~in)
                        next_state <= start;
                start:
                    if(in)
                        next_state <= trans0;
                trans0:
                    if(~in)
                        next_state <= trans1;
                trans1:
                    if(~in)
                        next_state <= trans2;
                trans2:
                    if(~in)
                        next_state <= trans3;
                trans3:
                    if(~in)
                        next_state <= trans4;
                trans4:
                    if(~in)
                        next_state <= trans5;
                trans5:
                    if(~in)
                        next_state <= trans6;
                trans6:
                    if(~in)
                        next_state <= trans7;
                trans7:
                    if(~in)
                        next_state <= pari;
                pari:
                    if(in)
                        next_state <= idle;
                default:
                    next_state <= idle;
            endcase
    end
    
    assign done = (state == stop);
    
    // New: Datapath to latch input bits.
    reg [7:0] out;
    always @(posedge clk) begin
        if(state == trans0 || state == trans1 || state == trans2 || state == trans3 || state == trans4 || state == trans5 || state == trans6 || state == trans7)
            out <= {in, out[7:1]};
        else
            out <= out;
    end
    
    assign out_byte = out;
    
endmodule"
N/A,N/A,-0.1,4.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Modify FSM and datapath from Fsm_serial

// New: Latch input bits.

endmodule"
N/A,N/A,-0.1,5.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

// Define states
localparam
    idle = 0,
    start = 1,
    data = 2,
    stop = 3,
    last = 4;

reg [1:0] state, next_state;
reg [3:0] counter;
reg [7:0] data_reg;
reg [7:0] out;
reg done_reg;

// New: Datapath to latch input bits.
// New: Output byte stream

always @(posedge clk) begin
    if(reset)
        state <= idle;
    else
        state <= next_state;
end

always @(*) begin
    case(state)
        idle: begin
            if(~in)
                next_state = start;
            else
                next_state = idle;
        end
        start: begin
            if(counter == 7)
                next_state = data;
            else
                next_state = start;
        end
        data: begin
            if(counter == 15)
                next_state = stop;
            else
                next_state = data;
        end
        stop: begin
            if(counter == 7)
                next_state = last;
            else
                next_state = stop;
        end
        last: begin
            if(counter == 7)
                next_state = idle;
            else
                next_state = last;
        end
        default: next_state = idle;
    endcase
end

always @(posedge clk) begin
    if(state == data)
        counter <= counter + 1;
    else
        counter <= 0;
end

always @(posedge clk) begin
    if(state == stop) begin
        data_reg <= {data_reg[6:0], in};
    end
end

always @(posedge clk) begin
    if(state == last) begin
        out <= data_reg;
        done_reg <= 1;
    end
    else
        done_reg <= 0;
end

assign out_byte = out;
assign done = done_reg;

endmodule"
N/A,N/A,-0.1,6.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Use FSM from Fsm_serial

endmodule"
N/A,N/A,-0.1,7.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serial
    
    parameter idle = 0, rec_data = 1, stop_bit = 2;
    reg [1:0] state, next_state;
    
    always @(*) begin
        state <= next_state;
    end
    
    always @(posedge clk) begin
        if(reset)
            next_state <= idle;
        else
            begin
                case(state)
                    idle:
                        begin
                            if(~in)
                                next_state <= rec_data;
                            else
                                next_state <= idle;
                        end
                    rec_data:
                        begin
                            if(~in)
                                next_state <= stop_bit;
                            else
                                next_state <= rec_data;
                        end
                    stop_bit:
                        begin
                            if(in)
                                next_state <= idle;
                            else
                                next_state <= rec_data;
                        end
                    default:
                        next_state <= idle;
                endcase
            end
    end
    
    assign done = (state == stop_bit);
    
    // New: Datapath to latch input bits.
    
    reg [7:0] out;
    
    always @(posedge clk) begin
        if(state == rec_data)
            out <= {out[6:0], in};
    end
    
    assign out_byte = out;
    
endmodule"
N/A,N/A,-0.1,8.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serial
    // New: Datapath to latch input bits.
    
    reg [2:0] state, next_state;
    reg [7:0] out_byte_reg;
    reg done_reg;
    
    always @(*) begin
        state <= next_state;
    end
    
    always @(posedge clk) begin
        if(reset) begin
            out_byte_reg <= 0;
            done_reg <= 0;
        end
        else begin
            out_byte_reg <= out_byte;
            done_reg <= done;
        end
    end
    
    always @(*) begin
        next_state = state;
        case (state)
            3'b000: begin
                if(in)
                    next_state = 3'b001;
            end
            3'b001: begin
                if(in)
                    next_state = 3'b010;
            end
            3'b010: begin
                if(in)
                    next_state = 3'b011;
            end
            3'b011: begin
                if(in)
                    next_state = 3'b100;
            end
            3'b100: begin
                if(in)
                    next_state = 3'b101;
            end
            3'b101: begin
                if(in)
                    next_state = 3'b110;
            end
            3'b110: begin
                if(in)
                    next_state = 3'b111;
            end
            3'b111: begin
                if(~in)
                    next_state = 3'b000;
            end
            default: begin
                next_state = 3'b000;
            end
        endcase
    end
    
    assign done = (state == 3'b111)? 1 : 0;
    assign out_byte = out_byte_reg;
    
endmodule"
N/A,N/A,-0.1,9.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serial
    // New: Datapath to latch input bits.
    
    reg [2:0] state, next_state;
    reg [7:0] out_byte_reg;
    reg done_reg;
    
    always @(*) begin
        state <= next_state;
    end
    
    always @(posedge clk) begin
        if(reset) begin
            out_byte_reg <= 0;
            done_reg <= 0;
        end
        else begin
            out_byte_reg <= out_byte;
            done_reg <= done;
        end
    end
    
    always @(*) begin
        next_state = state;
        case (state)
            3'b000: begin
                if(in)
                    next_state = 3'b001;
            end
            3'b001: begin
                if(in)
                    next_state = 3'b010;
            end
            3'b010: begin
                if(in)
                    next_state = 3'b011;
            end
            3'b011: begin
                if(in)
                    next_state = 3'b100;
            end
            3'b100: begin
                if(in)
                    next_state = 3'b101;
            end
            3'b101: begin
                if(in)
                    next_state = 3'b110;
            end
            3'b110: begin
                if(in)
                    next_state = 3'b111;
            end
            3'b111: begin
                if(~in)
                    next_state = 3'b000;
            end
            default: begin
                next_state = 3'b000;
            end
        endcase
    end
    
    assign done = (state == 3'b111)? 1 : 0;
    assign out_byte = out_byte_reg;
    
endmodule"
N/A,N/A,-0.1,10.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serial
    
    parameter idle = 0, rec_data = 1, stop_bit = 2, overflow = 3;
    reg [1:0] state, next_state;
    reg [3:0] count;
    reg [7:0] rec_data_reg;
    reg [7:0] out_byte_reg;
    reg done_reg;
    
    always @(*) begin
        case (state)
            idle: begin
                if(~in)
                    next_state = rec_data;
                else
                    next_state = idle;
            end
            rec_data: begin
                if(count == 7)
                    next_state = stop_bit;
                else
                    next_state = rec_data;
            end
            stop_bit: begin
                if(in)
                    next_state = idle;
                else
                    next_state = overflow;
            end
            overflow: begin
                if(count == 7)
                    next_state = idle;
                else
                    next_state = overflow;
            end
            default: next_state = idle;
        endcase
    end
    
    always @(posedge clk) begin
        if(reset) begin
            state <= idle;
            count <= 0;
            rec_data_reg <= 0;
            out_byte_reg <= 0;
            done_reg <= 0;
        end
        else begin
            state <= next_state;
            case (next_state)
                idle: begin
                    count <= 0;
                    done_reg <= 0;
                end
                rec_data: begin
                    rec_data_reg[7] <= in;
                    count <= count + 1;
                end
                stop_bit: begin
                    out_byte_reg <= rec_data_reg;
                    done_reg <= 1;
                end
                overflow: begin
                    done_reg <= 1;
                end
            endcase
        end
    end
    
    assign done = done_reg;
    assign out_byte = out_byte_reg;
    
endmodule"
N/A,N/A,-0.1,11.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serial
    
    // New: Datapath to latch input bits.
    
    reg [7:0] out_byte_reg;
    
    always @(posedge clk) begin
        if(reset)
            out_byte_reg <= 0;
        else begin
            if(in)
                out_byte_reg <= {out_byte_reg[6:0], 1'b0};
            else
                out_byte_reg <= out_byte_reg;
        end
    end
    
    assign done = (out_byte_reg == 8'h0);
    assign out_byte = done? out_byte_reg : out_byte_reg + 8'h01;
    
endmodule"
N/A,N/A,-0.1,12.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Use FSM from Fsm_serial

// New: Datapath to latch input bits.

// Define states

// New: Datapath to latch input bits.

endmodule"
N/A,N/A,-1,13.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    // Use FSM from Fsm_serial
    // New: Datapath to latch input bits.
    
    reg [2:0] state, next_state;
    reg [7:0] out;
    reg out_bit;
    
    always @(*) begin
        state <= next_state;
    end
    
    always @(posedge clk) begin
        if(reset) begin
            out <= 0;
            out_bit <= 0;
            done <= 0;
        end
        else begin
            if(state == 0) begin
                out_bit <= in;
                out <= 0;
                next_state <= 1;
            end
            else if(state == 1) begin
                out_bit <= out[0];
                out <= {out[6:0], out_bit};
                next_state <= 2;
            end
            else if(state == 2) begin
                out_bit <= out[7];
                out <= {out[6:0], out_bit};
                done <= 1;
                next_state <= 0;
            end
        end
    end
endmodule"
N/A,N/A,-1,14.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    // Use FSM from Fsm_serial
    // New: Datapath to latch input bits.
    
    reg [2:0] state, next_state;
    reg [7:0] out;
    reg out_bit;
    
    always @(*) begin
        state <= next_state;
    end
    
    always @(posedge clk) begin
        if(reset) begin
            out <= 0;
            out_bit <= 0;
            done <= 0;
        end
        else begin
            if(state == 0) begin
                out_bit <= in;
                out <= 0;
                next_state <= 1;
            end
            else if(state == 1) begin
                out_bit <= out[0];
                out <= {out[6:0], out_bit};
                next_state <= 2;
            end
            else if(state == 2) begin
                out_bit <= out[7];
                out <= {out[6:0], out_bit};
                done <= 1;
                next_state <= 0;
            end
        end
    end
endmodule"
N/A,N/A,-0.1,15.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Use FSM from Fsm_serial

// New: Datapath to latch input bits.

endmodule"
N/A,N/A,-1,16.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

// Define states
localparam
    IDLE = 0,
    GET_BIT = 1;

// Define state transitions
localparam
    S0 = IDLE,
    S1 = GET_BIT;

// Define state register
reg [1:0] state;

// Define output signals
wire bit_clk;
wire [7:0] byte;

// Instantiate FSM
fsm_serial fsm_serial_unit (
  .clk(clk),
  .reset(reset),
  .in(in),
  .out_byte(byte),
  .done(done),
  .bit_clk(bit_clk)
);

// Instantiate datapath
datapath dpath_unit (
  .clk(clk),
  .reset(reset),
  .in(in),
  .bit_clk(bit_clk),
  .byte(byte),
  .out_byte(out_byte)
);

// Instantiate state register
always @(posedge clk) begin
    if (reset) begin
        state <= IDLE;
    end else begin
        state <= S1;
    end
end

// Define state transition logic
always @(*) begin
    case (state)
        IDLE: begin
            if (in) state <= S1;
        end
        GET_BIT: begin
            if (done) state <= IDLE;
        end
    endcase
end

endmodule"
N/A,N/A,-1,17.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

// Define states
localparam
    IDLE = 0,
    GET_BIT = 1;

// Define state transitions
localparam
    S0 = IDLE,
    S1 = GET_BIT;

// Define state register
reg [1:0] state;

// Define output signals
wire bit_clk;
wire [7:0] byte;

// Instantiate FSM
fsm_serial fsm_serial_unit (
  .clk(clk),
  .reset(reset),
  .in(in),
  .out_byte(byte),
  .done(done),
  .bit_clk(bit_clk)
);

// Instantiate datapath
datapath dpath_unit (
  .clk(clk),
  .reset(reset),
  .in(in),
  .bit_clk(bit_clk),
  .byte(byte),
  .out_byte(out_byte)
);

// Instantiate state register
always @(posedge clk) begin
    if (reset) begin
        state <= IDLE;
    end else begin
        state <= S1;
    end
end

// Define state transition logic
always @(*) begin
    case (state)
        IDLE: begin
            if (in) state <= S1;
        end
        GET_BIT: begin
            if (done) state <= IDLE;
        end
    endcase
end

endmodule"
N/A,N/A,-0.1,18.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serial
    
    // New: Datapath to latch input bits.
    
    reg [7:0] out_byte_reg;
    
    always @(posedge clk) begin
        if(reset)
            out_byte_reg <= 0;
        else begin
            if(in)
                out_byte_reg <= {out_byte_reg[6:0], 1'b0};
            else
                out_byte_reg <= out_byte_reg;
        end
    end
    
    assign done = (in && out_byte_reg == 8'b11000000)? 1 : 0;
    
    assign out_byte = out_byte_reg;
    
endmodule"
N/A,N/A,-0.1,19.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Use FSM from Fsm_serial

endmodule"
N/A,N/A,-0.1,20.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serial
    // New: Latch input bits.
    
    reg [2:0] state, next_state;
    reg [7:0] out;
    reg done_reg;
    
    always @(*) begin
        case (state)
            3'b000: begin
                if(~in)
                    next_state = 3'b001;
                else
                    next_state = 3'b000;
            end
            3'b001: begin
                if(in)
                    next_state = 3'b010;
                else
                    next_state = 3'b000;
            end
            3'b010: begin
                if(in)
                    next_state = 3'b011;
                else
                    next_state = 3'b000;
            end
            3'b011: begin
                if(in)
                    next_state = 3'b100;
                else
                    next_state = 3'b000;
            end
            3'b100: begin
                if(in)
                    next_state = 3'b101;
                else
                    next_state = 3'b000;
            end
            3'b101: begin
                if(in)
                    next_state = 3'b110;
                else
                    next_state = 3'b000;
            end
            3'b110: begin
                if(in)
                    next_state = 3'b111;
                else
                    next_state = 3'b000;
            end
            3'b111: begin
                if(~in)
                    next_state = 3'b000;
                else
                    next_state = 3'b111;
            end
            default: begin
                next_state = 3'b000;
            end
        endcase
    end
    
    always @(posedge clk) begin
        if(reset) begin
            state <= 3'b000;
            done_reg <= 1'b0;
        end
        else begin
            state <= next_state;
            done_reg <= (next_state == 3'b111);
            out <= 8'b0;
            if(next_state == 3'b111)
                out[7:1] <= in;
        end
    end
    
    assign done = done_reg;
    assign out_byte = out;
    
endmodule"
N/A,N/A,-0.1,21.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serial
    
    parameter idle = 0, rec_data = 1, stop_bit = 2, error = 3;
    reg [2:0] state, next_state;
    
    always @(*) begin
        case (state)
            idle: begin
                if(~in)
                    next_state = rec_data;
                else
                    next_state = idle;
            end
            rec_data: begin
                if(~in)
                    next_state = stop_bit;
                else
                    next_state = rec_data;
            end
            stop_bit: begin
                if(in)
                    next_state = idle;
                else
                    next_state = error;
            end
            error: begin
                if(in)
                    next_state = idle;
                else
                    next_state = error;
            end
        endcase
    end
    
    always @(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    assign done = (state == stop_bit);
    
    // New: Datapath to latch input bits.
    reg [7:0] out_byte_reg;
    always @(posedge clk) begin
        if(reset)
            out_byte_reg <= 0;
        else begin
            if(state == rec_data)
                out_byte_reg <= {out_byte_reg[6:0], in};
        end
    end
    assign out_byte = out_byte_reg;
    
endmodule"
N/A,N/A,-0.1,22.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serial
    
    parameter idle = 0, rec_data = 1, stop_bit = 2, error = 3;
    reg [2:0] state, next_state;
    
    always @(*) begin
        case (state)
            idle: begin
                if(~in)
                    next_state = rec_data;
                else
                    next_state = idle;
            end
            rec_data: begin
                if(~in)
                    next_state = stop_bit;
                else
                    next_state = rec_data;
            end
            stop_bit: begin
                if(in)
                    next_state = idle;
                else
                    next_state = error;
            end
            error: begin
                if(in)
                    next_state = idle;
                else
                    next_state = error;
            end
        endcase
    end
    
    always @(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    assign done = (state == stop_bit);
    
    // New: Datapath to latch input bits.
    reg [7:0] out_byte_reg;
    always @(posedge clk) begin
        if(reset)
            out_byte_reg <= 0;
        else begin
            if(state == rec_data)
                out_byte_reg <= {out_byte_reg[6:0], in};
        end
    end
    assign out_byte = out_byte_reg;
    
endmodule"
N/A,N/A,-0.1,23.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Use FSM from Fsm_serial

endmodule"
N/A,N/A,-1,24.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serial
    
    parameter idle = 0, rec_data = 1, stop_bit = 2, overflow = 3;
    reg [2:0] state, next_state;
    reg [3:0] count;
    reg [7:0] data;
    reg out;
    
    always @(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    always @(*) begin
        case(state)
            idle: begin
                if(~in)
                    next_state = rec_data;
                else
                    next_state = idle;
            end
            
            rec_data: begin
                if(count == 8)
                    next_state = stop_bit;
                else
                    next_state = rec_data;
            end
            
            stop_bit: begin
                if(in)
                    next_state = overflow;
                else
                    next_state = idle;
            end
            
            overflow: begin
                if(count == 8)
                    next_state = idle;
                else
                    next_state = overflow;
            end
            
            default: next_state = idle;
        endcase
    end
    
    always @(posedge clk) begin
        if(state == rec_data && count < 8)
            data[7:1] <= data[6:0];
        
        if(state == stop_bit) begin
            data[7:1] <= data[6:0];
            out_byte <= data;
            done <= 1;
        end
        else
            done <= 0;
    end
    
    always @(posedge clk) begin
        if(state == rec_data)
            count <= count + 1;
        else
            count <= 0;
    end
    
    always @(*) begin
        case(state)
            idle: begin
                out = 0;
            end
            
            rec_data: begin
                out = data[0];
            end
            
            stop_bit: begin
                out = 0;
            end
            
            overflow: begin
                out = 0;
            end
        endcase
    end
    
endmodule"
N/A,N/A,-0.1,25.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Use FSM from Fsm_serial

// New: Datapath to latch input bits.

endmodule"
N/A,N/A,-0.1,26.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serial
    // New: Datapath to latch input bits.
    
    reg [2:0] state, next_state;
    reg [7:0] out;
    reg done_reg;
    
    always @(*) begin
        done_reg <= 1'b0;
        case (state)
            3'b000: begin
                if(~in)
                    next_state = 3'b001;
                else
                    next_state = 3'b000;
            end
            3'b001: begin
                if(in)
                    next_state = 3'b010;
                else
                    next_state = 3'b000;
            end
            3'b010: begin
                if(~in)
                    next_state = 3'b011;
                else
                    next_state = 3'b010;
            end
            3'b011: begin
                if(in)
                    next_state = 3'b100;
                else
                    next_state = 3'b010;
            end
            3'b100: begin
                if(~in)
                    next_state = 3'b101;
                else
                    next_state = 3'b100;
            end
            3'b101: begin
                if(in)
                    next_state = 3'b110;
                else
                    next_state = 3'b100;
            end
            3'b110: begin
                if(~in)
                    next_state = 3'b111;
                else
                    next_state = 3'b110;
            end
            3'b111: begin
                if(in)
                    next_state = 3'b000;
                else
                    next_state = 3'b110;
            end
            default: begin
                next_state = 3'b000;
            end
        endcase
    end
    
    always @(posedge clk) begin
        if(reset) begin
            state <= 3'b000;
            out <= 8'b0;
        end
        else begin
            state <= next_state;
            case (next_state)
                3'b000: begin
                    out <= 8'b0;
                end
                3'b001: begin
                    out <= {in, out[7:1]};
                end
                3'b010: begin
                    out <= {out[6:0], in};
                end
                3'b011: begin
                    out <= {out[5:0], in};
                end
                3'b100: begin
                    out <= {out[4:0], in};
                end
                3'b101: begin
                    out <= {out[3:0], in};
                end
                3'b110: begin
                    out <= {out[2:0], in};
                end
                3'b111: begin
                    out <= {out[1:0], in};
                end
            endcase
        end
    end
    
    assign done = done_reg;
    assign out_byte = out;
    
endmodule"
N/A,N/A,-1,27.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serial
    
    // New: Latch input bits.
    
    reg [7:0] out;
    
    always @(posedge clk) begin
        if(reset)
            out <= 0;
        else begin
            out <= {out[6:0], in};
            if(out[7])
                done <= 1;
            else
                done <= 0;
        end
    end
    
    assign out_byte = out;
    
endmodule"
N/A,N/A,-1,28.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    // Use FSM from Fsm_serial
    // New: Datapath to latch input bits.
    
    reg [2:0] state;
    reg [7:0] out_byte_reg;
    reg done_reg;
    
    always @(posedge clk) begin
        if(reset) begin
            state <= 0;
            out_byte_reg <= 0;
            done_reg <= 0;
        end
        else begin
            case(state)
                3'b000: begin // Start bit detected
                    if(in) begin
                        state <= 3'b001;
                    end
                end
                3'b001: begin // 8 data bits detected
                    if(in) begin
                        state <= 3'b010;
                    end
                    else begin
                        state <= 3'b000;
                    end
                end
                3'b010: begin // Stop bit detected
                    if(in) begin
                        done_reg <= 1;
                        state <= 3'b000;
                    end
                    else begin
                        state <= 3'b000;
                    end
                end
                default: begin
                    state <= 3'b000;
                end
            endcase
        end
    end
    
    always @(posedge clk) begin
        if(reset) begin
            out_byte <= 0;
        end
        else begin
            if(done_reg) begin
                out_byte <= out_byte_reg;
            end
        end
    end
    
    assign done = done_reg;
    
    // New: Datapath to latch input bits.
    always @(posedge clk) begin
        if(reset) begin
            out_byte_reg <= 0;
        end
        else begin
            if(state == 3'b010) begin
                out_byte_reg <= {in, out_byte_reg[7:1]};
            end
        end
    end
    
endmodule"
N/A,N/A,-0.1,29.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Modify FSM and datapath from Fsm_serial

// New: Latch input bits.

endmodule"
N/A,N/A,-0.1,30.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Use FSM from Fsm_serial

// New: Datapath to latch input bits.

endmodule"
N/A,N/A,-0.1,31.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serial
    
    parameter idle = 0, rec_data = 1, stop_bit = 2, overflow = 3;
    reg [1:0] state, next_state;
    
    always @(*) begin
        case (state)
            idle: begin
                if(~in)
                    next_state = rec_data;
                else
                    next_state = idle;
            end
            rec_data: begin
                if(~in)
                    next_state = stop_bit;
                else
                    next_state = rec_data;
            end
            stop_bit: begin
                if(~in)
                    next_state = idle;
                else
                    next_state = overflow;
            end
            overflow: begin
                if(~in)
                    next_state = idle;
                else
                    next_state = overflow;
            end
        endcase
    end
    
    always @(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    assign done = (state == overflow);
    
    // New: Datapath to latch input bits.
    reg [3:0] shift_reg;
    always @(posedge clk) begin
        if(state == rec_data)
            shift_reg <= {shift_reg[2:0], in};
    end
    
    assign out_byte = shift_reg;
    
endmodule"
N/A,N/A,-0.1,32.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Use FSM from Fsm_serial

// New: Datapath to latch input bits.

endmodule"
N/A,N/A,-0.1,33.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Use FSM from Fsm_serial

// New: Datapath to latch input bits.

endmodule"
N/A,N/A,-0.1,34.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Use FSM from Fsm_serial

endmodule"
N/A,N/A,-0.1,35.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serial
    // New: Datapath to latch input bits.
    
    reg [2:0] state, next_state;
    reg [7:0] out_byte_reg;
    reg done_reg;
    
    localparam IDLE = 3'd0;
    localparam GET_BYTE = 3'd1;
    localparam DONE = 3'd2;
    
    always @(*) begin
        case (state)
            IDLE: begin
                if(~in)
                    next_state = GET_BYTE;
                else
                    next_state = IDLE;
            end
            GET_BYTE: begin
                if(in)
                    next_state = DONE;
                else
                    next_state = GET_BYTE;
            end
            DONE: begin
                if(~in)
                    next_state = IDLE;
                else
                    next_state = DONE;
            end
            default: next_state = IDLE;
        endcase
    end
    
    always @(posedge clk) begin
        if(reset) begin
            state <= IDLE;
            out_byte_reg <= 8'h00;
            done_reg <= 1'b0;
        end
        else begin
            state <= next_state;
            out_byte_reg <= out_byte;
            done_reg <= done;
        end
    end
    
    assign out_byte = out_byte_reg;
    assign done = done_reg;
    
endmodule"
N/A,N/A,-0.1,36.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serial
    // New: Datapath to latch input bits.
    
    reg [2:0] state, next_state;
    reg [7:0] out_byte_reg;
    reg done_reg;
    
    localparam IDLE = 3'd0;
    localparam GET_BYTE = 3'd1;
    localparam DONE = 3'd2;
    
    always @(*) begin
        case (state)
            IDLE: begin
                if(~in)
                    next_state = GET_BYTE;
                else
                    next_state = IDLE;
            end
            GET_BYTE: begin
                if(in)
                    next_state = DONE;
                else
                    next_state = GET_BYTE;
            end
            DONE: begin
                if(~in)
                    next_state = IDLE;
                else
                    next_state = DONE;
            end
            default: next_state = IDLE;
        endcase
    end
    
    always @(posedge clk) begin
        if(reset) begin
            state <= IDLE;
            out_byte_reg <= 8'h00;
            done_reg <= 1'b0;
        end
        else begin
            state <= next_state;
            out_byte_reg <= out_byte;
            done_reg <= done;
        end
    end
    
    assign out_byte = out_byte_reg;
    assign done = done_reg;
    
endmodule"
N/A,N/A,-0.1,37.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Use FSM from Fsm_serial

endmodule"
N/A,N/A,-1,38.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serial
    // New: Datapath to latch input bits.
    
    reg [2:0] state, next_state;
    reg [7:0] out;
    reg done_reg;
    
    always @(*) begin
        state <= next_state;
    end
    
    always @(posedge clk) begin
        if(reset) begin
            done_reg <= 0;
            out <= 0;
        end
        else begin
            if(next_state == 3)
                out <= in;
            else if(next_state == 4)
                out <= out;
            else if(next_state == 5)
                done_reg <= 1;
        end
    end
    
    always @(*) begin
        case (state)
            0: begin
                next_state <= (in)? 1:0;
                out_byte <= out;
            end
            1: begin
                next_state <= (in)? 2:0;
                out_byte <= out;
            end
            2: begin
                next_state <= (in)? 3:0;
                out_byte <= out;
            end
            3: begin
                next_state <= 0;
                out_byte <= out;
            end
            4: begin
                next_state <= 0;
                out_byte <= out;
            end
            5: begin
                next_state <= 0;
                out_byte <= out;
            end
            default: begin
                next_state <= 0;
                out_byte <= out;
            end
        endcase
    end
    
    assign done = done_reg;
    
endmodule"
N/A,N/A,-0.1,39.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serial
    
    parameter idle = 0, rec_data = 1, stop_bit = 2;
    reg [2:0] state, next_state;
    reg [7:0] rec_data_reg;
    reg [3:0] counter;
    reg out_bit;
    
    always @(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    always @(*) begin
        case(state)
            idle:
                begin
                    if(~in)
                        next_state = idle;
                    else
                        next_state = rec_data;
                end
            rec_data:
                begin
                    if(counter == 7)
                        next_state = stop_bit;
                    else
                        next_state = rec_data;
                end
            stop_bit:
                begin
                    if(in)
                        next_state = idle;
                    else
                        next_state = rec_data;
                end
            default:
                next_state = idle;
        endcase
    end
    
    always @(posedge clk) begin
        if(state == rec_data && in)
            rec_data_reg <= rec_data_reg << 1;
        else if(state == stop_bit && ~in)
            rec_data_reg <= rec_data_reg << 1;
    end
    
    assign done = (state == stop_bit);
    assign out_byte = rec_data_reg;
    
    always @(posedge clk) begin
        if(state == rec_data && counter < 7)
            counter <= counter + 1;
        else if(state == stop_bit && out_bit)
            counter <= 0;
    end
    
    always @(posedge clk) begin
        if(state == rec_data && counter < 7)
            out_bit <= rec_data_reg[0];
        else
            out_bit <= 0;
    end
    
endmodule"
N/A,N/A,-0.1,40.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serial
    // New: Datapath to latch input bits.
    
    reg [2:0] state, next_state;
    reg [7:0] out_byte_reg;
    reg done_reg;
    
    always @(*) begin
        state <= next_state;
    end
    
    always @(posedge clk) begin
        if(reset) begin
            out_byte_reg <= 0;
            done_reg <= 0;
        end
        else begin
            out_byte_reg <= out_byte;
            done_reg <= done;
        end
    end
    
    always @(*) begin
        next_state = state;
        case (state)
            3'b000: begin
                if(~in)
                    next_state = 3'b001;
            end
            3'b001: begin
                if(in)
                    next_state = 3'b010;
            end
            3'b010: begin
                if(~in)
                    next_state = 3'b011;
            end
            3'b011: begin
                if(in)
                    next_state = 3'b100;
            end
            3'b100: begin
                if(~in)
                    next_state = 3'b101;
            end
            3'b101: begin
                if(in)
                    next_state = 3'b110;
            end
            3'b110: begin
                if(~in)
                    next_state = 3'b111;
            end
            3'b111: begin
                if(in)
                    next_state = 3'b000;
            end
            default: begin
                next_state = 3'b000;
            end
        endcase
    end
    
    assign done = done_reg;
    assign out_byte = out_byte_reg;
    
endmodule"
N/A,N/A,-0.1,41.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Use FSM from Fsm_serial

// New: Datapath to latch input bits.

endmodule"
N/A,N/A,-0.1,42.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    // Use FSM from Fsm_serial
    // New: Datapath to latch input bits.
    
    parameter idle = 0, rec_data = 1, stop_bit = 2;
    reg [1:0] state, next_state;
    reg [3:0] counter;
    reg out;
    
    always @(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    always @(*) begin
        case(state)
            idle:
                begin
                    if(~in)
                        next_state = rec_data;
                    else
                        next_state = idle;
                end
            rec_data:
                begin
                    if(counter == 8)
                        next_state = stop_bit;
                    else
                        next_state = rec_data;
                end
            stop_bit:
                begin
                    if(in)
                        next_state = idle;
                    else
                        next_state = rec_data;
                end
            default:
                next_state = idle;
        endcase
    end
    
    always @(posedge clk) begin
        if(state == rec_data && counter < 8)
            counter <= counter + 1;
        else
            counter <= 0;
    end
    
    always @(posedge clk) begin
        if(state == stop_bit)
            out <= in;
    end
    
    assign done = (state == stop_bit)? 1 : 0;
    
    assign out_byte = (state == rec_data)? {out, out, out, out, out, out, out, out} : 8'b0;
    
endmodule"
N/A,N/A,-1,43.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

// Define states
localparam [2:0]
    idle = 3'd0,
    start = 3'd1,
    data = 3'd2,
    stop = 3'd3,
    last = 3'd4;

// State transition logic
reg [2:0] state_next;

always @(*) begin
    state_next = state_reg;
    case (state_reg)
        idle:
            if (in)
                state_next = start;
        start:
            if (in)
                state_next = data;
        data:
            if (in)
                state_next = data;
        stop:
            if (in)
                state_next = last;
        last:
            if (in)
                state_next = idle;
        default:
            state_next = idle;
    endcase
end

// State register
always @(posedge clk) begin
    if (reset)
        state_reg <= idle;
    else
        state_reg <= state_next;
end

// Output logic
reg [7:0] out_byte_reg;
assign done = (state_reg == last);

always @(*) begin
    if (state_reg == data)
        out_byte_reg = {in, out_byte_reg[7:1]}; // Shift in input bits
end

assign out_byte = out_byte_reg;

endmodule"
N/A,N/A,-0.1,44.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Use FSM from Fsm_serial

endmodule"
N/A,N/A,-0.1,45.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serial
    // New: Datapath to latch input bits.
    
    parameter idle = 0, rec_data = 1, stop_bit = 2;
    reg [1:0] state, next_state;
    reg [3:0] counter;
    reg [7:0] data;
    
    always @(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    always @(*) begin
        case (state)
            idle:
                begin
                    if(~in)
                        next_state = rec_data;
                    else
                        next_state = idle;
                end
            rec_data:
                begin
                    if(counter == 8)
                        next_state = stop_bit;
                    else
                        next_state = rec_data;
                end
            stop_bit:
                begin
                    if(in)
                        next_state = idle;
                    else
                        next_state = rec_data;
                end
            default:
                next_state = idle;
        endcase
    end
    
    always @(posedge clk) begin
        if(state == rec_data && in)
            counter <= counter + 4'd1;
        else if(state == stop_bit)
            counter <= 4'd0;
    end
    
    always @(posedge clk) begin
        if(state == rec_data)
            data <= {data[6:0], in};
    end
    
    assign done = (state == stop_bit) && (counter == 8);
    assign out_byte = data;
    
endmodule"
N/A,N/A,-0.1,46.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Modify FSM and datapath from Fsm_serial

// New: Latch input bits.

endmodule"
N/A,N/A,-0.1,47.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Modify FSM and datapath from Fsm_serial

// New: Latch input bits.

endmodule"
N/A,N/A,-0.1,48.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Modify FSM and datapath from Fsm_serial

// New: Latch input bits.

endmodule"
N/A,N/A,-0.1,49.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serial
    
    parameter idle = 0, rec_data = 1, stop_bit = 2;
    reg [1:0] state, next_state;
    reg [3:0] counter;
    reg out;
    
    always @(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    always @(*) begin
        case(state)
            idle: begin
                if(~in)
                    next_state = rec_data;
                else
                    next_state = idle;
            end
            rec_data: begin
                if(counter == 8)
                    next_state = stop_bit;
                else
                    next_state = rec_data;
            end
            stop_bit: begin
                if(in)
                    next_state = idle;
                else
                    next_state = rec_data;
            end
            default: next_state = idle;
        endcase
    end
    
    always @(posedge clk) begin
        if(state == rec_data && counter < 8)
            counter <= counter + 1;
        else
            counter <= 0;
    end
    
    always @(posedge clk) begin
        if(state == stop_bit)
            out <= in;
    end
    
    assign done = (state == stop_bit)? (out == 1) : 1'b0;
    
    assign out_byte = (state == rec_data)? {out, out_byte[7:1]} : 8'b0;
    
endmodule"
N/A,N/A,-0.1,50.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serial
    
    parameter idle = 0, rec_data = 1, stop_bit = 2;
    reg [1:0] state, next_state;
    reg [3:0] counter;
    reg out;
    
    always @(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    always @(*) begin
        case(state)
            idle: begin
                if(~in)
                    next_state = rec_data;
                else
                    next_state = idle;
            end
            rec_data: begin
                if(counter == 8)
                    next_state = stop_bit;
                else
                    next_state = rec_data;
            end
            stop_bit: begin
                if(in)
                    next_state = idle;
                else
                    next_state = rec_data;
            end
            default: next_state = idle;
        endcase
    end
    
    always @(posedge clk) begin
        if(state == rec_data && counter < 8)
            counter <= counter + 1;
        else
            counter <= 0;
    end
    
    always @(posedge clk) begin
        if(state == stop_bit)
            out <= in;
    end
    
    assign done = (state == stop_bit)? (out == 1) : 1'b0;
    
    assign out_byte = (state == rec_data)? {out, out_byte[7:1]} : 8'b0;
    
endmodule"
N/A,N/A,-0.1,51.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Use FSM from Fsm_serial

endmodule"
N/A,N/A,-0.1,52.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serial
    
    parameter idle = 0, rec_data = 1, stop_bit = 2;
    reg [1:0] state, next_state;
    
    always @(*) begin
        state <= next_state;
    end
    
    always @(posedge clk) begin
        if(reset)
            next_state <= idle;
        else
            begin
                case(state)
                    idle:
                        if(~in)
                            next_state <= rec_data;
                    rec_data:
                        if(~in)
                            next_state <= stop_bit;
                    stop_bit:
                        if(in)
                            next_state <= idle;
                    default:
                        next_state <= idle;
                endcase
            end
    end
    
    assign done = (state == stop_bit);
    
    // New: Datapath to latch input bits.
    
    reg [7:0] out_byte_reg;
    
    always @(posedge clk) begin
        if(state == rec_data)
            out_byte_reg <= {out_byte_reg, in};
    end
    
    assign out_byte = out_byte_reg;
    
endmodule"
N/A,N/A,-0.1,53.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    // Use FSM from Fsm_serial
    // New: Latch input bits.
    
    parameter idle = 0, rec_data = 1, stop_bit = 2;
    reg [1:0] state, next_state;
    reg [7:0] rec_data_reg;
    reg [2:0] counter;
    reg out_bit;
    
    always @(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    always @(*) begin
        case(state)
            idle: begin
                if(~in)
                    next_state = rec_data;
                else
                    next_state = idle;
            end
            
            rec_data: begin
                if(counter == 7)
                    next_state = stop_bit;
                else
                    next_state = rec_data;
            end
            
            stop_bit: begin
                if(in)
                    next_state = idle;
                else
                    next_state = rec_data;
            end
            
            default: next_state = idle;
        endcase
    end
    
    always @(posedge clk) begin
        if(state == rec_data && counter < 7)
            rec_data_reg[7-counter] <= in;
    end
    
    assign done = (state == stop_bit)? 1 : 0;
    
    assign out_byte = rec_data_reg;
    
    always @(posedge clk) begin
        if(state == rec_data && counter < 7)
            out_bit <= rec_data_reg[7-counter];
        else
            out_bit <= 0;
    end
    
    always @(posedge clk) begin
        if(state == stop_bit)
            counter <= counter + 1;
        else
            counter <= 0;
    end
    
endmodule"
N/A,N/A,-0.1,54.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serial
    // New: Datapath to latch input bits.
    
    reg [2:0] state, next_state;
    reg [7:0] out;
    reg [2:0] n_reg;
    reg out_bit;
    
    always @(*) begin
        state <= next_state;
    end
    
    always @(posedge clk) begin
        if(reset) begin
            state <= 3'b000;
            out <= 8'b0;
            n_reg <= 3'b0;
            out_bit <= 1'b0;
        end
        else begin
            // New: Latch input bits.
            out_bit <= in;
            n_reg <= n_reg + 1'b1;
            if(n_reg == 3'b111) begin
                out <= {out_bit, out[7:1]};
                n_reg <= 3'b0;
            end
        end
    end
    
    always @(state) begin
        case(state)
            3'b000: begin
                if(in)
                    next_state <= 3'b001;
                else
                    next_state <= 3'b000;
            end
            3'b001: begin
                if(in)
                    next_state <= 3'b011;
                else
                    next_state <= 3'b000;
            end
            3'b011: begin
                if(in)
                    next_state <= 3'b101;
                else
                    next_state <= 3'b000;
            end
            3'b101: begin
                if(in)
                    next_state <= 3'b110;
                else
                    next_state <= 3'b000;
            end
            3'b110: begin
                if(in)
                    next_state <= 3'b111;
                else
                    next_state <= 3'b000;
            end
            3'b111: begin
                if(in)
                    next_state <= 3'b111;
                else
                    next_state <= 3'b000;
            end
            default: begin
                next_state <= 3'b000;
            end
        endcase
    end
    
    assign done = (state == 3'b111)? 1'b1 : 1'b0;
    assign out_byte = out;
    
endmodule"
N/A,N/A,-0.1,55.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serial
    // New: Datapath to latch input bits.
    
    reg [2:0] state, next_state;
    reg [7:0] out;
    reg [2:0] n_reg;
    reg out_bit;
    
    always @(*) begin
        state <= next_state;
    end
    
    always @(posedge clk) begin
        if(reset) begin
            state <= 3'b000;
            out <= 8'b0;
            n_reg <= 3'b0;
            out_bit <= 1'b0;
        end
        else begin
            // New: Latch input bits.
            out_bit <= in;
            n_reg <= n_reg + 1'b1;
            if(n_reg == 3'b111) begin
                out <= {out_bit, out[7:1]};
                n_reg <= 3'b0;
            end
        end
    end
    
    always @(state) begin
        case(state)
            3'b000: begin
                if(in)
                    next_state <= 3'b001;
                else
                    next_state <= 3'b000;
            end
            3'b001: begin
                if(in)
                    next_state <= 3'b011;
                else
                    next_state <= 3'b000;
            end
            3'b011: begin
                if(in)
                    next_state <= 3'b101;
                else
                    next_state <= 3'b000;
            end
            3'b101: begin
                if(in)
                    next_state <= 3'b110;
                else
                    next_state <= 3'b000;
            end
            3'b110: begin
                if(in)
                    next_state <= 3'b111;
                else
                    next_state <= 3'b000;
            end
            3'b111: begin
                if(in)
                    next_state <= 3'b111;
                else
                    next_state <= 3'b000;
            end
            default: begin
                next_state <= 3'b000;
            end
        endcase
    end
    
    assign done = (state == 3'b111)? 1'b1 : 1'b0;
    assign out_byte = out;
    
endmodule"
N/A,N/A,-0.1,56.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serial
    // New: Datapath to latch input bits.
    
    reg [2:0] state, next_state;
    reg [7:0] out;
    reg [2:0] n_reg;
    reg out_bit;
    
    always @(*) begin
        state <= next_state;
    end
    
    always @(posedge clk) begin
        if(reset) begin
            state <= 3'b000;
            out <= 8'b0;
            n_reg <= 3'b0;
            out_bit <= 1'b0;
        end
        else begin
            // New: Latch input bits.
            out_bit <= in;
            n_reg <= n_reg + 1'b1;
            if(n_reg == 3'b111) begin
                out <= {out_bit, out[7:1]};
                n_reg <= 3'b0;
            end
        end
    end
    
    always @(state) begin
        case(state)
            3'b000: begin
                if(in)
                    next_state <= 3'b001;
                else
                    next_state <= 3'b000;
            end
            3'b001: begin
                if(in)
                    next_state <= 3'b011;
                else
                    next_state <= 3'b000;
            end
            3'b011: begin
                if(in)
                    next_state <= 3'b101;
                else
                    next_state <= 3'b000;
            end
            3'b101: begin
                if(in)
                    next_state <= 3'b110;
                else
                    next_state <= 3'b000;
            end
            3'b110: begin
                if(in)
                    next_state <= 3'b111;
                else
                    next_state <= 3'b000;
            end
            3'b111: begin
                if(in)
                    next_state <= 3'b111;
                else
                    next_state <= 3'b000;
            end
            default: begin
                next_state <= 3'b000;
            end
        endcase
    end
    
    assign done = (state == 3'b111)? 1'b1 : 1'b0;
    assign out_byte = out;
    
endmodule"
N/A,N/A,-0.1,57.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Use FSM from Fsm_serial

endmodule"
N/A,N/A,-0.1,58.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serial
    
    // New: Latch input bits.
    
    // State transition logic
    reg [2:0] state;
    reg [2:0] next_state;
    
    // New: Datapath to latch input bits.
    
    reg [7:0] out_byte_reg;
    
    // New: Output byte.
    
    assign done = (state == 3'd3);
    
    always @(*) begin
        case (state)
            3'd0: begin
                next_state <= (in)? 3'd1 : 3'd0;
                out_byte_reg <= (in)? 8'b11111111 : 8'b00000000;
            end
            3'd1: begin
                next_state <= (in)? 3'd2 : 3'd0;
                out_byte_reg <= (in)? 8'b11111111 : 8'b00000000;
            end
            3'd2: begin
                next_state <= (in)? 3'd3 : 3'd0;
                out_byte_reg <= (in)? 8'b11111111 : 8'b00000000;
            end
            3'd3: begin
                next_state <= (in)? 3'd3 : 3'd0;
                out_byte_reg <= (in)? 8'b11111111 : 8'b00000000;
            end
            default: begin
                next_state <= 3'd0;
                out_byte_reg <= 8'b00000000;
            end
        endcase
    end
    
    always @(posedge clk) begin
        if(reset) begin
            state <= 3'd0;
        end
        else begin
            state <= next_state;
        end
    end
    
    assign out_byte = out_byte_reg;
    
endmodule"
N/A,N/A,-0.1,59.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serial
    
    // New: Latch input bits.
    
    // State transition logic
    reg [2:0] state;
    reg [2:0] next_state;
    
    // New: Datapath to latch input bits.
    
    reg [7:0] out_byte_reg;
    
    // New: Output byte.
    
    assign done = (state == 3'd3);
    
    always @(*) begin
        case (state)
            3'd0: begin
                next_state <= (in)? 3'd1 : 3'd0;
                out_byte_reg <= (in)? 8'b11111111 : 8'b00000000;
            end
            3'd1: begin
                next_state <= (in)? 3'd2 : 3'd0;
                out_byte_reg <= (in)? 8'b11111111 : 8'b00000000;
            end
            3'd2: begin
                next_state <= (in)? 3'd3 : 3'd0;
                out_byte_reg <= (in)? 8'b11111111 : 8'b00000000;
            end
            3'd3: begin
                next_state <= (in)? 3'd3 : 3'd0;
                out_byte_reg <= (in)? 8'b11111111 : 8'b00000000;
            end
            default: begin
                next_state <= 3'd0;
                out_byte_reg <= 8'b00000000;
            end
        endcase
    end
    
    always @(posedge clk) begin
        if(reset) begin
            state <= 3'd0;
        end
        else begin
            state <= next_state;
        end
    end
    
    assign out_byte = out_byte_reg;
    
endmodule"
N/A,N/A,-0.1,60.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Use FSM from Fsm_serial

// New: Datapath to latch input bits.

endmodule"
N/A,N/A,-0.1,61.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Use FSM from Fsm_serial

// New: Datapath to latch input bits.

// Define states
localparam
    IDLE = 0,
    START_BIT = 1,
    DATA = 2,
    STOP_BIT = 3,
    DONE = 4;

// State register
reg [2:0] state;

// FSM next-state logic
reg [2:0] next_state;

// FSM output logic
reg [7:0] out_byte_reg;
reg done_reg;

// New: Datapath to latch input bits.
reg [3:0] in_reg;

// Define state transitions
always @(*) begin
    case (state)
        IDLE: begin
            if (in)
                next_state = START_BIT;
            else
                next_state = IDLE;
        end
        START_BIT: begin
            if (in)
                next_state = DATA;
            else
                next_state = IDLE;
        end
        DATA: begin
            if (in)
                next_state = DATA;
            else
                next_state = STOP_BIT;
        end
        STOP_BIT: begin
            if (in)
                next_state = DONE;
            else
                next_state = IDLE;
        end
        DONE: begin
            if (in)
                next_state = START_BIT;
            else
                next_state = IDLE;
        end
        default: next_state = IDLE;
    endcase
end

// FSM output logic
always @(posedge clk) begin
    if (reset) begin
        state <= IDLE;
        out_byte_reg <= 0;
        done_reg <= 0;
    end else begin
        state <= next_state;
        out_byte_reg <= out_byte;
        done_reg <= done;
    end
end

// New: Datapath to latch input bits.
always @(posedge clk) begin
    if (reset) begin
        in_reg <= 0;
    end else begin
        in_reg <= in;
    end
end

// New: Datapath to latch input bits.
assign out_byte = out_byte_reg;
assign done = done_reg;

endmodule"
N/A,N/A,-0.1,62.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serial
    
    // New: Datapath to latch input bits.
    
    reg [7:0] out_byte_reg;
    
    always @(posedge clk) begin
        if(reset) begin
            out_byte_reg <= 0;
        end
        else begin
            out_byte_reg <= {out_byte_reg[6:0], in};
        end
    end
    
    assign done = (out_byte_reg == ""done"");
    assign out_byte = out_byte_reg;
    
endmodule"
N/A,N/A,-0.1,63.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serial
    
    // New: Datapath to latch input bits.
    
    reg [7:0] out_byte_reg;
    
    always @(posedge clk) begin
        if(reset) begin
            out_byte_reg <= 0;
        end
        else begin
            out_byte_reg <= {out_byte_reg[6:0], in};
        end
    end
    
    assign done = (out_byte_reg == ""done"");
    assign out_byte = out_byte_reg;
    
endmodule"
N/A,N/A,-0.1,64.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serial
    // New: Datapath to latch input bits.
    
    parameter idle = 0, rec_data = 1, stop_bit = 2, error = 3;
    reg [2:0] state, next_state;
    reg [7:0] data;
    reg out;
    
    always @(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    always @(*) begin
        case(state)
            idle:
                if(~in)
                    next_state = rec_data;
                else
                    next_state = idle;
            rec_data:
                if(in)
                    next_state = stop_bit;
                else
                    next_state = rec_data;
            stop_bit:
                if(in)
                    next_state = idle;
                else
                    next_state = error;
            error:
                if(in)
                    next_state = idle;
                else
                    next_state = error;
        endcase
    end
    
    always @(posedge clk) begin
        if(state == rec_data)
            data <= {data[6:0], in};
        else if(state == stop_bit)
            out <= data[7];
    end
    
    assign done = (state == stop_bit);
    assign out_byte = out? data[7:1] : data[6:0];
    
endmodule"
N/A,N/A,-0.1,65.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Modify FSM and datapath from Fsm_serial

endmodule"
N/A,N/A,-0.1,66.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Use FSM from Fsm_serial

endmodule"
N/A,N/A,-1,67.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

reg [7:0] out_byte_reg;
reg done_reg;

always @(posedge clk) begin
    if(reset) begin
        out_byte_reg <= 0;
        done_reg <= 0;
    end
    else begin
        out_byte_reg <= out_byte_next;
        done_reg <= done_next;
    end
end

assign out_byte = out_byte_reg;
assign done = done_reg;

// New: Datapath to latch input bits.
reg [3:0] in_reg, in_next;

always @(posedge clk) begin
    if(reset) begin
        in_reg <= 0;
    end
    else begin
        in_reg <= in_next;
    end
end

always @* begin
    in_next = in_reg;
    if(in) begin
        in_next = in_reg + 1;
    end
end

// New: Datapath to latch input bits.

endmodule"
N/A,N/A,-0.1,68.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serial
    
    // New: Latch input bits.
    
    reg [2:0] state, next_state;
    reg [7:0] out_byte_reg;
    
    localparam
        IDLE = 3'd0,
        START_BIT = 3'd1,
        DATA = 3'd2,
        STOP_BIT = 3'd3,
        DONE = 3'd4;
    
    always @(*) begin
        case (state)
            IDLE: begin
                if(~in)
                    next_state = START_BIT;
                else
                    next_state = IDLE;
            end
            START_BIT: begin
                if(in)
                    next_state = DATA;
                else
                    next_state = START_BIT;
            end
            DATA: begin
                if(in)
                    next_state = DATA;
                else
                    next_state = STOP_BIT;
            end
            STOP_BIT: begin
                if(~in)
                    next_state = DONE;
                else
                    next_state = START_BIT;
            end
            DONE: begin
                if(in)
                    next_state = START_BIT;
                else
                    next_state = IDLE;
            end
            default: next_state = IDLE;
        endcase
    end
    
    always @(posedge clk) begin
        if(reset)
            state <= IDLE;
        else
            state <= next_state;
    end
    
    always @(posedge clk) begin
        if(state == DATA || state == STOP_BIT)
            out_byte_reg <= {out_byte_reg[6:0], in};
    end
    
    assign done = (state == DONE)? 1'b1 : 1'b0;
    assign out_byte = done? out_byte_reg : 8'd0;
    
endmodule"
N/A,N/A,-0.1,69.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serial
    
    // New: Datapath to latch input bits.
    
    reg [7:0] out;
    
    always @(posedge clk) begin
        if(reset)
            out <= 0;
        else begin
            if(~in)
                out <= out;
            else
                out <= {out[6:0], 1'b0};
        end
    end
    
    assign done = (out == 8'h1b)? 1:0;
    assign out_byte = out;
    
endmodule"
N/A,N/A,-0.1,70.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Use FSM from Fsm_serial

endmodule"
N/A,N/A,-0.1,71.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Use FSM from Fsm_serial

// New: Datapath to latch input bits.

endmodule"
N/A,N/A,-1,72.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serial
    
    parameter idle = 0, rec_data = 1, stop_bit = 2, overflow = 3;
    reg [1:0] state, next_state;
    reg [3:0] counter;
    reg [7:0] rec_data_reg;
    reg [2:0] rec_data_bit_idx;
    reg [7:0] out_byte_reg;
    reg out_byte_bit_idx;
    
    always @(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    always @(*) begin
        case(state)
            idle: begin
                if(~in)
                    next_state = rec_data;
                else
                    next_state = idle;
            end
            
            rec_data: begin
                if(counter == 4'd15)
                    next_state = stop_bit;
                else
                    next_state = rec_data;
            end
            
            stop_bit: begin
                if(in)
                    next_state = overflow;
                else
                    next_state = idle;
            end
            
            overflow: begin
                next_state = idle;
            end
            
            default: next_state = idle;
        endcase
    end
    
    always @(posedge clk) begin
        if(state == rec_data && counter < 4'd15) begin
            rec_data_reg[rec_data_bit_idx] <= in;
            rec_data_bit_idx <= rec_data_bit_idx + 3'd1;
        end
    end
    
    always @(posedge clk) begin
        if(state == stop_bit) begin
            counter <= 4'd0;
            rec_data_bit_idx <= 3'd0;
        end
        else if(state == overflow) begin
            out_byte_bit_idx <= 3'd0;
        end
        else if(state == idle && next_state == rec_data) begin
            counter <= counter + 4'd1;
            rec_data_bit_idx <= 3'd0;
        end
    end
    
    always @(*) begin
        if(state == rec_data && counter == 4'd15) begin
            out_byte_reg[out_byte_bit_idx] <= rec_data_reg[rec_data_bit_idx];
            out_byte_bit_idx <= out_byte_bit_idx + 3'd1;
        end
        else if(state == stop_bit) begin
            out_byte[out_byte_bit_idx] <= rec_data_reg[rec_data_bit_idx];
            out_byte_bit_idx <= 3'd0;
        end
    end
    
    assign done = (state == overflow? 1 : 0);
    
endmodule"
N/A,N/A,-0.1,73.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    // Use FSM from Fsm_serial
    // New: Datapath to latch input bits.
    
    reg [2:0] state, next_state;
    reg [7:0] out_byte_reg;
    reg done_reg;
    
    always @(*) begin
        state <= next_state;
    end
    
    always @(posedge clk) begin
        if(reset) begin
            out_byte_reg <= 0;
            done_reg <= 0;
        end
        else begin
            out_byte_reg <= out_byte;
            done_reg <= done;
        end
    end
    
    always @(*) begin
        case (state)
            3'b000: begin
                if(~in)
                    next_state = 3'b001;
                else
                    next_state = 3'b000;
            end
            3'b001: begin
                if(in)
                    next_state = 3'b010;
                else
                    next_state = 3'b001;
            end
            3'b010: begin
                if(~in)
                    next_state = 3'b011;
                else
                    next_state = 3'b010;
            end
            3'b011: begin
                if(in)
                    next_state = 3'b100;
                else
                    next_state = 3'b011;
            end
            3'b100: begin
                if(~in)
                    next_state = 3'b101;
                else
                    next_state = 3'b100;
            end
            3'b101: begin
                if(in)
                    next_state = 3'b110;
                else
                    next_state = 3'b101;
            end
            3'b110: begin
                if(~in)
                    next_state = 3'b111;
                else
                    next_state = 3'b110;
            end
            3'b111: begin
                if(in)
                    next_state = 3'b000;
                else
                    next_state = 3'b111;
            end
            default: begin
                next_state = 3'b000;
            end
        endcase
    end
    
    assign done = done_reg;
    assign out_byte = out_byte_reg;
    
endmodule"
N/A,N/A,-0.1,74.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serial
    // New: Datapath to latch input bits.
    
    parameter idle = 0, rec_data = 1, stop_bit = 2;
    reg [1:0] state, next_state;
    reg [7:0] rec_data_reg;
    reg [3:0] counter;
    
    always @(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    always @(*) begin
        case(state)
            idle:
                begin
                    if(~in)
                        next_state = rec_data;
                    else
                        next_state = idle;
                end
            rec_data:
                begin
                    if(counter == 8)
                        next_state = stop_bit;
                    else
                        next_state = rec_data;
                end
            stop_bit:
                begin
                    if(in)
                        next_state = idle;
                    else
                        next_state = rec_data;
                end
            default:
                next_state = idle;
        endcase
    end
    
    always @(posedge clk) begin
        if(state == rec_data && reset)
            rec_data_reg <= {rec_data_reg[6:0], 1'b0};
        else if(state == stop_bit && reset)
            rec_data_reg <= {rec_data_reg[6:0], 1'b1};
    end
    
    assign done = (state == stop_bit) && (counter == 8);
    assign out_byte = rec_data_reg;
    
    always @(posedge clk) begin
        if(state == rec_data && reset)
            counter <= 4'b0;
        else if(state == stop_bit && reset)
            counter <= 4'b0;
        else if(state == rec_data)
            counter <= counter + 4'b1;
    end
    
    // New: Datapath to latch input bits.
    
    // New: Parallel load of input bits to rec_data_reg
    
endmodule"
N/A,N/A,-0.1,75.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Modify FSM and datapath from Fsm_serial

// New: Latch input bits.

// New: Add parity checking.

endmodule"
N/A,N/A,-0.1,76.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Use FSM from Fsm_serial

endmodule"
N/A,N/A,-0.1,77.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serial
    // New: Datapath to latch input bits.
    
    reg [2:0] state, next_state;
    reg [7:0] out_byte_reg;
    reg done_reg;
    
    always @(*) begin
        state <= next_state;
    end
    
    always @(posedge clk) begin
        if(reset) begin
            out_byte_reg <= 0;
            done_reg <= 0;
        end
        else begin
            out_byte_reg <= out_byte;
            done_reg <= done;
        end
    end
    
    always @(*) begin
        case (state)
            3'b000: begin
                if(~in)
                    next_state = 3'b001;
                else
                    next_state = 3'b000;
            end
            3'b001: begin
                if(in)
                    next_state = 3'b010;
                else
                    next_state = 3'b001;
            end
            3'b010: begin
                if(in)
                    next_state = 3'b011;
                else
                    next_state = 3'b010;
            end
            3'b011: begin
                if(in)
                    next_state = 3'b100;
                else
                    next_state = 3'b011;
            end
            3'b100: begin
                if(~in)
                    next_state = 3'b101;
                else
                    next_state = 3'b100;
            end
            3'b101: begin
                if(in)
                    next_state = 3'b110;
                else
                    next_state = 3'b101;
            end
            3'b110: begin
                if(in)
                    next_state = 3'b111;
                else
                    next_state = 3'b110;
            end
            3'b111: begin
                if(~in)
                    next_state = 3'b000;
                else
                    next_state = 3'b111;
            end
            default: begin
                next_state = 3'b000;
            end
        endcase
    end
    
    assign done = done_reg;
    assign out_byte = out_byte_reg;
    
endmodule"
N/A,N/A,-0.1,78.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serial
    
    // New: Datapath to latch input bits.
    
    reg [7:0] out_byte_reg;
    
    always @(posedge clk) begin
        if(reset)
            out_byte_reg <= 0;
        else begin
            out_byte_reg[0] <= in;
            out_byte_reg[7:1] <= out_byte_reg[6:0];
        end
    end
    
    assign done = (out_byte_reg == ""done"")? 1 : 0;
    assign out_byte = out_byte_reg;
    
endmodule"
N/A,N/A,-0.1,79.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serial
    
    // New: Datapath to latch input bits.
    
    reg [7:0] out_byte_reg;
    
    always @(posedge clk) begin
        if(reset)
            out_byte_reg <= 0;
        else begin
            out_byte_reg[0] <= in;
            out_byte_reg[7:1] <= out_byte_reg[6:0];
        end
    end
    
    assign done = (out_byte_reg == ""done"")? 1 : 0;
    assign out_byte = out_byte_reg;
    
endmodule"
N/A,N/A,-0.1,80.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serial
    
    // New: Datapath to latch input bits.
    
    reg [7:0] out_byte_reg;
    
    always @(posedge clk) begin
        if(reset)
            out_byte_reg <= 0;
        else begin
            out_byte_reg[0] <= in;
            out_byte_reg[7:1] <= out_byte_reg[6:0];
        end
    end
    
    assign done = (out_byte_reg == ""done"")? 1 : 0;
    assign out_byte = out_byte_reg;
    
endmodule"
N/A,N/A,-0.1,81.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    // Use FSM from Fsm_serial
    // New: Datapath to latch input bits.
    
    parameter idle = 0, rec_data = 1, stop_bit = 2;
    reg [1:0] state, next_state;
    
    always @(*) begin
        state <= next_state;
    end
    
    always @(posedge clk) begin
        if(reset)
            next_state <= idle;
        else
            begin
                case (state)
                    idle:
                        if(~in)
                            next_state <= rec_data;
                    rec_data:
                        if(~in)
                            next_state <= stop_bit;
                    stop_bit:
                        if(in)
                            next_state <= idle;
                    default:
                        next_state <= idle;
                endcase
            end
    end
    
    assign done = (state == stop_bit);
    
    // New: Datapath to latch input bits.
    reg [7:0] data_reg;
    
    always @(posedge clk) begin
        if(reset)
            data_reg <= 0;
        else begin
            if(state == rec_data)
                data_reg <= {data_reg[6:0], in};
        end
    end
    
    assign out_byte = data_reg;
    
endmodule"
N/A,N/A,-0.1,82.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Use FSM from Fsm_serial

reg [2:0] state, next_state;
reg [7:0] out_byte;
reg done;

always @(*) begin
    case (state)
        3'b000: begin
            if(~in)
                next_state = 3'b001;
            else
                next_state = 3'b000;
        end
        3'b001: begin
            if(in)
                next_state = 3'b010;
            else
                next_state = 3'b000;
        end
        3'b010: begin
            if(~in)
                next_state = 3'b011;
            else
                next_state = 3'b000;
        end
        3'b011: begin
            if(in)
                next_state = 3'b100;
            else
                next_state = 3'b000;
        end
        3'b100: begin
            if(~in)
                next_state = 3'b101;
            else
                next_state = 3'b000;
        end
        3'b101: begin
            if(in)
                next_state = 3'b110;
            else
                next_state = 3'b000;
        end
        3'b110: begin
            if(~in)
                next_state = 3'b111;
            else
                next_state = 3'b000;
        end
        3'b111: begin
            if(in)
                next_state = 3'b000;
            else
                next_state = 3'b000;
        end
        default: begin
            next_state = 3'b000;
        end
    endcase
end

always @(posedge clk) begin
    if(reset) begin
        state <= 3'b000;
        done <= 1'b0;
    end
    else begin
        state <= next_state;
        done <= 1'b0;
        case (next_state)
            3'b000: begin
                out_byte <= 8'b00000000;
            end
            3'b001: begin
                out_byte <= {in, out_byte[7:1]};
            end
            3'b010: begin
                out_byte <= {out_byte[6:0], in};
            end
            3'b011: begin
                out_byte <= {out_byte[6:0], in};
            end
            3'b100: begin
                out_byte <= {out_byte[6:0], in};
            end
            3'b101: begin
                out_byte <= {out_byte[6:0], in};
            end
            3'b110: begin
                out_byte <= {out_byte[6:0], in};
            end
            3'b111: begin
                out_byte <= {out_byte[6:0], in};
            end
        endcase
    end
end

endmodule"
