Area,Delay,Score,Current Run,Episode,Verilog
N/A,N/A,-0.1,2.0,1,"//Please finish designing the 64 bit multiplier module (multiplier_64) below.
//There are two 64 bit inputs (A and B) and a 128 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_64(output [127:0] product, input [63:0] A, B);
    /* Write your code here */
    genvar i;
    generate
        for(i = 0; i < 64; i = i + 1) begin
            assign product[(i+1)*8 - 1 -: 8] = A[i]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
        end
    endgenerate
    /* Write your code here */
endmodule"
N/A,N/A,-1,3.0,1,"//Please finish designing the 64 bit multiplier module (multiplier_64) below.
//There are two 64 bit inputs (A and B) and a 128 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_64(output [127:0] product, input [63:0] A, B);
    /*
        Group Members: Kevin Ingram and Warren Seto

        Lab Name: Combinational Logic
        Project Name: eng312_proj2
        Design Name: multiplier_64bit.v
        Design Description: Verilog Module to implement a 64 bit multiplier
    */
    
    //64 bit input A and B
    
    //128 bit output product
    
    //64 bit intermediate product
    
    //32 bit intermediate A and B
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
"
30438.114,3921.99,0.1,4.0,1,"//Please finish designing the 64 bit multiplier module (multiplier_64) below.
//There are two 64 bit inputs (A and B) and a 128 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_64(output [127:0] product, input [63:0] A, B);
    /*
        Implement a 64 bit multiplier with 128 bit output.
        This implementation uses a 32 bit by 32 bit multiply and a 64 bit adder.
        Use the module below to generate the code.
    */
    assign product = A * B;
endmodule"
N/A,N/A,-1,5.0,1,"//Please finish designing the 64 bit multiplier module (multiplier_64) below.
//There are two 64 bit inputs (A and B) and a 128 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_64(output [127:0] product, input [63:0] A, B);

    /* Please fill in the implementation here... */
    genvar i;
    generate
        for (i = 0; i < 64; i = i + 1) begin: mul_digit
            assign product[(8 * i) + 7:8 * i] = mul_digit[i].mul_digit_reg[7:0];
        end
    endgenerate

    /*
    always @(A or B) begin
        //$display(""%d * %d"", A, B);
        product <= A * B;
    end
    */

endmodule"
N/A,N/A,-1,6.0,1,"//Please finish designing the 64 bit multiplier module (multiplier_64) below.
//There are two 64 bit inputs (A and B) and a 128 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_64(output [127:0] product, input [63:0] A, B);
	/* Write your code here */
	genvar i;
	generate
		for (i = 0; i < 64; i = i + 1) begin: mul_digit
			assign product[(8 * i) + 7:8 * i] = mul_digit[i].A * mul_digit[i].B;
		end
	endgenerate
	/* Write your code here */
endmodule"
N/A,N/A,-1,7.0,1,"//Please finish designing the 64 bit multiplier module (multiplier_64) below.
//There are two 64 bit inputs (A and B) and a 128 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_64(output [127:0] product, input [63:0] A, B);

	/* Please fill in the implementation here... */
	genvar i;
	generate
		for (i = 0; i < 64; i = i + 1) begin: mul_digit
			assign product[(8 * i) + 7:8 * i] = mul_digit[i].A * mul_digit[i].B;
		end
	endgenerate

endmodule"
N/A,N/A,-1,8.0,1,"//Please finish designing the 64 bit multiplier module (multiplier_64) below.
//There are two 64 bit inputs (A and B) and a 128 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_64(output [127:0] product, input [63:0] A, B);
    /* Please fill in the implementation here... */
    genvar i;
    generate
        for (i = 0; i < 64; i = i + 1) begin: mul_digit
            assign product[(8 * i) + 7:8 * i] = mul_digit[i].A * mul_digit[i].B;
        end
    endgenerate
endmodule"
N/A,N/A,-1,9.0,1,"//Please finish designing the 64 bit multiplier module (multiplier_64) below.
//There are two 64 bit inputs (A and B) and a 128 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_64(output [127:0] product, input [63:0] A, B);
    assign pp0 = A[0]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp1 = A[1]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp2 = A[2]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp3 = A[3]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp4 = A[4]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp5 = A[5]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp6 = A[6]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp7 = A[7]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp8 = A[8]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp9 = A[9]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp10 = A[10]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp11 = A[11]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp12 = A[12]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp13 = A[13]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp14 = A[14]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp15 = A[15]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp16 = A[16]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp17 = A[17]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp18 = A[18]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp19 = A[19]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp20 = A[20]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp21 = A[21]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp22 = A[22]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp23 = A[23]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp24 = A[24]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp25 = A[25]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp26 = A[26]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp27 = A[27]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp28 = A[28]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp29 = A[29]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp30 = A[30]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp31 = A[31]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp32 = A[32]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp33 = A[33]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp34 = A[34]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp35 = A[35]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp36 = A[36]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp37 = A[37]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp38 = A[38]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp39 = A[39]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp40 = A[40]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp41 = A[41]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp42 = A[42]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp43 = A[43]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp44 = A[44]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp45 = A[45]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp46 = A[46]?"
N/A,N/A,-1,10.0,1,"//Please finish designing the 64 bit multiplier module (multiplier_64) below.
//There are two 64 bit inputs (A and B) and a 128 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_64(output [127:0] product, input [63:0] A, B);

	/* Please fill in the implementation here... */
	genvar i;
	generate
		for (i = 0; i < 64; i = i + 1) begin: mul_digit
			assign product[(8 * i) + 7:8 * i] = mul_digit[i].A * mul_digit[i].B;
		end
	endgenerate

endmodule"
N/A,N/A,-1,11.0,1,"//Please finish designing the 64 bit multiplier module (multiplier_64) below.
//There are two 64 bit inputs (A and B) and a 128 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_64(output [127:0] product, input [63:0] A, B);
    /*
        Group Members: Kevin Ingram and Warren Seto

        Lab Name: Combinational Logic
        Project Name: eng312_proj2
        Design Name: multiplier_64bit.v
        Design Description: Verilog Module to implement a 64 bit multiplier
    */
    
    //64 bit input A and B
    
    //128 bit output product
    
    //64 bit intermediate product
    
    //32 bit intermediate A and B
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
"
N/A,N/A,-1,12.0,1,"//Please finish designing the 64 bit multiplier module (multiplier_64) below.
//There are two 64 bit inputs (A and B) and a 128 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_64(output [127:0] product, input [63:0] A, B);
    /*
        Implement a 64 bit multiplier with a 128 bit output. The output should be the 128 bit product of the two inputs.
        The inputs are both 64 bit numbers.
        
        For this implementation, use a 128 bit wire for the output. The first 64 bits are the high bits of the output,
        and the last 64 bits are the low bits of the output.
        
        For the final implementation, use a 128 bit wire for the output. The first 64 bits are the high bits of the output,
        and the last 64 bits are the low bits of the output.
    */
    
    /*
        Use two 64 bit multipliers (multiplier_64_1 and multiplier_64_2) to compute the product.
        Use the following algorithm:
        
        1. Use a 128 bit wire for the output of multiplier_64_1. The first 64 bits are the high bits of the output,
        and the last 64 bits are the low bits of the output.
        2. Use a 128 bit wire for the output of multiplier_64_2. The first 64 bits are the high bits of the output,
        and the last 64 bits are the low bits of the output.
        3. Use a 128 bit wire for the final output of the multiplier. The first 64 bits are the high bits of the final output,
        and the last 64 bits are the low bits of the final output.
        
        For the final implementation, use a 128 bit wire for the final output of the multiplier. The first 64 bits are the high bits of the final output,
        and the last 64 bits are the low bits of the final output.
    */
    
    /*
        Use two 64 bit multipliers (multiplier_64_1 and multiplier_64_2) to compute the product.
        Use the following algorithm:
        
        1. Use a 128 bit wire for the output of multiplier_64_1. The first 64 bits are the high bits of the output,
        and the last 64 bits are the low bits of the output.
        2. Use a 128 bit wire for the output of multiplier_64_2. The first 64 bits are the high bits of the output,
        and the last 64 bits are the low bits of the output.
        3. Use a 128 bit wire for the final output of the multiplier. The first 64 bits are the high bits of the final output,
        and the last 64 bits are the low bits of the final output.
        
        For the final implementation, use a 128 bit wire for the final output of the multiplier. The first 64 bits are the high bits of the final output,
        and the last 64 bits are the low bits of the final output.
    */
    
    /*
        Use two 64 bit multipliers (multiplier_64_1 and multiplier_64_2) to compute the product.
        Use the following algorithm:
        
        1. Use a 128 bit wire for the output of multiplier_64_1. The first 64 bits are the high bits of the output,
        and the last 64 bits are the low bits of the output.
        2. Use a 128 bit wire for the output of multiplier_64_2. The first 64 bits are the high bits of the output,
        and the last 64 bits are the low bits of the output.
        3. Use a 128 bit wire for the final output of the multiplier. The first 64 bits are the high bits of the final output,
        and the last 64 bits are the low bits of the final output.
        
        For the final implementation, use a 128 bit wire for the final output of the multiplier. The first 64 bits are the high bits of the final output,
        and the last 64 bits are the low bits of the final output.
    */
    
    /*
        Use two 64 bit multipliers (multiplier_64_1 and multiplier_64_2) to compute the product.
        Use the following algorithm:
        
        1. Use a 128 bit wire for the output of multiplier_64_1. The first 64 bits are the high bits of the output,
        and the last 64 bits are the low bits of the output.
        2. Use a 128 bit wire for the output of multiplier_64_2. The first 64 bits are the high bits of the output,
        and the last 64 bits are the low bits of the output.
        3. Use a 128 bit wire for the final output of the multiplier. The first 64 bits are the high bits of the final output,
        and the last 64 bits are the low bits of the final output.
        
        For the final implementation, use a 128 bit wire"
N/A,N/A,-1,13.0,1,"//Please finish designing the 64 bit multiplier module (multiplier_64) below.
//There are two 64 bit inputs (A and B) and a 128 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_64(output [127:0] product, input [63:0] A, B);
    /* Write your code here */
    genvar i;
    generate
        for (i = 0; i < 64; i = i + 1) begin: mul_digit
            assign product[(i+1)*8 - 1 -: 8] = mul_digit[i].A * mul_digit[i].B;
        end
    endgenerate
    /* Write your code here */
endmodule"
N/A,N/A,-1,14.0,1,"//Please finish designing the 64 bit multiplier module (multiplier_64) below.
//There are two 64 bit inputs (A and B) and a 128 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_64(output [127:0] product, input [63:0] A, B);
    /*
        Group Members: Kevin Ingram and Warren Seto
        Lab Name: Combinational Logic
        Design Name: multiplier_64bit.v
        Design Description: Verilog Module for 64 bit multiplication
    */
    
    //64 bit input A and B
    
    //128 bit output product
    
    //64 bit intermediate results
    
    //32 bit intermediate results
    
    //32 bit input A and B
    
    //32 bit output product
    
    //64 bit intermediate results
    
    //32 bit intermediate results
    
    //32 bit input A and B
    
    //32 bit output product
    
    //64 bit intermediate results
    
    //32 bit intermediate results
    
    //32 bit input A and B
    
    //32 bit output product
    
    //64 bit intermediate results
    
    //32 bit intermediate results
    
    //32 bit input A and B
    
    //32 bit output product
    
    //64 bit intermediate results
    
    //32 bit intermediate results
    
    //32 bit input A and B
    
    //32 bit output product
    
    //64 bit intermediate results
    
    //32 bit intermediate results
    
    //32 bit input A and B
    
    //32 bit output product
    
    //64 bit intermediate results
    
    //32 bit intermediate results
    
    //32 bit input A and B
    
    //32 bit output product
    
    //64 bit intermediate results
    
    //32 bit intermediate results
    
    //32 bit input A and B
    
    //32 bit output product
    
    //64 bit intermediate results
    
    //32 bit intermediate results
    
    //32 bit input A and B
    
    //32 bit output product
    
    //64 bit intermediate results
    
    //32 bit intermediate results
    
    //32 bit input A and B
    
    //32 bit output product
    
    //64 bit intermediate results
    
    //32 bit intermediate results
    
    //32 bit input A and B
    
    //32 bit output product
    
    //64 bit intermediate results
    
    //32 bit intermediate results
    
    //32 bit input A and B
    
    //32 bit output product
    
    //64 bit intermediate results
    
    //32 bit intermediate results
    
    //32 bit input A and B
    
    //32 bit output product
    
    //64 bit intermediate results
    
    //32 bit intermediate results
    
    //32 bit input A and B
    
    //32 bit output product
    
    //64 bit intermediate results
    
    //32 bit intermediate results
    
    //32 bit input A and B
    
    //32 bit output product
    
    //64 bit intermediate results
    
    //32 bit intermediate results
    
    //32 bit input A and B
    
    //32 bit output product
    
    //64 bit intermediate results
    
    //32 bit intermediate results
    
    //32 bit input A and B
    
    //32 bit output product
    
    //64 bit intermediate results
    
    //32 bit intermediate results
    
    //32 bit input A and B
    
    //32 bit output product
    
    //64 bit intermediate results
    
    //32 bit intermediate results
    
    //32 bit input A and B
    
    //32 bit output product
    
    //64 bit intermediate results
    
    //32 bit intermediate results
    
    //32 bit input A and B
    
    //32 bit output product
    
    //64 bit intermediate results
    
    //32 bit intermediate results
    
    //32 bit input A and B
    
    //32 bit output product
    
    //64 bit intermediate results
    
    //32 bit intermediate results
    
    //32 bit input A and B
    
    //32 bit output product
    
    //64 bit intermediate results
    
    //32 bit intermediate results
    
    //32 bit input A and B
    
    //32 bit output product
    
    //64 bit intermediate results
    
    //32 bit intermediate results
    
    //32 bit input A and B
    
    //32 bit output product
    
    //64 bit intermediate results
    
    //32 bit intermediate results
    
    //32 bit input A and B
    
    //32 bit output product
    
    "
N/A,N/A,-1,15.0,1,"//Please finish designing the 64 bit multiplier module (multiplier_64) below.
//There are two 64 bit inputs (A and B) and a 128 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_64(output [127:0] product, input [63:0] A, B);

    /* Please fill in the implementation here... */
    genvar i;
    generate
        for (i = 0; i < 64; i = i + 1) begin: mul_digit
            assign product[(8 * i) + 7:8 * i] = mul_digit[i].mul_digit_reg[7:0];
        end
    endgenerate

    /*
    always @(A or B) begin
        //$display(""%d * %d"", A, B);
        product <= A * B;
    end
    */

endmodule"
N/A,N/A,-1,16.0,1,"//Please finish designing the 64 bit multiplier module (multiplier_64) below.
//There are two 64 bit inputs (A and B) and a 128 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_64(output [127:0] product, input [63:0] A, B);
	/* Write your code here */
	genvar i;
	generate
		for (i = 0; i < 64; i = i + 1) begin: mul_digit
			assign product[(8 * i) + 7:8 * i] = mul_digit[i].A * mul_digit[i].B;
		end
	endgenerate
	/* Write your code here */
endmodule"
N/A,N/A,-1,17.0,1,"//Please finish designing the 64 bit multiplier module (multiplier_64) below.
//There are two 64 bit inputs (A and B) and a 128 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_64(output [127:0] product, input [63:0] A, B);

	/* Please fill in the implementation here... */
	genvar i;
	generate
		for (i = 0; i < 64; i = i + 1) begin: mul_digit
			assign product[(8 * i) + 7:8 * i] = mul_digit[i].A * mul_digit[i].B;
		end
	endgenerate

endmodule"
N/A,N/A,-1,18.0,1,"//Please finish designing the 64 bit multiplier module (multiplier_64) below.
//There are two 64 bit inputs (A and B) and a 128 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_64(output [127:0] product, input [63:0] A, B);
    /* Please fill in the implementation here... */
    genvar i;
    generate
        for (i = 0; i < 64; i = i + 1) begin: mul_digit
            assign product[(8 * i) + 7:8 * i] = mul_digit[i].A * mul_digit[i].B;
        end
    endgenerate
endmodule"
N/A,N/A,-1,19.0,1,"//Please finish designing the 64 bit multiplier module (multiplier_64) below.
//There are two 64 bit inputs (A and B) and a 128 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_64(output [127:0] product, input [63:0] A, B);
    assign pp0 = A[0]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp1 = A[1]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp2 = A[2]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp3 = A[3]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp4 = A[4]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp5 = A[5]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp6 = A[6]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp7 = A[7]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp8 = A[8]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp9 = A[9]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp10 = A[10]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp11 = A[11]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp12 = A[12]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp13 = A[13]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp14 = A[14]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp15 = A[15]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp16 = A[16]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp17 = A[17]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp18 = A[18]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp19 = A[19]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp20 = A[20]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp21 = A[21]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp22 = A[22]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp23 = A[23]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp24 = A[24]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp25 = A[25]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp26 = A[26]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp27 = A[27]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp28 = A[28]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp29 = A[29]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp30 = A[30]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp31 = A[31]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp32 = A[32]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp33 = A[33]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp34 = A[34]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp35 = A[35]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp36 = A[36]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp37 = A[37]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp38 = A[38]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp39 = A[39]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp40 = A[40]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp41 = A[41]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp42 = A[42]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp43 = A[43]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp44 = A[44]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp45 = A[45]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp46 = A[46]?"
N/A,N/A,-1,20.0,1,"//Please finish designing the 64 bit multiplier module (multiplier_64) below.
//There are two 64 bit inputs (A and B) and a 128 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_64(output [127:0] product, input [63:0] A, B);

	/* Please fill in the implementation here... */
	genvar i;
	generate
		for (i = 0; i < 64; i = i + 1) begin: mul_digit
			assign product[(8 * i) + 7:8 * i] = mul_digit[i].A * mul_digit[i].B;
		end
	endgenerate

endmodule"
N/A,N/A,-1,21.0,1,"//Please finish designing the 64 bit multiplier module (multiplier_64) below.
//There are two 64 bit inputs (A and B) and a 128 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_64(output [127:0] product, input [63:0] A, B);
    /*
        Group Members: Kevin Ingram and Warren Seto

        Lab Name: Combinational Logic
        Project Name: eng312_proj2
        Design Name: multiplier_64bit.v
        Design Description: Verilog Module to implement a 64 bit multiplier
    */
    
    //64 bit input A and B
    
    //128 bit output product
    
    //64 bit intermediate product
    
    //32 bit intermediate A and B
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
"
30438.114,3921.99,0.1,22.0,1,"//Please finish designing the 64 bit multiplier module (multiplier_64) below.
//There are two 64 bit inputs (A and B) and a 128 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_64(output [127:0] product, input [63:0] A, B);
    /*
        Implement a 64 bit multiplier with a 128 bit output.
        The output should be equal to (A * B)
    */
    assign product = A * B;
endmodule"
N/A,N/A,-0.1,23.0,1,"//Please finish designing the 64 bit multiplier module (multiplier_64) below.
//There are two 64 bit inputs (A and B) and a 128 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_64(output [127:0] product, input [63:0] A, B);
    /* Write your code here */
    genvar i;
    generate
        for(i = 0; i < 64; i = i + 1) begin
            assign product[(i+1)*8 - 1 -: 8] = A[i]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
        end
    endgenerate
    /* Write your code here */
endmodule"
N/A,N/A,-1,24.0,1,"//Please finish designing the 64 bit multiplier module (multiplier_64) below.
//There are two 64 bit inputs (A and B) and a 128 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_64(output [127:0] product, input [63:0] A, B);
    /*
        Group Members: Kevin Ingram and Warren Seto
        Lab Name: Combinational Logic
        Design Name: multiplier_64bit.v
        Design Description: Verilog Module for 64 bit multiplication
    */
    
    //64 bit input A and B
    
    //128 bit output product
    
    //64 bit intermediate results
    
    //32 bit intermediate results
    
    //32 bit input A and B
    
    //32 bit output product
    
    //64 bit intermediate results
    
    //32 bit intermediate results
    
    //32 bit input A and B
    
    //32 bit output product
    
    //64 bit intermediate results
    
    //32 bit intermediate results
    
    //32 bit input A and B
    
    //32 bit output product
    
    //64 bit intermediate results
    
    //32 bit intermediate results
    
    //32 bit input A and B
    
    //32 bit output product
    
    //64 bit intermediate results
    
    //32 bit intermediate results
    
    //32 bit input A and B
    
    //32 bit output product
    
    //64 bit intermediate results
    
    //32 bit intermediate results
    
    //32 bit input A and B
    
    //32 bit output product
    
    //64 bit intermediate results
    
    //32 bit intermediate results
    
    //32 bit input A and B
    
    //32 bit output product
    
    //64 bit intermediate results
    
    //32 bit intermediate results
    
    //32 bit input A and B
    
    //32 bit output product
    
    //64 bit intermediate results
    
    //32 bit intermediate results
    
    //32 bit input A and B
    
    //32 bit output product
    
    //64 bit intermediate results
    
    //32 bit intermediate results
    
    //32 bit input A and B
    
    //32 bit output product
    
    //64 bit intermediate results
    
    //32 bit intermediate results
    
    //32 bit input A and B
    
    //32 bit output product
    
    //64 bit intermediate results
    
    //32 bit intermediate results
    
    //32 bit input A and B
    
    //32 bit output product
    
    //64 bit intermediate results
    
    //32 bit intermediate results
    
    //32 bit input A and B
    
    //32 bit output product
    
    //64 bit intermediate results
    
    //32 bit intermediate results
    
    //32 bit input A and B
    
    //32 bit output product
    
    //64 bit intermediate results
    
    //32 bit intermediate results
    
    //32 bit input A and B
    
    //32 bit output product
    
    //64 bit intermediate results
    
    //32 bit intermediate results
    
    //32 bit input A and B
    
    //32 bit output product
    
    //64 bit intermediate results
    
    //32 bit intermediate results
    
    //32 bit input A and B
    
    //32 bit output product
    
    //64 bit intermediate results
    
    //32 bit intermediate results
    
    //32 bit input A and B
    
    //32 bit output product
    
    //64 bit intermediate results
    
    //32 bit intermediate results
    
    //32 bit input A and B
    
    //32 bit output product
    
    //64 bit intermediate results
    
    //32 bit intermediate results
    
    //32 bit input A and B
    
    //32 bit output product
    
    //64 bit intermediate results
    
    //32 bit intermediate results
    
    //32 bit input A and B
    
    //32 bit output product
    
    //64 bit intermediate results
    
    //32 bit intermediate results
    
    //32 bit input A and B
    
    //32 bit output product
    
    //64 bit intermediate results
    
    //32 bit intermediate results
    
    //32 bit input A and B
    
    //32 bit output product
    
    //64 bit intermediate results
    
    //32 bit intermediate results
    
    //32 bit input A and B
    
    //32 bit output product
    
    //64 bit intermediate results
    
    //32 bit intermediate results
    
    //32 bit input A and B
    
    //32 bit output product
    
    "
N/A,N/A,-1,25.0,1,"//Please finish designing the 64 bit multiplier module (multiplier_64) below.
//There are two 64 bit inputs (A and B) and a 128 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_64(output [127:0] product, input [63:0] A, B);

    /* Please fill in the implementation here... */
    genvar i;
    generate
        for (i = 0; i < 64; i = i + 1) begin: mul_digit
            assign product[(8 * i) + 7:8 * i] = mul_digit[i].mul_digit_reg[7:0];
        end
    endgenerate

    /*
    always @(A or B) begin
        //$display(""%d * %d"", A, B);
        product <= A * B;
    end
    */

endmodule"
N/A,N/A,-1,26.0,1,"//Please finish designing the 64 bit multiplier module (multiplier_64) below.
//There are two 64 bit inputs (A and B) and a 128 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_64(output [127:0] product, input [63:0] A, B);
	/* Write your code here */
	genvar i;
	generate
		for(i=0; i<64; i=i+1) begin
			assign product[i] = A[i] & B[0];
			assign product[i+64] = A[i] & B[1];
			assign product[i+128] = A[i] & B[2];
			assign product[i+192] = A[i] & B[3];
			assign product[i+256] = A[i] & B[4];
			assign product[i+320] = A[i] & B[5];
			assign product[i+384] = A[i] & B[6];
			assign product[i+448] = A[i] & B[7];
			assign product[i+512] = A[i] & B[8];
			assign product[i+576] = A[i] & B[9];
			assign product[i+640] = A[i] & B[10];
			assign product[i+704] = A[i] & B[11];
			assign product[i+768] = A[i] & B[12];
			assign product[i+832] = A[i] & B[13];
			assign product[i+896] = A[i] & B[14];
			assign product[i+960] = A[i] & B[15];
			assign product[i+1024] = A[i] & B[16];
			assign product[i+1088] = A[i] & B[17];
			assign product[i+1152] = A[i] & B[18];
			assign product[i+1216] = A[i] & B[19];
			assign product[i+1280] = A[i] & B[20];
			assign product[i+1344] = A[i] & B[21];
			assign product[i+1408] = A[i] & B[22];
			assign product[i+1472] = A[i] & B[23];
			assign product[i+1536] = A[i] & B[24];
			assign product[i+1600] = A[i] & B[25];
			assign product[i+1664] = A[i] & B[26];
			assign product[i+1728] = A[i] & B[27];
			assign product[i+1792] = A[i] & B[28];
			assign product[i+1856] = A[i] & B[29];
			assign product[i+1920] = A[i] & B[30];
			assign product[i+1984] = A[i] & B[31];
		end
	endgenerate
	/* Write your code here */
endmodule"
N/A,N/A,-1,27.0,1,"//Please finish designing the 64 bit multiplier module (multiplier_64) below.
//There are two 64 bit inputs (A and B) and a 128 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_64(output [127:0] product, input [63:0] A, B);

	/* Please fill in the implementation here... */
	genvar i;
	generate
		for (i = 0; i < 64; i = i + 1) begin: mul_digit
			assign product[(8 * i) + 7:8 * i] = mul_digit[i].A * mul_digit[i].B;
		end
	endgenerate

endmodule"
N/A,N/A,-1,28.0,1,"//Please finish designing the 64 bit multiplier module (multiplier_64) below.
//There are two 64 bit inputs (A and B) and a 128 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_64(output [127:0] product, input [63:0] A, B);
    /* Please fill in the implementation here... */
    genvar i;
    generate
        for (i = 0; i < 64; i = i + 1) begin: mul_digit
            assign product[(8 * i) + 7:8 * i] = mul_digit[i].A * mul_digit[i].B;
        end
    endgenerate
endmodule"
N/A,N/A,-1,29.0,1,"//Please finish designing the 64 bit multiplier module (multiplier_64) below.
//There are two 64 bit inputs (A and B) and a 128 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_64(output [127:0] product, input [63:0] A, B);
    assign pp0 = A[0]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp1 = A[1]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp2 = A[2]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp3 = A[3]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp4 = A[4]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp5 = A[5]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp6 = A[6]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp7 = A[7]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp8 = A[8]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp9 = A[9]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp10 = A[10]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp11 = A[11]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp12 = A[12]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp13 = A[13]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp14 = A[14]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp15 = A[15]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp16 = A[16]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp17 = A[17]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp18 = A[18]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp19 = A[19]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp20 = A[20]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp21 = A[21]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp22 = A[22]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp23 = A[23]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp24 = A[24]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp25 = A[25]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp26 = A[26]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp27 = A[27]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp28 = A[28]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp29 = A[29]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp30 = A[30]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp31 = A[31]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp32 = A[32]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp33 = A[33]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp34 = A[34]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp35 = A[35]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp36 = A[36]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp37 = A[37]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp38 = A[38]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp39 = A[39]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp40 = A[40]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp41 = A[41]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp42 = A[42]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp43 = A[43]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp44 = A[44]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp45 = A[45]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp46 = A[46]?"
N/A,N/A,-1,30.0,1,"//Please finish designing the 64 bit multiplier module (multiplier_64) below.
//There are two 64 bit inputs (A and B) and a 128 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_64(output [127:0] product, input [63:0] A, B);

	/* Please fill in the implementation here... */
	genvar i;
	generate
		for (i = 0; i < 64; i = i + 1) begin: mul_digit
			assign product[(8 * i) + 7:8 * i] = mul_digit[i].A * mul_digit[i].B;
		end
	endgenerate

endmodule"
N/A,N/A,-1,31.0,1,"//Please finish designing the 64 bit multiplier module (multiplier_64) below.
//There are two 64 bit inputs (A and B) and a 128 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_64(output [127:0] product, input [63:0] A, B);
    /*
        Group Members: Kevin Ingram and Warren Seto
        Lab Name: Combinational Logic
        Design Name: multiplier_64bit.v
        Design Description: Verilog Module for 64 bit multiplication
    */
    
    //64 bit input A and B
    
    //128 bit output product
    
    //64 bit intermediate results
    
    //32 bit intermediate results
    
    //32 bit input A and B
    
    //32 bit output product
    
    //64 bit intermediate results
    
    //32 bit intermediate results
    
    //32 bit input A and B
    
    //32 bit output product
    
    //64 bit intermediate results
    
    //32 bit intermediate results
    
    //32 bit input A and B
    
    //32 bit output product
    
    //64 bit intermediate results
    
    //32 bit intermediate results
    
    //32 bit input A and B
    
    //32 bit output product
    
    //64 bit intermediate results
    
    //32 bit intermediate results
    
    //32 bit input A and B
    
    //32 bit output product
    
    //64 bit intermediate results
    
    //32 bit intermediate results
    
    //32 bit input A and B
    
    //32 bit output product
    
    //64 bit intermediate results
    
    //32 bit intermediate results
    
    //32 bit input A and B
    
    //32 bit output product
    
    //64 bit intermediate results
    
    //32 bit intermediate results
    
    //32 bit input A and B
    
    //32 bit output product
    
    //64 bit intermediate results
    
    //32 bit intermediate results
    
    //32 bit input A and B
    
    //32 bit output product
    
    //64 bit intermediate results
    
    //32 bit intermediate results
    
    //32 bit input A and B
    
    //32 bit output product
    
    //64 bit intermediate results
    
    //32 bit intermediate results
    
    //32 bit input A and B
    
    //32 bit output product
    
    //64 bit intermediate results
    
    //32 bit intermediate results
    
    //32 bit input A and B
    
    //32 bit output product
    
    //64 bit intermediate results
    
    //32 bit intermediate results
    
    //32 bit input A and B
    
    //32 bit output product
    
    //64 bit intermediate results
    
    //32 bit intermediate results
    
    //32 bit input A and B
    
    //32 bit output product
    
    //64 bit intermediate results
    
    //32 bit intermediate results
    
    //32 bit input A and B
    
    //32 bit output product
    
    //64 bit intermediate results
    
    //32 bit intermediate results
    
    //32 bit input A and B
    
    //32 bit output product
    
    //64 bit intermediate results
    
    //32 bit intermediate results
    
    //32 bit input A and B
    
    //32 bit output product
    
    //64 bit intermediate results
    
    //32 bit intermediate results
    
    //32 bit input A and B
    
    //32 bit output product
    
    //64 bit intermediate results
    
    //32 bit intermediate results
    
    //32 bit input A and B
    
    //32 bit output product
    
    //64 bit intermediate results
    
    //32 bit intermediate results
    
    //32 bit input A and B
    
    //32 bit output product
    
    //64 bit intermediate results
    
    //32 bit intermediate results
    
    //32 bit input A and B
    
    //32 bit output product
    
    //64 bit intermediate results
    
    //32 bit intermediate results
    
    //32 bit input A and B
    
    //32 bit output product
    
    //64 bit intermediate results
    
    //32 bit intermediate results
    
    //32 bit input A and B
    
    //32 bit output product
    
    //64 bit intermediate results
    
    //32 bit intermediate results
    
    //32 bit input A and B
    
    //32 bit output product
    
    //64 bit intermediate results
    
    //32 bit intermediate results
    
    //32 bit input A and B
    
    //32 bit output product
    
    "
N/A,N/A,-1,32.0,1,"//Please finish designing the 64 bit multiplier module (multiplier_64) below.
//There are two 64 bit inputs (A and B) and a 128 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_64(output [127:0] product, input [63:0] A, B);
    /*
        Implement a 64 bit multiplier with the following algorithm:
        
        For each bit in the input, multiply the bit by the bit on the right.
        Store the resulting 64 bit value in the current spot in the array.
        Move to the next spot in the array.
        
        Example:
        
        A = 10011011
        B = 00100011
        
        product = 010110101011001101000000000000
        
        In this example, the first bit is multiplied by the first bit (10011011 * 00100011)
        which results in 010110101011001101000000000000
        
        The next bit is multiplied by the second bit (010110101011001101000000000000)
        which results in 010110101011001101000000000000
        
        The next bit is multiplied by the third bit (010110101011001101000000000000)
        which results in 010110101011001101000000000000
        
        The next bit is multiplied by the fourth bit (010110101011001101000000000000)
        which results in 010110101011001101000000000000
        
        The next bit is multiplied by the fifth bit (010110101011001101000000000000)
        which results in 010110101011001101000000000000
        
        The next bit is multiplied by the sixth bit (010110101011001101000000000000)
        which results in 010110101011001101000000000000
        
        The next bit is multiplied by the seventh bit (010110101011001101000000000000)
        which results in 010110101011001101000000000000
        
        The next bit is multiplied by the eighth bit (010110101011001101000000000000)
        which results in 010110101011001101000000000000
        
        The next bit is multiplied by the ninth bit (010110101011001101000000000000)
        which results in 010110101011001101000000000000
        
        The next bit is multiplied by the tenth bit (010110101011001101000000000000)
        which results in 010110101011001101000000000000
        
        The next bit is multiplied by the eleventh bit (010110101011001101000000000000)
        which results in 010110101011001101000000000000
        
        The next bit is multiplied by the twelfth bit (010110101011001101000000000000)
        which results in 010110101011001101000000000000
        
        The next bit is multiplied by the thirteenth bit (010110101011001101000000000000)
        which results in 010110101011001101000000000000
        
        The next bit is multiplied by the fourteenth bit (010110101011001101000000000000)
        which results in 010110101011001101000000000000
        
        The next bit is multiplied by the fifteenth bit (010110101011001101000000000000)
        which results in 010110101011001101000000000000
        
        The next bit is multiplied by the sixteenth bit (010110101011001101000000000000)
        which results in 010110101011001101000000000000
        
        The next bit is multiplied by the seventeenth bit (010110101011001101000000000000)
        which results in 010110101011001101000000000000
        
        The next bit is multiplied by the eighteenth bit (010110101011001101000000000000)
        which results in 010110101011001101000000000000
        
        The next bit is multiplied by the nineteenth bit (010110101011001101000000000000)
        which results in 010110101011001101000000000000
        
        The next bit is multiplied by the twentieth bit (010110101011001101000000000000)
        which results in 010110101011001101000000000000
        
        The next bit is multiplied by the twenty-first bit (010110101011001101000000000000)
        which results in 010110101011001101000000000000
        
        The next bit is multiplied by the twenty-second bit (010110101011001101000000000000)
        which results in 010110101011001101000000000000
        
        The next bit is multiplied by the twenty-third bit (010110101011001101000000000000)
        "
N/A,N/A,-0.1,33.0,1,"//Please finish designing the 64 bit multiplier module (multiplier_64) below.
//There are two 64 bit inputs (A and B) and a 128 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_64(output [127:0] product, input [63:0] A, B);
    /* Write your code here */
    genvar i;
    generate
        for(i = 0; i < 64; i = i + 1) begin
            assign product[(i+1)*8 - 1 -: 8] = A[i]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
        end
    endgenerate
    /* Write your code here */
endmodule"
N/A,N/A,-1,34.0,1,"//Please finish designing the 64 bit multiplier module (multiplier_64) below.
//There are two 64 bit inputs (A and B) and a 128 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_64(output [127:0] product, input [63:0] A, B);
    /* Write your code here */
    genvar i;
    generate
        for (i = 0; i < 64; i = i + 1) begin: mul_digit
            assign product[(i+1)*8 - 1 -: 8] = mul_digit[i].A * mul_digit[i].B;
        end
    endgenerate
    /* Write your code here */
endmodule"
N/A,N/A,-1,35.0,1,"//Please finish designing the 64 bit multiplier module (multiplier_64) below.
//There are two 64 bit inputs (A and B) and a 128 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_64(output [127:0] product, input [63:0] A, B);
    /*
        Group Members: Kevin Ingram and Warren Seto
        Lab Name: Combinational Circuit Design
        Design Name: multiplier_64bit
        Design Description: Verilog Module for 64 bit multiplication
    */
    
    //64 bit input A and B
    
    //128 bit output product
    
    //64 bit intermediate product
    
    //32 bit intermediate A and B
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate"
N/A,N/A,-1,36.0,1,"//Please finish designing the 64 bit multiplier module (multiplier_64) below.
//There are two 64 bit inputs (A and B) and a 128 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_64(output [127:0] product, input [63:0] A, B);

    /* Please fill in the implementation here... */
    genvar i;
    generate
        for (i = 0; i < 64; i = i + 1) begin: mul_digit
            assign product[(8 * i) + 7:8 * i] = mul_digit[i].mul_digit_reg[7:0];
        end
    endgenerate

    /*
    always @(A or B) begin
        //$display(""%d * %d"", A, B);
        product <= A * B;
    end
    */

endmodule"
N/A,N/A,-0.1,37.0,1,"//Please finish designing the 64 bit multiplier module (multiplier_64) below.
//There are two 64 bit inputs (A and B) and a 128 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_64(output [127:0] product, input [63:0] A, B);
	/* Write your code here */
	genvar i;
	generate
		for(i = 0; i < 64; i = i + 1) begin
			assign product[(i+1)*8-1:i*8] = A[i]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
		end
	endgenerate
	/* Write your code here */
endmodule"
N/A,N/A,-1,38.0,1,"//Please finish designing the 64 bit multiplier module (multiplier_64) below.
//There are two 64 bit inputs (A and B) and a 128 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_64(output [127:0] product, input [63:0] A, B);

	/* Please fill in the implementation here... */
	genvar i;
	generate
		for (i = 0; i < 64; i = i + 1) begin: mul_digit
			assign product[(8 * i) + 7:8 * i] = mul_digit[i].A * mul_digit[i].B;
		end
	endgenerate

endmodule"
N/A,N/A,-1,39.0,1,"//Please finish designing the 64 bit multiplier module (multiplier_64) below.
//There are two 64 bit inputs (A and B) and a 128 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_64(output [127:0] product, input [63:0] A, B);
    /* Please fill in the implementation here... */
    genvar i;
    generate
        for (i = 0; i < 64; i = i + 1) begin: mul_digit
            assign product[(8 * i) + 7:8 * i] = mul_digit[i].A * mul_digit[i].B;
        end
    endgenerate
endmodule"
N/A,N/A,-1,40.0,1,"//Please finish designing the 64 bit multiplier module (multiplier_64) below.
//There are two 64 bit inputs (A and B) and a 128 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_64(output [127:0] product, input [63:0] A, B);
    assign pp0 = A[0]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp1 = A[1]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp2 = A[2]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp3 = A[3]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp4 = A[4]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp5 = A[5]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp6 = A[6]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp7 = A[7]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp8 = A[8]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp9 = A[9]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp10 = A[10]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp11 = A[11]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp12 = A[12]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp13 = A[13]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp14 = A[14]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp15 = A[15]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp16 = A[16]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp17 = A[17]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp18 = A[18]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp19 = A[19]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp20 = A[20]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp21 = A[21]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp22 = A[22]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp23 = A[23]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp24 = A[24]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp25 = A[25]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp26 = A[26]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp27 = A[27]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp28 = A[28]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp29 = A[29]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp30 = A[30]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp31 = A[31]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp32 = A[32]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp33 = A[33]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp34 = A[34]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp35 = A[35]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp36 = A[36]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp37 = A[37]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp38 = A[38]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp39 = A[39]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp40 = A[40]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp41 = A[41]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp42 = A[42]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp43 = A[43]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp44 = A[44]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp45 = A[45]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp46 = A[46]?"
N/A,N/A,-1,41.0,1,"//Please finish designing the 64 bit multiplier module (multiplier_64) below.
//There are two 64 bit inputs (A and B) and a 128 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_64(output [127:0] product, input [63:0] A, B);

	/* Please fill in the implementation here... */
	genvar i;
	generate
		for (i = 0; i < 64; i = i + 1) begin: mul_digit
			assign product[(8 * i) + 7:8 * i] = mul_digit[i].A * mul_digit[i].B;
		end
	endgenerate

endmodule"
N/A,N/A,-1,42.0,1,"//Please finish designing the 64 bit multiplier module (multiplier_64) below.
//There are two 64 bit inputs (A and B) and a 128 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_64(output [127:0] product, input [63:0] A, B);
    /*
        Group Members: Kevin Ingram and Warren Seto
        Lab Name: Combinational Circuit Design
        Design Name: multiplier_64bit
        Design Description: Verilog Module for 64 bit multiplication
    */
    
    //64 bit input A and B
    
    //128 bit output product
    
    //64 bit intermediate product
    
    //32 bit intermediate A and B
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate"
30438.114,3921.99,0.1,43.0,1,"//Please finish designing the 64 bit multiplier module (multiplier_64) below.
//There are two 64 bit inputs (A and B) and a 128 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_64(output [127:0] product, input [63:0] A, B);
    /*
        Implement a 64 bit multiplier with 128 bit output.
        This implementation uses a 32 bit by 32 bit multiply and a 64 bit adder.
        Use the module below to generate the code.
    */
    assign product = A * B;
endmodule"
N/A,N/A,-0.1,44.0,1,"//Please finish designing the 64 bit multiplier module (multiplier_64) below.
//There are two 64 bit inputs (A and B) and a 128 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_64(output [127:0] product, input [63:0] A, B);
    /*
        Implement a 64 bit multiplier with a 128 bit output.
        The output should be the same as the following:
        assign product = A * B;
    */
    assign product[63:0] = A * B;
    assign product[127:64] = 0;
endmodule"
N/A,N/A,-1,45.0,1,"//Please finish designing the 64 bit multiplier module (multiplier_64) below.
//There are two 64 bit inputs (A and B) and a 128 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_64(output [127:0] product, input [63:0] A, B);
	/* Write your code here */
	genvar i;
	generate
		for (i = 0; i < 64; i = i + 1) begin: mul_digit
			assign product[(8 * i) + 7:8 * i] = mul_digit[i].A * mul_digit[i].B;
		end
	endgenerate
	/* Write your code here */
endmodule"
N/A,N/A,-1,46.0,1,"//Please finish designing the 64 bit multiplier module (multiplier_64) below.
//There are two 64 bit inputs (A and B) and a 128 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_64(output [127:0] product, input [63:0] A, B);
    /* Write your code here */
    genvar i;
    generate
        for(i=0; i<64; i=i+1) begin
            assign product[i] = A[i] & B[0];
            assign product[i+64] = A[i] & B[1];
            assign product[i+128] = A[i] & B[2];
            assign product[i+192] = A[i] & B[3];
            assign product[i+256] = A[i] & B[4];
            assign product[i+320] = A[i] & B[5];
            assign product[i+384] = A[i] & B[6];
            assign product[i+448] = A[i] & B[7];
            assign product[i+512] = A[i] & B[8];
            assign product[i+576] = A[i] & B[9];
            assign product[i+640] = A[i] & B[10];
            assign product[i+704] = A[i] & B[11];
            assign product[i+768] = A[i] & B[12];
            assign product[i+832] = A[i] & B[13];
            assign product[i+896] = A[i] & B[14];
            assign product[i+960] = A[i] & B[15];
            assign product[i+1024] = A[i] & B[16];
            assign product[i+1088] = A[i] & B[17];
            assign product[i+1152] = A[i] & B[18];
            assign product[i+1216] = A[i] & B[19];
            assign product[i+1280] = A[i] & B[20];
            assign product[i+1344] = A[i] & B[21];
            assign product[i+1408] = A[i] & B[22];
            assign product[i+1472] = A[i] & B[23];
            assign product[i+1536] = A[i] & B[24];
            assign product[i+1600] = A[i] & B[25];
            assign product[i+1664] = A[i] & B[26];
            assign product[i+1728] = A[i] & B[27];
            assign product[i+1792] = A[i] & B[28];
            assign product[i+1856] = A[i] & B[29];
            assign product[i+1920] = A[i] & B[30];
            assign product[i+1984] = A[i] & B[31];
        end
    endgenerate
    /* Write your code here */
endmodule"
N/A,N/A,-0.1,47.0,1,"//Please finish designing the 64 bit multiplier module (multiplier_64) below.
//There are two 64 bit inputs (A and B) and a 128 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_64(output [127:0] product, input [63:0] A, B);
    /*
        Implement a 64 bit multiplier with the below algorithm.
        
        1. A 32 bit multiplier (multiplier_32) is used to generate a 32 bit product.
        2. The 32 bit product is then used to generate a 64 bit product.
        3. The 64 bit product is then stored in the output.
    */
    
    /*
        Use a 32 bit multiplier to generate a 32 bit product.
    */
    
    /*
        Use the 32 bit product to generate a 64 bit product.
    */
    
    /*
        Store the 64 bit product in the output.
    */
    
endmodule"
N/A,N/A,-1,48.0,1,"//Please finish designing the 64 bit multiplier module (multiplier_64) below.
//There are two 64 bit inputs (A and B) and a 128 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_64(output [127:0] product, input [63:0] A, B);
    /*
        Group Members: Kevin Ingram and Warren Seto
        Lab Name: Combinational Circuit Design
        Design Name: multiplier_64bit
        Design Description: Verilog Module for 64 bit multiplication
    */
    
    //64 bit input A and B
    
    //128 bit output product
    
    //64 bit intermediate product
    
    //32 bit intermediate A and B
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate"
N/A,N/A,-1,49.0,1,"//Please finish designing the 64 bit multiplier module (multiplier_64) below.
//There are two 64 bit inputs (A and B) and a 128 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_64(output [127:0] product, input [63:0] A, B);

    /* Please fill in the implementation here... */
    genvar i;
    generate
        for (i = 0; i < 64; i = i + 1) begin: mul_digit
            assign product[(8 * i) + 7:8 * i] = mul_digit[i].mul_digit_reg[7:0];
        end
    endgenerate

    /*
    always @(A or B) begin
        //$display(""%d * %d"", A, B);
        product <= A * B;
    end
    */

endmodule"
N/A,N/A,-1,50.0,1,"//Please finish designing the 64 bit multiplier module (multiplier_64) below.
//There are two 64 bit inputs (A and B) and a 128 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_64(output [127:0] product, input [63:0] A, B);

	/* Please fill in the implementation here... */
	genvar i;
	generate
		for (i = 0; i < 64; i = i + 1) begin: mul_digit
			assign product[(8 * i) + 7:8 * i] = mul_digit[i].A * mul_digit[i].B;
		end
	endgenerate

endmodule"
N/A,N/A,-1,51.0,1,"//Please finish designing the 64 bit multiplier module (multiplier_64) below.
//There are two 64 bit inputs (A and B) and a 128 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_64(output [127:0] product, input [63:0] A, B);
    /* Please fill in the implementation here... */
    genvar i;
    generate
        for (i = 0; i < 64; i = i + 1) begin: mul_digit
            assign product[(8 * i) + 7:8 * i] = mul_digit[i].A * mul_digit[i].B;
        end
    endgenerate
endmodule"
N/A,N/A,-1,52.0,1,"//Please finish designing the 64 bit multiplier module (multiplier_64) below.
//There are two 64 bit inputs (A and B) and a 128 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_64(output [127:0] product, input [63:0] A, B);
    assign pp0 = A[0]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp1 = A[1]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp2 = A[2]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp3 = A[3]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp4 = A[4]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp5 = A[5]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp6 = A[6]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp7 = A[7]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp8 = A[8]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp9 = A[9]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp10 = A[10]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp11 = A[11]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp12 = A[12]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp13 = A[13]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp14 = A[14]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp15 = A[15]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp16 = A[16]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp17 = A[17]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp18 = A[18]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp19 = A[19]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp20 = A[20]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp21 = A[21]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp22 = A[22]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp23 = A[23]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp24 = A[24]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp25 = A[25]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp26 = A[26]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp27 = A[27]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp28 = A[28]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp29 = A[29]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp30 = A[30]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp31 = A[31]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp32 = A[32]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp33 = A[33]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp34 = A[34]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp35 = A[35]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp36 = A[36]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp37 = A[37]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp38 = A[38]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp39 = A[39]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp40 = A[40]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp41 = A[41]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp42 = A[42]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp43 = A[43]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp44 = A[44]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp45 = A[45]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp46 = A[46]?"
N/A,N/A,-1,53.0,1,"//Please finish designing the 64 bit multiplier module (multiplier_64) below.
//There are two 64 bit inputs (A and B) and a 128 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_64(output [127:0] product, input [63:0] A, B);

	/* Please fill in the implementation here... */
	genvar i;
	generate
		for (i = 0; i < 64; i = i + 1) begin: mul_digit
			assign product[(8 * i) + 7:8 * i] = mul_digit[i].A * mul_digit[i].B;
		end
	endgenerate

endmodule"
N/A,N/A,-1,54.0,1,"//Please finish designing the 64 bit multiplier module (multiplier_64) below.
//There are two 64 bit inputs (A and B) and a 128 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_64(output [127:0] product, input [63:0] A, B);
    /*
        Group Members: Kevin Ingram and Warren Seto

        Lab Name: Combinational Logic
        Project Name: eng312_proj2
        Design Name: multiplier_64bit.v
        Design Description: Verilog Module to implement a 64 bit multiplier
    */
    
    //64 bit input A and B
    
    //128 bit output product
    
    //64 bit intermediate product
    
    //32 bit intermediate A and B
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
"
N/A,N/A,-0.1,55.0,1,"//Please finish designing the 64 bit multiplier module (multiplier_64) below.
//There are two 64 bit inputs (A and B) and a 128 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_64(output [127:0] product, input [63:0] A, B);
    /*
        Implement a 64 bit multiplier with a 128 bit output.
        The output should be the same as the following:
        assign product = A * B;
    */
    assign product[63:0] = A * B;
    assign product[127:64] = 0;
endmodule"
N/A,N/A,-1,56.0,1,"//Please finish designing the 64 bit multiplier module (multiplier_64) below.
//There are two 64 bit inputs (A and B) and a 128 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_64(output [127:0] product, input [63:0] A, B);
	/* Write your code here */
	genvar i;
	generate
		for (i = 0; i < 64; i = i + 1) begin: mul_digit
			assign product[(8 * i) + 7:8 * i] = mul_digit[i].A * mul_digit[i].B;
		end
	endgenerate
	/* Write your code here */
endmodule"
N/A,N/A,-1,57.0,1,"//Please finish designing the 64 bit multiplier module (multiplier_64) below.
//There are two 64 bit inputs (A and B) and a 128 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_64(output [127:0] product, input [63:0] A, B);
    /* Write your code here */
    genvar i;
    generate
        for (i = 0; i < 64; i = i + 1) begin: mul_digit
            assign product[(i+1)*8 - 1 -: 8] = mul_digit[i].A * mul_digit[i].B;
        end
    endgenerate
    /* Write your code here */
endmodule"
30438.114,3921.99,0.1,58.0,1,"//Please finish designing the 64 bit multiplier module (multiplier_64) below.
//There are two 64 bit inputs (A and B) and a 128 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_64(output [127:0] product, input [63:0] A, B);
    /*
        Implement a 64 bit multiplier with a 128 bit output.
        This implementation uses a long kogge-stone adder and
        a long kogge-stone adder to compute the product.
        Use the module below to help you design the circuit.
    */
    assign product = A * B;
endmodule"
N/A,N/A,-1,59.0,1,"//Please finish designing the 64 bit multiplier module (multiplier_64) below.
//There are two 64 bit inputs (A and B) and a 128 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_64(output [127:0] product, input [63:0] A, B);
    /*
        Group Members: Kevin Ingram and Warren Seto

        Lab Name: Combinational Logic
        Project Name: eng312_proj2
        Design Name: multiplier_64bit.v
        Design Description: Verilog Module to implement a 64 bit multiplier
    */
    
    //64 bit input A and B
    
    //128 bit output product
    
    //64 bit intermediate product
    
    //32 bit intermediate A and B
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
"
N/A,N/A,-1,60.0,1,"//Please finish designing the 64 bit multiplier module (multiplier_64) below.
//There are two 64 bit inputs (A and B) and a 128 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_64(output [127:0] product, input [63:0] A, B);

    /* Please fill in the implementation here... */
    genvar i;
    generate
        for (i = 0; i < 64; i = i + 1) begin: mul_digit
            assign product[(8 * i) + 7:8 * i] = mul_digit[i].mul_digit_reg[7:0];
        end
    endgenerate

    /*
    always @(A or B) begin
        //$display(""%d * %d"", A, B);
        product <= A * B;
    end
    */

endmodule"
N/A,N/A,-1,61.0,1,"//Please finish designing the 64 bit multiplier module (multiplier_64) below.
//There are two 64 bit inputs (A and B) and a 128 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_64(output [127:0] product, input [63:0] A, B);

	/* Please fill in the implementation here... */
	genvar i;
	generate
		for (i = 0; i < 64; i = i + 1) begin: mul_digit
			assign product[(8 * i) + 7:8 * i] = mul_digit[i].A * mul_digit[i].B;
		end
	endgenerate

endmodule"
N/A,N/A,-1,62.0,1,"//Please finish designing the 64 bit multiplier module (multiplier_64) below.
//There are two 64 bit inputs (A and B) and a 128 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_64(output [127:0] product, input [63:0] A, B);
    /* Please fill in the implementation here... */
    assign pp0 = A[0]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp1 = A[1]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp2 = A[2]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp3 = A[3]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp4 = A[4]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp5 = A[5]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp6 = A[6]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp7 = A[7]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp8 = A[8]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp9 = A[9]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp10 = A[10]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp11 = A[11]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp12 = A[12]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp13 = A[13]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp14 = A[14]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp15 = A[15]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp16 = A[16]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp17 = A[17]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp18 = A[18]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp19 = A[19]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp20 = A[20]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp21 = A[21]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp22 = A[22]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp23 = A[23]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp24 = A[24]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp25 = A[25]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp26 = A[26]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp27 = A[27]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp28 = A[28]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp29 = A[29]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp30 = A[30]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp31 = A[31]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp32 = A[32]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp33 = A[33]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp34 = A[34]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp35 = A[35]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp36 = A[36]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp37 = A[37]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp38 = A[38]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp39 = A[39]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp40 = A[40]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp41 = A[41]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp42 = A[42]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp43 = A[43]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp44 = A[44]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp45 = A[45]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
"
N/A,N/A,-1,63.0,1,"//Please finish designing the 64 bit multiplier module (multiplier_64) below.
//There are two 64 bit inputs (A and B) and a 128 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_64(output [127:0] product, input [63:0] A, B);
    assign pp0 = A[0]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp1 = A[1]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp2 = A[2]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp3 = A[3]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp4 = A[4]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp5 = A[5]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp6 = A[6]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp7 = A[7]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp8 = A[8]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp9 = A[9]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp10 = A[10]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp11 = A[11]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp12 = A[12]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp13 = A[13]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp14 = A[14]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp15 = A[15]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp16 = A[16]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp17 = A[17]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp18 = A[18]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp19 = A[19]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp20 = A[20]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp21 = A[21]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp22 = A[22]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp23 = A[23]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp24 = A[24]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp25 = A[25]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp26 = A[26]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp27 = A[27]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp28 = A[28]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp29 = A[29]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp30 = A[30]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp31 = A[31]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp32 = A[32]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp33 = A[33]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp34 = A[34]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp35 = A[35]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp36 = A[36]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp37 = A[37]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp38 = A[38]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp39 = A[39]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp40 = A[40]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp41 = A[41]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp42 = A[42]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp43 = A[43]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp44 = A[44]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp45 = A[45]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp46 = A[46]?"
N/A,N/A,-1,64.0,1,"//Please finish designing the 64 bit multiplier module (multiplier_64) below.
//There are two 64 bit inputs (A and B) and a 128 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_64(output [127:0] product, input [63:0] A, B);

	/* Please fill in the implementation here... */
	genvar i;
	generate
		for (i = 0; i < 64; i = i + 1) begin: mul_digit
			assign product[(8 * i) + 7:8 * i] = mul_digit[i].A * mul_digit[i].B;
		end
	endgenerate

endmodule"
N/A,N/A,-1,65.0,1,"//Please finish designing the 64 bit multiplier module (multiplier_64) below.
//There are two 64 bit inputs (A and B) and a 128 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_64(output [127:0] product, input [63:0] A, B);
    /*
        Group Members: Kevin Ingram and Warren Seto

        Lab Name: Combinational Logic
        Project Name: eng312_proj2
        Design Name: multiplier_64bit.v
        Design Description: Verilog Module to implement a 64 bit multiplier
    */
    
    //64 bit input A and B
    
    //128 bit output product
    
    //64 bit intermediate product
    
    //32 bit intermediate A and B
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
"
N/A,N/A,-0.1,66.0,1,"//Please finish designing the 64 bit multiplier module (multiplier_64) below.
//There are two 64 bit inputs (A and B) and a 128 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_64(output [127:0] product, input [63:0] A, B);
    /*
        Implement a 64 bit multiplier with a 128 bit output. The output should be the same as the following
        64 bit x 64 bit = 128 bit
        
        If the input is A = 64'h0000000000000011 and B = 64'h0000000000000111, then the output should be
        product = 128'h0000000000000011111010111011010110
        
        If the input is A = 64'h0000000000000111 and B = 64'h0000000000000011, then the output should be
        product = 128'h000000000000000011010111011010110
        
        If the input is A = 64'h0000000000000011 and B = 64'h0000000000000011, then the output should be
        product = 128'h00000000000000000
        
        If the input is A = 64'h1111111111111111 and B = 64'h0000000000000011, then the output should be
        product = 128'h1111111111111111100000000000000000
        
        If the input is A = 64'h0000000000000011 and B = 64'h1111111111111111, then the output should be
        product = 128'h000000000000000000000000000000000
    */
    
    assign product[63:0] = A * B;
    assign product[127:64] = 0;
endmodule"
N/A,N/A,-1,67.0,1,"//Please finish designing the 64 bit multiplier module (multiplier_64) below.
//There are two 64 bit inputs (A and B) and a 128 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_64(output [127:0] product, input [63:0] A, B);
	/* Write your code here */
	genvar i;
	generate
		for (i = 0; i < 64; i = i + 1) begin: mul_digit
			assign product[(8 * i) + 7:8 * i] = mul_digit[i].A * mul_digit[i].B;
		end
	endgenerate
	/* Write your code here */
endmodule"
N/A,N/A,-0.1,68.0,1,"//Please finish designing the 64 bit multiplier module (multiplier_64) below.
//There are two 64 bit inputs (A and B) and a 128 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_64(output [127:0] product, input [63:0] A, B);
    /* Write your code here */
    genvar i;
    generate
        for(i = 0; i < 64; i = i + 1) begin
            assign product[(i+1)*8 - 1 -: 8] = A[i]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
        end
    endgenerate
    /* Write your code here */
endmodule"
N/A,N/A,-1,69.0,1,"//Please finish designing the 64 bit multiplier module (multiplier_64) below.
//There are two 64 bit inputs (A and B) and a 128 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_64(output [127:0] product, input [63:0] A, B);
    /*
        Implement a 64 bit multiplier with 128 bit output.
        
        This implementation uses a 32 bit by 32 bit multiply and a 64 bit adder.
        
        If the final carry out is 1, then the result is negative.
        
        If the final carry out is 0, then the result is positive.
        
        If the final carry out is X, then the result is indeterminate.
        
        Example:
        
        A = 32'h00000001; B = 32'h00000002;
        
        In this case, the final carry out is 0, so the result is positive.
        
        A = 32'h00000001; B = 32'h00000002;
        
        In this case, the final carry out is 1, so the result is negative.
        
        A = 32'h00000001; B = 32'h00000002;
        
        In this case, the final carry out is X, so the result is indeterminate.
        
        A = 32'h00000001; B = 32'h00000002;
        
        In this case, the final carry out is X, so the result is indeterminate.
        
        A = 32'h00000001; B = 32'h00000002;
        
        In this case, the final carry out is X, so the result is indeterminate.
        
        A = 32'h00000001; B = 32'h00000002;
        
        In this case, the final carry out is X, so the result is indeterminate.
        
        A = 32'h00000001; B = 32'h00000002;
        
        In this case, the final carry out is X, so the result is indeterminate.
        
        A = 32'h00000001; B = 32'h00000002;
        
        In this case, the final carry out is X, so the result is indeterminate.
        
        A = 32'h00000001; B = 32'h00000002;
        
        In this case, the final carry out is X, so the result is indeterminate.
        
        A = 32'h00000001; B = 32'h00000002;
        
        In this case, the final carry out is X, so the result is indeterminate.
        
        A = 32'h00000001; B = 32'h00000002;
        
        In this case, the final carry out is X, so the result is indeterminate.
        
        A = 32'h00000001; B = 32'h00000002;
        
        In this case, the final carry out is X, so the result is indeterminate.
        
        A = 32'h00000001; B = 32'h00000002;
        
        In this case, the final carry out is X, so the result is indeterminate.
        
        A = 32'h00000001; B = 32'h00000002;
        
        In this case, the final carry out is X, so the result is indeterminate.
        
        A = 32'h00000001; B = 32'h00000002;
        
        In this case, the final carry out is X, so the result is indeterminate.
        
        A = 32'h00000001; B = 32'h00000002;
        
        In this case, the final carry out is X, so the result is indeterminate.
        
        A = 32'h00000001; B = 32'h00000002;
        
        In this case, the final carry out is X, so the result is indeterminate.
        
        A = 32'h00000001; B = 32'h00000002;
        
        In this case, the final carry out is X, so the result is indeterminate.
        
        A = 32'h00000001; B = 32'h00000002;
        
        In this case, the final carry out is X, so the result is indeterminate.
        
        A = 32'h00000001; B = 32'h00000002;
        
        In this case, the final carry out is X, so the result is indeterminate.
        
        A = 32'h00000001; B = 32'h00000002;
        
        In this case, the final carry out is X, so the result is indeterminate.
        
        A = 32'h00000001; B = 32'h00000002;
        
        In this"
N/A,N/A,-1,70.0,1,"//Please finish designing the 64 bit multiplier module (multiplier_64) below.
//There are two 64 bit inputs (A and B) and a 128 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_64(output [127:0] product, input [63:0] A, B);
    /* Write your code here */
    genvar i;
    generate
        for(i=0; i<64; i=i+1) begin
            assign product[i] = A[i] & B[0];
            assign product[i+64] = A[i] & B[1];
            assign product[i+128] = A[i] & B[2];
            assign product[i+192] = A[i] & B[3];
            assign product[i+256] = A[i] & B[4];
            assign product[i+320] = A[i] & B[5];
            assign product[i+384] = A[i] & B[6];
            assign product[i+448] = A[i] & B[7];
            assign product[i+512] = A[i] & B[8];
            assign product[i+576] = A[i] & B[9];
            assign product[i+640] = A[i] & B[10];
            assign product[i+704] = A[i] & B[11];
            assign product[i+768] = A[i] & B[12];
            assign product[i+832] = A[i] & B[13];
            assign product[i+896] = A[i] & B[14];
            assign product[i+960] = A[i] & B[15];
            assign product[i+1024] = A[i] & B[16];
            assign product[i+1088] = A[i] & B[17];
            assign product[i+1152] = A[i] & B[18];
            assign product[i+1216] = A[i] & B[19];
            assign product[i+1280] = A[i] & B[20];
            assign product[i+1344] = A[i] & B[21];
            assign product[i+1408] = A[i] & B[22];
            assign product[i+1472] = A[i] & B[23];
            assign product[i+1536] = A[i] & B[24];
            assign product[i+1600] = A[i] & B[25];
            assign product[i+1664] = A[i] & B[26];
            assign product[i+1728] = A[i] & B[27];
            assign product[i+1792] = A[i] & B[28];
            assign product[i+1856] = A[i] & B[29];
            assign product[i+1920] = A[i] & B[30];
            assign product[i+1984] = A[i] & B[31];
        end
    endgenerate
    /* Write your code here */
endmodule"
N/A,N/A,-1,71.0,1,"//Please finish designing the 64 bit multiplier module (multiplier_64) below.
//There are two 64 bit inputs (A and B) and a 128 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_64(output [127:0] product, input [63:0] A, B);
    /*
        Group Members: Kevin Ingram and Warren Seto

        Lab Name: Combinational Logic
        Project Name: eng312_proj2
        Design Name: multiplier_64bit.v
        Design Description: Verilog Module to implement a 64 bit multiplier
    */
    
    //64 bit input A and B
    
    //128 bit output product
    
    //64 bit intermediate product
    
    //32 bit intermediate A and B
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
"
N/A,N/A,-1,72.0,1,"//Please finish designing the 64 bit multiplier module (multiplier_64) below.
//There are two 64 bit inputs (A and B) and a 128 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_64(output [127:0] product, input [63:0] A, B);

    /* Please fill in the implementation here... */
    genvar i;
    generate
        for (i = 0; i < 64; i = i + 1) begin: mul_digit
            assign product[(8 * i) + 7:8 * i] = mul_digit[i].mul_digit_reg[7:0];
        end
    endgenerate

    /*
    always @(A or B) begin
        //$display(""%d * %d"", A, B);
        product <= A * B;
    end
    */

endmodule"
N/A,N/A,-1,73.0,1,"//Please finish designing the 64 bit multiplier module (multiplier_64) below.
//There are two 64 bit inputs (A and B) and a 128 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_64(output [127:0] product, input [63:0] A, B);

	/* Please fill in the implementation here... */
	genvar i;
	generate
		for (i = 0; i < 64; i = i + 1) begin: mul_digit
			assign product[(8 * i) + 7:8 * i] = mul_digit[i].A * mul_digit[i].B;
		end
	endgenerate

endmodule"
N/A,N/A,-1,74.0,1,"//Please finish designing the 64 bit multiplier module (multiplier_64) below.
//There are two 64 bit inputs (A and B) and a 128 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_64(output [127:0] product, input [63:0] A, B);
    /* Please fill in the implementation here... */
    assign pp0 = A[0]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp1 = A[1]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp2 = A[2]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp3 = A[3]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp4 = A[4]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp5 = A[5]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp6 = A[6]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp7 = A[7]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp8 = A[8]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp9 = A[9]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp10 = A[10]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp11 = A[11]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp12 = A[12]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp13 = A[13]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp14 = A[14]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp15 = A[15]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp16 = A[16]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp17 = A[17]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp18 = A[18]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp19 = A[19]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp20 = A[20]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp21 = A[21]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp22 = A[22]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp23 = A[23]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp24 = A[24]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp25 = A[25]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp26 = A[26]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp27 = A[27]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp28 = A[28]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp29 = A[29]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp30 = A[30]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp31 = A[31]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp32 = A[32]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp33 = A[33]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp34 = A[34]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp35 = A[35]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp36 = A[36]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp37 = A[37]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp38 = A[38]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp39 = A[39]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp40 = A[40]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp41 = A[41]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp42 = A[42]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp43 = A[43]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp44 = A[44]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp45 = A[45]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
"
N/A,N/A,-1,75.0,1,"//Please finish designing the 64 bit multiplier module (multiplier_64) below.
//There are two 64 bit inputs (A and B) and a 128 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_64(output [127:0] product, input [63:0] A, B);
    assign pp0 = A[0]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp1 = A[1]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp2 = A[2]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp3 = A[3]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp4 = A[4]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp5 = A[5]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp6 = A[6]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp7 = A[7]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp8 = A[8]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp9 = A[9]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp10 = A[10]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp11 = A[11]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp12 = A[12]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp13 = A[13]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp14 = A[14]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp15 = A[15]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp16 = A[16]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp17 = A[17]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp18 = A[18]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp19 = A[19]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp20 = A[20]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp21 = A[21]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp22 = A[22]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp23 = A[23]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp24 = A[24]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp25 = A[25]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp26 = A[26]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp27 = A[27]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp28 = A[28]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp29 = A[29]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp30 = A[30]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp31 = A[31]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp32 = A[32]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp33 = A[33]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp34 = A[34]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp35 = A[35]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp36 = A[36]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp37 = A[37]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp38 = A[38]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp39 = A[39]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp40 = A[40]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp41 = A[41]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp42 = A[42]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp43 = A[43]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp44 = A[44]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp45 = A[45]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp46 = A[46]?"
N/A,N/A,-1,76.0,1,"//Please finish designing the 64 bit multiplier module (multiplier_64) below.
//There are two 64 bit inputs (A and B) and a 128 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_64(output [127:0] product, input [63:0] A, B);

	/* Please fill in the implementation here... */
	genvar i;
	generate
		for (i = 0; i < 64; i = i + 1) begin: mul_digit
			assign product[(8 * i) + 7:8 * i] = mul_digit[i].A * mul_digit[i].B;
		end
	endgenerate

endmodule"
N/A,N/A,-1,77.0,1,"//Please finish designing the 64 bit multiplier module (multiplier_64) below.
//There are two 64 bit inputs (A and B) and a 128 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_64(output [127:0] product, input [63:0] A, B);
    /*
        Group Members: Kevin Ingram and Warren Seto

        Lab Name: Combinational Logic
        Project Name: eng312_proj2
        Design Name: multiplier_64bit.v
        Design Description: Verilog Module to implement a 64 bit multiplier
    */
    
    //64 bit input A and B
    
    //128 bit output product
    
    //64 bit intermediate product
    
    //32 bit intermediate A and B
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
"
30438.114,3921.99,0.1,78.0,1,"//Please finish designing the 64 bit multiplier module (multiplier_64) below.
//There are two 64 bit inputs (A and B) and a 128 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_64(output [127:0] product, input [63:0] A, B);
    /*
        Implement a 64 bit multiplier with a 128 bit output.
        The output should be the same as the input (A) and (B) multiplied together.
        The inputs are both 64 bit numbers.
        The output is a 128 bit number.
    */
    assign product = A * B;
endmodule"
N/A,N/A,-1,79.0,1,"//Please finish designing the 64 bit multiplier module (multiplier_64) below.
//There are two 64 bit inputs (A and B) and a 128 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_64(output [127:0] product, input [63:0] A, B);
	/* Write your code here */
	genvar i;
	generate
		for (i = 0; i < 64; i = i + 1) begin: mul_digit
			assign product[(8 * i) + 7:8 * i] = mul_digit[i].A * mul_digit[i].B;
		end
	endgenerate
	/* Write your code here */
endmodule"
N/A,N/A,-1,80.0,1,"//Please finish designing the 64 bit multiplier module (multiplier_64) below.
//There are two 64 bit inputs (A and B) and a 128 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_64(output [127:0] product, input [63:0] A, B);
    /*
        Implement a 64 bit multiplier with 128 bit output.
        This implementation uses a 32 bit by 32 bit multiply and a 64 bit adder.
    */
    
    wire [63:0] pp0;
    wire [63:0] pp1;
    wire [63:0] pp2;
    wire [63:0] pp3;
    wire [63:0] pp4;
    wire [63:0] pp5;
    wire [63:0] pp6;
    wire [63:0] pp7;
    wire [63:0] pp8;
    wire [63:0] pp9;
    wire [63:0] pp10;
    wire [63:0] pp11;
    wire [63:0] pp12;
    wire [63:0] pp13;
    wire [63:0] pp14;
    wire [63:0] pp15;
    wire [63:0] pp16;
    wire [63:0] pp17;
    wire [63:0] pp18;
    wire [63:0] pp19;
    wire [63:0] pp20;
    wire [63:0] pp21;
    wire [63:0] pp22;
    wire [63:0] pp23;
    wire [63:0] pp24;
    wire [63:0] pp25;
    wire [63:0] pp26;
    wire [63:0] pp27;
    wire [63:0] pp28;
    wire [63:0] pp29;
    wire [63:0] pp30;
    wire [63:0] pp31;
    wire [63:0] pp32;
    wire [63:0] pp33;
    wire [63:0] pp34;
    wire [63:0] pp35;
    wire [63:0] pp36;
    wire [63:0] pp37;
    wire [63:0] pp38;
    wire [63:0] pp39;
    wire [63:0] pp40;
    wire [63:0] pp41;
    wire [63:0] pp42;
    wire [63:0] pp43;
    wire [63:0] pp44;
    wire [63:0] pp45;
    wire [63:0] pp46;
    wire [63:0] pp47;
    wire [63:0] pp48;
    wire [63:0] pp49;
    wire [63:0] pp50;
    wire [63:0] pp51;
    wire [63:0] pp52;
    wire [63:0] pp53;
    wire [63:0] pp54;
    wire [63:0] pp55;
    wire [63:0] pp56;
    wire [63:0] pp57;
    wire [63:0] pp58;
    wire [63:0] pp59;
    wire [63:0] pp60;
    wire [63:0] pp61;
    wire [63:0] pp62;
    wire [63:0] pp63;
    
    assign pp0 = A[0]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp1 = A[1]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp2 = A[2]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp3 = A[3]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp4 = A[4]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp5 = A[5]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp6 = A[6]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp7 = A[7]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp8 = A[8]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp9 = A[9]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp10 = A[10]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp11 = A[11]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp12 = A[12]? B:"
N/A,N/A,-0.1,81.0,1,"//Please finish designing the 64 bit multiplier module (multiplier_64) below.
//There are two 64 bit inputs (A and B) and a 128 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_64(output [127:0] product, input [63:0] A, B);
    /* Write your code here */
    genvar i;
    generate
        for(i = 0; i < 64; i = i + 1) begin
            assign product[(i+1)*8 - 1 -: 8] = A[i]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
        end
    endgenerate
    /* Write your code here */
endmodule"
N/A,N/A,-1,82.0,1,"//Please finish designing the 64 bit multiplier module (multiplier_64) below.
//There are two 64 bit inputs (A and B) and a 128 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_64(output [127:0] product, input [63:0] A, B);
    /*
        Group Members: Kevin Ingram and Warren Seto

        Lab Name: Combinational Logic
        Project Name: eng312_proj2
        Design Name: multiplier_64bit.v
        Design Description: Verilog Module to implement a 64 bit multiplier
    */
    
    //64 bit input A and B
    
    //128 bit output product
    
    //64 bit intermediate product
    
    //32 bit intermediate A and B
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
"
N/A,N/A,-1,83.0,1,"//Please finish designing the 64 bit multiplier module (multiplier_64) below.
//There are two 64 bit inputs (A and B) and a 128 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_64(output [127:0] product, input [63:0] A, B);

    /* Please fill in the implementation here... */
    genvar i;
    generate
        for (i = 0; i < 64; i = i + 1) begin: mul_digit
            assign product[(8 * i) + 7:8 * i] = mul_digit[i].mul_digit_reg[7:0];
        end
    endgenerate

    /*
    always @(A or B) begin
        //$display(""%d * %d"", A, B);
        product <= A * B;
    end
    */

endmodule"
N/A,N/A,-1,84.0,1,"//Please finish designing the 64 bit multiplier module (multiplier_64) below.
//There are two 64 bit inputs (A and B) and a 128 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_64(output [127:0] product, input [63:0] A, B);

	/* Please fill in the implementation here... */
	genvar i;
	generate
		for (i = 0; i < 64; i = i + 1) begin: mul_digit
			assign product[(8 * i) + 7:8 * i] = mul_digit[i].A * mul_digit[i].B;
		end
	endgenerate

endmodule"
N/A,N/A,-1,85.0,1,"//Please finish designing the 64 bit multiplier module (multiplier_64) below.
//There are two 64 bit inputs (A and B) and a 128 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_64(output [127:0] product, input [63:0] A, B);
    /* Please fill in the implementation here... */
    genvar i;
    generate
        for (i = 0; i < 64; i = i + 1) begin: mul_digit
            assign product[(8 * i) + 7:8 * i] = mul_digit[i].A * mul_digit[i].B;
        end
    endgenerate
endmodule"
N/A,N/A,-1,86.0,1,"//Please finish designing the 64 bit multiplier module (multiplier_64) below.
//There are two 64 bit inputs (A and B) and a 128 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_64(output [127:0] product, input [63:0] A, B);
    assign pp0 = A[0]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp1 = A[1]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp2 = A[2]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp3 = A[3]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp4 = A[4]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp5 = A[5]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp6 = A[6]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp7 = A[7]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp8 = A[8]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp9 = A[9]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp10 = A[10]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp11 = A[11]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp12 = A[12]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp13 = A[13]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp14 = A[14]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp15 = A[15]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp16 = A[16]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp17 = A[17]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp18 = A[18]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp19 = A[19]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp20 = A[20]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp21 = A[21]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp22 = A[22]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp23 = A[23]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp24 = A[24]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp25 = A[25]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp26 = A[26]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp27 = A[27]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp28 = A[28]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp29 = A[29]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp30 = A[30]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp31 = A[31]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp32 = A[32]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp33 = A[33]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp34 = A[34]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp35 = A[35]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp36 = A[36]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp37 = A[37]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp38 = A[38]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp39 = A[39]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp40 = A[40]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp41 = A[41]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp42 = A[42]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp43 = A[43]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp44 = A[44]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp45 = A[45]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp46 = A[46]?"
N/A,N/A,-1,87.0,1,"//Please finish designing the 64 bit multiplier module (multiplier_64) below.
//There are two 64 bit inputs (A and B) and a 128 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_64(output [127:0] product, input [63:0] A, B);

	/* Please fill in the implementation here... */
	genvar i;
	generate
		for (i = 0; i < 64; i = i + 1) begin: mul_digit
			assign product[(8 * i) + 7:8 * i] = mul_digit[i].A * mul_digit[i].B;
		end
	endgenerate

endmodule"
N/A,N/A,-1,88.0,1,"//Please finish designing the 64 bit multiplier module (multiplier_64) below.
//There are two 64 bit inputs (A and B) and a 128 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_64(output [127:0] product, input [63:0] A, B);
    /*
        Group Members: Kevin Ingram and Warren Seto

        Lab Name: Combinational Logic
        Project Name: eng312_proj2
        Design Name: multiplier_64bit.v
        Design Description: Verilog Module to implement a 64 bit multiplier
    */
    
    //64 bit input A and B
    
    //128 bit output product
    
    //64 bit intermediate product
    
    //32 bit intermediate A and B
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
"
N/A,N/A,-1,89.0,1,"//Please finish designing the 64 bit multiplier module (multiplier_64) below.
//There are two 64 bit inputs (A and B) and a 128 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_64(output [127:0] product, input [63:0] A, B);
    /* Write your code here */
    genvar i;
    generate
        for (i = 0; i < 64; i = i + 1) begin: mul_digit
            assign product[(i+1)*8 - 1 -: 8] = mul_digit[i].A * mul_digit[i].B;
        end
    endgenerate
    /* Write your code here */
endmodule"
N/A,N/A,-1,90.0,1,"//Please finish designing the 64 bit multiplier module (multiplier_64) below.
//There are two 64 bit inputs (A and B) and a 128 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_64(output [127:0] product, input [63:0] A, B);
	/* Write your code here */
	genvar i;
	generate
		for (i = 0; i < 64; i = i + 1) begin: mul_digit
			assign product[(8 * i) + 7:8 * i] = mul_digit[i].A * mul_digit[i].B;
		end
	endgenerate
	/* Write your code here */
endmodule"
N/A,N/A,-1,91.0,1,"//Please finish designing the 64 bit multiplier module (multiplier_64) below.
//There are two 64 bit inputs (A and B) and a 128 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_64(output [127:0] product, input [63:0] A, B);
    /*
        Implement a 64 bit multiplier with a 128 bit output.
        This is a combinational circuit with a single input and output.
        The input is a 64 bit binary number.
        The output is a 128 bit binary number.
        The output is the product of the input and the input.
        For example, if the input is 32'b10001000100010001000100010001000 then the output is
        32'b000000000000000000000000000000000000000000000000000000000000010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101"
N/A,N/A,-1,92.0,1,"//Please finish designing the 64 bit multiplier module (multiplier_64) below.
//There are two 64 bit inputs (A and B) and a 128 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_64(output [127:0] product, input [63:0] A, B);
    /*
        Group Members: Kevin Ingram and Warren Seto

        Lab Name: Combinational Logic
        Project Name: eng312_proj2
        Design Name: multiplier_64bit.v
        Design Description: Verilog Module to implement a 64 bit multiplier
    */
    
    //64 bit input A and B
    
    //128 bit output product
    
    //64 bit intermediate product
    
    //32 bit intermediate A and B
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
"
N/A,N/A,-1,93.0,1,"//Please finish designing the 64 bit multiplier module (multiplier_64) below.
//There are two 64 bit inputs (A and B) and a 128 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_64(output [127:0] product, input [63:0] A, B);

    /* Please fill in the implementation here... */
    genvar i;
    generate
        for (i = 0; i < 64; i = i + 1) begin: mul_digit
            assign product[(8 * i) + 7:8 * i] = mul_digit[i].mul_digit_reg[7:0];
        end
    endgenerate

    /*
    always @(A or B) begin
        //$display(""%d * %d"", A, B);
        product <= A * B;
    end
    */

endmodule"
N/A,N/A,-1,94.0,1,"//Please finish designing the 64 bit multiplier module (multiplier_64) below.
//There are two 64 bit inputs (A and B) and a 128 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_64(output [127:0] product, input [63:0] A, B);

	/* Please fill in the implementation here... */
	genvar i;
	generate
		for (i = 0; i < 64; i = i + 1) begin: mul_digit
			assign product[(8 * i) + 7:8 * i] = mul_digit[i].A * mul_digit[i].B;
		end
	endgenerate

endmodule"
N/A,N/A,-1,95.0,1,"//Please finish designing the 64 bit multiplier module (multiplier_64) below.
//There are two 64 bit inputs (A and B) and a 128 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_64(output [127:0] product, input [63:0] A, B);
    /* Please fill in the implementation here... */
    assign pp0 = A[0]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp1 = A[1]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp2 = A[2]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp3 = A[3]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp4 = A[4]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp5 = A[5]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp6 = A[6]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp7 = A[7]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp8 = A[8]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp9 = A[9]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp10 = A[10]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp11 = A[11]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp12 = A[12]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp13 = A[13]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp14 = A[14]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp15 = A[15]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp16 = A[16]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp17 = A[17]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp18 = A[18]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp19 = A[19]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp20 = A[20]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp21 = A[21]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp22 = A[22]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp23 = A[23]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp24 = A[24]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp25 = A[25]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp26 = A[26]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp27 = A[27]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp28 = A[28]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp29 = A[29]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp30 = A[30]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp31 = A[31]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp32 = A[32]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp33 = A[33]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp34 = A[34]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp35 = A[35]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp36 = A[36]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp37 = A[37]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp38 = A[38]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp39 = A[39]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp40 = A[40]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp41 = A[41]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp42 = A[42]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp43 = A[43]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp44 = A[44]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp45 = A[45]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
"
N/A,N/A,-1,96.0,1,"//Please finish designing the 64 bit multiplier module (multiplier_64) below.
//There are two 64 bit inputs (A and B) and a 128 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_64(output [127:0] product, input [63:0] A, B);
    assign pp0 = A[0]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp1 = A[1]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp2 = A[2]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp3 = A[3]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp4 = A[4]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp5 = A[5]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp6 = A[6]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp7 = A[7]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp8 = A[8]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp9 = A[9]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp10 = A[10]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp11 = A[11]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp12 = A[12]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp13 = A[13]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp14 = A[14]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp15 = A[15]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp16 = A[16]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp17 = A[17]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp18 = A[18]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp19 = A[19]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp20 = A[20]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp21 = A[21]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp22 = A[22]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp23 = A[23]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp24 = A[24]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp25 = A[25]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp26 = A[26]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp27 = A[27]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp28 = A[28]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp29 = A[29]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp30 = A[30]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp31 = A[31]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp32 = A[32]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp33 = A[33]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp34 = A[34]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp35 = A[35]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp36 = A[36]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp37 = A[37]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp38 = A[38]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp39 = A[39]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp40 = A[40]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp41 = A[41]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp42 = A[42]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp43 = A[43]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp44 = A[44]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp45 = A[45]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
    assign pp46 = A[46]?"
N/A,N/A,-1,97.0,1,"//Please finish designing the 64 bit multiplier module (multiplier_64) below.
//There are two 64 bit inputs (A and B) and a 128 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_64(output [127:0] product, input [63:0] A, B);

	/* Please fill in the implementation here... */
	genvar i;
	generate
		for (i = 0; i < 64; i = i + 1) begin: mul_digit
			assign product[(8 * i) + 7:8 * i] = mul_digit[i].A * mul_digit[i].B;
		end
	endgenerate

endmodule"
N/A,N/A,-1,98.0,1,"//Please finish designing the 64 bit multiplier module (multiplier_64) below.
//There are two 64 bit inputs (A and B) and a 128 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_64(output [127:0] product, input [63:0] A, B);
    /*
        Group Members: Kevin Ingram and Warren Seto

        Lab Name: Combinational Circuit Design
        Project Name: eng312_proj2
        Design Name: multiplier_64.v
        Design Description: Verilog Module to implement a 64 bit multiplier
    */
    
    //64 bit input A and B
    
    //128 bit output product
    
    //64 bit intermediate product
    
    //32 bit intermediate A and B
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
    //32 bit intermediate product
    
"
N/A,N/A,-0.1,99.0,1,"//Please finish designing the 64 bit multiplier module (multiplier_64) below.
//There are two 64 bit inputs (A and B) and a 128 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_64(output [127:0] product, input [63:0] A, B);
    /* Write your code here */
    genvar i;
    generate
        for(i = 0; i < 64; i = i + 1) begin
            assign product[(i+1)*8 - 1 -: 8] = A[i]? B: 64'b0000000000000000000000000000000000000000000000000000000000000000;
        end
    endgenerate
    /* Write your code here */
endmodule"
N/A,N/A,-0.1,100.0,1,"//Please finish designing the 64 bit multiplier module (multiplier_64) below.
//There are two 64 bit inputs (A and B) and a 128 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_64(output [127:0] product, input [63:0] A, B);
    /*
        Implement a 64 bit multiplier with a 128 bit output.
        The output should be the same as the following:
        assign product = A * B;
    */
    assign product[63:0] = A * B;
    assign product[127:64] = 0;
endmodule"
N/A,N/A,-1,101.0,1,"//Please finish designing the 64 bit multiplier module (multiplier_64) below.
//There are two 64 bit inputs (A and B) and a 128 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_64(output [127:0] product, input [63:0] A, B);
	/* Write your code here */
	genvar i;
	generate
		for (i = 0; i < 64; i = i + 1) begin: mul_digit
			assign product[(8 * i) + 7:8 * i] = mul_digit[i].A * mul_digit[i].B;
		end
	endgenerate
	/* Write your code here */
endmodule"
