Area,Delay,Score,Current Run,Episode,Verilog
N/A,N/A,-1,2.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Use FSM from Fsm_serial

// New: Datapath to latch input bits.

endmodule"
N/A,N/A,-1,3.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    // Use FSM from Fsm_serial
    // New: Datapath to latch input bits.
    
    parameter idle = 4'd0, start = 4'd1, trans0 = 4'd2, trans1 = 4'd3, trans2 = 4'd4, trans3 = 4'd5;
    parameter trans4 = 4'd6, trans5 = 4'd7, trans6 = 4'd8, trans7 = 4'd9, stop = 4'd10, error = 4'd11, pari = 4'd12;
    reg [3:0] state, next_state;
    
    always @(*) begin
        state <= next_state;
    end
    
    always @(posedge clk) begin
        if(reset)
            next_state <= idle;
        else
            case(state)
                idle:
                    if(~in)
                        next_state <= start;
                start:
                    if(in)
                        next_state <= trans0;
                trans0:
                    if(~in)
                        next_state <= trans1;
                trans1:
                    if(~in)
                        next_state <= trans2;
                trans2:
                    if(~in)
                        next_state <= trans3;
                trans3:
                    if(~in)
                        next_state <= trans4;
                trans4:
                    if(~in)
                        next_state <= trans5;
                trans5:
                    if(~in)
                        next_state <= trans6;
                trans6:
                    if(~in)
                        next_state <= trans7;
                trans7:
                    if(~in)
                        next_state <= pari;
                pari:
                    if(in)
                        next_state <= idle;
                default:
                    next_state <= idle;
            endcase
    end
    
    assign done = (state == stop);
    
    // New: Datapath to latch input bits.
    reg [7:0] out;
    always @(posedge clk) begin
        if(state == trans0 || state == trans1 || state == trans2 || state == trans3 || state == trans4 || state == trans5 || state == trans6 || state == trans7)
            out <= {in, out[7:1]};
        else
            out <= out;
    end
    
    assign out_byte = out;
    
endmodule"
N/A,N/A,-1,4.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Modify FSM and datapath from Fsm_serial

// New: Latch input bits.

endmodule"
N/A,N/A,-1,5.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

// Define states
localparam
    idle = 0,
    start = 1,
    data = 2,
    stop = 3,
    last = 4;

reg [1:0] state, next_state;
reg [3:0] counter;
reg [7:0] data_reg;
reg [7:0] out;
reg done_reg;

// New: Datapath to latch input bits.
// New: Output byte stream

always @(posedge clk) begin
    if(reset)
        state <= idle;
    else
        state <= next_state;
end

always @(*) begin
    case(state)
        idle: begin
            if(~in)
                next_state = start;
            else
                next_state = idle;
        end
        start: begin
            if(counter == 7)
                next_state = data;
            else
                next_state = start;
        end
        data: begin
            if(counter == 15)
                next_state = stop;
            else
                next_state = data;
        end
        stop: begin
            if(counter == 7)
                next_state = last;
            else
                next_state = stop;
        end
        last: begin
            if(counter == 7)
                next_state = idle;
            else
                next_state = last;
        end
        default: next_state = idle;
    endcase
end

always @(posedge clk) begin
    if(state == data)
        counter <= counter + 1;
    else
        counter <= 0;
end

always @(posedge clk) begin
    if(state == stop) begin
        data_reg <= {data_reg[6:0], in};
    end
end

always @(posedge clk) begin
    if(state == last) begin
        out <= data_reg;
        done_reg <= 1;
    end
    else
        done_reg <= 0;
end

assign out_byte = out;
assign done = done_reg;

endmodule"
N/A,N/A,-1,6.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Use FSM from Fsm_serial

endmodule"
N/A,N/A,-1,7.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serial
    
    parameter idle = 0, rec_data = 1, stop_bit = 2;
    reg [1:0] state, next_state;
    
    always @(*) begin
        state <= next_state;
    end
    
    always @(posedge clk) begin
        if(reset)
            next_state <= idle;
        else
            begin
                case(state)
                    idle:
                        begin
                            if(~in)
                                next_state <= rec_data;
                            else
                                next_state <= idle;
                        end
                    rec_data:
                        begin
                            if(~in)
                                next_state <= stop_bit;
                            else
                                next_state <= rec_data;
                        end
                    stop_bit:
                        begin
                            if(in)
                                next_state <= idle;
                            else
                                next_state <= rec_data;
                        end
                    default:
                        next_state <= idle;
                endcase
            end
    end
    
    assign done = (state == stop_bit);
    
    // New: Datapath to latch input bits.
    
    reg [7:0] out;
    
    always @(posedge clk) begin
        if(state == rec_data)
            out <= {out[6:0], in};
    end
    
    assign out_byte = out;
    
endmodule"
N/A,N/A,-1,8.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serial
    // New: Datapath to latch input bits.
    
    reg [2:0] state, next_state;
    reg [7:0] out_byte_reg;
    reg done_reg;
    
    always @(*) begin
        state <= next_state;
    end
    
    always @(posedge clk) begin
        if(reset) begin
            out_byte_reg <= 0;
            done_reg <= 0;
        end
        else begin
            out_byte_reg <= out_byte;
            done_reg <= done;
        end
    end
    
    always @(*) begin
        next_state = state;
        case (state)
            3'b000: begin
                if(in)
                    next_state = 3'b001;
            end
            3'b001: begin
                if(in)
                    next_state = 3'b010;
            end
            3'b010: begin
                if(in)
                    next_state = 3'b011;
            end
            3'b011: begin
                if(in)
                    next_state = 3'b100;
            end
            3'b100: begin
                if(in)
                    next_state = 3'b101;
            end
            3'b101: begin
                if(in)
                    next_state = 3'b110;
            end
            3'b110: begin
                if(in)
                    next_state = 3'b111;
            end
            3'b111: begin
                if(~in)
                    next_state = 3'b000;
            end
            default: begin
                next_state = 3'b000;
            end
        endcase
    end
    
    assign done = (state == 3'b111)? 1 : 0;
    assign out_byte = out_byte_reg;
    
endmodule"
N/A,N/A,-1,9.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serial
    // New: Datapath to latch input bits.
    
    reg [2:0] state, next_state;
    reg [7:0] out_byte_reg;
    reg done_reg;
    
    always @(*) begin
        state <= next_state;
    end
    
    always @(posedge clk) begin
        if(reset) begin
            out_byte_reg <= 0;
            done_reg <= 0;
        end
        else begin
            out_byte_reg <= out_byte;
            done_reg <= done;
        end
    end
    
    always @(*) begin
        next_state = state;
        case (state)
            3'b000: begin
                if(in)
                    next_state = 3'b001;
            end
            3'b001: begin
                if(in)
                    next_state = 3'b010;
            end
            3'b010: begin
                if(in)
                    next_state = 3'b011;
            end
            3'b011: begin
                if(in)
                    next_state = 3'b100;
            end
            3'b100: begin
                if(in)
                    next_state = 3'b101;
            end
            3'b101: begin
                if(in)
                    next_state = 3'b110;
            end
            3'b110: begin
                if(in)
                    next_state = 3'b111;
            end
            3'b111: begin
                if(~in)
                    next_state = 3'b000;
            end
            default: begin
                next_state = 3'b000;
            end
        endcase
    end
    
    assign done = (state == 3'b111)? 1 : 0;
    assign out_byte = out_byte_reg;
    
endmodule"
N/A,N/A,-1,10.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serial
    
    parameter idle = 0, rec_data = 1, stop_bit = 2, overflow = 3;
    reg [1:0] state, next_state;
    reg [3:0] count;
    reg [7:0] rec_data_reg;
    reg [7:0] out_byte_reg;
    reg done_reg;
    
    always @(*) begin
        case (state)
            idle: begin
                if(~in)
                    next_state = rec_data;
                else
                    next_state = idle;
            end
            rec_data: begin
                if(count == 7)
                    next_state = stop_bit;
                else
                    next_state = rec_data;
            end
            stop_bit: begin
                if(in)
                    next_state = idle;
                else
                    next_state = overflow;
            end
            overflow: begin
                if(count == 7)
                    next_state = idle;
                else
                    next_state = overflow;
            end
            default: next_state = idle;
        endcase
    end
    
    always @(posedge clk) begin
        if(reset) begin
            state <= idle;
            count <= 0;
            rec_data_reg <= 0;
            out_byte_reg <= 0;
            done_reg <= 0;
        end
        else begin
            state <= next_state;
            case (next_state)
                idle: begin
                    count <= 0;
                    done_reg <= 0;
                end
                rec_data: begin
                    rec_data_reg[7] <= in;
                    count <= count + 1;
                end
                stop_bit: begin
                    out_byte_reg <= rec_data_reg;
                    done_reg <= 1;
                end
                overflow: begin
                    done_reg <= 1;
                end
            endcase
        end
    end
    
    assign done = done_reg;
    assign out_byte = out_byte_reg;
    
endmodule"
N/A,N/A,-1,11.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serial
    
    // New: Datapath to latch input bits.
    
    reg [7:0] out_byte_reg;
    
    always @(posedge clk) begin
        if(reset)
            out_byte_reg <= 0;
        else begin
            if(in)
                out_byte_reg <= {out_byte_reg[6:0], 1'b0};
            else
                out_byte_reg <= out_byte_reg;
        end
    end
    
    assign done = (out_byte_reg == 8'h0);
    assign out_byte = done? out_byte_reg : out_byte_reg + 8'h01;
    
endmodule"
N/A,N/A,-1,12.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Use FSM from Fsm_serial

// New: Datapath to latch input bits.

// Define states

// New: Datapath to latch input bits.

endmodule"
N/A,N/A,-1,13.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    // Use FSM from Fsm_serial
    // New: Datapath to latch input bits.
    
    reg [2:0] state, next_state;
    reg [7:0] out;
    reg out_bit;
    
    always @(*) begin
        state <= next_state;
    end
    
    always @(posedge clk) begin
        if(reset) begin
            out <= 0;
            out_bit <= 0;
            done <= 0;
        end
        else begin
            if(state == 0) begin
                out_bit <= in;
                out <= 0;
                next_state <= 1;
            end
            else if(state == 1) begin
                out_bit <= out[0];
                out <= {out[6:0], out_bit};
                next_state <= 2;
            end
            else if(state == 2) begin
                out_bit <= out[7];
                out <= {out[6:0], out_bit};
                done <= 1;
                next_state <= 0;
            end
        end
    end
endmodule"
N/A,N/A,-1,14.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    // Use FSM from Fsm_serial
    // New: Datapath to latch input bits.
    
    reg [2:0] state, next_state;
    reg [7:0] out;
    reg out_bit;
    
    always @(*) begin
        state <= next_state;
    end
    
    always @(posedge clk) begin
        if(reset) begin
            out <= 0;
            out_bit <= 0;
            done <= 0;
        end
        else begin
            if(state == 0) begin
                out_bit <= in;
                out <= 0;
                next_state <= 1;
            end
            else if(state == 1) begin
                out_bit <= out[0];
                out <= {out[6:0], out_bit};
                next_state <= 2;
            end
            else if(state == 2) begin
                out_bit <= out[7];
                out <= {out[6:0], out_bit};
                done <= 1;
                next_state <= 0;
            end
        end
    end
endmodule"
N/A,N/A,-1,15.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Use FSM from Fsm_serial

// New: Datapath to latch input bits.

endmodule"
N/A,N/A,-1,16.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

// Define states
localparam
    IDLE = 0,
    GET_BIT = 1;

// Define state transitions
localparam
    S0 = IDLE,
    S1 = GET_BIT;

// Define state register
reg [1:0] state;

// Define output signals
wire bit_clk;
wire [7:0] byte;

// Instantiate FSM
fsm_serial fsm_serial_unit (
  .clk(clk),
  .reset(reset),
  .in(in),
  .out_byte(byte),
  .done(done),
  .bit_clk(bit_clk)
);

// Instantiate datapath
datapath dpath_unit (
  .clk(clk),
  .reset(reset),
  .in(in),
  .bit_clk(bit_clk),
  .byte(byte),
  .out_byte(out_byte)
);

// Instantiate state register
always @(posedge clk) begin
    if (reset) begin
        state <= IDLE;
    end else begin
        state <= S1;
    end
end

// Define state transition logic
always @(*) begin
    case (state)
        IDLE: begin
            if (in) state <= S1;
        end
        GET_BIT: begin
            if (done) state <= IDLE;
        end
    endcase
end

endmodule"
N/A,N/A,-1,17.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

// Define states
localparam
    IDLE = 0,
    GET_BIT = 1;

// Define state transitions
localparam
    S0 = IDLE,
    S1 = GET_BIT;

// Define state register
reg [1:0] state;

// Define output signals
wire bit_clk;
wire [7:0] byte;

// Instantiate FSM
fsm_serial fsm_serial_unit (
  .clk(clk),
  .reset(reset),
  .in(in),
  .out_byte(byte),
  .done(done),
  .bit_clk(bit_clk)
);

// Instantiate datapath
datapath dpath_unit (
  .clk(clk),
  .reset(reset),
  .in(in),
  .bit_clk(bit_clk),
  .byte(byte),
  .out_byte(out_byte)
);

// Instantiate state register
always @(posedge clk) begin
    if (reset) begin
        state <= IDLE;
    end else begin
        state <= S1;
    end
end

// Define state transition logic
always @(*) begin
    case (state)
        IDLE: begin
            if (in) state <= S1;
        end
        GET_BIT: begin
            if (done) state <= IDLE;
        end
    endcase
end

endmodule"
N/A,N/A,-1,18.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serial
    
    // New: Datapath to latch input bits.
    
    reg [7:0] out_byte_reg;
    
    always @(posedge clk) begin
        if(reset)
            out_byte_reg <= 0;
        else begin
            if(in)
                out_byte_reg <= {out_byte_reg[6:0], 1'b0};
            else
                out_byte_reg <= out_byte_reg;
        end
    end
    
    assign done = (in && out_byte_reg == 8'b11000000)? 1 : 0;
    
    assign out_byte = out_byte_reg;
    
endmodule"
N/A,N/A,-1,19.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Use FSM from Fsm_serial

endmodule"
N/A,N/A,-1,20.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serial
    // New: Latch input bits.
    
    reg [2:0] state, next_state;
    reg [7:0] out;
    reg done_reg;
    
    always @(*) begin
        case (state)
            3'b000: begin
                if(~in)
                    next_state = 3'b001;
                else
                    next_state = 3'b000;
            end
            3'b001: begin
                if(in)
                    next_state = 3'b010;
                else
                    next_state = 3'b000;
            end
            3'b010: begin
                if(in)
                    next_state = 3'b011;
                else
                    next_state = 3'b000;
            end
            3'b011: begin
                if(in)
                    next_state = 3'b100;
                else
                    next_state = 3'b000;
            end
            3'b100: begin
                if(in)
                    next_state = 3'b101;
                else
                    next_state = 3'b000;
            end
            3'b101: begin
                if(in)
                    next_state = 3'b110;
                else
                    next_state = 3'b000;
            end
            3'b110: begin
                if(in)
                    next_state = 3'b111;
                else
                    next_state = 3'b000;
            end
            3'b111: begin
                if(~in)
                    next_state = 3'b000;
                else
                    next_state = 3'b111;
            end
            default: begin
                next_state = 3'b000;
            end
        endcase
    end
    
    always @(posedge clk) begin
        if(reset) begin
            state <= 3'b000;
            done_reg <= 1'b0;
        end
        else begin
            state <= next_state;
            done_reg <= (next_state == 3'b111);
            out <= 8'b0;
            if(next_state == 3'b111)
                out[7:1] <= in;
        end
    end
    
    assign done = done_reg;
    assign out_byte = out;
    
endmodule"
N/A,N/A,-1,21.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serial
    
    parameter idle = 0, rec_data = 1, stop_bit = 2, error = 3;
    reg [2:0] state, next_state;
    
    always @(*) begin
        case (state)
            idle: begin
                if(~in)
                    next_state = rec_data;
                else
                    next_state = idle;
            end
            rec_data: begin
                if(~in)
                    next_state = stop_bit;
                else
                    next_state = rec_data;
            end
            stop_bit: begin
                if(in)
                    next_state = idle;
                else
                    next_state = error;
            end
            error: begin
                if(in)
                    next_state = idle;
                else
                    next_state = error;
            end
        endcase
    end
    
    always @(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    assign done = (state == stop_bit);
    
    // New: Datapath to latch input bits.
    reg [7:0] out_byte_reg;
    always @(posedge clk) begin
        if(reset)
            out_byte_reg <= 0;
        else begin
            if(state == rec_data)
                out_byte_reg <= {out_byte_reg[6:0], in};
        end
    end
    assign out_byte = out_byte_reg;
    
endmodule"
N/A,N/A,-1,22.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serial
    
    parameter idle = 0, rec_data = 1, stop_bit = 2, error = 3;
    reg [2:0] state, next_state;
    
    always @(*) begin
        case (state)
            idle: begin
                if(~in)
                    next_state = rec_data;
                else
                    next_state = idle;
            end
            rec_data: begin
                if(~in)
                    next_state = stop_bit;
                else
                    next_state = rec_data;
            end
            stop_bit: begin
                if(in)
                    next_state = idle;
                else
                    next_state = error;
            end
            error: begin
                if(in)
                    next_state = idle;
                else
                    next_state = error;
            end
        endcase
    end
    
    always @(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    assign done = (state == stop_bit);
    
    // New: Datapath to latch input bits.
    reg [7:0] out_byte_reg;
    always @(posedge clk) begin
        if(reset)
            out_byte_reg <= 0;
        else begin
            if(state == rec_data)
                out_byte_reg <= {out_byte_reg[6:0], in};
        end
    end
    assign out_byte = out_byte_reg;
    
endmodule"
N/A,N/A,-1,23.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    // Use FSM from Fsm_serial
    // New: Datapath to latch input bits.
    
    parameter idle = 0, rec_data = 1, stop_bit = 2, error = 3;
    reg [2:0] state, next_state;
    reg [7:0] rec_data_reg;
    reg [3:0] counter;
    reg out_bit;
    
    always @(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    always @(*) begin
        case(state)
            idle: begin
                if(~in)
                    next_state = rec_data;
                else
                    next_state = idle;
            end
            rec_data: begin
                if(counter == 7)
                    next_state = stop_bit;
                else
                    next_state = rec_data;
            end
            stop_bit: begin
                if(in)
                    next_state = idle;
                else
                    next_state = error;
            end
            error: begin
                if(in)
                    next_state = idle;
                else
                    next_state = error;
            end
        endcase
    end
    
    always @(posedge clk) begin
        if(state == rec_data) begin
            rec_data_reg[7] <= in;
            rec_data_reg[6] <= rec_data_reg[7];
            rec_data_reg[5] <= rec_data_reg[6];
            rec_data_reg[4] <= rec_data_reg[5];
            rec_data_reg[3] <= rec_data_reg[4];
            rec_data_reg[2] <= rec_data_reg[3];
            rec_data_reg[1] <= rec_data_reg[2];
            rec_data_reg[0] <= rec_data_reg[1];
        end
    end
    
    assign out_byte = rec_data_reg;
    
    always @(posedge clk) begin
        if(state == stop_bit) begin
            done <= 1'b1;
            out_bit <= rec_data_reg[0];
        end
        else begin
            done <= 1'b0;
            out_bit <= 1'b0;
        end
    end
    
    always @(posedge clk) begin
        if(state == rec_data && counter < 7)
            counter <= counter + 1;
        else
            counter <= 0;
    end
    
endmodule"
N/A,N/A,-1,24.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Modify FSM and datapath from Fsm_serial

// New: Latch input bits.

endmodule"
N/A,N/A,-1,25.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Use FSM from Fsm_serial

endmodule"
N/A,N/A,-1,26.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Use FSM from Fsm_serial

// New: Datapath to latch input bits.

endmodule"
N/A,N/A,-1,27.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serial
    
    parameter idle = 0, rec_data = 1, stop_bit = 2;
    reg [1:0] state, next_state;
    reg [3:0] counter;
    reg out;
    
    always @(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    always @(*) begin
        case(state)
            idle:
                begin
                    if(~in)
                        next_state = rec_data;
                    else
                        next_state = idle;
                end
            rec_data:
                begin
                    if(counter == 8)
                        next_state = stop_bit;
                    else
                        next_state = rec_data;
                end
            stop_bit:
                begin
                    if(in)
                        next_state = idle;
                    else
                        next_state = rec_data;
                end
            default:
                next_state = idle;
        endcase
    end
    
    always @(posedge clk) begin
        if(state == rec_data && counter < 8)
            counter <= counter + 1;
        else
            counter <= 0;
    end
    
    always @(posedge clk) begin
        if(state == stop_bit)
            out <= in;
        else
            out <= 1'b0;
    end
    
    assign done = (state == stop_bit)? 1 : 0;
    
    assign out_byte = (state == rec_data)? {out, out_byte[7:1]} : out_byte;
    
endmodule"
N/A,N/A,-1,28.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serial
    
    parameter idle = 0, rec_data = 1, stop_bit = 2, error = 3;
    reg [2:0] state, next_state;
    reg [3:0] counter;
    reg out;
    reg [7:0] rec_data_byte;
    
    always @(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    always @(*) begin
        case(state)
            idle: begin
                if(~in)
                    next_state = rec_data;
                else
                    next_state = idle;
            end
            
            rec_data: begin
                if(counter == 8)
                    next_state = stop_bit;
                else
                    next_state = rec_data;
            end
            
            stop_bit: begin
                if(in)
                    next_state = idle;
                else
                    next_state = error;
            end
            
            error: begin
                if(in)
                    next_state = idle;
                else
                    next_state = error;
            end
        endcase
    end
    
    always @(posedge clk) begin
        if(state == rec_data && counter < 8)
            rec_data_byte[7:0] <= rec_data_byte[6:0];
        if(state == stop_bit && in)
            rec_data_byte[7:0] <= rec_data_byte[7:0] ^ 0x01;
    end
    
    assign done = (state == stop_bit) && (next_state == idle);
    
    assign out_byte = rec_data_byte;
    
    always @(posedge clk) begin
        if(state == rec_data)
            counter <= counter + 1;
        else
            counter <= 0;
    end
    
endmodule"
N/A,N/A,-1,29.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Use FSM from Fsm_serial

// New: Datapath to latch input bits.

endmodule"
N/A,N/A,-1,30.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serial
    // New: Datapath to latch input bits.
    
    reg [2:0] state, next_state;
    reg [7:0] out;
    reg done_reg;
    
    always @(*) begin
        state <= next_state;
    end
    
    always @(posedge clk) begin
        if(reset) begin
            out <= 0;
            done_reg <= 0;
        end
        else begin
            if(state == 3'b101) begin
                out <= out_byte;
                done_reg <= 1;
            end
            else begin
                out <= out;
                done_reg <= 0;
            end
        end
    end
    
    always @(*) begin
        next_state = state;
        case (state)
            3'b000: begin
                if(in) next_state = 3'b001;
            end
            3'b001: begin
                if(in) next_state = 3'b010;
            end
            3'b010: begin
                if(in) next_state = 3'b011;
            end
            3'b011: begin
                if(in) next_state = 3'b100;
            end
            3'b100: begin
                if(~in) next_state = 3'b000;
            end
            3'b101: begin
                if(~in) next_state = 3'b010;
            end
            3'b110: begin
                if(~in) next_state = 3'b011;
            end
            3'b111: begin
                if(~in) next_state = 3'b100;
            end
        endcase
    end
    
    assign done = done_reg;
    
endmodule"
N/A,N/A,-1,31.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serial
    // New: Datapath to latch input bits.
    
    reg [2:0] state, next_state;
    reg [7:0] out;
    reg done_reg;
    
    always @(*) begin
        state <= next_state;
    end
    
    always @(posedge clk) begin
        if(reset) begin
            out <= 0;
            done_reg <= 0;
        end
        else begin
            if(state == 3'b101) begin
                out <= out_byte;
                done_reg <= 1;
            end
            else begin
                out <= out;
                done_reg <= 0;
            end
        end
    end
    
    always @(*) begin
        next_state = state;
        case (state)
            3'b000: begin
                if(in) next_state = 3'b001;
            end
            3'b001: begin
                if(in) next_state = 3'b010;
            end
            3'b010: begin
                if(in) next_state = 3'b011;
            end
            3'b011: begin
                if(in) next_state = 3'b100;
            end
            3'b100: begin
                if(~in) next_state = 3'b000;
            end
            3'b101: begin
                if(~in) next_state = 3'b010;
            end
            3'b110: begin
                if(~in) next_state = 3'b011;
            end
            3'b111: begin
                if(~in) next_state = 3'b100;
            end
        endcase
    end
    
    assign done = done_reg;
    
endmodule"
N/A,N/A,-1,32.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Use FSM from Fsm_serial

// New: Datapath to latch input bits.

// Define states

parameter idle = 0, rec_data = 1, stop_bit = 2, overflow = 3;

reg [1:0] state, next_state;
reg [3:0] counter;
reg [7:0] in_byte;
reg out_byte_en;

assign done = (state == stop_bit);

always @(posedge clk) begin
    if(reset)
        state <= idle;
    else
        state <= next_state;
end

always @(*) begin
    case(state)
        idle: begin
            if(~in)
                next_state = rec_data;
            else
                next_state = idle;
        end
        rec_data: begin
            if(counter == 8)
                next_state = stop_bit;
            else
                next_state = rec_data;
        end
        stop_bit: begin
            if(~in)
                next_state = overflow;
            else
                next_state = idle;
        end
        overflow: begin
            next_state = idle;
        end
    endcase
end

always @(posedge clk) begin
    if(state == rec_data)
        counter <= counter + 4'd1;
    else
        counter <= 4'd0;
end

always @(posedge clk) begin
    if(state == rec_data && counter == 8)
        in_byte <= {in, in_byte[7:1]};
end

always @(posedge clk) begin
    if(state == stop_bit && ~in)
        out_byte_en <= 1;
    else
        out_byte_en <= 0;
end

assign out_byte = out_byte_en? in_byte : 8'd0;

endmodule"
N/A,N/A,-1,33.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    // Use FSM from Fsm_serial
    // New: Datapath to latch input bits.
    
    reg [3:0] state;
    reg [3:0] next_state;
    reg [7:0] out;
    reg out_bit;
    
    parameter idle = 4'd0, start = 4'd1, trans0 = 4'd2, trans1 = 4'd3, trans2 = 4'd4, trans3 = 4'd5;
    parameter trans4 = 4'd6, trans5 = 4'd7, trans6 = 4'd8, trans7 = 4'd9, stop = 4'd10, error = 4'd11, pari = 4'd12;
    
    always @(*) begin
        next_state = state;
        case (state)
            idle: begin
                if(~in)
                    next_state = start;
            end
            start: 
                if(in)
                    next_state = trans0;
            trans0:
                if(~in)
                    next_state = trans1;
            trans1:
                if(~in)
                    next_state = trans2;
            trans2:
                if(~in)
                    next_state = trans3;
            trans3:
                if(~in)
                    next_state = trans4;
            trans4:
                if(~in)
                    next_state = trans5;
            trans5:
                if(~in)
                    next_state = trans6;
            trans6:
                if(~in)
                    next_state = trans7;
            trans7:
                if(~in)
                    next_state = pari;
            pari: begin
                if(in)
                    next_state = idle;
            end
            default: next_state = idle;
        endcase
    end
    
    always @(posedge clk) begin
        if(reset) begin
            state <= idle;
            out <= 8'd0;
            out_bit <= 1'b0;
        end
        else begin
            state <= next_state;
            case (next_state)
                start: begin
                    out <= 8'd0;
                    out_bit <= 1'b0;
                end
                trans0: begin
                    out[0] <= in;
                end
                trans1: begin
                    out[1] <= in;
                end
                trans2: begin
                    out[2] <= in;
                end
                trans3: begin
                    out[3] <= in;
                end
                trans4: begin
                    out[4] <= in;
                end
                trans5: begin
                    out[5] <= in;
                end
                trans6: begin
                    out[6] <= in;
                end
                trans7: begin
                    out[7] <= in;
                end
                pari: begin
                    out_bit <= in;
                end
            endcase
        end
    end
    
    assign done = (state == stop);
    assign out_byte = out;
endmodule"
N/A,N/A,-1,34.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Modify FSM and datapath from Fsm_serial

reg [2:0] state, next_state;
reg [7:0] out_byte;
reg done;

always @(*) begin
    case (state)
        3'b000: begin
            if(~in)
                next_state = 3'b001;
            else
                next_state = 3'b000;
        end
        3'b001: begin
            if(in)
                next_state = 3'b010;
            else
                next_state = 3'b000;
        end
        3'b010: begin
            if(in)
                next_state = 3'b011;
            else
                next_state = 3'b000;
        end
        3'b011: begin
            if(in)
                next_state = 3'b100;
            else
                next_state = 3'b000;
        end
        3'b100: begin
            if(in)
                next_state = 3'b101;
            else
                next_state = 3'b000;
        end
        3'b101: begin
            if(in)
                next_state = 3'b110;
            else
                next_state = 3'b000;
        end
        3'b110: begin
            if(in)
                next_state = 3'b111;
            else
                next_state = 3'b000;
        end
        3'b111: begin
            if(~in)
                next_state = 3'b000;
            else
                next_state = 3'b111;
        end
        default: begin
            next_state = 3'b000;
        end
    endcase
end

always @(posedge clk) begin
    if(reset) begin
        state <= 3'b000;
        done <= 1'b0;
    end
    else begin
        state <= next_state;
        done <= 1'b0;
        case (next_state)
            3'b000: begin
                out_byte <= 8'b00000000;
            end
            3'b001: begin
                out_byte <= 8'b00000001;
            end
            3'b010: begin
                out_byte <= 8'b00000010;
            end
            3'b011: begin
                out_byte <= 8'b00000011;
            end
            3'b100: begin
                out_byte <= 8'b00000100;
            end
            3'b101: begin
                out_byte <= 8'b00000101;
            end
            3'b110: begin
                out_byte <= 8'b00000110;
            end
            3'b111: begin
                out_byte <= 8'b00000111;
            end
        endcase
    end
end

endmodule"
N/A,N/A,-1,35.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Use FSM from Fsm_serial

// New: Datapath to latch input bits.

endmodule"
N/A,N/A,-1,36.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Use FSM from Fsm_serial

endmodule"
N/A,N/A,-1,37.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serial
    // New: Datapath to latch input bits.
    
    parameter idle = 0, rec_data = 1, stop_bit = 2, error = 3;
    reg [2:0] state, next_state;
    
    always @(*) begin
        state <= next_state;
    end
    
    always @(posedge clk) begin
        if(reset)
            next_state <= idle;
        else
            begin
                case (state)
                    idle:
                        begin
                            if(~in)
                                next_state <= rec_data;
                            else
                                next_state <= idle;
                        end
                    rec_data:
                        begin
                            if(in)
                                next_state <= stop_bit;
                            else
                                next_state <= rec_data;
                        end
                    stop_bit:
                        begin
                            if(in)
                                next_state <= idle;
                            else
                                next_state <= error;
                        end
                    error:
                        next_state <= idle;
                endcase
            end
    end
    
    assign done = (state == stop_bit);
    
    // New: Datapath to latch input bits.
    reg [7:0] out_byte_reg;
    always @(posedge clk) begin
        if(state == rec_data)
            out_byte_reg <= {out_byte_reg[6:0], in};
    end
    assign out_byte = out_byte_reg;
    
endmodule"
N/A,N/A,-1,38.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serial
    
    parameter idle = 0, rec_data = 1, stop_bit = 2;
    reg [1:0] state, next_state;
    reg [3:0] counter;
    reg out;
    
    always @(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    always @(*) begin
        case (state)
            idle: begin
                if(~in)
                    next_state = rec_data;
                else
                    next_state = idle;
            end
            
            rec_data: begin
                if(counter == 8)
                    next_state = stop_bit;
                else
                    next_state = rec_data;
            end
            
            stop_bit: begin
                if(in)
                    next_state = idle;
                else
                    next_state = rec_data;
            end
            
            default: next_state = idle;
        endcase
    end
    
    always @(posedge clk) begin
        if(state == rec_data && counter < 8)
            counter <= counter + 1;
        else
            counter <= 0;
    end
    
    always @(posedge clk) begin
        if(state == stop_bit)
            out <= in;
        else
            out <= 1'b0;
    end
    
    assign done = (state == stop_bit)? 1 : 0;
    
    assign out_byte = (state == rec_data)? {out, out, out, out, out, out, out, out} : 8'h00;
    
endmodule"
N/A,N/A,-1,39.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Use FSM from Fsm_serial

endmodule"
N/A,N/A,-1,40.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serial
    // New: Datapath to latch input bits.
    
    reg [2:0] state, next_state;
    reg [7:0] out;
    reg [3:0] counter;
    reg done_reg;
    
    localparam IDLE = 3'd0;
    localparam GET_BIT = 3'd1;
    localparam WAIT_FOR_STOP_BIT = 3'd2;
    localparam VERIFY_STOP_BIT = 3'd3;
    localparam OUTPUT_BYTE = 3'd4;
    
    always @(*) begin
        case (state)
            IDLE: begin
                if(~in)
                    next_state = GET_BIT;
                else
                    next_state = IDLE;
            end
            GET_BIT: begin
                if(counter == 4'd15)
                    next_state = WAIT_FOR_STOP_BIT;
                else
                    next_state = GET_BIT;
            end
            WAIT_FOR_STOP_BIT: begin
                if(~in)
                    next_state = VERIFY_STOP_BIT;
                else
                    next_state = WAIT_FOR_STOP_BIT;
            end
            VERIFY_STOP_BIT: begin
                if(in)
                    next_state = OUTPUT_BYTE;
                else
                    next_state = IDLE;
            end
            OUTPUT_BYTE: begin
                if(counter == 4'd8)
                    next_state = IDLE;
                else
                    next_state = OUTPUT_BYTE;
            end
            default: next_state = IDLE;
        endcase
    end
    
    always @(posedge clk) begin
        if(reset) begin
            state <= IDLE;
            out <= 8'd0;
            done_reg <= 1'b0;
            counter <= 4'd0;
        end
        else begin
            state <= next_state;
            case (next_state)
                IDLE: begin
                    out <= 8'd0;
                    done_reg <= 1'b0;
                    counter <= 4'd0;
                end
                GET_BIT: begin
                    out <= {out, in};
                    counter <= counter + 4'd1;
                end
                WAIT_FOR_STOP_BIT: begin
                    out <= out;
                    counter <= counter + 4'd1;
                end
                VERIFY_STOP_BIT: begin
                    done_reg <= 1'b1;
                    counter <= counter + 4'd1;
                end
                OUTPUT_BYTE: begin
                    out_byte <= out;
                    counter <= counter + 4'd1;
                end
                default: begin
                    out <= 8'd0;
                    done_reg <= 1'b0;
                    counter <= 4'd0;
                end
            endcase
        end
    end
    
    assign done = done_reg;
    
endmodule"
N/A,N/A,-1,41.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serial
    // New: Datapath to latch input bits.
    
    reg [2:0] state, next_state;
    reg [3:0] count;
    reg [7:0] out;
    reg out_bit;
    
    localparam IDLE = 3'd0;
    localparam START = 3'd1;
    localparam DATA = 3'd2;
    localparam STOP = 3'd3;
    localparam CLEANUP = 3'd4;
    
    always @(*) begin
        case (state)
            IDLE: begin
                if (in)
                    next_state = START;
                else
                    next_state = IDLE;
            end
            
            START: begin
                next_state = DATA;
            end
            
            DATA: begin
                if(count < 4'd8)
                    next_state = DATA;
                else
                    next_state = STOP;
            end
            
            STOP: begin
                next_state = CLEANUP;
            end
            
            CLEANUP: begin
                if(count < 4'd8)
                    next_state = CLEANUP;
                else
                    next_state = IDLE;
            end
            
            default: next_state = IDLE;
        endcase
    end
    
    always @(posedge clk) begin
        if(reset)
            state <= IDLE;
        else
            state <= next_state;
    end
    
    always @(posedge clk) begin
        if(state == START)
            out_bit <= in;
        else if(state == DATA)
            out_bit <= out_bit;
        else if(state == STOP)
            out_bit <= 1'b0;
    end
    
    always @(posedge clk) begin
        if(state == START)
            count <= 4'd0;
        else if(state == DATA)
            count <= count + 4'd1;
        else if(state == STOP)
            count <= count + 4'd1;
    end
    
    always @(posedge clk) begin
        if(state == START)
            out <= 8'd0;
        else if(state == DATA)
            out <= {out[6:0], out_bit};
    end
    
    assign done = (state == CLEANUP);
    
    assign out_byte = out;
    
endmodule"
N/A,N/A,-1,42.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Use FSM from Fsm_serial

// New: Datapath to latch input bits.

endmodule"
N/A,N/A,-1,43.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    // Use FSM from Fsm_serial
    // New: Latch input bits.
    
    reg [2:0] state, next_state;
    reg [7:0] out_byte_reg;
    reg done_reg;
    
    localparam IDLE = 3'd0;
    localparam START = 3'd1;
    localparam DATA = 3'd2;
    localparam STOP = 3'd3;
    localparam END = 3'd4;
    
    always @(*) begin
        case (state)
            IDLE: begin
                if(~in)
                    next_state = START;
                else
                    next_state = IDLE;
            end
            START: begin
                if(in)
                    next_state = DATA;
                else
                    next_state = START;
            end
            DATA: begin
                if(~in)
                    next_state = STOP;
                else
                    next_state = DATA;
            end
            STOP: begin
                if(in)
                    next_state = END;
                else
                    next_state = START;
            end
            END: begin
                if(in)
                    next_state = IDLE;
                else
                    next_state = END;
            end
            default: next_state = IDLE;
        endcase
    end
    
    always @(posedge clk) begin
        if(reset) begin
            state <= IDLE;
            out_byte_reg <= 8'b0;
            done_reg <= 1'b0;
        end
        else begin
            state <= next_state;
            out_byte_reg <= out_byte;
            done_reg <= done;
        end
    end
    
    assign done = done_reg;
    assign out_byte = out_byte_reg;
    
endmodule"
N/A,N/A,-1,44.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Modify FSM and datapath from Fsm_serial

// New: Latch input bits.

endmodule"
N/A,N/A,-1,45.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

// Define states
localparam
    idle = 2'b00,
    start = 2'b01,
    data = 2'b10,
    stop = 2'b11;

// State register
reg [1:0] state;

// FSM next-state logic
always @(posedge clk) begin
    if(reset)
        state <= idle;
    else
        state <= state_next;
end

// FSM output logic
assign done = (state == stop);

// New: Datapath to latch input bits.
reg [7:0] data_byte;

always @(posedge clk) begin
    if(state == start)
        data_byte <= {in, data_byte[7:1]};  // Shift in input bits, but skip the first bit since it's already in data_byte
end

assign out_byte = data_byte;

// New: Datapath to latch input bits.

endmodule"
N/A,N/A,-1,46.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

// Define states
localparam
    idle = 2'b00,
    start = 2'b01,
    data = 2'b10,
    stop = 2'b11;

// State register
reg [1:0] state;

// FSM next-state logic
always @(posedge clk) begin
    if(reset)
        state <= idle;
    else
        state <= state_next;
end

// FSM output logic
assign done = (state == stop);

// New: Datapath to latch input bits.
reg [7:0] data_byte;

always @(posedge clk) begin
    if(state == start)
        data_byte <= {in, data_byte[7:1]};  // Shift in input bits, but skip the first bit since it's already in data_byte
end

assign out_byte = data_byte;

// New: Datapath to latch input bits.

endmodule"
N/A,N/A,-1,47.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serial
    // New: Datapath to latch input bits.
    
    reg [3:0] state, next_state;
    reg [7:0] out;
    reg out_bit;
    
    localparam IDLE = 4'd0,
               GET_BIT = 4'd1,
               SHIFT_BIT = 4'd2,
               DONE = 4'd3,
               ERROR = 4'd4;
    
    always @(*) begin
        case (state)
            IDLE: begin
                if(~in)
                    next_state = GET_BIT;
                else
                    next_state = IDLE;
            end
            
            GET_BIT: begin
                if(in)
                    next_state = SHIFT_BIT;
                else
                    next_state = IDLE;
            end
            
            SHIFT_BIT: begin
                if(in)
                    next_state = SHIFT_BIT;
                else
                    next_state = DONE;
            end
            
            DONE: begin
                if(in)
                    next_state = ERROR;
                else
                    next_state = IDLE;
            end
            
            ERROR: begin
                if(in)
                    next_state = ERROR;
                else
                    next_state = IDLE;
            end
            
            default: next_state = IDLE;
        endcase
    end
    
    always @(posedge clk) begin
        if(reset)
            state <= IDLE;
        else
            state <= next_state;
    end
    
    always @(posedge clk) begin
        if(state == SHIFT_BIT)
            out_bit <= in;
        else
            out_bit <= 1'b0;
    end
    
    always @(posedge clk) begin
        if(state == SHIFT_BIT)
            out <= {out[6:0], out_bit};
    end
    
    assign done = (state == DONE);
    
    assign out_byte = out;
    
endmodule"
N/A,N/A,-1,48.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serial
    // New: Datapath to latch input bits.
    
    reg [3:0] state, next_state;
    reg [7:0] out;
    reg out_bit;
    
    localparam IDLE = 4'd0,
               GET_BIT = 4'd1,
               SHIFT_BIT = 4'd2,
               DONE = 4'd3,
               ERROR = 4'd4;
    
    always @(*) begin
        case (state)
            IDLE: begin
                if(~in)
                    next_state = GET_BIT;
                else
                    next_state = IDLE;
            end
            
            GET_BIT: begin
                if(in)
                    next_state = SHIFT_BIT;
                else
                    next_state = IDLE;
            end
            
            SHIFT_BIT: begin
                if(in)
                    next_state = SHIFT_BIT;
                else
                    next_state = DONE;
            end
            
            DONE: begin
                if(in)
                    next_state = ERROR;
                else
                    next_state = IDLE;
            end
            
            ERROR: begin
                if(in)
                    next_state = ERROR;
                else
                    next_state = IDLE;
            end
            
            default: next_state = IDLE;
        endcase
    end
    
    always @(posedge clk) begin
        if(reset)
            state <= IDLE;
        else
            state <= next_state;
    end
    
    always @(posedge clk) begin
        if(state == SHIFT_BIT)
            out_bit <= in;
        else
            out_bit <= 1'b0;
    end
    
    always @(posedge clk) begin
        if(state == SHIFT_BIT)
            out <= {out[6:0], out_bit};
    end
    
    assign done = (state == DONE);
    
    assign out_byte = out;
    
endmodule"
N/A,N/A,-1,49.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Use FSM from Fsm_serial

endmodule"
N/A,N/A,-1,50.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serial
    // New: Datapath to latch input bits.
    
    parameter idle = 0, rec_data = 1, stop_bit = 2;
    reg [1:0] state, next_state;
    reg [7:0] rec_data_reg;
    reg [2:0] counter;
    reg out;
    
    always @(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    always @(*) begin
        case(state)
            idle:
                begin
                    if(~in)
                        next_state = rec_data;
                    else
                        next_state = idle;
                end
            rec_data:
                begin
                    if(counter == 7)
                        next_state = stop_bit;
                    else
                        next_state = rec_data;
                end
            stop_bit:
                begin
                    if(in)
                        next_state = idle;
                    else
                        next_state = rec_data;
                end
            default:
                next_state = idle;
        endcase
    end
    
    always @(posedge clk) begin
        if(state == rec_data && counter < 7)
            rec_data_reg[7-counter] <= in;
    end
    
    assign done = (state == stop_bit)? 1 : 0;
    assign out_byte = rec_data_reg;
    
    always @(posedge clk) begin
        if(state == rec_data && counter < 7)
            counter <= counter + 1;
        else
            counter <= 0;
    end
    
    // New: Datapath to latch input bits.
    
    always @(*) begin
        case(state)
            idle:
                out <= 1'b0;
            rec_data:
                out <= rec_data_reg[7-counter];
            stop_bit:
                out <= 1'b0;
            default:
                out <= 1'b0;
        endcase
    end
    
endmodule"
N/A,N/A,-1,51.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serial
    
    parameter idle = 0, rec_data = 1, stop_bit = 2;
    reg [1:0] state, next_state;
    
    always @(*) begin
        state <= next_state;
    end
    
    always @(posedge clk) begin
        if(reset)
            next_state <= idle;
        else
            begin
                case(state)
                    idle:
                        if(~in)
                            next_state <= rec_data;
                    rec_data:
                        if(~in)
                            next_state <= stop_bit;
                    stop_bit:
                        if(in)
                            next_state <= idle;
                    default:
                        next_state <= idle;
                endcase
            end
    end
    
    assign done = (state == stop_bit);
    
    // New: Datapath to latch input bits.
    
    reg [7:0] out_byte_reg;
    
    always @(posedge clk) begin
        if(reset)
            out_byte_reg <= 0;
        else begin
            if(state == rec_data)
                out_byte_reg <= {out_byte_reg[6:0], in};
        end
    end
    
    assign out_byte = out_byte_reg;
    
endmodule"
N/A,N/A,-1,52.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Use FSM from Fsm_serial

// New: Datapath to latch input bits.

endmodule"
N/A,N/A,-1,53.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    // Use FSM from Fsm_serial
    // New: Datapath to latch input bits.
    
    reg [2:0] state, next_state;
    reg [7:0] out_byte_reg;
    
    localparam IDLE = 3'd0;
    localparam WAIT_HIGH = 3'd1;
    localparam WAIT_LOW = 3'd2;
    localparam SHIFT_MSB = 3'd3;
    localparam SHIFT_LSB = 3'd4;
    
    always @(*) begin
        case (state)
            IDLE: begin
                if(~in)
                    next_state = WAIT_HIGH;
                else
                    next_state = IDLE;
            end
            WAIT_HIGH: begin
                if(in)
                    next_state = WAIT_LOW;
                else
                    next_state = IDLE;
            end
            WAIT_LOW: begin
                if (~in)
                    next_state = SHIFT_MSB;
                else
                    next_state = IDLE;
            end
            SHIFT_MSB: begin
                if(in)
                    next_state = SHIFT_LSB;
                else
                    next_state = IDLE;
            end
            SHIFT_LSB: begin
                if(in)
                    next_state = IDLE;
                else
                    next_state = IDLE;
            end
            default: next_state = IDLE;
        endcase
    end
    
    always @(posedge clk) begin
        if(reset)
            state <= IDLE;
        else
            state <= next_state;
    end
    
    always @(posedge clk) begin
        if(reset)
            out_byte_reg <= 8'd0;
        else begin
            case(state)
                IDLE: begin
                    out_byte_reg <= 8'd0;
                end
                WAIT_HIGH: begin
                    out_byte_reg[0] <= 1'b0;
                end
                WAIT_LOW: begin
                    out_byte_reg <= out_byte_reg >> 1;
                    out_byte_reg[7] <= 1'b1;
                end
                SHIFT_MSB: begin
                    out_byte_reg <= out_byte_reg >> 1;
                    out_byte_reg[7] <= 1'b0;
                end
                SHIFT_LSB: begin
                    out_byte_reg <= out_byte_reg << 1;
                    out_byte_reg[0] <= 1'b1;
                end
            endcase
        end
    end
    
    assign done = (state == SHIFT_LSB);
    
    assign out_byte = out_byte_reg;
    
endmodule"
N/A,N/A,-1,54.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Modify FSM and datapath from Fsm_serial

reg [2:0] state, next_state;
reg [7:0] out_byte;
reg done;

always @(*) begin
    case (state)
        3'b000: begin
            if(~in)
                next_state = 3'b001;
            else
                next_state = 3'b000;
        end
        3'b001: begin
            if(in)
                next_state = 3'b010;
            else
                next_state = 3'b000;
        end
        3'b010: begin
            if(in)
                next_state = 3'b011;
            else
                next_state = 3'b000;
        end
        3'b011: begin
            if(in)
                next_state = 3'b100;
            else
                next_state = 3'b000;
        end
        3'b100: begin
            if(in)
                next_state = 3'b101;
            else
                next_state = 3'b000;
        end
        3'b101: begin
            if(in)
                next_state = 3'b110;
            else
                next_state = 3'b000;
        end
        3'b110: begin
            if(in)
                next_state = 3'b111;
            else
                next_state = 3'b000;
        end
        3'b111: begin
            if(~in)
                next_state = 3'b000;
            else
                next_state = 3'b111;
        end
        default: begin
            next_state = 3'b000;
        end
    endcase
end

always @(posedge clk) begin
    if(reset) begin
        state <= 3'b000;
        out_byte <= 8'b0;
        done <= 1'b0;
    end
    else begin
        state <= next_state;
        case (next_state)
            3'b000: begin
                done <= 1'b0;
            end
            3'b001: begin
                out_byte[0] <= in;
            end
            3'b010: begin
                out_byte[1] <= in;
            end
            3'b011: begin
                out_byte[2] <= in;
            end
            3'b100: begin
                out_byte[3] <= in;
            end
            3'b101: begin
                out_byte[4] <= in;
            end
            3'b110: begin
                out_byte[5] <= in;
            end
            3'b111: begin
                out_byte[6] <= in;
            end
        endcase
        if(state == 3'b111)
            done <= 1'b1;
        else
            done <= 1'b0;
    end
end

endmodule"
N/A,N/A,-1,55.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Modify FSM and datapath from Fsm_serial

reg [2:0] state, next_state;
reg [7:0] out_byte;
reg done;

always @(*) begin
    case (state)
        3'b000: begin
            if(~in)
                next_state = 3'b001;
            else
                next_state = 3'b000;
        end
        3'b001: begin
            if(in)
                next_state = 3'b010;
            else
                next_state = 3'b000;
        end
        3'b010: begin
            if(in)
                next_state = 3'b011;
            else
                next_state = 3'b000;
        end
        3'b011: begin
            if(in)
                next_state = 3'b100;
            else
                next_state = 3'b000;
        end
        3'b100: begin
            if(in)
                next_state = 3'b101;
            else
                next_state = 3'b000;
        end
        3'b101: begin
            if(in)
                next_state = 3'b110;
            else
                next_state = 3'b000;
        end
        3'b110: begin
            if(in)
                next_state = 3'b111;
            else
                next_state = 3'b000;
        end
        3'b111: begin
            if(~in)
                next_state = 3'b000;
            else
                next_state = 3'b111;
        end
        default: begin
            next_state = 3'b000;
        end
    endcase
end

always @(posedge clk) begin
    if(reset) begin
        state <= 3'b000;
        out_byte <= 8'b0;
        done <= 1'b0;
    end
    else begin
        state <= next_state;
        case (next_state)
            3'b000: begin
                done <= 1'b0;
            end
            3'b001: begin
                out_byte[0] <= in;
            end
            3'b010: begin
                out_byte[1] <= in;
            end
            3'b011: begin
                out_byte[2] <= in;
            end
            3'b100: begin
                out_byte[3] <= in;
            end
            3'b101: begin
                out_byte[4] <= in;
            end
            3'b110: begin
                out_byte[5] <= in;
            end
            3'b111: begin
                out_byte[6] <= in;
            end
        endcase
        if(state == 3'b111)
            done <= 1'b1;
        else
            done <= 1'b0;
    end
end

endmodule"
N/A,N/A,-1,56.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Use FSM from Fsm_serial

endmodule"
N/A,N/A,-1,57.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Use FSM from Fsm_serial

endmodule"
N/A,N/A,-1,58.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serial
    
    // New: Latch input bits.
    
    // State machine:
    parameter idle = 0, rec_data = 1, stop_bit = 2, wait_start_bit = 3;
    reg [2:0] state, next_state;
    
    always @(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    always @(*) begin
        case(state)
            idle:
                begin
                    if(~in)
                        next_state = rec_data;
                    else
                        next_state = idle;
                end
            rec_data:
                begin
                    if(~in)
                        next_state = stop_bit;
                    else
                        next_state = rec_data;
                end
            stop_bit:
                begin
                    if(in)
                        next_state = wait_start_bit;
                    else
                        next_state = idle;
                end
            wait_start_bit:
                begin
                    if(in)
                        next_state = idle;
                    else
                        next_state = rec_data;
                end
            default:
                next_state = idle;
        endcase
    end
    
    // New: Datapath to latch input bits.
    reg [7:0] rec_data_reg;
    always @(posedge clk) begin
        if(state == rec_data)
            rec_data_reg <= {rec_data_reg[6:0], in};
    end
    
    assign out_byte = rec_data_reg;
    
    assign done = (state == stop_bit);
    
endmodule"
N/A,N/A,-1,59.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Use FSM from Fsm_serial

endmodule"
N/A,N/A,-1,60.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serial
    
    parameter idle = 0, rec_data = 1, stop_bit = 2, overflow = 3;
    reg [2:0] state, next_state;
    reg [7:0] rec_data_reg;
    reg [2:0] count;
    reg out_bit;
    reg done_reg;
    
    always @(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    always @(*) begin
        case(state)
            idle: begin
                if(~in)
                    next_state = rec_data;
                else
                    next_state = idle;
            end
            
            rec_data: begin
                next_state = rec_data_reg[7]? stop_bit : rec_data;
                rec_data_reg = {rec_data_reg[6:0], in};
            end
            
            stop_bit: begin
                next_state = overflow;
                out_bit = 1;
            end
            
            overflow: begin
                next_state = idle;
                out_bit = 1;
            end
        endcase
    end
    
    always @(posedge clk) begin
        if(state == rec_data && count < 9)
            count = count + 1;
        else
            count = 0;
    end
    
    always @(posedge clk) begin
        if(state == rec_data && count == 9)
            done_reg = 1;
        else
            done_reg = 0;
    end
    
    assign done = done_reg;
    assign out_byte = rec_data_reg;
    
    always @(*) begin
        case(state)
            idle: begin
                out_bit = 1;
            end
            
            rec_data: begin
                out_bit = rec_data_reg[7];
            end
            
            stop_bit: begin
                out_bit = 1;
            end
            
            overflow: begin
                out_bit = 1;
            end
        endcase
    end
    
    assign out_bit = 1;
    
endmodule"
N/A,N/A,-1,61.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serial
    
    parameter idle = 0, rec_data = 1, stop_bit = 2, overflow = 3;
    reg [2:0] state, next_state;
    reg [7:0] rec_data_reg;
    reg [2:0] count;
    reg out_bit;
    reg done_reg;
    
    always @(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    always @(*) begin
        case(state)
            idle: begin
                if(~in)
                    next_state = rec_data;
                else
                    next_state = idle;
            end
            
            rec_data: begin
                next_state = rec_data_reg[7]? stop_bit : rec_data;
                rec_data_reg = {rec_data_reg[6:0], in};
            end
            
            stop_bit: begin
                next_state = overflow;
                out_bit = 1;
            end
            
            overflow: begin
                next_state = idle;
                out_bit = 1;
            end
        endcase
    end
    
    always @(posedge clk) begin
        if(state == rec_data && count < 9)
            count = count + 1;
        else
            count = 0;
    end
    
    always @(posedge clk) begin
        if(state == rec_data && count == 9)
            done_reg = 1;
        else
            done_reg = 0;
    end
    
    assign done = done_reg;
    assign out_byte = rec_data_reg;
    
    always @(*) begin
        case(state)
            idle: begin
                out_bit = 1;
            end
            
            rec_data: begin
                out_bit = rec_data_reg[7];
            end
            
            stop_bit: begin
                out_bit = 1;
            end
            
            overflow: begin
                out_bit = 1;
            end
        endcase
    end
    
    assign out_bit = 1;
    
endmodule"
N/A,N/A,-1,62.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serial
    
    parameter idle = 0, rec_data = 1, stop_bit = 2, overflow = 3;
    reg [2:0] state, next_state;
    reg [7:0] rec_data_reg;
    reg [2:0] count;
    reg out_bit;
    reg done_reg;
    
    always @(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    always @(*) begin
        case(state)
            idle: begin
                if(~in)
                    next_state = rec_data;
                else
                    next_state = idle;
            end
            
            rec_data: begin
                next_state = rec_data_reg[7]? stop_bit : rec_data;
                rec_data_reg = {rec_data_reg[6:0], in};
            end
            
            stop_bit: begin
                next_state = overflow;
                out_bit = 1;
            end
            
            overflow: begin
                next_state = idle;
                out_bit = 1;
            end
        endcase
    end
    
    always @(posedge clk) begin
        if(state == rec_data && count < 9)
            count = count + 1;
        else
            count = 0;
    end
    
    always @(posedge clk) begin
        if(state == rec_data && count == 9)
            done_reg = 1;
        else
            done_reg = 0;
    end
    
    assign done = done_reg;
    assign out_byte = rec_data_reg;
    
    always @(*) begin
        case(state)
            idle: begin
                out_bit = 1;
            end
            
            rec_data: begin
                out_bit = rec_data_reg[7];
            end
            
            stop_bit: begin
                out_bit = 1;
            end
            
            overflow: begin
                out_bit = 1;
            end
        endcase
    end
    
    assign out_bit = 1;
    
endmodule"
N/A,N/A,-1,63.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    // Use FSM from Fsm_serial
    // New: Datapath to latch input bits.
    
    parameter idle = 0, rec_data = 1, stop_bit = 2;
    reg [1:0] state, next_state;
    reg [7:0] rec_data_reg;
    reg [3:0] counter;
    reg out_bit;
    reg done_reg;
    
    always @(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    always @(*) begin
        case(state)
            idle: begin
                if(~in)
                    next_state = rec_data;
                else
                    next_state = idle;
            end
            
            rec_data: begin
                if(counter == 7)
                    next_state = stop_bit;
                else
                    next_state = rec_data;
            end
            
            stop_bit: begin
                if(in)
                    next_state = idle;
                else
                    next_state = rec_data;
            end
            
            default: next_state = idle;
        endcase
    end
    
    always @(posedge clk) begin
        if(reset) begin
            state <= idle;
            done_reg <= 0;
        end
        else begin
            case(state)
                idle: begin
                    done_reg <= 0;
                    out_bit <= 0;
                    rec_data_reg <= 0;
                    counter <= 0;
                end
                
                rec_data: begin
                    rec_data_reg[7] <= rec_data_reg[6];
                    rec_data_reg[6] <= rec_data_reg[5];
                    rec_data_reg[5] <= rec_data_reg[4];
                    rec_data_reg[4] <= rec_data_reg[3];
                    rec_data_reg[3] <= rec_data_reg[2];
                    rec_data_reg[2] <= rec_data_reg[1];
                    rec_data_reg[1] <= rec_data_reg[0];
                    rec_data_reg[0] <= in;
                    
                    if(counter < 7)
                        counter <= counter + 1;
                    else begin
                        counter <= 0;
                        out_bit <= rec_data_reg[7];
                        done_reg <= 1;
                    end
                end
                
                stop_bit: begin
                    done_reg <= 0;
                    counter <= 0;
                end
            endcase
        end
    end
    
    assign done = done_reg;
    assign out_byte = out_bit;
endmodule"
N/A,N/A,-1,64.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Modify FSM and datapath from Fsm_serial

endmodule"
N/A,N/A,-1,65.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Use FSM from Fsm_serial

endmodule"
N/A,N/A,-1,66.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Use FSM from Fsm_serial

endmodule"
N/A,N/A,-1,67.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serial
    // New: Datapath to latch input bits.
    
    reg [2:0] state, next_state;
    reg [3:0] count;
    reg out;
    
    localparam IDLE = 3'd0;
    localparam START = 3'd1;
    localparam DATA = 3'd2;
    localparam STOP = 3'd3;
    localparam CLEANUP = 3'd4;
    
    always @(*) begin
        case (state)
            IDLE: begin
                if(~in)
                    next_state = START;
                else
                    next_state = IDLE;
            end
            
            START: begin
                if(count == 8)
                    next_state = DATA;
                else
                    next_state = START;
            end
            
            DATA: begin
                if(count == 8)
                    next_state = STOP;
                else
                    next_state = DATA;
            end
            
            STOP: begin
                if(count == 8)
                    next_state = CLEANUP;
                else
                    next_state = START;
            end
            
            CLEANUP: begin
                if(count == 8)
                    next_state = IDLE;
                else
                    next_state = CLEANUP;
            end
            
            default: next_state = IDLE;
        endcase
    end
    
    always @(posedge clk) begin
        if(reset)
            state <= IDLE;
        else
            state <= next_state;
    end
    
    always @(posedge clk) begin
        if(state == DATA || state == STOP)
            out <= in;
        else
            out <= 1'bz;
    end
    
    always @(posedge clk) begin
        if(state == CLEANUP)
            count <= 4'd0;
        else
            count <= count + 1'b1;
    end
    
    assign done = (state == CLEANUP) && (count == 8);
    
    assign out_byte = (state == CLEANUP)? (out? 8'b11111111 : 8'b00000000) : 8'bz;
    
endmodule"
N/A,N/A,-1,68.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serial
    
    // New: Latch input bits.
    
    reg [3:0] state, next_state;
    reg [7:0] out;
    
    localparam IDLE = 4'd0,
               GET_BYTE = 4'd1,
               WAIT_STOP = 4'd2,
               INCREMENT = 4'd3,
               DONE = 4'd4;
               
    always @(*) begin
        case (state)
            IDLE: begin
                if(~in)
                    next_state = GET_BYTE;
                else
                    next_state = IDLE;
            end
            
            GET_BYTE: begin
                if(in)
                    next_state = WAIT_STOP;
                else
                    next_state = GET_BYTE;
            end
            
            WAIT_STOP: begin
                if(in)
                    next_state = INCREMENT;
                else
                    next_state = WAIT_STOP;
            end
            
            INCREMENT: begin
                next_state = DONE;
            end
            
            DONE: begin
                if(in)
                    next_state = IDLE;
                else
                    next_state = GET_BYTE;
            end
            
            default: next_state = IDLE;
        endcase
    end
    
    always @(posedge clk) begin
        if(reset)
            state <= IDLE;
        else
            state <= next_state;
    end
    
    always @(posedge clk) begin
        if(state == GET_BYTE)
            out <= {out, in};
    end
    
    assign done = (state == DONE);
    
    assign out_byte = out;
    
endmodule"
N/A,N/A,-1,69.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Use FSM from Fsm_serial

// New: Datapath to latch input bits.

endmodule"
N/A,N/A,-1,70.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Use FSM from Fsm_serial

// New: Datapath to latch input bits.

endmodule"
N/A,N/A,-1,71.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serial
    
    // New: Datapath to latch input bits.
    
    reg [7:0] out_byte;
    reg done;
    
    always @(posedge clk) begin
        if(reset) begin
            done <= 0;
            out_byte <= 0;
        end
        else begin
            if(~in) begin
                done <= 1;
                out_byte <= out_byte;
            end
            else begin
                done <= 0;
                out_byte <= out_byte + 1;
            end
        end
    end
    
endmodule"
N/A,N/A,-1,72.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Use FSM from Fsm_serial

endmodule"
N/A,N/A,-1,73.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    // Use FSM from Fsm_serial
    // New: Datapath to latch input bits.
    
    // Define states
    parameter START = 0, DATA = 1, STOP = 2, DELAY = 3;
    reg [1:0] state, next_state;
    reg [7:0] data;
    reg out;
    
    always @(posedge clk) begin
        if(reset)
            state <= START;
        else
            state <= next_state;
    end
    
    always @(*) begin
        case(state)
            START: begin
                if(~in)
                    next_state = DATA;
                else
                    next_state = START;
            end
            DATA: begin
                if(~in)
                    next_state = STOP;
                else
                    next_state = DATA;
            end
            STOP: begin
                if(in)
                    next_state = DELAY;
                else
                    next_state = START;
            end
            DELAY: begin
                if(in)
                    next_state = DELAY;
                else
                    next_state = START;
            end
            default: next_state = START;
        endcase
    end
    
    always @(posedge clk) begin
        if(state == DATA)
            data <= {data[6:0], in};
    end
    
    assign done = (state == DELAY) && (next_state == START);
    
    assign out_byte = data;
    
endmodule"
N/A,N/A,-1,74.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Modify FSM and datapath from Fsm_serial

// New: Latch input bits.

endmodule"
N/A,N/A,-1,75.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Use FSM from Fsm_serial

endmodule"
N/A,N/A,-1,76.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Use FSM from Fsm_serial

endmodule"
N/A,N/A,-1,77.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Use FSM from Fsm_serial

endmodule"
N/A,N/A,-1,78.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serial
    // New: Datapath to latch input bits.
    
    parameter idle = 0, rec_data = 1, stop_bit = 2, error = 3;
    reg [2:0] state, next_state;
    reg [7:0] data;
    reg [3:0] counter;
    reg out;
    
    always @(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    always @(*) begin
        case(state)
            idle: begin
                if(~in)
                    next_state = rec_data;
                else
                    next_state = idle;
            end
            
            rec_data: begin
                if(counter == 7)
                    next_state = stop_bit;
                else
                    next_state = rec_data;
            end
            
            stop_bit: begin
                if(in)
                    next_state = idle;
                else
                    next_state = error;
            end
            
            error: begin
                if(in)
                    next_state = idle;
                else
                    next_state = error;
            end
            
            default: next_state = idle;
        endcase
    end
    
    always @(posedge clk) begin
        if(state == rec_data && in)
            counter <= counter + 1;
        else
            counter <= 0;
    end
    
    always @(posedge clk) begin
        if(state == rec_data)
            data <= {data[6:0], in};
    end
    
    always @(posedge clk) begin
        if(state == stop_bit) begin
            out_byte <= data;
            done <= 1;
        end
        else
            done <= 0;
    end
    
    // New: Datapath to latch input bits.
    always @(posedge clk) begin
        if(state == rec_data)
            out <= in;
    end
    
endmodule"
N/A,N/A,-1,79.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Use FSM from Fsm_serial

// New: Datapath to latch input bits.

endmodule"
N/A,N/A,-1,80.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serial
    
    parameter idle = 0, rec_data = 1, stop_bit = 2, overflow = 3;
    reg [2:0] state, next_state;
    reg [3:0] counter;
    reg [7:0] rec_data_byte;
    
    always @(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    always @(state) begin
        case(state)
            idle:
                begin
                    done = 0;
                    next_state = rec_data;
                    counter = 4'b0;
                    rec_data_byte = 8'b0;
                end
            rec_data:
                begin
                    if(counter < 4'b1110) begin
                        next_state = rec_data;
                        rec_data_byte = {in, rec_data_byte[7:1]};
                        counter = counter + 4'b1;
                    end
                    else begin
                        next_state = stop_bit;
                        counter = 4'b0;
                        done = 1;
                    end
                end
            stop_bit:
                begin
                    if(in)
                        next_state = overflow;
                    else
                        next_state = idle;
                end
            overflow:
                begin
                    next_state = idle;
                    done = 1;
                end
            default:
                next_state = idle;
        endcase
    end
    
    assign out_byte = rec_data_byte;
    
endmodule"
N/A,N/A,-1,81.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serial
    
    parameter idle = 0, rec_data = 1, stop_bit = 2, overflow = 3;
    reg [2:0] state, next_state;
    reg [3:0] counter;
    reg [7:0] rec_data_byte;
    
    always @(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    always @(state) begin
        case(state)
            idle:
                begin
                    done = 0;
                    next_state = rec_data;
                    counter = 4'b0;
                    rec_data_byte = 8'b0;
                end
            rec_data:
                begin
                    if(counter < 4'b1110) begin
                        next_state = rec_data;
                        rec_data_byte = {in, rec_data_byte[7:1]};
                        counter = counter + 4'b1;
                    end
                    else begin
                        next_state = stop_bit;
                        counter = 4'b0;
                        done = 1;
                    end
                end
            stop_bit:
                begin
                    if(in)
                        next_state = overflow;
                    else
                        next_state = idle;
                end
            overflow:
                begin
                    next_state = idle;
                    done = 1;
                end
            default:
                next_state = idle;
        endcase
    end
    
    assign out_byte = rec_data_byte;
    
endmodule"
N/A,N/A,-1,82.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serial
    
    parameter idle = 0, rec_data = 1, stop_bit = 2, overflow = 3;
    reg [2:0] state, next_state;
    reg [3:0] counter;
    reg [7:0] rec_data_byte;
    
    always @(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    always @(state) begin
        case(state)
            idle:
                begin
                    done = 0;
                    next_state = rec_data;
                    counter = 4'b0;
                    rec_data_byte = 8'b0;
                end
            rec_data:
                begin
                    if(counter < 4'b1110) begin
                        next_state = rec_data;
                        rec_data_byte = {in, rec_data_byte[7:1]};
                        counter = counter + 4'b1;
                    end
                    else begin
                        next_state = stop_bit;
                        counter = 4'b0;
                        done = 1;
                    end
                end
            stop_bit:
                begin
                    if(in)
                        next_state = overflow;
                    else
                        next_state = idle;
                end
            overflow:
                begin
                    next_state = idle;
                    done = 1;
                end
            default:
                next_state = idle;
        endcase
    end
    
    assign out_byte = rec_data_byte;
    
endmodule"
N/A,N/A,-1,83.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    // Use FSM from Fsm_serial
    // New: Latch input bits.
    
    reg [2:0] state, next_state;
    localparam IDLE = 3'd0, DATA = 3'd1, STOP = 3'd2, DELAY = 3'd3;
    
    always @(*) begin
        case (state)
            IDLE: begin
                if(~in)
                    next_state = DATA;
                else
                    next_state = IDLE;
            end
            DATA: begin
                if(~in)
                    next_state = STOP;
                else
                    next_state = DATA;
            end
            STOP: begin
                if(in)
                    next_state = DELAY;
                else
                    next_state = IDLE;
            end
            DELAY: begin
                if(in)
                    next_state = DATA;
                else
                    next_state = DELAY;
            end
        endcase
    end
    
    always @(posedge clk) begin
        if(reset)
            state <= IDLE;
        else
            state <= next_state;
    end
    
    // New: Latch input bits.
    reg [7:0] out_byte_reg;
    always @(posedge clk) begin
        if(state == DATA)
            out_byte_reg <= {out_byte_reg[6:0], in};
    end
    
    assign out_byte = out_byte_reg;
    assign done = (state == DELAY) && (next_state == IDLE);
    
endmodule"
N/A,N/A,-1,84.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Modify FSM and datapath from Fsm_serial

reg [2:0] state, next_state;
reg [3:0] count;
reg [7:0] out;
reg out_bit;

always @(posedge clk) begin
    if(reset)
        state <= 0;
    else
        state <= next_state;
end

always @(*) begin
    case(state)
        0: begin
            if(~in)
                next_state = 0;
            else
                next_state = 1;
        end
        1: begin
            if(count == 7)
                next_state = 2;
            else
                next_state = 1;
        end
        2: begin
            if(in)
                next_state = 1;
            else
                next_state = 0;
        end
    endcase
end

always @(posedge clk) begin
    if(state == 0 || state == 1) begin
        count <= 4'b0000;
        out_bit <= 0;
    end
    else begin
        if(state == 2)
            out_bit <= 1'b0;
        else
            out_bit <= in;
        count <= count + 1;
    end
end

always @(*) begin
    case(state)
        0: out = 8'b00000000;
        1: out = {out[6:0], out_bit};
        2: out = {out[5:0], out_bit};
    endcase
end

assign done = (state == 2);
assign out_byte = out;

endmodule"
N/A,N/A,-1,85.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Use FSM from Fsm_serial

reg [2:0] state, next_state;
reg [2:0] count;
reg [7:0] out;
reg out_bit;
reg [1:0] next_count;
reg [1:0] next_out_bit;

always @(*) begin
    next_count = count + 1;
    next_out_bit = out_bit + 1;
    case (state)
        S_IDLE: begin
            if (in)
                next_state = S_INIT;
            else
                next_state = S_IDLE;
        end
        S_INIT: begin
            if (next_count == 3)
                next_state = S_BIT0;
            else
                next_state = S_INIT;
        end
        S_BIT0: begin
            if (next_count == 3)
                next_state = S_BIT1;
            else
                next_state = S_BIT0;
        end
        S_BIT1: begin
            if (next_count == 3)
                next_state = S_BIT2;
            else
                next_state = S_BIT1;
        end
        S_BIT2: begin
            if (next_count == 3)
                next_state = S_BIT3;
            else
                next_state = S_BIT2;
        end
        S_BIT3: begin
            if (next_count == 3)
                next_state = S_BIT4;
            else
                next_state = S_BIT3;
        end
        S_BIT4: begin
            if (next_count == 3)
                next_state = S_BIT5;
            else
                next_state = S_BIT4;
        end
        S_BIT5: begin
            if (next_count == 3)
                next_state = S_BIT6;
            else
                next_state = S_BIT5;
        end
        S_BIT6: begin
            if (next_count == 3)
                next_state = S_BIT7;
            else
                next_state = S_BIT6;
        end
        S_BIT7: begin
            if (next_count == 3)
                next_state = S_INIT;
            else
                next_state = S_BIT7;
        end
        default: begin
            next_state = S_IDLE;
        end
    endcase
end

always @(posedge clk) begin
    if (reset) begin
        state <= S_IDLE;
        count <= 0;
        out <= 0;
        out_bit <= 0;
    end
    else begin
        state <= next_state;
        count <= next_count;
        out <= next_out_bit;
        out_bit <= next_out_bit;
    end
end

assign done = (state == S_BIT7)? 1 : 0;

assign out_byte = out;

endmodule"
N/A,N/A,-1,86.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Use FSM from Fsm_serial

reg [2:0] state, next_state;
reg [3:0] count;
reg [7:0] out;
reg out_bit;

assign done = (state == 3'd7) && (count == 4'd8);

always @(*) begin
    case (state)
        3'd0: begin
            next_state = in? 3'd1 : 3'd0;
            out_bit = 1'b0;
        end
        3'd1: begin
            next_state = in? 3'd2 : 3'd0;
            out_bit = 1'b0;
        end
        3'd2: begin
            next_state = in? 3'd3 : 3'd0;
            out_bit = 1'b0;
        end
        3'd3: begin
            next_state = in? 3'd4 : 3'd0;
            out_bit = 1'b0;
        end
        3'd4: begin
            next_state = in? 3'd5 : 3'd0;
            out_bit = 1'b0;
        end
        3'd5: begin
            next_state = in? 3'd6 : 3'd0;
            out_bit = 1'b0;
        end
        3'd6: begin
            next_state = in? 3'd7 : 3'd0;
            out_bit = 1'b0;
        end
        3'd7: begin
            next_state = in? 3'd0 : 3'd0;
            out_bit = 1'b0;
        end
    endcase
end

always @(posedge clk) begin
    if(reset) begin
        state <= 3'd0;
        count <= 4'd0;
        out <= 8'd0;
    end else begin
        state <= next_state;
        count <= count + 4'd1;
        if(state == 3'd0) out <= out;
        else if(state == 3'd1) out <= {out[6:0], out_bit};
        else if(state == 3'd2) out <= {out[5:0], out_bit};
        else if(state == 3'd3) out <= {out[4:0], out_bit};
        else if(state == 3'd4) out <= {out[3:0], out_bit};
        else if(state == 3'd5) out <= {out[2:0], out_bit};
        else if(state == 3'd6) out <= {out[1:0], out_bit};
        else if(state == 3'd7) out <= {out[0], out_bit};
    end
end

assign out_byte = out;

endmodule"
N/A,N/A,-1,87.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Use FSM from Fsm_serial

reg [2:0] state, next_state;
reg [3:0] count;
reg [7:0] out;
reg out_bit;

assign done = (state == 3'd7) && (count == 4'd8);

always @(*) begin
    case (state)
        3'd0: begin
            next_state = in? 3'd1 : 3'd0;
            out_bit = 1'b0;
        end
        3'd1: begin
            next_state = in? 3'd2 : 3'd0;
            out_bit = 1'b0;
        end
        3'd2: begin
            next_state = in? 3'd3 : 3'd0;
            out_bit = 1'b0;
        end
        3'd3: begin
            next_state = in? 3'd4 : 3'd0;
            out_bit = 1'b0;
        end
        3'd4: begin
            next_state = in? 3'd5 : 3'd0;
            out_bit = 1'b0;
        end
        3'd5: begin
            next_state = in? 3'd6 : 3'd0;
            out_bit = 1'b0;
        end
        3'd6: begin
            next_state = in? 3'd7 : 3'd0;
            out_bit = 1'b0;
        end
        3'd7: begin
            next_state = in? 3'd0 : 3'd0;
            out_bit = 1'b0;
        end
    endcase
end

always @(posedge clk) begin
    if(reset) begin
        state <= 3'd0;
        count <= 4'd0;
        out <= 8'd0;
    end else begin
        state <= next_state;
        count <= count + 4'd1;
        if(state == 3'd0) out <= out;
        else if(state == 3'd1) out <= {out[6:0], out_bit};
        else if(state == 3'd2) out <= {out[5:0], out_bit};
        else if(state == 3'd3) out <= {out[4:0], out_bit};
        else if(state == 3'd4) out <= {out[3:0], out_bit};
        else if(state == 3'd5) out <= {out[2:0], out_bit};
        else if(state == 3'd6) out <= {out[1:0], out_bit};
        else if(state == 3'd7) out <= {out[0], out_bit};
    end
end

assign out_byte = out;

endmodule"
N/A,N/A,-1,88.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serial
    
    // New: Datapath to latch input bits.
    
    reg [7:0] out_byte_reg;
    
    always @(posedge clk) begin
        if(reset) begin
            out_byte_reg <= 0;
        end
        else begin
            out_byte_reg <= {out_byte_reg[6:0], in};
        end
    end
    
    assign done = (out_byte_reg == ""done"");
    assign out_byte = done? out_byte_reg : 0;
    
endmodule"
N/A,N/A,-1,89.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Use FSM from Fsm_serial

reg [2:0] state, next_state;
reg [7:0] out_byte_reg;
reg done_reg;

parameter idle = 3'b000, rec_data = 3'b001, stop_bit = 3'b010, done = 3'b100;

always @(*) begin
    case(state)
        idle: begin
            if(~in)
                next_state = rec_data;
            else
                next_state = idle;
        end
        rec_data: begin
            if(in)
                next_state = rec_data; // Wait for a low to start receiving data
            else
                next_state = stop_bit;
        end
        stop_bit: begin
            if(in)
                next_state = done; // Wait for a high to complete the stop bit
            else
                next_state = idle;
        end
        done: begin
            if(in)
                next_state = idle; // Wait for a low to complete the transmission
            else
                next_state = idle;
        end
        default: next_state = idle;
    endcase
end

always @(posedge clk) begin
    if(reset) begin
        state <= idle;
        out_byte_reg <= 0;
        done_reg <= 0;
    end
    else begin
        state <= next_state;
        out_byte_reg <= out_byte;
        done_reg <= done;
    end
end

assign out_byte = out_byte_reg;
assign done = done_reg;

endmodule"
N/A,N/A,-1,90.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serial
    // New: Datapath to latch input bits.
    
    parameter idle = 0, rec_data = 1, stop_bit = 2, error = 3;
    reg [2:0] state, next_state;
    reg [7:0] data;
    reg [3:0] count;
    reg out;
    
    always @(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    always @(*) begin
        case(state)
            idle: begin
                if(~in)
                    next_state = rec_data;
                else
                    next_state = idle;
            end
            
            rec_data: begin
                if(count == 7)
                    next_state = stop_bit;
                else
                    next_state = rec_data;
            end
            
            stop_bit: begin
                if(in)
                    next_state = idle;
                else
                    next_state = error;
            end
            
            error: begin
                if(in)
                    next_state = idle;
                else
                    next_state = error;
            end
            
            default: next_state = idle;
        endcase
    end
    
    always @(posedge clk) begin
        if(state == rec_data && count < 7) begin
            data[count] <= in;
            count <= count + 1;
        end
        
        if(state == stop_bit) begin
            out <= data[0];
            done <= 1;
        end
        else
            done <= 0;
    end
    
    assign out_byte = data;
    
endmodule"
N/A,N/A,-1,91.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serial
    // New: Datapath to latch input bits.
    
    reg [7:0] out_byte_reg;
    reg done_reg;
    
    always @(posedge clk) begin
        if(reset) begin
            out_byte_reg <= 0;
            done_reg <= 0;
        end
        else begin
            out_byte_reg <= out_byte;
            done_reg <= done;
        end
    end
    
    assign out_byte = out_byte_reg;
    assign done = done_reg;
    
endmodule"
N/A,N/A,-1,92.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

reg [2:0] state, next_state;
reg [7:0] out;
reg out_bit;

always @(*) begin
    state <= next_state;
end

always @(posedge clk) begin
    if(reset) begin
        out <= 0;
        out_bit <= 0;
        state <= 0;
        next_state <= 0;
    end else begin
        case(state)
            0: begin
                if(~in)
                    next_state <= 0;
                else
                    next_state <= 1;
            end
            1: begin
                if(in)
                    next_state <= 1;
                else
                    next_state <= 0;
            end
            default: begin
                if(in)
                    next_state <= 1;
                else
                    next_state <= 0;
            end
        endcase
    end
end

always @(posedge clk) begin
    if(state == 0 && next_state == 1) begin
        out_bit <= 1;
    end else begin
        out_bit <= 0;
    end
end

assign done = (state == 3);

always @(*) begin
    case(state)
        0: out_byte = {out, out_bit};
        1: out_byte = {out, 1'b0};
        2: out_byte = {1'b0, out};
        3: out_byte = {1'b0, 1'b0};
    endcase
end

endmodule"
N/A,N/A,-1,93.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    // Use FSM from Fsm_serial
    // New: Datapath to latch input bits.
    
    reg [2:0] state, next_state;
    reg [7:0] out;
    reg out_bit;
    
    always @(*) begin
        state <= next_state;
    end
    
    always @(posedge clk) begin
        if(reset)
            out_bit <= 1'b0;
        else begin
            case(state)
                3'b000: begin
                    out_bit <= in;
                end
                3'b001: begin
                    out_bit <= out[0];
                end
                3'b010: begin
                    out_bit <= out[1];
                end
                3'b011: begin
                    out_bit <= out[2];
                end
                3'b100: begin
                    out_bit <= out[3];
                end
                3'b101: begin
                    out_bit <= out[4];
                end
                3'b110: begin
                    out_bit <= out[5];
                end
                3'b111: begin
                    out_bit <= out[6];
                end
            endcase
        end
    end
    
    always @(*) begin
        next_state = state;
        done = 0;
        case (state)
            3'b000: begin
                if(in)
                    next_state = 3'b001;
            end
            3'b001: begin
                if(in)
                    next_state = 3'b010;
            end
            3'b010: begin
                if(in)
                    next_state = 3'b011;
            end
            3'b011: begin
                if(in)
                    next_state = 3'b100;
            end
            3'b100: begin
                if(in)
                    next_state = 3'b101;
            end
            3'b101: begin
                if(in)
                    next_state = 3'b110;
            end
            3'b110: begin
                if(in)
                    next_state = 3'b111;
                else
                    done = 1;
            end
            3'b111: begin
                if(in)
                    next_state = 3'b000;
                else
                    done = 1;
            end
        endcase
    end
    
    assign out_byte = out;
    
endmodule"
N/A,N/A,-1,94.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Modify FSM and datapath from Fsm_serial

endmodule"
N/A,N/A,-1,95.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Use FSM from Fsm_serial

// New: Datapath to latch input bits.

endmodule"
N/A,N/A,-1,96.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Use FSM from Fsm_serial

endmodule"
N/A,N/A,-1,97.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serial
    // New: Datapath to latch input bits.
    
    reg [2:0] state, next_state;
    reg [3:0] count;
    reg out;
    
    always @(*) begin
        case (state)
            3'b000: begin
                if(~in)
                    next_state = 3'b001;
                else
                    next_state = 3'b000;
            end
            3'b001: begin
                if(count == 9)
                    next_state = 3'b010;
                else
                    next_state = 3'b001;
            end
            3'b010: begin
                if(count == 18)
                    next_state = 3'b011;
                else
                    next_state = 3'b010;
            end
            3'b011: begin
                if(count == 27)
                    next_state = 3'b100;
                else
                    next_state = 3'b011;
            end
            3'b100: begin
                if(count == 36)
                    next_state = 3'b101;
                else
                    next_state = 3'b100;
            end
            3'b101: begin
                if(count == 45)
                    next_state = 3'b110;
                else
                    next_state = 3'b101;
            end
            3'b110: begin
                if(count == 54)
                    next_state = 3'b110;
                else
                    next_state = 3'b110;
            end
            default: next_state = 3'b000;
        endcase
    end
    
    always @(posedge clk) begin
        if(reset)
            state <= 3'b000;
        else
            state <= next_state;
    end
    
    always @(posedge clk) begin
        if(reset) begin
            count <= 0;
            out <= 0;
        end
        else begin
            case (state)
                3'b000: begin
                    count <= count + 1;
                    out <= 0;
                end
                3'b001: begin
                    count <= count + 1;
                    out <= in;
                end
                3'b010: begin
                    count <= count + 1;
                    out <= in;
                end
                3'b011: begin
                    count <= count + 1;
                    out <= in;
                end
                3'b100: begin
                    count <= count + 1;
                    out <= in;
                end
                3'b101: begin
                    count <= count + 1;
                    out <= in;
                end
                3'b110: begin
                    count <= count + 1;
                    out <= in;
                end
            endcase
        end
    end
    
    assign done = (state == 3'b110)? 1 : 0;
    
    assign out_byte = out;
    
endmodule"
N/A,N/A,-1,98.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serial
    // New: Datapath to latch input bits.
    
    reg [2:0] state, next_state;
    reg [7:0] out_byte_reg;
    reg done_reg;
    
    localparam IDLE = 3'd0;
    localparam GET_BYTE = 3'd1;
    localparam GET_BYTE_2 = 3'd2;
    localparam WAIT_STOP = 3'd3;
    
    always @(*) begin
        case (state)
            IDLE: begin
                if(~in)
                    next_state = GET_BYTE;
                else
                    next_state = IDLE;
            end
            GET_BYTE: begin
                if(in)
                    next_state = GET_BYTE_2;
                else
                    next_state = IDLE;
            end
            GET_BYTE_2: begin
                if(~in)
                    next_state = WAIT_STOP;
                else
                    next_state = IDLE;
            end
            WAIT_STOP: begin
                if(in)
                    next_state = IDLE;
                else
                    next_state = WAIT_STOP;
            end
            default: next_state = IDLE;
        endcase
    end
    
    always @(posedge clk) begin
        if(reset) begin
            state <= IDLE;
            out_byte_reg <= 0;
            done_reg <= 0;
        end
        else begin
            state <= next_state;
            out_byte_reg <= out_byte;
            done_reg <= done;
        end
    end
    
    assign out_byte = out_byte_reg;
    assign done = done_reg;
    
endmodule"
N/A,N/A,-1,99.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Use FSM from Fsm_serial

reg [2:0] state, next_state;
reg [7:0] out;
reg done_reg;

always @(*) begin
    case(state)
        3'b000: begin
            if(~in)
                next_state = 3'b001;
            else
                next_state = 3'b000;
        end
        3'b001: begin
            if(in)
                next_state = 3'b010;
            else
                next_state = 3'b000;
        end
        3'b010: begin
            if(in)
                next_state = 3'b011;
            else
                next_state = 3'b000;
        end
        3'b011: begin
            if(in)
                next_state = 3'b100;
            else
                next_state = 3'b000;
        end
        3'b100: begin
            if(in)
                next_state = 3'b101;
            else
                next_state = 3'b000;
        end
        3'b101: begin
            if(in)
                next_state = 3'b110;
            else
                next_state = 3'b000;
        end
        3'b110: begin
            if(in)
                next_state = 3'b111;
            else
                next_state = 3'b000;
        end
        3'b111: begin
            if(~in)
                next_state = 3'b000;
            else
                next_state = 3'b111;
        end
        default: next_state = 3'b000;
    endcase
end

always @(posedge clk) begin
    if(reset) begin
        state <= 3'b000;
        out <= 8'b0;
        done_reg <= 1'b0;
    end
    else begin
        state <= next_state;
        out <= out;
        done_reg <= done;
    end
end

assign done = done_reg;
assign out_byte = out;

endmodule"
N/A,N/A,-1,100.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Use FSM from Fsm_serial

reg [2:0] state, next_state;
reg [7:0] out;
reg done_reg;

always @(*) begin
    case(state)
        3'b000: begin
            if(~in)
                next_state = 3'b001;
            else
                next_state = 3'b000;
        end
        3'b001: begin
            if(in)
                next_state = 3'b010;
            else
                next_state = 3'b000;
        end
        3'b010: begin
            if(in)
                next_state = 3'b011;
            else
                next_state = 3'b000;
        end
        3'b011: begin
            if(in)
                next_state = 3'b100;
            else
                next_state = 3'b000;
        end
        3'b100: begin
            if(in)
                next_state = 3'b101;
            else
                next_state = 3'b000;
        end
        3'b101: begin
            if(in)
                next_state = 3'b110;
            else
                next_state = 3'b000;
        end
        3'b110: begin
            if(in)
                next_state = 3'b111;
            else
                next_state = 3'b000;
        end
        3'b111: begin
            if(~in)
                next_state = 3'b000;
            else
                next_state = 3'b111;
        end
        default: next_state = 3'b000;
    endcase
end

always @(posedge clk) begin
    if(reset) begin
        state <= 3'b000;
        out <= 8'b0;
        done_reg <= 1'b0;
    end
    else begin
        state <= next_state;
        out <= out;
        done_reg <= done;
    end
end

assign done = done_reg;
assign out_byte = out;

endmodule"
N/A,N/A,-1,101.0,1,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serial
    // New: Datapath to latch input bits.
    
    parameter idle = 0, rec_data = 1, stop_bit = 2, error = 3;
    reg [2:0] state, next_state;
    reg [3:0] counter;
    reg [7:0] data;
    reg out;
    
    always @(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    always @(*) begin
        case(state)
            idle: begin
                if(~in)
                    next_state = rec_data;
                else
                    next_state = idle;
            end
            
            rec_data: begin
                if(counter == 8)
                    next_state = stop_bit;
                else
                    next_state = rec_data;
            end
            
            stop_bit: begin
                if(in)
                    next_state = idle;
                else
                    next_state = error;
            end
            
            error: begin
                if(in)
                    next_state = idle;
                else
                    next_state = error;
            end
        endcase
    end
    
    always @(posedge clk) begin
        if(state == rec_data && counter < 8) begin
            data[7:1] <= data[6:0];
            data[0] <= in;
        end
    end
    
    always @(posedge clk) begin
        if(state == stop_bit) begin
            out_byte[7:0] <= data;
            out <= 1'b1;
        end
        else
            out <= 1'b0;
    end
    
    always @(posedge clk) begin
        if(state == rec_data && counter == 8)
            counter <= 4'b0;
        else if(state == stop_bit)
            counter <= counter + 1;
    end
    
    always @(posedge clk) begin
        if(state == rec_data && counter == 8)
            done <= 1'b1;
        else
            done <= 1'b0;
    end
    
endmodule"
