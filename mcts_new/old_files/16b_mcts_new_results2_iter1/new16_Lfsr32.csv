Area,Delay,Score,Current Run,Episode,Verilog
N/A,N/A,-1,0,0,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 
    
    // Give the DFFs a size that is large enough to contain the full register contents.
    // The DFFs only need to be larger than the number of bits that flip flop (reset)
    // has to change.
    //
    // For this example, the DFFs are 32 bits, even though only the lower 32 bits
    // are used to store the actual register contents.
    
    reg [31:0] q_next;
    
    always @(*) begin
        // Calculate the next value of the register
        q_next = q[31:1];
        q_next[0] = q[0] ^ q[31] ^ q[23] ^ q[15] ^ q[7];
        q_next[31:1] = q[30:0];
        q_next[31] = q[31] ^ q[23] ^ q[15] ^ q[7];
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end
    
endmodule"
N/A,N/A,-1,1,0,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31] ^ q[0] ^ q[1] ^ q[2] ^ q[3] ^ q[4] ^ q[5] ^ q[6] ^ q[7] ^ q[8] ^ q[9] ^ q[10] ^ q[11] ^ q[12] ^ q[13] ^ q[14] ^ q[15] ^ q[16] ^ q[17] ^ q[18] ^ q[19] ^ q[20] ^ q[21] ^ q[22] ^ q[23] ^ q[24] ^ q[25] ^ q[26] ^ q[27] ^ q[28] ^ q[29] ^ q[30] ^ q[31];
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end
    
endmodule"
N/A,N/A,-1,2,0,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31] ^ q[0] ^ q[1] ^ q[2] ^ q[3] ^ q[4] ^ q[5] ^ q[6] ^ q[7] ^ q[8] ^ q[9] ^ q[10] ^ q[11] ^ q[12] ^ q[13] ^ q[14] ^ q[15] ^ q[16] ^ q[17] ^ q[18] ^ q[19] ^ q[20] ^ q[21] ^ q[22] ^ q[23] ^ q[24] ^ q[25] ^ q[26] ^ q[27] ^ q[28] ^ q[29] ^ q[30] ^ q[31];
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end

endmodule"
N/A,N/A,-1,3,0,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31] ^ q[0];
        q_next[31] = q[0] ^ q[1] ^ q[2] ^ q[3] ^ q[4] ^ q[5] ^ q[6] ^ q[7] ^ q[8] ^ q[9] ^ q[10] ^ q[11] ^ q[12] ^ q[13] ^ q[14] ^ q[15] ^ q[16] ^ q[17] ^ q[18] ^ q[19] ^ q[20] ^ q[21] ^ q[22] ^ q[23] ^ q[24] ^ q[25] ^ q[26] ^ q[27] ^ q[28] ^ q[29] ^ q[30] ^ q[31];
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end
    
endmodule"
N/A,N/A,-1,4,0,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 
    
    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31] ^ q[0] ^ q[1] ^ q[2] ^ q[3];
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end
    
endmodule"
N/A,N/A,-1,5,0,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 
    
    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31] ^ q[0] ^ q[1] ^ q[2] ^ q[3];
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end
    
endmodule"
N/A,N/A,-1,6,0,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31] ^ q[0] ^ q[1] ^ q[2] ^ q[3] ^ q[4] ^ q[5] ^ q[6] ^ q[7] ^ q[8] ^ q[9] ^ q[10] ^ q[11] ^ q[12] ^ q[13] ^ q[14] ^ q[15] ^ q[16] ^ q[17] ^ q[18] ^ q[19] ^ q[20] ^ q[21] ^ q[22] ^ q[23] ^ q[24] ^ q[25] ^ q[26] ^ q[27] ^ q[28] ^ q[29] ^ q[30] ^ q[31];
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end

endmodule"
N/A,N/A,-1,7,0,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31] ^ q[30] ^ q[29] ^ q[28] ^ q[27] ^ q[26] ^ q[25] ^ q[24] ^ q[23] ^ q[22] ^ q[21] ^ q[20] ^ q[19] ^ q[18] ^ q[17] ^ q[16] ^ q[15] ^ q[14] ^ q[13] ^ q[12] ^ q[11] ^ q[10] ^ q[9] ^ q[8] ^ q[7] ^ q[6] ^ q[5] ^ q[4] ^ q[3] ^ q[2] ^ q[1] ^ q[0];
        q_next[31] = q[31] ^ q[31] ^ q[30] ^ q[29] ^ q[28] ^ q[27] ^ q[26] ^ q[25] ^ q[24] ^ q[23] ^ q[22] ^ q[21] ^ q[20] ^ q[19] ^ q[18] ^ q[17] ^ q[16] ^ q[15] ^ q[14] ^ q[13] ^ q[12] ^ q[11] ^ q[10] ^ q[9] ^ q[8] ^ q[7] ^ q[6] ^ q[5] ^ q[4] ^ q[3] ^ q[2] ^ q[1] ^ q[0];
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end
    
endmodule"
N/A,N/A,-1,8,0,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31] ^ q[30] ^ q[29] ^ q[28] ^ q[27] ^ q[26] ^ q[25] ^ q[24] ^ q[23] ^ q[22] ^ q[21] ^ q[20] ^ q[19] ^ q[18] ^ q[17] ^ q[16] ^ q[15] ^ q[14] ^ q[13] ^ q[12] ^ q[11] ^ q[10] ^ q[9] ^ q[8] ^ q[7] ^ q[6] ^ q[5] ^ q[4] ^ q[3] ^ q[2] ^ q[1] ^ q[0];
        q_next[31] = q[31] ^ q[31] ^ q[30] ^ q[29] ^ q[28] ^ q[27] ^ q[26] ^ q[25] ^ q[24] ^ q[23] ^ q[22] ^ q[21] ^ q[20] ^ q[19] ^ q[18] ^ q[17] ^ q[16] ^ q[15] ^ q[14] ^ q[13] ^ q[12] ^ q[11] ^ q[10] ^ q[9] ^ q[8] ^ q[7] ^ q[6] ^ q[5] ^ q[4] ^ q[3] ^ q[2] ^ q[1] ^ q[0];
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end
    
endmodule"
N/A,N/A,-1,9,0,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31] ^ q[0] ^ q[1] ^ q[2] ^ q[3] ^ q[4] ^ q[5] ^ q[6] ^ q[7] ^ q[8] ^ q[9] ^ q[10] ^ q[11] ^ q[12] ^ q[13] ^ q[14] ^ q[15] ^ q[16] ^ q[17] ^ q[18] ^ q[19] ^ q[20] ^ q[21] ^ q[22] ^ q[23] ^ q[24] ^ q[25] ^ q[26] ^ q[27] ^ q[28] ^ q[29] ^ q[30] ^ q[31];
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end
    
endmodule"
N/A,N/A,-1,10,0,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    wire [31:0] q_next, q_reg;
    
    assign q_next = q_reg + 1;
    
    always @(posedge clk) begin
        if(reset)
            q_reg <= 32'h1;
        else
            q_reg <= q_next;
    end
    
    assign q = q_reg;
    
endmodule"
N/A,N/A,-1,11,0,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31] ^ q[0] ^ q[1] ^ q[2] ^ q[3] ^ q[4] ^ q[5] ^ q[6] ^ q[7] ^ q[8] ^ q[9] ^ q[10] ^ q[11] ^ q[12] ^ q[13] ^ q[14] ^ q[15] ^ q[16] ^ q[17] ^ q[18] ^ q[19] ^ q[20] ^ q[21] ^ q[22] ^ q[23] ^ q[24] ^ q[25] ^ q[26] ^ q[27] ^ q[28] ^ q[29] ^ q[30] ^ q[31];
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end
    
endmodule"
N/A,N/A,-1,12,0,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31] ^ q[30] ^ q[29] ^ q[28] ^ q[27] ^ q[26] ^ q[25] ^ q[24] ^ q[23] ^ q[22] ^ q[21] ^ q[20] ^ q[19] ^ q[18] ^ q[17] ^ q[16] ^ q[15] ^ q[14] ^ q[13] ^ q[12] ^ q[11] ^ q[10] ^ q[9] ^ q[8] ^ q[7] ^ q[6] ^ q[5] ^ q[4] ^ q[3] ^ q[2] ^ q[1] ^ q[0];
        q_next[31] = q[31] ^ q[31] ^ q[30] ^ q[29] ^ q[28] ^ q[27] ^ q[26] ^ q[25] ^ q[24] ^ q[23] ^ q[22] ^ q[21] ^ q[20] ^ q[19] ^ q[18] ^ q[17] ^ q[16] ^ q[15] ^ q[14] ^ q[13] ^ q[12] ^ q[11] ^ q[10] ^ q[9] ^ q[8] ^ q[7] ^ q[6] ^ q[5] ^ q[4] ^ q[3] ^ q[2] ^ q[1] ^ q[0];
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end
    
endmodule"
N/A,N/A,-1,13,0,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31] ^ q[0] ^ q[1] ^ q[2] ^ q[3] ^ q[4] ^ q[5] ^ q[6] ^ q[7] ^ q[8] ^ q[9] ^ q[10] ^ q[11] ^ q[12] ^ q[13] ^ q[14] ^ q[15] ^ q[16] ^ q[17] ^ q[18] ^ q[19] ^ q[20] ^ q[21] ^ q[22] ^ q[23] ^ q[24] ^ q[25] ^ q[26] ^ q[27] ^ q[28] ^ q[29] ^ q[30] ^ q[31];
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end

endmodule"
N/A,N/A,-1,14,0,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31]? {q[30:0], 1'b0} : q_next;
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end

endmodule"
N/A,N/A,-1,15,0,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    wire [31:0] q_bar, q_next;
    assign q_bar = ~q;
    
    assign q_next = q_bar ^ {q[31], q[23], q[15], q[7]};
    
    always @(posedge clk)
        if(reset)
            q <= 32'h1;
    	else
            q <= q_next;

endmodule"
N/A,N/A,-1,16,0,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31] ^ q[0] ^ q[1] ^ q[2] ^ q[3] ^ q[4] ^ q[5] ^ q[6] ^ q[7] ^ q[8] ^ q[9] ^ q[10] ^ q[11] ^ q[12] ^ q[13] ^ q[14] ^ q[15] ^ q[16] ^ q[17] ^ q[18] ^ q[19] ^ q[20] ^ q[21] ^ q[22] ^ q[23] ^ q[24] ^ q[25] ^ q[26] ^ q[27] ^ q[28] ^ q[29] ^ q[30] ^ q[31];
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end
    
endmodule"
N/A,N/A,-1,17,0,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31] ^ q[0] ^ q[1] ^ q[2] ^ q[3] ^ q[4] ^ q[5] ^ q[6] ^ q[7] ^ q[8] ^ q[9] ^ q[10] ^ q[11] ^ q[12] ^ q[13] ^ q[14] ^ q[15] ^ q[16] ^ q[17] ^ q[18] ^ q[19] ^ q[20] ^ q[21] ^ q[22] ^ q[23] ^ q[24] ^ q[25] ^ q[26] ^ q[27] ^ q[28] ^ q[29] ^ q[30] ^ q[31];
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end
    
endmodule"
N/A,N/A,-1,18,0,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31] ^ q[0] ^ q[1] ^ q[2] ^ q[3] ^ q[4] ^ q[5] ^ q[6] ^ q[7] ^ q[8] ^ q[9] ^ q[10] ^ q[11] ^ q[12] ^ q[13] ^ q[14] ^ q[15] ^ q[16] ^ q[17] ^ q[18] ^ q[19] ^ q[20] ^ q[21] ^ q[22] ^ q[23] ^ q[24] ^ q[25] ^ q[26] ^ q[27] ^ q[28] ^ q[29] ^ q[30] ^ q[31];
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end
    
endmodule"
N/A,N/A,-1,19,0,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31] ^ q[0] ^ q[1] ^ q[2] ^ q[3] ^ q[4] ^ q[5] ^ q[6] ^ q[7] ^ q[8] ^ q[9] ^ q[10] ^ q[11] ^ q[12] ^ q[13] ^ q[14] ^ q[15] ^ q[16] ^ q[17] ^ q[18] ^ q[19] ^ q[20] ^ q[21] ^ q[22] ^ q[23] ^ q[24] ^ q[25] ^ q[26] ^ q[27] ^ q[28] ^ q[29] ^ q[30] ^ q[31];
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end
    
endmodule"
N/A,N/A,-1,20,0,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31]? {q[30:0], 1'b0} : q_next;
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end

endmodule"
N/A,N/A,-1,21,0,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31] ^ q[0] ^ q[1] ^ q[2] ^ q[3] ^ q[4] ^ q[5] ^ q[6] ^ q[7] ^ q[8] ^ q[9] ^ q[10] ^ q[11] ^ q[12] ^ q[13] ^ q[14] ^ q[15] ^ q[16] ^ q[17] ^ q[18] ^ q[19] ^ q[20] ^ q[21] ^ q[22] ^ q[23] ^ q[24] ^ q[25] ^ q[26] ^ q[27] ^ q[28] ^ q[29] ^ q[30] ^ q[31];
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end
    
endmodule"
N/A,N/A,-1,22,0,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31] ^ q[0] ^ q[1] ^ q[2] ^ q[3] ^ q[4] ^ q[5] ^ q[6] ^ q[7] ^ q[8] ^ q[9] ^ q[10] ^ q[11] ^ q[12] ^ q[13] ^ q[14] ^ q[15] ^ q[16] ^ q[17] ^ q[18] ^ q[19] ^ q[20] ^ q[21] ^ q[22] ^ q[23] ^ q[24] ^ q[25] ^ q[26] ^ q[27] ^ q[28] ^ q[29] ^ q[30] ^ q[31];
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end
    
endmodule"
N/A,N/A,-1,23,0,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31]? {q[30:0], 1'b0} : q_next;
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end

endmodule"
N/A,N/A,-1,24,0,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31] ^ q[30] ^ q[29] ^ q[28] ^ q[27] ^ q[26] ^ q[25] ^ q[24] ^ q[23] ^ q[22] ^ q[21] ^ q[20] ^ q[19] ^ q[18] ^ q[17] ^ q[16] ^ q[15] ^ q[14] ^ q[13] ^ q[12] ^ q[11] ^ q[10] ^ q[9] ^ q[8] ^ q[7] ^ q[6] ^ q[5] ^ q[4] ^ q[3] ^ q[2] ^ q[1] ^ q[0];
        q_next[31] = q[31] ^ q[31] ^ q[30] ^ q[30] ^ q[29] ^ q[29] ^ q[28] ^ q[28] ^ q[27] ^ q[27] ^ q[26] ^ q[26] ^ q[25] ^ q[25] ^ q[24] ^ q[24] ^ q[23] ^ q[23] ^ q[22] ^ q[22] ^ q[21] ^ q[21] ^ q[20] ^ q[20] ^ q[19] ^ q[19] ^ q[18] ^ q[18] ^ q[17] ^ q[17] ^ q[16] ^ q[16] ^ q[15] ^ q[15] ^ q[14] ^ q[14] ^ q[13] ^ q[13] ^ q[12] ^ q[12] ^ q[11] ^ q[11] ^ q[10] ^ q[10] ^ q[9] ^ q[9] ^ q[8] ^ q[8] ^ q[7] ^ q[7] ^ q[6] ^ q[6] ^ q[5] ^ q[5] ^ q[4] ^ q[4] ^ q[3] ^ q[3] ^ q[2] ^ q[2] ^ q[1] ^ q[1] ^ q[0];
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end
    
endmodule"
N/A,N/A,-1,25,0,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    wire [31:0] q_bar, q_next;
    
    assign q_bar = ~q;
    
    assign q_next = q_bar ^ q[31];
    
    always @(posedge clk)
        if(reset)
            q <= 32'h1;
    	else
            q <= q_next;
endmodule"
N/A,N/A,-1,26,0,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31] ^ q[0] ^ q[1] ^ q[2] ^ q[3] ^ q[4] ^ q[5] ^ q[6] ^ q[7] ^ q[8] ^ q[9] ^ q[10] ^ q[11] ^ q[12] ^ q[13] ^ q[14] ^ q[15] ^ q[16] ^ q[17] ^ q[18] ^ q[19] ^ q[20] ^ q[21] ^ q[22] ^ q[23] ^ q[24] ^ q[25] ^ q[26] ^ q[27] ^ q[28] ^ q[29] ^ q[30] ^ q[31];
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end
    
endmodule"
N/A,N/A,-1,27,0,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31] ^ q[0];
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end
    
endmodule"
N/A,N/A,-1,28,0,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31] ^ q[0] ^ q[1] ^ q[2] ^ q[3] ^ q[4] ^ q[5] ^ q[6] ^ q[7] ^ q[8] ^ q[9] ^ q[10] ^ q[11] ^ q[12] ^ q[13] ^ q[14] ^ q[15] ^ q[16] ^ q[17] ^ q[18] ^ q[19] ^ q[20] ^ q[21] ^ q[22] ^ q[23] ^ q[24] ^ q[25] ^ q[26] ^ q[27] ^ q[28] ^ q[29] ^ q[30] ^ q[31];
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end
    
endmodule"
N/A,N/A,-1,29,0,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31] ^ q[0];
        q_next[31] = q[0];
        q_next[22] = q[0];
        q_next[2] = q[0];
        q_next[1] = q[0];
        q_next[0] = q[0];
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end
    
endmodule"
N/A,N/A,-1,30,0,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31]? {q[30:0], 1'b0} : q_next;
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end
    
endmodule"
N/A,N/A,-1,31,0,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31]? {q[30:0], 1'b0} : q_next;
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end
    
endmodule"
N/A,N/A,-1,32,0,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 
    
    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31]? {q[30:0], 1'b0} : q[31:0];
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end
    
endmodule"
N/A,N/A,-1,33,0,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31] ^ q[0] ^ q[1] ^ q[2] ^ q[3];
        q_next[31] = q[0][31] ^ q[0][0] ^ q[0][1] ^ q[0][2] ^ q[0][3];
        q_next[30:0] = q[31:0];
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end
    
endmodule"
N/A,N/A,-1,34,0,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    wire [31:0] q_next, q_reg;
    
    assign q_next = q_reg + 1;
    
    always @ (posedge clk)
        if (reset)
            q_reg <= 32'h1;
        else
            q_reg <= q_next;
    
    assign q = q_reg;

endmodule"
N/A,N/A,-1,35,0,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31]? {q[30:0], 1'b0} : q_next;
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end
    
endmodule"
N/A,N/A,-1,36,0,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31] ^ q[0] ^ q[1] ^ q[2] ^ q[3];
        q_next[31] = q[0][31] ^ q[0][0] ^ q[0][1] ^ q[0][2] ^ q[0][3];
        q_next[30:0] = q[31:0];
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end
    
endmodule"
N/A,N/A,-1,37,0,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31] ^ q[0];
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end

endmodule"
N/A,N/A,-1,38,0,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31]? {q[30:0], 1'b0} : q[31:0];
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end
    
endmodule"
N/A,N/A,-1,39,0,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31]? {q[30:0], 1'b0} : q[31:0];
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end
    
endmodule"
N/A,N/A,-1,40,0,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    wire [31:0] q_wire;
    
    assign q = q_wire;
    
    assign q_wire[31] = q_wire[30] ^ q_wire[31];
    assign q_wire[30] = q_wire[29] ^ q_wire[31];
    assign q_wire[29] = q_wire[28] ^ q_wire[31];
    assign q_wire[28] = q_wire[27] ^ q_wire[31];
    assign q_wire[27] = q_wire[26] ^ q_wire[31];
    assign q_wire[26] = q_wire[25] ^ q_wire[31];
    assign q_wire[25] = q_wire[24] ^ q_wire[31];
    assign q_wire[24] = q_wire[23] ^ q_wire[31];
    assign q_wire[23] = q_wire[22] ^ q_wire[31];
    assign q_wire[22] = q_wire[21] ^ q_wire[31];
    assign q_wire[21] = q_wire[20] ^ q_wire[31];
    assign q_wire[20] = q_wire[19] ^ q_wire[31];
    assign q_wire[19] = q_wire[18] ^ q_wire[31];
    assign q_wire[18] = q_wire[17] ^ q_wire[31];
    assign q_wire[17] = q_wire[16] ^ q_wire[31];
    assign q_wire[16] = q_wire[15] ^ q_wire[31];
    assign q_wire[15] = q_wire[14] ^ q_wire[31];
    assign q_wire[14] = q_wire[13] ^ q_wire[31];
    assign q_wire[13] = q_wire[12] ^ q_wire[31];
    assign q_wire[12] = q_wire[11] ^ q_wire[31];
    assign q_wire[11] = q_wire[10] ^ q_wire[31];
    assign q_wire[10] = q_wire[9] ^ q_wire[31];
    assign q_wire[9] = q_wire[8] ^ q_wire[31];
    assign q_wire[8] = q_wire[7] ^ q_wire[31];
    assign q_wire[7] = q_wire[6] ^ q_wire[31];
    assign q_wire[6] = q_wire[5] ^ q_wire[31];
    assign q_wire[5] = q_wire[4] ^ q_wire[31];
    assign q_wire[4] = q_wire[3] ^ q_wire[31];
    assign q_wire[3] = q_wire[2] ^ q_wire[31];
    assign q_wire[2] = q_wire[1] ^ q_wire[31];
    assign q_wire[1] = q_wire[0] ^ q_wire[31];
    assign q_wire[0] = q_wire[0] ^ q_wire[31];
    
    always @(posedge clk) begin
        if(reset)
            q_wire <= 32'h1;
        else
            q_wire <= q_wire >> 1;
    end
    
endmodule"
N/A,N/A,-1,41,0,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31] ^ q[0] ^ q[1] ^ q[2] ^ q[3] ^ q[4] ^ q[5] ^ q[6] ^ q[7] ^ q[8] ^ q[9] ^ q[10] ^ q[11] ^ q[12] ^ q[13] ^ q[14] ^ q[15] ^ q[16] ^ q[17] ^ q[18] ^ q[19] ^ q[20] ^ q[21] ^ q[22] ^ q[23] ^ q[24] ^ q[25] ^ q[26] ^ q[27] ^ q[28] ^ q[29] ^ q[30] ^ q[31];
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end
    
endmodule"
N/A,N/A,-1,42,0,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31]? {q[30:0], 1'b0} : q[30:0] ^ q[31];
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end
    
endmodule"
N/A,N/A,-1,43,0,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31]? {q[30:0], 1'b0} : q[30:0] ^ q[31];
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end
    
endmodule"
N/A,N/A,-1,44,0,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31]? {q[30:0], 1'b0} : q_next;
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end
    
endmodule"
N/A,N/A,-1,45,0,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31] ^ q[0];
        q_next[31] = q[0];
        q_next[22] = q[0];
        q_next[2] = q[0];
        q_next[1] = q[0];
        q_next[0] = q[0];
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end
    
endmodule"
N/A,N/A,-1,46,0,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31] ^ q[0];
        q_next = q_next >> 1;
        q_next[31] = q[0] ^ q[31];
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end
    
endmodule"
N/A,N/A,-1,47,0,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31]? {q[30:0], 1'b0} : q_next;
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end
    
endmodule"
N/A,N/A,-1,48,0,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31] ^ q[0] ^ q[1] ^ q[2] ^ q[3] ^ q[4] ^ q[5] ^ q[6] ^ q[7] ^ q[8] ^ q[9] ^ q[10] ^ q[11] ^ q[12] ^ q[13] ^ q[14] ^ q[15] ^ q[16] ^ q[17] ^ q[18] ^ q[19] ^ q[20] ^ q[21] ^ q[22] ^ q[23] ^ q[24] ^ q[25] ^ q[26] ^ q[27] ^ q[28] ^ q[29] ^ q[30] ^ q[31];
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end
    
endmodule"
N/A,N/A,-1,49,0,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31] ^ q[0] ^ q[1] ^ q[2] ^ q[3];
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end
    
endmodule"
N/A,N/A,-1,50,0,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31] ^ q[0] ^ q[1] ^ q[2] ^ q[3];
        q_next[31] = q[0][31] ^ q[0][0] ^ q[0][1] ^ q[0][2] ^ q[0][3];
        q_next[30:0] = q[31:0];
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end
    
endmodule"
N/A,N/A,-1,51,0,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31] ^ q[0] ^ q[1] ^ q[2] ^ q[3];
        q_next[31] = q[0][31] ^ q[0][0] ^ q[0][1] ^ q[0][2] ^ q[0][3];
        q_next[30:0] = q[31:0];
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end

endmodule"
N/A,N/A,-1,52,0,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31]? {q[30:0], 1'b0} : q_next;
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end
    
endmodule"
N/A,N/A,-1,53,0,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31]? {q[30:0], 1'b0} : q[30:0];
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end
    
endmodule"
N/A,N/A,-1,54,0,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31] ^ q[0] ^ q[1] ^ q[2] ^ q[3];
        q_next[31] = q[0][31] ^ q[0][0] ^ q[0][1] ^ q[0][2] ^ q[0][3];
        q_next[30:0] = q[31:0];
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end
    
endmodule"
N/A,N/A,-1,55,0,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    wire [31:0] q_wire;
    
    assign q = q_wire;
    
    always @(posedge clk) begin
        if(reset)
            q_wire <= 32'h1;
        else
            q_wire <= {q_wire[30:0], q_wire[31] ^ q_wire[30:1]};
    end
    
endmodule"
N/A,N/A,-1,56,0,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    wire [31:0] q_next, q_reg;
    
    assign q_next = q_reg + 1;
    
    always @(posedge clk)
        if(reset)
            q_reg <= 32'h1;
    	else
            q_reg <= q_next;
    
    assign q = q_reg;

endmodule"
N/A,N/A,-1,57,0,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31]? {q[30:0], 1'b0} : q[31:0];
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end
    
endmodule"
N/A,N/A,-1,58,0,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    wire [31:0] q_next;
    assign q_next = {q[30:0], q[31] ^ q[23] ^ q[1]};
    
    always @ (posedge clk)
        if(reset)
            q <= 32'h1;
    	else
            q <= q_next;
endmodule"
N/A,N/A,-1,59,0,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31] ^ q[0] ^ q[1] ^ q[2] ^ q[3];
        q_next[31] = q[0][31] ^ q[0][0] ^ q[0][1] ^ q[0][2] ^ q[0][3];
        q_next[30:0] = q[31:1];
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end
    
endmodule"
N/A,N/A,-1,60,0,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31]? {q[30:0], 1'b0} : q_next;
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end
    
endmodule"
N/A,N/A,-1,61,0,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31] ^ q[0] ^ q[1] ^ q[2] ^ q[3] ^ q[4] ^ q[5] ^ q[6] ^ q[7] ^ q[8] ^ q[9] ^ q[10] ^ q[11] ^ q[12] ^ q[13] ^ q[14] ^ q[15] ^ q[16] ^ q[17] ^ q[18] ^ q[19] ^ q[20] ^ q[21] ^ q[22] ^ q[23] ^ q[24] ^ q[25] ^ q[26] ^ q[27] ^ q[28] ^ q[29] ^ q[30] ^ q[31];
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end
    
endmodule"
N/A,N/A,-1,62,0,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31]? {q[30:0], 1'b0} : q_next;
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end
endmodule"
N/A,N/A,-1,63,0,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31]? {q[30:0], 1'b0} : q_next;
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end

endmodule"
N/A,N/A,-1,64,0,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31] ^ q[0];
        q_next[31] = q[0];
        q_next[22] = q[0];
        q_next[2] = q[0];
        q_next[1] = q[0];
        q_next[0] = q[0];
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end

endmodule"
N/A,N/A,-1,65,0,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31]? {q[30:0], 1'b0} : q[31:0];
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end
    
endmodule"
N/A,N/A,-1,66,0,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31]? {q[30:0], 1'b0} : q[31:0];
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end

endmodule"
N/A,N/A,-1,67,0,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 
    
    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31] ^ q[30] ^ q[29] ^ q[28] ^ q[27] ^ q[26] ^ q[25] ^ q[24] ^ q[23] ^ q[22] ^ q[21] ^ q[20] ^ q[19] ^ q[18] ^ q[17] ^ q[16] ^ q[15] ^ q[14] ^ q[13] ^ q[12] ^ q[11] ^ q[10] ^ q[9] ^ q[8] ^ q[7] ^ q[6] ^ q[5] ^ q[4] ^ q[3] ^ q[2] ^ q[1] ^ q[0];
        
        if(reset)
            q_next = 32'h1;
    end
    
    always @(posedge clk) begin
        q <= q_next;
    end
    
endmodule"
N/A,N/A,-1,68,0,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31]? {q[30:0], 1'b0} : q_next;
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end

endmodule"
N/A,N/A,-1,69,0,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31] ^ q[0] ^ q[1] ^ q[2] ^ q[3];
        q_next[31] = q[0][31] ^ q[0][0] ^ q[0][1] ^ q[0][2] ^ q[0][3];
        q_next[30:0] = q[31:0];
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end
    
endmodule"
N/A,N/A,-1,70,0,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    wire [31:0] q_bar;
    assign q_bar = ~q;
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_bar;
    end

endmodule"
N/A,N/A,-1,71,0,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    wire [31:0] q_next;
    reg [31:0] q_reg;
    
    assign q = q_reg;
    
    always @(*) begin
        q_next = q_reg;
        q_next[31] = q_reg[0] ^ q_reg[31];
        q_next[30:23] = q_reg[31:24];
        q_next[22:1] = q_reg[23:1];
        q_next[0] = q_reg[22] ^ q_reg[0];
    end
    
    always @(posedge clk) begin
        if(reset)
            q_reg <= 32'h1;
        else
            q_reg <= q_next;
    end
endmodule"
N/A,N/A,-1,72,0,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31]? {q[30:0], 1'b0} : q[31:0];
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end

endmodule"
N/A,N/A,-1,73,0,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31]? {q[30:0], 1'b0} : q[31:0];
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end
    
endmodule"
N/A,N/A,-1,74,0,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31] ^ q[0] ^ q[1] ^ q[2] ^ q[3] ^ q[4] ^ q[5] ^ q[6] ^ q[7] ^ q[8] ^ q[9] ^ q[10] ^ q[11] ^ q[12] ^ q[13] ^ q[14] ^ q[15] ^ q[16] ^ q[17] ^ q[18] ^ q[19] ^ q[20] ^ q[21] ^ q[22] ^ q[23] ^ q[24] ^ q[25] ^ q[26] ^ q[27] ^ q[28] ^ q[29] ^ q[30] ^ q[31];
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end
    
endmodule"
N/A,N/A,-1,75,0,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    wire [31:0] q_bar, q_next;
    
    assign q_bar = ~q;
    
    assign q_next = q_bar ^ q[31:1];
    
    always @(posedge clk)
        if(reset)
            q <= 32'h1;
    	else
            q <= q_next;
endmodule"
N/A,N/A,-1,76,0,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31] ^ q[0];
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end
    
endmodule"
N/A,N/A,-1,77,0,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31] ^ q[0] ^ q[1] ^ q[2] ^ q[3];
        q_next[31] = q[0][31] ^ q[0][0] ^ q[0][1] ^ q[0][2] ^ q[0][3];
        q_next[30:0] = q[31:0];
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end

endmodule"
N/A,N/A,-1,78,0,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 
    
    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31] ^ q[30] ^ q[29] ^ q[28] ^ q[27] ^ q[26] ^ q[25] ^ q[24] ^ q[23] ^ q[22] ^ q[21] ^ q[20] ^ q[19] ^ q[18] ^ q[17] ^ q[16] ^ q[15] ^ q[14] ^ q[13] ^ q[12] ^ q[11] ^ q[10] ^ q[9] ^ q[8] ^ q[7] ^ q[6] ^ q[5] ^ q[4] ^ q[3] ^ q[2] ^ q[1] ^ q[0];
        
        if(reset)
            q_next = 32'h1;
    end
    
    always @(posedge clk) begin
        q <= q_next;
    end
    
endmodule"
N/A,N/A,-1,79,0,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    wire [31:0] q_bar, q_next;
    
    assign q_bar = ~q;
    
    assign q_next = q_bar ^ q[31];
    
    always @ (posedge clk)
        if(reset)
            q <= 32'h1;
    	else
            q <= q_next;
endmodule"
N/A,N/A,-1,80,0,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 
    
    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31] ^ q[0] ^ q[1] ^ q[2] ^ q[3] ^ q[4] ^ q[5] ^ q[6] ^ q[7] ^ q[8] ^ q[9] ^ q[10] ^ q[11] ^ q[12] ^ q[13] ^ q[14] ^ q[15] ^ q[16] ^ q[17] ^ q[18] ^ q[19] ^ q[20] ^ q[21] ^ q[22] ^ q[23] ^ q[24] ^ q[25] ^ q[26] ^ q[27] ^ q[28] ^ q[29] ^ q[30] ^ q[31];
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end
    
endmodule"
N/A,N/A,-1,81,0,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31] ^ q[0];
        q_next[31] = q[0] ^ q[1] ^ q[2] ^ q[3] ^ q[4] ^ q[5] ^ q[6] ^ q[7] ^ q[8] ^ q[9] ^ q[10] ^ q[11] ^ q[12] ^ q[13] ^ q[14] ^ q[15] ^ q[16] ^ q[17] ^ q[18] ^ q[19] ^ q[20] ^ q[21] ^ q[22] ^ q[23] ^ q[24] ^ q[25] ^ q[26] ^ q[27] ^ q[28] ^ q[29] ^ q[30] ^ q[31];
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end
    
endmodule"
N/A,N/A,-1,82,0,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31] ^ q[0] ^ q[1] ^ q[2] ^ q[3];
        q_next[31] = q[0][31] ^ q[0][0] ^ q[0][1] ^ q[0][2] ^ q[0][3];
        q_next[30:0] = q[31:1];
        q_next[31] = q[31] ^ q[31] ^ q[31] ^ q[31] ^ q[31];
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end

endmodule"
N/A,N/A,-1,83,0,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31] ^ q[30] ^ q[29] ^ q[28] ^ q[27] ^ q[26] ^ q[25] ^ q[24] ^ q[23] ^ q[22] ^ q[21] ^ q[20] ^ q[19] ^ q[18] ^ q[17] ^ q[16] ^ q[15] ^ q[14] ^ q[13] ^ q[12] ^ q[11] ^ q[10] ^ q[9] ^ q[8] ^ q[7] ^ q[6] ^ q[5] ^ q[4] ^ q[3] ^ q[2] ^ q[1] ^ q[0];
        q_next[31] = q[31] ^ q[30] ^ q[29] ^ q[28] ^ q[27] ^ q[26] ^ q[25] ^ q[24] ^ q[23] ^ q[22] ^ q[21] ^ q[20] ^ q[19] ^ q[18] ^ q[17] ^ q[16] ^ q[15] ^ q[14] ^ q[13] ^ q[12] ^ q[11] ^ q[10] ^ q[9] ^ q[8] ^ q[7] ^ q[6] ^ q[5] ^ q[4] ^ q[3] ^ q[2] ^ q[1] ^ q[0];
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end
    
endmodule"
N/A,N/A,-1,84,0,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31] ^ q[0] ^ q[1] ^ q[2] ^ q[3] ^ q[4] ^ q[5] ^ q[6] ^ q[7] ^ q[8] ^ q[9] ^ q[10] ^ q[11] ^ q[12] ^ q[13] ^ q[14] ^ q[15] ^ q[16] ^ q[17] ^ q[18] ^ q[19] ^ q[20] ^ q[21] ^ q[22] ^ q[23] ^ q[24] ^ q[25] ^ q[26] ^ q[27] ^ q[28] ^ q[29] ^ q[30] ^ q[31];
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end
    
endmodule"
N/A,N/A,-1,85,0,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31] ^ q[0] ^ q[1] ^ q[2] ^ q[3];
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end
    
endmodule"
N/A,N/A,-1,86,0,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 
    
    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31]? {q[30:0], 1'b0} : q_next;
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end
    
endmodule"
N/A,N/A,-1,87,0,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 
    
    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31]? {q[30:0], 1'b0} : q_next;
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end
    
endmodule"
N/A,N/A,-1,88,0,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 
    
    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31]? {q[30:0], 1'b0} : q_next;
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end
    
endmodule"
N/A,N/A,-1,89,0,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31]? {q[30:0], 1'b0} : q[30:0];
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end
    
endmodule"
N/A,N/A,-1,90,0,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31] ^ q[0] ^ q[1] ^ q[2] ^ q[3] ^ q[4] ^ q[5] ^ q[6] ^ q[7] ^ q[8] ^ q[9] ^ q[10] ^ q[11] ^ q[12] ^ q[13] ^ q[14] ^ q[15] ^ q[16] ^ q[17] ^ q[18] ^ q[19] ^ q[20] ^ q[21] ^ q[22] ^ q[23] ^ q[24] ^ q[25] ^ q[26] ^ q[27] ^ q[28] ^ q[29] ^ q[30] ^ q[31];
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end
    
endmodule"
N/A,N/A,-1,91,0,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31] ^ q[0] ^ q[1] ^ q[2] ^ q[3];
        q_next[31] = q[0][31] ^ q[0][0] ^ q[0][1] ^ q[0][2] ^ q[0][3];
        q_next[30:0] = q[31:1];
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end
    
endmodule"
N/A,N/A,-1,92,0,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31] ^ q[0] ^ q[1] ^ q[2] ^ q[3] ^ q[4] ^ q[5] ^ q[6] ^ q[7] ^ q[8] ^ q[9] ^ q[10] ^ q[11] ^ q[12] ^ q[13] ^ q[14] ^ q[15] ^ q[16] ^ q[17] ^ q[18] ^ q[19] ^ q[20] ^ q[21] ^ q[22] ^ q[23] ^ q[24] ^ q[25] ^ q[26] ^ q[27] ^ q[28] ^ q[29] ^ q[30] ^ q[31];
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end
    
endmodule"
N/A,N/A,-1,93,0,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31] ^ q[0] ^ q[1] ^ q[2] ^ q[3] ^ q[4] ^ q[5] ^ q[6] ^ q[7] ^ q[8] ^ q[9] ^ q[10] ^ q[11] ^ q[12] ^ q[13] ^ q[14] ^ q[15] ^ q[16] ^ q[17] ^ q[18] ^ q[19] ^ q[20] ^ q[21] ^ q[22] ^ q[23] ^ q[24] ^ q[25] ^ q[26] ^ q[27] ^ q[28] ^ q[29] ^ q[30] ^ q[31];
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end

endmodule"
N/A,N/A,-1,94,0,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31] ^ q[0] ^ q[1] ^ q[2] ^ q[3];
        q_next[31] = q[0][31] ^ q[0][0] ^ q[0][1] ^ q[0][2] ^ q[0][3];
        q_next[30:0] = q[31:0];
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end
    
endmodule"
N/A,N/A,-1,95,0,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31] ^ q[0] ^ q[1] ^ q[2] ^ q[3];
        q_next[31] = q[0] & q[1] & q[2] & q[3];
        q_next[30:0] = q[31:1];
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end
    
endmodule"
N/A,N/A,-1,96,0,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31] ^ q[0] ^ q[1] ^ q[2] ^ q[3];
        q_next[31] = q[0][31] ^ q[0][0] ^ q[0][1] ^ q[0][2] ^ q[0][3];
        q_next[30:0] = q[31:0];
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end
    
endmodule"
N/A,N/A,-1,97,0,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    wire [31:0] q_bar, q_next;
    assign q_bar = ~q;
    
    assign q_next = q_bar ^ {q[31], q[23], q[1], q[0]};
    
    always @(posedge clk)
        if(reset)
            q <= 32'h1;
    	else
            q <= q_next;
endmodule"
N/A,N/A,-1,98,0,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31] ^ q[0] ^ q[1] ^ q[2] ^ q[3];
        q_next[31] = q[0] & q[1] & q[2] & q[3];
        q_next[30:0] = q[30:0] >> 1;
        q_next[31] = q[31] ^ q[0] ^ q[1] ^ q[2] ^ q[3];
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end
    
endmodule"
N/A,N/A,-1,99,0,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    wire [31:0] q_bar, q_next;
    
    assign q_bar = ~q;
    
    assign q_next = q_bar ^ q[31:1];
    
    always @(posedge clk)
        if(reset)
            q <= 32'h1;
    	else
            q <= q_next;
endmodule"
