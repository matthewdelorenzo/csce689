Area,Delay,Score,Current Run,Episode,Verilog
N/A,N/A,-1,0,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serialdata
    // New: Add parity checking.
    
    parameter idle = 0, rec_data = 1, stop_bit = 2;
    reg [1:0] state, next_state;
    
    always @(posedge clk)
        if (reset) state <= idle;
        else state <= next_state;
    
    always @(*)
        case (state)
            idle:
                begin
                    if (in) next_state = rec_data;
                    else next_state = idle;
                end
            rec_data:
                begin
                    if (in) next_state = rec_data;
                    else next_state = stop_bit;
                end
            stop_bit:
                begin
                    if (in) next_state = idle;
                    else next_state = idle;
                end
            default:
                next_state = idle;
        endcase
    
    assign done = (state == stop_bit)? 1'b1 : 1'b0;
    
    // New: Add parity checking.
    parity pff(clk, reset, in, odd);
    
    always @(posedge clk)
        if (reset) out_byte <= 8'b0;
        else if (state == rec_data) out_byte <= {in, odd};

endmodule"
N/A,N/A,-1,1,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serialdata
    // New: Add parity checking.
    
    parameter idle = 0, rec_data = 1, stop_bit = 2;
    reg [1:0] state, next_state;
    reg [9:0] counter;
    reg odd;
    
    always @(posedge clk)
        if (reset)
            state <= idle;
        else
            state <= next_state;
    
    always @(*)
        case (state)
            idle:
                if (in)
                    next_state = rec_data;
                else
                    next_state = idle;
            rec_data:
                if (counter == 1023)
                    next_state = stop_bit;
                else
                    next_state = rec_data;
            stop_bit:
                if (in)
                    next_state = idle;
                else
                    next_state = idle;
            default:
                next_state = idle;
        endcase
    
    assign done = (state == stop_bit) && (counter == 1023);
    
    always @(posedge clk)
        if (reset)
            counter <= 0;
        else if (state == rec_data)
            counter <= counter + 1;
        else
            counter <= 0;
    
    assign out_byte = {in, odd};
    
    always @(posedge clk)
        if (reset)
            odd <= 0;
        else if (state == rec_data)
            if (counter[0])
                odd <= ~odd;
    
endmodule"
N/A,N/A,-1,2,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    parameter START = 3'd0, DATA = 3'd1, PARITY = 3'd2, STOP = 3'd3, DELAY = 3'd4;
    reg [2:0] state, next_state;
    reg [8:0] shift_reg;
    reg [3:0] counter;
    reg odd;
    reg out;
    reg [8:0] out_byte_reg;
    assign done = (state == STOP);
    
    always @(*)
        case (state)
            START: begin
                if (in)
                    next_state = DATA;
                else
                    next_state = START;
            end
            DATA: begin
                if (counter == 9)
                    next_state = PARITY;
                else
                    next_state = DATA;
            end
            PARITY: begin
                if (counter == 9)
                    next_state = STOP;
                else
                    next_state = PARITY;
            end
            STOP: begin
                if (in)
                    next_state = DELAY;
                else
                    next_state = START;
            end
            DELAY: next_state = START;
            default: next_state = START;
        endcase
    
    always @(posedge clk) begin
        if (reset)
            state <= START;
        else
            state <= next_state;
    end
    
    always @(posedge clk) begin
        if (state == DATA)
            shift_reg <= {shift_reg[7:0], in};
        else if (state == PARITY)
            shift_reg <= {shift_reg[7:0], odd};
    end
    
    always @(posedge clk) begin
        if (state == STOP) begin
            out_byte_reg <= shift_reg;
            out <= 0;
            counter <= 0;
        end
        else if (state == DELAY) begin
            counter <= counter + 4'd1;
            if (counter == 9) begin
                out <= 1;
                counter <= 0;
            end
        end
        else begin
            out <= 0;
            counter <= 0;
        end
    end
    
    assign out_byte = out_byte_reg[7:0];
    
    always @(*)
        case (state)
            START: begin
                odd <= 0;
            end
            DATA: begin
                odd <= in;
            end
            PARITY: begin
                odd <= odd ^ in;
            end
            STOP: begin
            end
            DELAY: begin
            end
        endcase

endmodule"
N/A,N/A,-1,3,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    parameter START = 3'd0, DATA = 3'd1, PARITY = 3'd2, STOP = 3'd3, DELAY = 3'd4;
    reg [2:0] state, next_state;
    reg [8:0] shift_reg;
    reg [3:0] counter;
    reg odd;
    reg out;
    reg [8:0] out_byte_reg;
    assign done = (state == STOP);
    
    always @(*)
        case (state)
            START: begin
                if (in)
                    next_state = DATA;
                else
                    next_state = START;
            end
            DATA: begin
                if (counter == 9)
                    next_state = PARITY;
                else
                    next_state = DATA;
            end
            PARITY: begin
                if (counter == 9)
                    next_state = STOP;
                else
                    next_state = PARITY;
            end
            STOP: begin
                if (in)
                    next_state = DELAY;
                else
                    next_state = START;
            end
            DELAY: next_state = START;
            default: next_state = START;
        endcase
    
    always @(posedge clk) begin
        if (reset)
            state <= START;
        else
            state <= next_state;
    end
    
    always @(posedge clk) begin
        if (state == DATA)
            shift_reg <= {shift_reg[7:0], in};
        else if (state == PARITY)
            shift_reg <= {shift_reg[7:0], odd};
    end
    
    always @(posedge clk) begin
        if (state == STOP) begin
            out_byte_reg <= shift_reg;
            out <= 0;
            counter <= 0;
        end
        else if (state == DELAY) begin
            counter <= counter + 4'd1;
            if (counter == 9) begin
                out <= 1;
                counter <= 0;
            end
        end
        else begin
            out <= 0;
            counter <= 0;
        end
    end
    
    assign out_byte = out_byte_reg[7:0];
    
    always @(*)
        case (state)
            START: begin
                odd <= 0;
            end
            DATA: begin
                odd <= in;
            end
            PARITY: begin
                odd <= odd ^ in;
            end
            STOP: begin
            end
            DELAY: begin
            end
        endcase

endmodule"
N/A,N/A,-1,4,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    parameter START = 3'd0, DATA = 3'd1, PARITY = 3'd2, STOP = 3'd3, DELAY = 3'd4;
    reg [2:0] state, next_state;
    reg [8:0] shift_reg;
    reg [3:0] counter;
    reg odd;
    reg out;
    reg [8:0] out_byte_reg;
    assign done = (state == STOP);
    
    always @(*)
        case (state)
            START: begin
                if (in)
                    next_state = DATA;
                else
                    next_state = START;
            end
            DATA: begin
                if (counter == 9)
                    next_state = PARITY;
                else
                    next_state = DATA;
            end
            PARITY: begin
                if (counter == 9)
                    next_state = STOP;
                else
                    next_state = PARITY;
            end
            STOP: begin
                if (in)
                    next_state = DELAY;
                else
                    next_state = START;
            end
            DELAY: next_state = START;
            default: next_state = START;
        endcase
    
    always @(posedge clk) begin
        if (reset)
            state <= START;
        else
            state <= next_state;
    end
    
    always @(posedge clk) begin
        if (state == DATA)
            shift_reg <= {shift_reg[7:0], in};
        else if (state == PARITY)
            shift_reg <= {shift_reg[7:0], odd};
    end
    
    always @(posedge clk) begin
        if (state == STOP) begin
            out_byte_reg <= shift_reg;
            out <= 0;
            counter <= 0;
        end
        else if (state == DELAY) begin
            counter <= counter + 4'd1;
            if (counter == 9) begin
                out <= 1;
                counter <= 0;
            end
        end
        else begin
            out <= 0;
            counter <= 0;
        end
    end
    
    assign out_byte = out_byte_reg[7:0];
    
    always @(*)
        case (state)
            START: begin
                odd <= 0;
            end
            DATA: begin
                odd <= in;
            end
            PARITY: begin
                odd <= odd ^ in;
            end
            STOP: begin
            end
            DELAY: begin
            end
        endcase

endmodule"
N/A,N/A,-1,5,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    parameter START = 3'd0, DATA = 3'd1, PARITY = 3'd2, STOP = 3'd3, DELAY = 3'd4;
    reg [2:0] state, next_state;
    reg [8:0] counter;
    reg odd;
    reg [7:0] out;
    reg out_bit;
    assign done = (state == STOP);
    always @(*)
        case (state)
            START: begin
                if(in)
                    next_state = DATA;
                else
                    next_state = START;
            end
            DATA: begin
                if(counter == 9'd159)
                    next_state = PARITY;
                else
                    next_state = DATA;
            end
            PARITY: begin
                if(counter == 9'd159)
                    next_state = STOP;
                else
                    next_state = PARITY;
            end
            STOP: begin
                if(counter == 9'd159)
                    next_state = DELAY;
                else
                    next_state = STOP;
            end
            DELAY: begin
                if(counter == 9'd159)
                    next_state = START;
                else
                    next_state = DELAY;
            end
            default: next_state = START;
        endcase
    always @(posedge clk)
        if(reset)
            state <= START;
    else
        state <= next_state;
    always @(posedge clk)
        if(state == DATA)
            counter <= counter + 1;
    always @(posedge clk)
        if(state == PARITY)
            out_byte[7:1] <= {out_bit, odd};
    always @(posedge clk)
        if(state == STOP) begin
            out_byte[0] <= in;
            counter <= 0;
        end
    always @(posedge clk)
        if(state == DELAY)
            out_bit <= in;
    always @(*)
        case (state)
            START: begin
                out = 0;
                out_bit = 0;
                odd = 0;
            end
            DATA: begin
                out = {out, in};
            end
            PARITY: begin
                odd = parity_bit;
            end
            STOP: begin
                out_bit = 1;
            end
            DELAY: begin
                // Intentionally left blank
            end
        endcase
    function parity_bit;
        input [7:0] data;
        begin
            parity_bit = ^data;
        end
    endfunction
endmodule"
N/A,N/A,-1,6,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    parameter START = 0, DATA = 1, STOP = 2, DELAY = 3;
    reg [1:0] state, next_state;
    reg [3:0] count;
    reg out;
    
    always @(*) begin
        case (state)
            START: begin
                if(in)
                    next_state = DATA;
                else
                    next_state = START;
            end
            DATA: begin
                if(count == 8)
                    next_state = STOP;
                else if(in)
                    next_state = DATA;
                else
                    next_state = START;
            end
            STOP: begin
                if(in) begin
                    next_state = DELAY;
                    out = 1;
                end
                else
                    next_state = START;
            end
            DELAY: begin
                if(count == 4)
                    next_state = START;
                else
                    next_state = DELAY;
            end
            default: next_state = START;
        endcase
    end
    
    always @(posedge clk) begin
        if(reset)
            state <= START;
        else
            state <= next_state;
    end
    
    always @(posedge clk) begin
        if(state == DATA || state == STOP)
            count <= count + 4'b1;
        else
            count <= 4'b0;
    end
    
    assign done = (state == DELAY)? out : 0;
    assign out_byte = (state == START)? count : 8'b0;
    
endmodule"
N/A,N/A,-1,7,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    parameter START = 0, DATA = 1, STOP = 2, DELAY = 3;
    reg [1:0] state, next_state;
    reg [3:0] count;
    reg out;
    
    always @(*) begin
        case (state)
            START: begin
                if(in)
                    next_state = DATA;
                else
                    next_state = START;
            end
            DATA: begin
                if(count == 8)
                    next_state = STOP;
                else if(in)
                    next_state = DATA;
                else
                    next_state = START;
            end
            STOP: begin
                if(in) begin
                    next_state = DELAY;
                    out = 1;
                end
                else
                    next_state = START;
            end
            DELAY: begin
                if(count == 4)
                    next_state = START;
                else
                    next_state = DELAY;
            end
            default: next_state = START;
        endcase
    end
    
    always @(posedge clk) begin
        if(reset)
            state <= START;
        else
            state <= next_state;
    end
    
    always @(posedge clk) begin
        if(state == DATA || state == STOP)
            count <= count + 4'b1;
        else
            count <= 4'b0;
    end
    
    assign done = (state == DELAY)? out : 0;
    assign out_byte = (state == START)? count : 8'b0;
    
endmodule"
N/A,N/A,-1,8,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serialdata
    // New: Add parity checking.
    
    parity p1(clk, reset, in, odd);
    
    // New: Add parity checking.
    
    // Create a byte counter
    
    reg [3:0] counter;
    
    always @(posedge clk)
        if (reset) counter <= 0;
        else if (counter < 8) counter <= counter + 1;
        else done <= 1;
    
    // New: Add parity checking.
    
    assign out_byte = {in, odd};
    
endmodule"
N/A,N/A,-1,9,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serialdata
    // New: Add parity checking.
    
    parity p1(clk, reset, in, odd);
    
    // New: Add parity checking.
    
    // Create a byte counter
    
    reg [3:0] counter;
    
    always @(posedge clk)
        if (reset) counter <= 0;
        else if (counter < 8) counter <= counter + 1;
        else done <= 1;
    
    // New: Add parity checking.
    
    assign out_byte = {in, odd};
    
endmodule"
N/A,N/A,-1,10,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serialdata
    // New: Add parity checking.
    
    parity p1(clk, reset, in, odd);
    
    // New: Add parity checking.
    
    // Create a byte counter
    
    reg [3:0] counter;
    
    always @(posedge clk)
        if (reset) counter <= 0;
        else if (counter < 8) counter <= counter + 1;
        else done <= 1;
    
    // New: Add parity checking.
    
    assign out_byte = {in, odd};
    
endmodule"
N/A,N/A,-1,11,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.
    
    parameter idle = 0, rec_data = 1, stop_bit = 2;
    reg [1:0] state, next_state;
    reg [3:0] counter;
    reg odd;
    
    always @(posedge clk)
        if (reset) state <= idle;
        else state <= next_state;
    
    always @(*)
        case (state)
            idle:
                if (in) next_state = rec_data;
                else next_state = idle;
            rec_data:
                if (counter < 8) next_state = rec_data;
                else next_state = stop_bit;
            stop_bit:
                if (in) next_state = idle;
                else next_state = idle;
            default:
                next_state = idle;
        endcase
    
    always @(posedge clk)
        if (reset) counter <= 0;
        else if (state == rec_data && next_state == rec_data) counter <= counter + 4'b1;
        else if (state == stop_bit && next_state == stop_bit) counter <= counter + 4'b1;
    
    assign done = (state == stop_bit);
    
    // New: Add parity checking.
    
    parity pff(clk, reset, in, odd);
    
    always @(posedge clk)
        if (reset) out_byte <= 8'b0;
        else if (state == rec_data && odd) out_byte <= {out_byte[6:0], in};

endmodule"
N/A,N/A,-1,12,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.
    
    parameter idle = 3'b000, start = 3'b001, data = 3'b010, stop = 3'b011, end = 3'b100;
    reg [2:0] state, next_state;
    reg odd;
    reg [7:0] out;
    reg [8:0] counter;
    
    always @(posedge clk)
        if (reset)
            state <= idle;
        else
            state <= next_state;
    
    always @(*)
        case (state)
            idle:
                if (in)
                    next_state = start;
                else
                    next_state = idle;
            start:
                if (counter == 9'd249)
                    next_state = data;
                else
                    next_state = start;
            data:
                if (counter == 9'd499)
                    next_state = stop;
                else
                    next_state = data;
            stop:
                if (counter == 9'd999)
                    next_state = end;
                else
                    next_state = stop;
            endcase
    
    always @(posedge clk)
        if (reset)
            counter <= 0;
        else if (next_state == data)
            counter <= counter + 1;
        else
            counter <= 0;
    
    always @(posedge clk)
        if (reset)
            out_byte <= 0;
        else if (next_state == end)
            out_byte <= out;
    
    always @(posedge clk)
        if (reset)
            done <= 0;
        else if (next_state == end)
            done <= 1;
    
    always @(posedge clk)
        if (reset)
            odd <= 0;
        else if (next_state == data)
            odd <= ~odd;
    
    always @(*)
        case (state)
            idle:
                out <= 8'b0;
            start:
                out <= 8'b0;
            data:
                out <= {in, odd};
            stop:
                out <= 8'b0;
            endcase

endmodule"
N/A,N/A,-1,13,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.
    
    parameter idle = 3'b000, start = 3'b001, data = 3'b010, stop = 3'b011, end = 3'b100;
    reg [2:0] state, next_state;
    reg odd;
    reg [7:0] out;
    reg [8:0] counter;
    
    always @(posedge clk)
        if (reset)
            state <= idle;
        else
            state <= next_state;
    
    always @(*)
        case (state)
            idle:
                if (in)
                    next_state = start;
                else
                    next_state = idle;
            start:
                if (counter == 9'd249)
                    next_state = data;
                else
                    next_state = start;
            data:
                if (counter == 9'd499)
                    next_state = stop;
                else
                    next_state = data;
            stop:
                if (counter == 9'd999)
                    next_state = end;
                else
                    next_state = stop;
            endcase
    
    always @(posedge clk)
        if (reset)
            counter <= 0;
        else if (next_state == data)
            counter <= counter + 1;
        else
            counter <= 0;
    
    always @(posedge clk)
        if (reset)
            out_byte <= 0;
        else if (next_state == end)
            out_byte <= out;
    
    always @(posedge clk)
        if (reset)
            done <= 0;
        else if (next_state == end)
            done <= 1;
    
    always @(posedge clk)
        if (reset)
            odd <= 0;
        else if (next_state == data)
            odd <= ~odd;
    
    always @(*)
        case (state)
            idle:
                out <= 8'b0;
            start:
                out <= 8'b0;
            data:
                out <= {in, odd};
            stop:
                out <= 8'b0;
            endcase

endmodule"
N/A,N/A,-1,14,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    // Use FSM from Fsm_serialdata
    // New: Add parity checking.
    
    parameter idle = 0, rec_data = 1, stop_bit = 2;
    reg [1:0] state, next_state;
    reg [3:0] counter;
    reg odd;
    
    always @(posedge clk)
        if (reset)
            state <= idle;
        else
            state <= next_state;
    
    always @(*)
        case (state)
            idle:
                begin
                    if (in)
                        next_state = rec_data;
                    else
                        next_state = idle;
                end
            rec_data:
                begin
                    if (counter == 7)
                        next_state = stop_bit;
                    else
                        next_state = rec_data;
                end
            stop_bit:
                begin
                    if (in)
                        next_state = idle;
                    else
                        next_state = idle;
                end
            default:
                next_state = idle;
        endcase
    
    always @(posedge clk)
        if (reset)
            counter <= 4'b0;
        else if (state == rec_data)
            counter <= counter + 4'b1;
    
    always @(posedge clk)
        if (reset)
            done <= 0;
        else if (state == stop_bit)
            done <= 1;
    
    assign out_byte = {in, odd};
    
    // New: Add parity checking.
    parity pff(clk, reset, in, odd);

endmodule"
N/A,N/A,-1,15,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    // Use FSM from Fsm_serialdata
    // New: Add parity checking.
    
    parameter idle = 0, rec_data = 1, stop_bit = 2;
    reg [1:0] state, next_state;
    reg [3:0] counter;
    reg odd;
    
    always @(posedge clk)
        if (reset)
            state <= idle;
        else
            state <= next_state;
    
    always @(*)
        case (state)
            idle:
                begin
                    if (in)
                        next_state = rec_data;
                    else
                        next_state = idle;
                end
            rec_data:
                begin
                    if (counter == 7)
                        next_state = stop_bit;
                    else
                        next_state = rec_data;
                end
            stop_bit:
                begin
                    if (in)
                        next_state = idle;
                    else
                        next_state = idle;
                end
            default:
                next_state = idle;
        endcase
    
    always @(posedge clk)
        if (reset)
            counter <= 4'b0;
        else if (state == rec_data)
            counter <= counter + 4'b1;
    
    always @(posedge clk)
        if (reset)
            done <= 0;
        else if (state == stop_bit)
            done <= 1;
    
    assign out_byte = {in, odd};
    
    // New: Add parity checking.
    parity pff(clk, reset, in, odd);

endmodule"
N/A,N/A,-1,16,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    parameter START = 0, DATA = 1, STOP = 2, DELAY = 3;
    reg [1:0] state, next_state;
    reg [3:0] count;
    reg out;
    
    always @(*) begin
        case (state)
            START: begin
                if(in)
                    next_state = DATA;
                else
                    next_state = START;
            end
            DATA: begin
                if(count < 9)
                    next_state = DATA;
                else
                    next_state = STOP;
            end
            STOP: begin
                if(in)
                    next_state = START;
                else
                    next_state = DELAY;
            end
            DELAY: begin
                if(in)
                    next_state = START;
                else
                    next_state = DELAY;
            end
        endcase
    end
    
    always @(posedge clk) begin
        if(reset)
            state <= START;
        else
            state <= next_state;
    end
    
    always @(posedge clk) begin
        if(state == DATA)
            count <= count + 1;
        else
            count <= 0;
    end
    
    always @(posedge clk) begin
        if(state == DATA)
            out <= in;
        else
            out <= 0;
    end
    
    assign done = (state == STOP);
    assign out_byte = out;
    
endmodule"
N/A,N/A,-1,17,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    parameter START = 0, DATA = 1, STOP = 2, DELAY = 3;
    reg [1:0] state, next_state;
    reg [3:0] count;
    reg out;
    
    always @(*) begin
        case (state)
            START: begin
                if(in)
                    next_state = DATA;
                else
                    next_state = START;
            end
            DATA: begin
                if(count < 9)
                    next_state = DATA;
                else
                    next_state = STOP;
            end
            STOP: begin
                if(in)
                    next_state = START;
                else
                    next_state = DELAY;
            end
            DELAY: begin
                if(in)
                    next_state = START;
                else
                    next_state = DELAY;
            end
        endcase
    end
    
    always @(posedge clk) begin
        if(reset)
            state <= START;
        else
            state <= next_state;
    end
    
    always @(posedge clk) begin
        if(state == DATA)
            count <= count + 1;
        else
            count <= 0;
    end
    
    always @(posedge clk) begin
        if(state == DATA)
            out <= in;
        else
            out <= 0;
    end
    
    assign done = (state == STOP);
    assign out_byte = out;
    
endmodule"
N/A,N/A,-1,18,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serialdata
    // New: Add parity checking.
    
    parameter idle = 0, rec_data = 1, stop_bit = 2;
    reg [1:0] state, next_state;
    
    always @(posedge clk) begin
        if (reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    always @(*) begin
        case (state)
            idle:
                if (in)
                    next_state = rec_data;
                else
                    next_state = idle;
            rec_data:
                if (in)
                    next_state = rec_data;
                else
                    next_state = stop_bit;
            stop_bit:
                next_state = idle;
            default:
                next_state = idle;
        endcase
    end
    
    assign done = (state == stop_bit);
    
    // New: Add parity checking.
    
    parity p1(clk, reset, in, odd);
    
    always @(posedge clk) begin
        if (reset)
            out_byte <= 8'b0;
        else if (state == rec_data)
            out_byte[7:0] <= {in, odd};
    end
    
endmodule"
N/A,N/A,-1,19,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    parameter START = 3'd0, DATA = 3'd1, PARITY = 3'd2, STOP = 3'd3, DELAY = 3'd4;
    reg [2:0] state, next_state;
    reg [8:0] shift_reg;
    reg odd;
    reg [3:0] counter;
    reg out;
    assign out_byte = out;
    assign done = done_reg;
    always @(posedge clk)
        if (reset)
            state <= START;
        else
            state <= next_state;
    always @(*)
        case (state)
            START: begin
                if (in)
                    next_state = DATA;
                else
                    next_state = START;
            end
            DATA: begin
                if (counter < 9)
                    next_state = DATA;
                else
                    next_state = PARITY;
            end
            PARITY: begin
                if (counter < 9)
                    next_state = PARITY;
                else
                    next_state = STOP;
            end
            STOP: begin
                if (counter < 4)
                    next_state = DELAY;
                else
                    next_state = START;
            end
            DELAY: next_state = START;
            default: next_state = START;
        endcase
    always @(posedge clk)
        if (reset) begin
            counter <= 0;
            out <= 0;
        end
        else if (next_state == DATA)
            counter <= counter + 1;
        else if (next_state == PARITY) begin
            shift_reg[0] <= in;
            odd <= 0;
            out <= 0;
            counter <= 1;
        end
    always @(posedge clk)
        if (reset)
            done_reg <= 0;
        else if (next_state == STOP)
            done_reg <= 1;
    always @(posedge clk)
        if (reset)
            shift_reg <= 0;
        else if (next_state == DATA)
            shift_reg <= {shift_reg[7:1], in};
    always @(posedge clk)
        if (reset)
            out <= 0;
        else if (next_state == PARITY)
            out <= odd;
endmodule"
N/A,N/A,-1,20,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    parameter START = 3'd0, DATA = 3'd1, PARITY = 3'd2, STOP = 3'd3, DELAY = 3'd4;
    reg [2:0] state, next_state;
    reg [8:0] shift_reg;
    reg odd;
    reg [3:0] counter;
    reg out;
    assign out_byte = out;
    assign done = done_reg;
    always @(posedge clk)
        if (reset)
            state <= START;
        else
            state <= next_state;
    always @(*)
        case (state)
            START: begin
                if (in)
                    next_state = DATA;
                else
                    next_state = START;
            end
            DATA: begin
                if (counter < 9)
                    next_state = DATA;
                else
                    next_state = PARITY;
            end
            PARITY: begin
                if (counter < 9)
                    next_state = PARITY;
                else
                    next_state = STOP;
            end
            STOP: begin
                if (counter < 4)
                    next_state = DELAY;
                else
                    next_state = START;
            end
            DELAY: next_state = START;
            default: next_state = START;
        endcase
    always @(posedge clk)
        if (reset) begin
            counter <= 0;
            out <= 0;
        end
        else if (next_state == DATA)
            counter <= counter + 1;
        else if (next_state == PARITY) begin
            shift_reg[0] <= in;
            odd <= 0;
            out <= 0;
            counter <= 1;
        end
    always @(posedge clk)
        if (reset)
            done_reg <= 0;
        else if (next_state == STOP)
            done_reg <= 1;
    always @(posedge clk)
        if (reset)
            shift_reg <= 0;
        else if (next_state == DATA)
            shift_reg <= {shift_reg[7:1], in};
    always @(posedge clk)
        if (reset)
            out <= 0;
        else if (next_state == PARITY)
            out <= odd;
endmodule"
N/A,N/A,-1,21,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    // Use FSM from Fsm_serialdata
    // New: Add parity checking.
    
    parameter idle = 0, rec_data = 1, stop_bit = 2, error = 3;
    reg [2:0] state, next_state;
    reg [8:0] counter;
    reg odd;
    
    always @(posedge clk)
        if (reset)
            state <= idle;
        else
            state <= next_state;
    
    always @(*)
        case (state)
            idle:
                if (in)
                    next_state = rec_data;
                else
                    next_state = idle;
            rec_data:
                if (counter == 9'd239)
                    next_state = stop_bit;
                else
                    next_state = rec_data;
            stop_bit:
                if (in)
                    next_state = error;
                else
                    next_state = idle;
            error:
                next_state = idle;
            default:
                next_state = idle;
        endcase
    
    always @(posedge clk)
        if (reset)
            counter <= 0;
        else if (state == rec_data)
            counter <= counter + 1;
    
    assign done = (state == stop_bit) && (counter == 9'd239);
    
    // New: Add parity checking.
    parity p1(clk, reset, in, odd);
    
    always @(posedge clk)
        case (state)
            idle:
                out_byte <= 8'b0;
            rec_data:
                out_byte[counter] <= in ^ odd;
            stop_bit:
                out_byte[8] <= in;
            error:
                out_byte <= 8'b0;
        endcase

endmodule"
N/A,N/A,-1,22,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    // Use FSM from Fsm_serialdata
    // New: Add parity checking.
    
    parameter idle = 0, rec_data = 1, stop_bit = 2, error = 3;
    reg [2:0] state, next_state;
    reg [8:0] counter;
    reg odd;
    
    always @(posedge clk)
        if (reset)
            state <= idle;
        else
            state <= next_state;
    
    always @(*)
        case (state)
            idle:
                if (in)
                    next_state = rec_data;
                else
                    next_state = idle;
            rec_data:
                if (counter == 9'd239)
                    next_state = stop_bit;
                else
                    next_state = rec_data;
            stop_bit:
                if (in)
                    next_state = error;
                else
                    next_state = idle;
            error:
                next_state = idle;
            default:
                next_state = idle;
        endcase
    
    always @(posedge clk)
        if (reset)
            counter <= 0;
        else if (state == rec_data)
            counter <= counter + 1;
    
    assign done = (state == stop_bit) && (counter == 9'd239);
    
    // New: Add parity checking.
    parity p1(clk, reset, in, odd);
    
    always @(posedge clk)
        case (state)
            idle:
                out_byte <= 8'b0;
            rec_data:
                out_byte[counter] <= in ^ odd;
            stop_bit:
                out_byte[8] <= in;
            error:
                out_byte <= 8'b0;
        endcase

endmodule"
N/A,N/A,-1,23,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serialdata
    // New: Add parity checking.
    
    parameter idle = 0, rec_data = 1, stop_bit = 2;
    reg [1:0] state, next_state;
    
    always @(*) begin
        case (state)
            idle: begin
                if (in)
                    next_state <= rec_data;
                else
                    next_state <= idle;
            end
            rec_data: begin
                if (in)
                    next_state <= rec_data;
                else
                    next_state <= stop_bit;
            end
            stop_bit: begin
                if (in)
                    next_state <= idle;
                else
                    next_state <= idle;
            end
            default: next_state <= idle;
        endcase
    end
    
    always @(posedge clk) begin
        if (reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    assign done = (state == stop_bit);
    
    // New: Add parity checking.
    parity p1(clk, reset, in, odd);
    
    // New: Add serial output byte
    reg [7:0] out_byte_reg;
    always @(posedge clk) begin
        if (reset)
            out_byte_reg <= 0;
        else if (state == rec_data)
            out_byte_reg <= {in, out_byte_reg[7:1]};
    end
    assign out_byte = out_byte_reg;
    
endmodule"
N/A,N/A,-1,24,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serialdata
    // New: Add parity checking.
    
    parameter idle = 0, rec_data = 1, stop_bit = 2;
    reg [1:0] state, next_state;
    
    always @(*) begin
        case (state)
            idle: begin
                if (in)
                    next_state <= rec_data;
                else
                    next_state <= idle;
            end
            rec_data: begin
                if (in)
                    next_state <= rec_data;
                else
                    next_state <= stop_bit;
            end
            stop_bit: begin
                if (in)
                    next_state <= idle;
                else
                    next_state <= idle;
            end
            default: next_state <= idle;
        endcase
    end
    
    always @(posedge clk) begin
        if (reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    assign done = (state == stop_bit);
    
    // New: Add parity checking.
    parity p1(clk, reset, in, odd);
    
    // New: Add serial output byte
    reg [7:0] out_byte_reg;
    always @(posedge clk) begin
        if (reset)
            out_byte_reg <= 0;
        else if (state == rec_data)
            out_byte_reg <= {in, out_byte_reg[7:1]};
    end
    assign out_byte = out_byte_reg;
    
endmodule"
N/A,N/A,-1,25,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serialdata
    // New: Add parity checking.
    
    parameter idle = 0, rec_data = 1, stop_bit = 2;
    reg [1:0] state, next_state;
    
    always @(*) begin
        case (state)
            idle: begin
                if (in)
                    next_state <= rec_data;
                else
                    next_state <= idle;
            end
            rec_data: begin
                if (in)
                    next_state <= rec_data;
                else
                    next_state <= stop_bit;
            end
            stop_bit: begin
                if (in)
                    next_state <= idle;
                else
                    next_state <= idle;
            end
            default: next_state <= idle;
        endcase
    end
    
    always @(posedge clk) begin
        if (reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    assign done = (state == stop_bit);
    
    // New: Add parity checking.
    parity p1(clk, reset, in, odd);
    
    // New: Add serial output byte
    reg [7:0] out_byte_reg;
    always @(posedge clk) begin
        if (reset)
            out_byte_reg <= 0;
        else if (state == rec_data)
            out_byte_reg <= {in, out_byte_reg[7:1]};
    end
    assign out_byte = out_byte_reg;
    
endmodule"
N/A,N/A,-1,26,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    // Use FSM from Fsm_serialdata
    // New: Add parity checking.
    
    parameter idle = 0, rec_data = 1, stop_bit = 2;
    reg [1:0] state, next_state;
    
    always @(*) begin
        case (state)
            idle: begin
                if(~in)
                    next_state = rec_data;
                else
                    next_state = idle;
            end
            rec_data: begin
                if(~in)
                    next_state = stop_bit;
                else
                    next_state = rec_data;
            end
            stop_bit: begin
                if(~in)
                    next_state = idle;
                else
                    next_state = rec_data;
            end
            default: next_state = idle;
        endcase
    end
    
    always @(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    // New: Add parity checking.
    parity p1(clk, reset, in, odd);
    
    // New: Add parity checking.
    //assign out_byte = (state == rec_data)? {in, odd} : 8'b0;
    assign out_byte = (state == rec_data)? {in, odd} : {8{1'b0}};
    
    assign done = (state == stop_bit);

endmodule"
N/A,N/A,-1,27,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    // Use FSM from Fsm_serialdata
    // New: Add parity checking.
    
    parameter idle = 0, rec_data = 1, stop_bit = 2;
    reg [1:0] state, next_state;
    
    always @(*) begin
        case (state)
            idle: begin
                if(~in)
                    next_state = rec_data;
                else
                    next_state = idle;
            end
            rec_data: begin
                if(~in)
                    next_state = stop_bit;
                else
                    next_state = rec_data;
            end
            stop_bit: begin
                if(~in)
                    next_state = idle;
                else
                    next_state = rec_data;
            end
            default: next_state = idle;
        endcase
    end
    
    always @(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    // New: Add parity checking.
    parity p1(clk, reset, in, odd);
    
    // New: Add parity checking.
    //assign out_byte = (state == rec_data)? {in, odd} : 8'b0;
    assign out_byte = (state == rec_data)? {in, odd} : {8{1'b0}};
    
    assign done = (state == stop_bit);

endmodule"
N/A,N/A,-1,28,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.
    
    wire clk_en;
    wire parity_error;
    wire stop_bit;
    wire [7:0] byte;
    
    parity p1(.clk(clk),.reset(reset),.in(in),.odd(odd));
    serial_receiver sr1(.clk(clk),.reset(reset),.in(in),.clk_en(clk_en),.parity_error(parity_error),.stop_bit(stop_bit),.byte(byte));
    
    always @(posedge clk)
        if (reset) done <= 0;
        else if (parity_error) done <= 1;
        else if (stop_bit) done <= 1;
        else done <= 0;
        
    assign out_byte = byte;
    
endmodule"
N/A,N/A,-1,29,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.
    
    wire parity;
    
    parity p1(clk, reset, in, parity);
    
    // New: Add parity checking.
    
    wire [8:0] data;
    
    serial_receiver sr1(clk, in, data, parity, reset, done);
    
    // New: Add parity checking.
    
    assign out_byte = data[7:0];
    
endmodule"
N/A,N/A,-1,30,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.
    
    wire parity;
    
    parity p1(clk, reset, in, parity);
    
    // New: Add parity checking.
    
    wire [8:0] data;
    
    serial_receiver sr1(clk, in, data, parity, reset, done);
    
    // New: Add parity checking.
    
    assign out_byte = data[7:0];
    
endmodule"
N/A,N/A,-1,31,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.
    
    wire parity;
    
    parity p1(clk, reset, in, parity);
    
    // New: Add parity checking.
    
    wire [8:0] data;
    
    serial_receiver sr1(clk, in, data, parity, reset, done);
    
    // New: Add parity checking.
    
    assign out_byte = data[7:0];
    
endmodule"
N/A,N/A,-1,32,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.
    
    wire parity;
    
    parity p1(clk, reset, in, parity);
    
    // New: Add parity checking.
    
    wire [8:0] data;
    
    serial_receiver sr1(clk, in, data, parity, reset, done);
    
    // New: Add parity checking.
    
    assign out_byte = data[7:0];
    
endmodule"
N/A,N/A,-1,33,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.
    
    wire parity;
    
    parity p1(clk, reset, in, parity);
    
    // New: Add parity checking.
    
    wire [8:0] data;
    
    serial_receiver sr1(clk, in, data, parity, reset, done);
    
    // New: Add parity checking.
    
    assign out_byte = data[7:0];
    
endmodule"
N/A,N/A,-1,34,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.
    
    wire parity;
    
    parity p1(clk, reset, in, parity);
    
    // New: Add parity checking.
    
    wire [8:0] data;
    
    serial_receiver sr1(clk, in, data, parity, reset, done);
    
    // New: Add parity checking.
    
    assign out_byte = data[7:0];
    
endmodule"
N/A,N/A,-1,35,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    // Use FSM from Fsm_serialdata
    // New: Add parity checking.
    
    parameter idle = 0, rec_data = 1, stop_bit = 2;
    reg [1:0] state, next_state;
    reg [9:0] counter;
    reg odd;
    
    always @(posedge clk)
        if (reset) state <= idle;
        else state <= next_state;
    
    always @(state)
    begin
        case (state)
            idle:
                begin
                    counter <= 0;
                    done <= 0;
                    if (in) next_state <= rec_data;
                    else next_state <= idle;
                end
            rec_data:
                begin
                    if (counter < 10'd9)
                        begin
                            next_state <= rec_data;
                            counter <= counter + 1;
                        end
                    else
                        begin
                            next_state <= stop_bit;
                            counter <= 0;
                        end
                end
            stop_bit:
                begin
                    if (in)
                        begin
                            next_state <= idle;
                            done <= 1;
                        end
                    else
                        begin
                            next_state <= idle;
                            done <= 0;
                        end
                end
        endcase
    end
    
    // New: Add parity checking.
    
    parity p1(clk, reset, in, odd);
    
    always @(posedge clk)
        out_byte <= {in, odd};

endmodule"
N/A,N/A,-1,36,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    parameter START = 0, DATA = 1, STOP = 2, DELAY = 3;
    reg [1:0] state, next_state;
    reg [3:0] count;
    reg out;
    
    always @(*) begin
        case (state)
            START: begin
                if(in)
                    next_state = DATA;
                else
                    next_state = START;
            end
            DATA: begin
                if(count == 8)
                    next_state = STOP;
                else if(in)
                    next_state = DATA;
                else
                    next_state = START;
            end
            STOP: begin
                if(in)
                    next_state = DELAY;
                else
                    next_state = START;
            end
            DELAY: begin
                if(count >= 4)
                    next_state = START;
                else
                    next_state = DELAY;
            end
        endcase
    end
    
    always @(posedge clk) begin
        if(reset)
            state <= START;
        else
            state <= next_state;
    end
    
    always @(posedge clk) begin
        if(state == DATA)
            count <= count + 1;
        else
            count <= 0;
    end
    
    always @(*) begin
        case (state)
            START: begin
                out_byte = 8'b0;
                done = 0;
            end
            DATA: begin
                out_byte = {out, out_byte[7:1]};
            end
            STOP: begin
                done = 1;
            end
        endcase
    end
    
    always @(posedge clk) begin
        if(state == DELAY)
            out <= ~out;
        else
            out <= 0;
    end
    
endmodule"
N/A,N/A,-1,37,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    // Use FSM from Fsm_serialdata
    // New: Add parity checking.
    
    parameter idle = 0, rec_data = 1, stop_bit = 2;
    reg [1:0] state, next_state;
    
    always @(*) begin
        case (state)
            idle: begin
                if (in) next_state <= rec_data;
                else next_state <= idle;
            end
            rec_data: begin
                if (in) next_state <= rec_data;
                else next_state <= stop_bit;
            end
            stop_bit: begin
                if (in) next_state <= idle;
                else next_state <= idle;
            end
            default: next_state <= idle;
        endcase
    end
    
    always @(posedge clk) begin
        if (reset) state <= idle;
        else state <= next_state;
    end
    
    assign done = (state == stop_bit);
    
    // New: Add parity checking.
    parity p1(clk, reset, in, odd);
    
    // New: Add serial output byte stream.
    
    reg [7:0] out_byte_reg;
    assign out_byte = out_byte_reg;
    always @(posedge clk) begin
        if (reset) out_byte_reg <= 0;
        else if (state == rec_data) out_byte_reg <= {in, out_byte_reg[7:1]};
    end
    
endmodule"
N/A,N/A,-1,38,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    parameter START = 3'd0, DATA = 3'd1, PARITY = 3'd2, STOP = 3'd3, DELAY = 3'd4;
    reg [2:0] state, next_state;
    reg [8:0] counter;
    reg odd;
    reg [7:0] out;
    
    always @(posedge clk)
        if (reset)
            state <= START;
        else
            state <= next_state;
    
    always @(*)
        case (state)
            START:
                begin
                    if (in)
                        next_state = DATA;
                    else
                        next_state = START;
                end
            DATA:
                begin
                    if (counter < 9'd255)
                        next_state = DATA;
                    else
                        next_state = PARITY;
                end
            PARITY:
                begin
                    if (counter < 9'd255)
                        next_state = PARITY;
                    else
                        next_state = STOP;
                end
            STOP:
                begin
                    if (counter < 9'd255)
                        next_state = DELAY;
                    else
                        next_state = START;
                end
            DELAY:
                begin
                    if (counter < 9'd255)
                        next_state = DELAY;
                    else
                        next_state = START;
                end
            default:
                next_state = START;
        endcase
    
    always @(posedge clk)
        if (reset)
            counter <= 0;
        else if (next_state == DATA)
            counter <= counter + 1'b1;
        else
            counter <= 0;
    
    always @(posedge clk)
        if (reset)
            out_byte <= 0;
        else if (next_state == PARITY)
            out_byte <= {out, odd};
    
    always @(posedge clk)
        if (reset)
            done <= 0;
        else if (next_state == STOP)
            done <= 1'b1;
        else
            done <= 0;
    
    always @(posedge clk)
        if (reset)
            out <= 0;
        else if (next_state == DELAY)
            out <= in;
    
    always @(posedge clk)
        if (reset)
            odd <= 0;
        else if (next_state == PARITY)
            odd <= in;

endmodule"
N/A,N/A,-1,39,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.
    
    parity p1(clk, reset, in, odd);
    
    // New: Add shift register to hold the received data.
    
    reg [7:0] data_shift = 0;
    
    always @(posedge clk)
        if (reset) data_shift <= 0;
        else if (odd) data_shift <= {data_shift[6:0], in};
    
    // New: Add a counter to count the number of bits received.
    
    reg [7:0] counter = 0;
    
    always @(posedge clk)
        if (reset) counter <= 0;
        else if (in) counter <= counter + 1;
    
    // New: Add a byte buffer to hold the received data.
    
    reg [7:0] out_byte = 0;
    
    always @(posedge clk)
        if (reset) out_byte <= 0;
        else if (counter == 9) out_byte <= data_shift;
    
    // New: Add a flag to signal when we have received a byte.
    
    reg done = 0;
    
    always @(posedge clk)
        if (reset) done <= 0;
        else if (counter == 9) done <= 1;
    
    // New: Add a parity checker to check the parity of the received data.
    
    reg odd = 0;
    
    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= odd ^ data_shift[7];
    
    // New: Add a byte output buffer.
    
    assign out_byte = odd? data_shift ^ 8'h1F : data_shift;
    
    // New: Add a done flag.
    
    assign done = odd;
    
endmodule"
N/A,N/A,-1,40,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    parameter START = 0, DATA = 1, STOP = 2, DELAY = 3;
    reg [1:0] state, next_state;
    reg [9:0] count;
    reg out;
    reg [8:0] data;
    
    always @(*) begin
        case (state)
            START: begin
                if(in)
                    next_state = DATA;
                else
                    next_state = START;
            end
            DATA: begin
                if(count == 1023)
                    next_state = STOP;
                else
                    next_state = DATA;
            end
            STOP: begin
                if(in)
                    next_state = START;
                else
                    next_state = DELAY;
            end
            DELAY: begin
                if(count == 1023)
                    next_state = DELAY;
                else
                    next_state = DATA;
            end
        endcase
    end
    
    always @(posedge clk) begin
        if(reset)
            state <= START;
        else
            state <= next_state;
    end
    
    always @(posedge clk) begin
        if(state == DATA)
            data[8] <= in;
        else if(state == START)
            data[8] <= 1'b0;
    end
    
    always @(posedge clk) begin
        if(state == DATA && count < 1023)
            count <= count + 1;
        else
            count <= 0;
    end
    
    always @(posedge clk) begin
        if(state == STOP && count < 1023)
            count <= count + 1;
        else
            count <= 0;
    end
    
    always @(posedge clk) begin
        if(state == DELAY)
            out <= 1;
        else if(state == START)
            out <= 0;
    end
    
    assign done = (state == DELAY)? out : 1'b0;
    assign out_byte = (state == START)? data : 8'b0;
    
endmodule"
N/A,N/A,-1,41,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    parameter START = 0, DATA = 1, STOP = 2, DELAY = 3;
    reg [1:0] state, next_state;
    reg [9:0] count;
    reg out;
    reg [8:0] data;
    
    always @(*) begin
        case (state)
            START: begin
                if(in)
                    next_state = DATA;
                else
                    next_state = START;
            end
            DATA: begin
                if(count == 1023)
                    next_state = STOP;
                else
                    next_state = DATA;
            end
            STOP: begin
                if(in)
                    next_state = START;
                else
                    next_state = DELAY;
            end
            DELAY: begin
                if(count == 1023)
                    next_state = DELAY;
                else
                    next_state = DATA;
            end
        endcase
    end
    
    always @(posedge clk) begin
        if(reset)
            state <= START;
        else
            state <= next_state;
    end
    
    always @(posedge clk) begin
        if(state == DATA)
            data[8] <= in;
        else if(state == START)
            data[8] <= 1'b0;
    end
    
    always @(posedge clk) begin
        if(state == DATA && count < 1023)
            count <= count + 1;
        else
            count <= 0;
    end
    
    always @(posedge clk) begin
        if(state == STOP && count < 1023)
            count <= count + 1;
        else
            count <= 0;
    end
    
    always @(posedge clk) begin
        if(state == DELAY)
            out <= 1;
        else if(state == START)
            out <= 0;
    end
    
    assign done = (state == DELAY)? out : 1'b0;
    assign out_byte = (state == START)? data : 8'b0;
    
endmodule"
N/A,N/A,-1,42,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    parameter START = 0, DATA = 1, STOP = 2, DELAY = 3;
    reg [1:0] state, next_state;
    reg [9:0] count;
    reg out;
    reg [8:0] data;
    
    always @(*) begin
        case (state)
            START: begin
                if(in)
                    next_state = DATA;
                else
                    next_state = START;
            end
            DATA: begin
                if(count == 1023)
                    next_state = STOP;
                else
                    next_state = DATA;
            end
            STOP: begin
                if(in)
                    next_state = START;
                else
                    next_state = DELAY;
            end
            DELAY: begin
                if(count == 1023)
                    next_state = DELAY;
                else
                    next_state = DATA;
            end
        endcase
    end
    
    always @(posedge clk) begin
        if(reset)
            state <= START;
        else
            state <= next_state;
    end
    
    always @(posedge clk) begin
        if(state == DATA)
            data[8] <= in;
        else if(state == START)
            data[8] <= 1'b0;
    end
    
    always @(posedge clk) begin
        if(state == DATA && count < 1023)
            count <= count + 1;
        else
            count <= 0;
    end
    
    always @(posedge clk) begin
        if(state == STOP && count < 1023)
            count <= count + 1;
        else
            count <= 0;
    end
    
    always @(posedge clk) begin
        if(state == DELAY)
            out <= 1;
        else if(state == START)
            out <= 0;
    end
    
    assign done = (state == DELAY)? out : 1'b0;
    assign out_byte = (state == START)? data : 8'b0;
    
endmodule"
N/A,N/A,-1,43,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serialdata
    // New: Add parity checking.
    
    parity p1(clk, reset, in, odd);
    
    // New: Add serial output byte stream.
    
    serial_out s1(clk, reset, odd, in, out_byte, done);
    
endmodule"
N/A,N/A,-1,44,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serialdata
    // New: Add parity checking.
    
    parity p1(clk, reset, in, odd);
    
    // New: Add serial output byte stream.
    
    serial_out s1(clk, reset, odd, in, out_byte, done);
    
endmodule"
N/A,N/A,-1,45,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.
    
    wire [8:0] data;
    wire parity;
    
    serial_receiver sr(clk, in, data, parity);
    
    parity_checker pc(clk, reset, data, parity, out_byte, done);
    
endmodule"
N/A,N/A,-1,46,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    parameter START = 0, DATA = 1, STOP = 2, DELAY = 3;
    reg [1:0] state, next_state;
    reg [9:0] count;
    reg out;
    
    always @(*) begin
        case (state)
            START: begin
                if(in)
                    next_state = DATA;
                else
                    next_state = START;
            end
            DATA: begin
                if(count == 10'd10)
                    next_state = STOP;
                else if(in)
                    next_state = DATA;
                else
                    next_state = START;
            end
            STOP: begin
                if(in) begin
                    next_state = DELAY;
                    out_byte = count;
                end
                else
                    next_state = START;
            end
            DELAY: begin
                if(count == 10'd400)
                    next_state = START;
                else
                    next_state = DELAY;
            end
            default: next_state = START;
        endcase
    end
    
    always @(posedge clk) begin
        if(reset)
            state <= START;
        else
            state <= next_state;
    end
    
    always @(posedge clk) begin
        if(state == DATA && count < 10'd10) begin
            out = in;
            count <= count + 1;
        end
        else
            count <= 0;
    end
    
    assign done = (state == DELAY);
    
    assign out_byte = (state == START)? 0 : out;
    
endmodule"
N/A,N/A,-1,47,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serialdata
    // New: Add parity checking.
    
    parameter idle = 0, rec_data = 1, stop_bit = 2;
    reg [1:0] state, next_state;
    
    parity p1(clk, reset, in, odd);
    
    always @(posedge clk)
        if (reset) state <= idle;
        else state <= next_state;
    
    always @(*)
        case (state)
            idle:
                if (in) next_state = rec_data;
                else next_state = idle;
            rec_data:
                if (odd) next_state = stop_bit;
                else next_state = rec_data;
            stop_bit:
                next_state = idle;
            default:
                next_state = idle;
        endcase
    
    assign done = (state == stop_bit);
    
    // New: Add parity checking.
    assign out_byte = (state == rec_data)? {in, odd} : 8'b0;
    
endmodule"
N/A,N/A,-1,48,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serialdata
    // New: Add parity checking.
    
    parameter idle = 0, rec_data = 1, stop_bit = 2;
    reg [1:0] state, next_state;
    
    parity p1(clk, reset, in, odd);
    
    always @(posedge clk)
        if (reset) state <= idle;
        else state <= next_state;
    
    always @(*)
        case (state)
            idle:
                if (in) next_state = rec_data;
                else next_state = idle;
            rec_data:
                if (odd) next_state = stop_bit;
                else next_state = rec_data;
            stop_bit:
                next_state = idle;
            default:
                next_state = idle;
        endcase
    
    assign done = (state == stop_bit);
    
    // New: Add parity checking.
    assign out_byte = (state == rec_data)? {in, odd} : 8'b0;
    
endmodule"
N/A,N/A,-1,49,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serialdata
    // New: Add parity checking.
    
    parameter idle = 0, rec_data = 1, stop_bit = 2, rec_parity = 3;
    reg [1:0] state, next_state;
    reg [3:0] counter;
    reg odd;
    
    always @(posedge clk)
        if (reset) state <= idle;
        else state <= next_state;
    
    always @(state)
    begin
        case (state)
            idle:
                begin
                    counter <= 4'b0;
                    done <= 0;
                    if (in) next_state <= rec_data;
                    else next_state <= idle;
                end
            rec_data:
                begin
                    if (counter < 9)
                        begin
                            next_state <= rec_data;
                            counter <= counter + 4'b1;
                        end
                    else
                        begin
                            next_state <= stop_bit;
                            counter <= 4'b0;
                        end
                end
            stop_bit:
                begin
                    if (in)
                        begin
                            next_state <= rec_parity;
                            odd <= in;
                        end
                    else
                        begin
                            next_state <= idle;
                            done <= 1;
                        end
                end
            rec_parity:
                begin
                    if (counter < 9)
                        begin
                            next_state <= rec_parity;
                            counter <= counter + 4'b1;
                        end
                    else
                        begin
                            next_state <= idle;
                            done <= 1;
                        end
                end
        endcase
    end
    
    assign out_byte = {state, odd};
    
endmodule"
N/A,N/A,-1,50,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serialdata
    // New: Add parity checking.
    
    parity p1(clk, reset, in, odd);
    
    // New: Add serial output byte stream
    
    serialdata s1(clk, reset, in, odd, out_byte, done);
    
endmodule"
N/A,N/A,-1,51,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serialdata
    // New: Add parity checking.
    
    parity p1(clk, reset, in, odd);
    
    // New: Add serial output byte stream
    
    serialdata s1(clk, reset, in, odd, out_byte, done);
    
endmodule"
N/A,N/A,-1,52,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serialdata
    // New: Add parity checking.
    
    parity p1(clk, reset, in, odd);
    
    // New: Add serial output byte stream
    
    serialdata s1(clk, reset, in, odd, out_byte, done);
    
endmodule"
N/A,N/A,-1,53,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serialdata
    // New: Add parity checking.
    
    parity p1(clk, reset, in, odd);
    
    // New: Add serial output byte stream
    
    serialdata s1(clk, reset, in, odd, out_byte, done);
    
endmodule"
N/A,N/A,-1,54,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serialdata
    // New: Add parity checking.
    
    parameter idle = 0, rec_data = 1, stop_bit = 2;
    reg [1:0] state, next_state;
    reg odd;
    reg [8:0] rec_data_bits;
    reg [3:0] rec_counter;
    
    always @(posedge clk)
        if (reset) state <= idle;
        else state <= next_state;
    
    always @(*)
        case (state)
            idle:
                if (in) next_state = rec_data;
                else next_state = idle;
            rec_data:
                if (rec_counter == 7) next_state = stop_bit;
                else next_state = rec_data;
            stop_bit:
                if (in) next_state = idle;
                else next_state = rec_data;
            default:
                next_state = idle;
        endcase
    
    always @(posedge clk)
        if (reset) begin
            rec_data_bits <= 0;
            rec_counter <= 0;
        end
        else begin
            // New: Add parity checking.
            if (state == rec_data && in) begin
                rec_data_bits[rec_counter] <= in;
                rec_counter <= rec_counter + 1;
                if (rec_counter == 7) odd <= parity(rec_data_bits);
            end
        end
    
    assign done = (state == stop_bit) && (in == 0);
    
    assign out_byte = rec_data_bits[7:0];
    
    function parity;
        input [8:0] data;
        parity = 0;
        for (i = 0; i < 9; i = i + 1) begin
            parity = parity + (data[i] ^ data[i+1]);
        end
    endfunction
    
endmodule"
N/A,N/A,-1,55,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serialdata
    // New: Add parity checking.
    
    parameter idle = 0, rec_data = 1, stop_bit = 2;
    reg [1:0] state, next_state;
    reg odd;
    reg [8:0] rec_data_bits;
    reg [3:0] rec_counter;
    
    always @(posedge clk)
        if (reset) state <= idle;
        else state <= next_state;
    
    always @(*)
        case (state)
            idle:
                if (in) next_state = rec_data;
                else next_state = idle;
            rec_data:
                if (rec_counter == 7) next_state = stop_bit;
                else next_state = rec_data;
            stop_bit:
                if (in) next_state = idle;
                else next_state = rec_data;
            default:
                next_state = idle;
        endcase
    
    always @(posedge clk)
        if (reset) begin
            rec_data_bits <= 0;
            rec_counter <= 0;
        end
        else begin
            // New: Add parity checking.
            if (state == rec_data && in) begin
                rec_data_bits[rec_counter] <= in;
                rec_counter <= rec_counter + 1;
                if (rec_counter == 7) odd <= parity(rec_data_bits);
            end
        end
    
    assign done = (state == stop_bit) && (in == 0);
    
    assign out_byte = rec_data_bits[7:0];
    
    function parity;
        input [8:0] data;
        parity = 0;
        for (i = 0; i < 9; i = i + 1) begin
            parity = parity + (data[i] ^ data[i+1]);
        end
    endfunction
    
endmodule"
N/A,N/A,-1,56,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serialdata
    // New: Add parity checking.
    
    parameter idle = 0, rec_data = 1, stop_bit = 2;
    reg [1:0] state, next_state;
    
    always @(posedge clk)
        if (reset) state <= idle;
        else state <= next_state;
    
    always @(*)
        case (state)
            idle:
                if (in) next_state = rec_data;
                else next_state = idle;
            rec_data:
                if (in) next_state = rec_data;
                else next_state = stop_bit;
            stop_bit:
                if (in) next_state = idle;
                else next_state = idle;
            default:
                next_state = idle;
        endcase
    
    assign done = (state == stop_bit)? 1 : 0;
    
    // New: Add parity checking.
    
    parity p1(clk, reset, in, odd);
    
    // New: Add parity checking.
    
    assign out_byte = (state == rec_data)? {in, odd} : 8'b0;
    
    // New: Add parity checking.
    
    
endmodule"
N/A,N/A,-1,57,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.
    
    parameter idle = 0, rec_data = 1, stop_bit = 2;
    reg [1:0] state, next_state;
    reg [9:0] cnt;
    reg odd;
    
    always @(posedge clk)
        if (reset) state <= idle;
        else state <= next_state;
    
    always @(*)
        case (state)
            idle:
                if (in) next_state = rec_data;
                else next_state = idle;
            rec_data:
                if (cnt == 10) next_state = stop_bit;
                else next_state = rec_data;
            stop_bit:
                next_state = idle;
            default:
                next_state = idle;
        endcase
    
    always @(posedge clk)
        if (reset) cnt <= 0;
        else if (state == rec_data) cnt <= cnt + 1;
    
    assign done = (state == stop_bit) && (cnt == 10);
    
    // New: Add parity checking.
    
    parity pff(clk, reset, in, odd);
    
    always @(posedge clk)
        if (reset) out_byte <= 8'b0;
        else if (state == rec_data) out_byte <= {in, odd};

endmodule"
N/A,N/A,-1,58,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.
    
    parity p1(clk, reset, in, odd);
    
    // New: Add parity checking.
    
    // You may need to add more states to the FSM.
    
    parameter s_idle = 0, s_wait = 1, s_read = 2, s_parity = 3, s_stop = 4, s_write = 5, s_delay = 6;
    
    reg [2:0] state, next_state;
    
    always @(*) begin
        state <= next_state;
    end
    
    always @(posedge clk) begin
        if (reset)
            next_state <= s_idle;
        else
            case (state)
                s_idle: begin
                    if (in)
                        next_state <= s_wait;
                    end
                s_wait: begin
                    if (in)
                        next_state <= s_read;
                    end
                s_read: begin
                    if (in)
                        next_state <= s_parity;
                    end
                s_parity: begin
                    if (in)
                        next_state <= s_stop;
                    end
                s_stop: begin
                    if (in)
                        next_state <= s_write;
                    end
                s_write: begin
                    if (in)
                        next_state <= s_delay;
                    end
                s_delay: begin
                    if (in)
                        next_state <= s_idle;
                    end
                default: begin
                    next_state <= s_idle;
                    end
            endcase
    end
    
    assign done = (state == s_idle);
    
    // New: Add parity checking.
    
    assign out_byte = (state == s_read)? {in, odd} : 8'b0;
    
    // New: Add parity checking.
    
    
endmodule"
N/A,N/A,-1,59,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    // Use FSM from Fsm_serialdata
    // New: Add parity checking.
    // New: Add DFF to synchronize the data input.
    // New: Add parity checking.

    parameter idle = 0, start = 1, data = 2, stop = 3, error = 4;
    reg [2:0] state, next_state;
    reg [7:0] data_reg;
    reg [3:0] count;
    reg out;
    reg odd;

    always @(posedge clk)
        if (reset)
            state <= idle;
        else
            state <= next_state;

    always @(*)
        case (state)
            idle:
                if (in)
                    next_state = start;
                else
                    next_state = idle;
            start:
                if (count == 9)
                    next_state = data;
                else
                    next_state = start;
            data:
                if (count == 18)
                    next_state = stop;
                else
                    next_state = data;
            stop:
                if (in)
                    next_state = error;
                else
                    next_state = idle;
            error:
                next_state = idle;
            default:
                next_state = idle;
        endcase

    always @(posedge clk)
        if (reset)
            count <= 0;
        else if (state == data)
            count <= count + 1;
        else
            count <= 0;

    always @(posedge clk)
        if (reset)
            data_reg <= 0;
        else if (state == data)
            data_reg <= data_reg << 1;
        else if (state == stop)
            data_reg <= data_reg | out;

    always @(posedge clk)
        if (reset)
            out <= 0;
        else if (state == stop)
            out <= in;

    always @(posedge clk)
        if (reset)
            odd <= 0;
        else if (state == data)
            odd <= odd ^ data_reg[0];

    assign done = (state == stop);
    assign out_byte = data_reg;

endmodule"
N/A,N/A,-1,60,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    // Use FSM from Fsm_serialdata
    // New: Add parity checking.
    // New: Add DFF to synchronize the data input.
    // New: Add parity checking.

    parameter idle = 0, start = 1, data = 2, stop = 3, error = 4;
    reg [2:0] state, next_state;
    reg [7:0] data_reg;
    reg [3:0] count;
    reg out;
    reg odd;

    always @(posedge clk)
        if (reset)
            state <= idle;
        else
            state <= next_state;

    always @(*)
        case (state)
            idle:
                if (in)
                    next_state = start;
                else
                    next_state = idle;
            start:
                if (count == 9)
                    next_state = data;
                else
                    next_state = start;
            data:
                if (count == 18)
                    next_state = stop;
                else
                    next_state = data;
            stop:
                if (in)
                    next_state = error;
                else
                    next_state = idle;
            error:
                next_state = idle;
            default:
                next_state = idle;
        endcase

    always @(posedge clk)
        if (reset)
            count <= 0;
        else if (state == data)
            count <= count + 1;
        else
            count <= 0;

    always @(posedge clk)
        if (reset)
            data_reg <= 0;
        else if (state == data)
            data_reg <= data_reg << 1;
        else if (state == stop)
            data_reg <= data_reg | out;

    always @(posedge clk)
        if (reset)
            out <= 0;
        else if (state == stop)
            out <= in;

    always @(posedge clk)
        if (reset)
            odd <= 0;
        else if (state == data)
            odd <= odd ^ data_reg[0];

    assign done = (state == stop);
    assign out_byte = data_reg;

endmodule"
N/A,N/A,-1,61,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serialdata
    // New: Add parity checking.
    
    parameter idle = 0, rec_data = 1, stop_bit = 2, rec_stop_bit = 3;
    reg [1:0] state, next_state;
    reg [3:0] counter;
    reg odd;
    reg [7:0] rec_data_reg;
    
    always @(posedge clk)
        if (reset) state <= idle;
        else state <= next_state;
    
    always @(*)
        case (state)
            idle:
                if (in) next_state = rec_data;
                else next_state = idle;
            rec_data:
                if (counter < 8) next_state = rec_data;
                else next_state = stop_bit;
            stop_bit:
                if (in) next_state = rec_stop_bit;
                else next_state = idle;
            rec_stop_bit:
                if (in) next_state = rec_data;
                else next_state = idle;
            default:
                next_state = idle;
        endcase
    
    always @(posedge clk)
        if (reset) counter <= 0;
        else if (next_state == rec_data) counter <= counter + 1;
        else if (next_state == stop_bit) counter <= counter + 1;
        else if (next_state == rec_stop_bit) counter <= counter + 1;
        else counter <= 0;
    
    always @(posedge clk)
        if (reset) odd <= 0;
        else if (next_state == rec_data) odd <= in;
        else if (next_state == stop_bit) odd <= ~in;
        else if (next_state == rec_stop_bit) odd <= in;
        else odd <= 0;
    
    always @(posedge clk)
        if (reset) rec_data_reg <= 0;
        else if (next_state == rec_data) rec_data_reg <= {in, rec_data_reg[7:1]};
    
    assign out_byte = rec_data_reg;
    assign done = (state == stop_bit) && (next_state == idle);
    
endmodule"
N/A,N/A,-1,62,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serialdata
    // New: Add parity checking.
    
    parameter idle = 0, rec_data = 1, stop_bit = 2, rec_stop_bit = 3;
    reg [1:0] state, next_state;
    reg [3:0] counter;
    reg odd;
    reg [7:0] rec_data_reg;
    
    always @(posedge clk)
        if (reset) state <= idle;
        else state <= next_state;
    
    always @(*)
        case (state)
            idle:
                if (in) next_state = rec_data;
                else next_state = idle;
            rec_data:
                if (counter < 8) next_state = rec_data;
                else next_state = stop_bit;
            stop_bit:
                if (in) next_state = rec_stop_bit;
                else next_state = idle;
            rec_stop_bit:
                if (in) next_state = rec_data;
                else next_state = idle;
            default:
                next_state = idle;
        endcase
    
    always @(posedge clk)
        if (reset) counter <= 0;
        else if (next_state == rec_data) counter <= counter + 1;
        else if (next_state == stop_bit) counter <= counter + 1;
        else if (next_state == rec_stop_bit) counter <= counter + 1;
        else counter <= 0;
    
    always @(posedge clk)
        if (reset) odd <= 0;
        else if (next_state == rec_data) odd <= in;
        else if (next_state == stop_bit) odd <= ~in;
        else if (next_state == rec_stop_bit) odd <= in;
        else odd <= 0;
    
    always @(posedge clk)
        if (reset) rec_data_reg <= 0;
        else if (next_state == rec_data) rec_data_reg <= {in, rec_data_reg[7:1]};
    
    assign out_byte = rec_data_reg;
    assign done = (state == stop_bit) && (next_state == idle);
    
endmodule"
N/A,N/A,-1,63,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serialdata
    // New: Add parity checking.
    
    parameter idle = 0, rec_data = 1, stop_bit = 2, rec_stop_bit = 3;
    reg [1:0] state, next_state;
    reg [3:0] counter;
    reg odd;
    reg [7:0] rec_data_reg;
    
    always @(posedge clk)
        if (reset) state <= idle;
        else state <= next_state;
    
    always @(*)
        case (state)
            idle:
                if (in) next_state = rec_data;
                else next_state = idle;
            rec_data:
                if (counter < 8) next_state = rec_data;
                else next_state = stop_bit;
            stop_bit:
                if (in) next_state = rec_stop_bit;
                else next_state = idle;
            rec_stop_bit:
                if (in) next_state = rec_data;
                else next_state = idle;
            default:
                next_state = idle;
        endcase
    
    always @(posedge clk)
        if (reset) counter <= 0;
        else if (next_state == rec_data) counter <= counter + 1;
        else if (next_state == stop_bit) counter <= counter + 1;
        else if (next_state == rec_stop_bit) counter <= counter + 1;
        else counter <= 0;
    
    always @(posedge clk)
        if (reset) odd <= 0;
        else if (next_state == rec_data) odd <= in;
        else if (next_state == stop_bit) odd <= ~in;
        else if (next_state == rec_stop_bit) odd <= in;
        else odd <= 0;
    
    always @(posedge clk)
        if (reset) rec_data_reg <= 0;
        else if (next_state == rec_data) rec_data_reg <= {in, rec_data_reg[7:1]};
    
    assign out_byte = rec_data_reg;
    assign done = (state == stop_bit) && (next_state == idle);
    
endmodule"
N/A,N/A,-1,64,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    parameter START = 0, DATA = 1, STOP = 2, DELAY = 3;
    reg [1:0] state, next_state;
    reg [3:0] count;
    reg out;
    
    always @(*) begin
        case (state)
            START: begin
                if(in)
                    next_state = DATA;
                else
                    next_state = START;
                out_byte = 4'b0000;
            end
            DATA: begin
                out_byte = {in, out_byte[7:1]};
                if(count < 8)
                    next_state = DATA;
                else
                    next_state = STOP;
            end
            STOP: begin
                done = 1;
                if(in) begin
                    next_state = START;
                    out_byte = 4'b0000;
                end
                else
                    next_state = START;
            end
            DELAY: begin
                next_state = state + 1;
            end
            default: begin
                next_state = state;
            end
        endcase
    end
    
    always @(posedge clk) begin
        if(reset)
            state <= START;
        else
            state <= next_state;
    end
    
    always @(posedge clk) begin
        if(state == DATA)
            count <= count + 1;
        else
            count <= 0;
    end
    
    always @(posedge clk) begin
        if(state == DATA)
            out <= in;
        else
            out <= 0;
    end
    
endmodule"
N/A,N/A,-1,65,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    parameter START = 3'd0, DATA = 3'd1, PARITY = 3'd2, STOP = 3'd3, DELAY = 3'd4;
    reg [2:0] state, next_state;
    reg [8:0] counter;
    reg odd;
    reg [7:0] out;
    assign done = (state == STOP);
    assign out_byte = odd? out : 8'bzzzz_zzzz;
    always @(*)
        case (state)
            START: begin
                if (in)
                    next_state = DATA;
                else
                    next_state = START;
            end
            DATA: begin
                if (counter == 9'd255)
                    next_state = PARITY;
                else
                    next_state = DATA;
            end
            PARITY: begin
                if (counter == 9'd255)
                    next_state = STOP;
                else
                    next_state = PARITY;
            end
            STOP: begin
                if (counter == 9'd255)
                    next_state = DELAY;
                else
                    next_state = STOP;
            end
            DELAY: next_state = START;
            default: next_state = START;
        endcase
    always @(posedge clk)
        if (reset)
            state <= START;
    else
        state <= next_state;
    always @(posedge clk)
        if (reset)
            counter <= 0;
    else if (state == DATA)
        counter <= counter + 1;
    else
        counter <= 0;
    always @(posedge clk)
        if (reset)
            out <= 0;
    else if (state == PARITY)
        out <= {out, odd};
    else if (state == STOP)
        out <= 0;
    else if (state == DELAY)
        out <= out;
    always @(posedge clk)
        if (reset)
            odd <= 0;
    else if (state == PARITY)
        odd <= ~odd;
endmodule"
N/A,N/A,-1,66,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    // Use FSM from Fsm_serialdata
    // New: Add parity checking.
    
    parity p1(clk, reset, in, odd);
    
    // New: Add serial output byte stream.
    
    serial_out s1(clk, reset, odd, in, out_byte, done);
    
endmodule"
N/A,N/A,-1,67,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    // Use FSM from Fsm_serialdata
    // New: Add parity checking.
    
    parity p1(clk, reset, in, odd);
    
    // New: Add serial output byte stream.
    
    serial_out s1(clk, reset, odd, in, out_byte, done);
    
endmodule"
N/A,N/A,-1,68,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    // Use FSM from Fsm_serialdata
    // New: Add parity checking.
    // New: Add shift register to hold the received data.
    
    parameter idle = 0, start = 1, data = 2, stop = 3, parity = 4, stop_err = 5;
    reg [2:0] state, next_state;
    reg [7:0] data_shift;
    reg odd;
    
    assign out_byte = data_shift;
    assign done = (state == stop) || (state == stop_err);
    
    always @(posedge clk)
        if(reset) state <= idle;
    	else state <= next_state;
    
    always @(*)
        case (state)
            idle:
                if(in)
                    next_state = start;
            	else
                    next_state = idle;
            start:
                if(in)
                    next_state = data;
                else
                    next_state = start;
            data:
                if(in)
                    next_state = data;
                else
                    next_state = parity;
            parity:
                if(in)
                    next_state = stop;
                else
                    next_state = parity;
            stop:
                if(in)
                    next_state = stop_err;
                else
                    next_state = idle;
            stop_err:
                if(in)
                    next_state = idle;
                else
                    next_state = idle;
            default:
                next_state = idle;
        endcase
    
    always @(posedge clk)
        if(reset)
            data_shift <= 0;
    	else if(next_state == data)
            data_shift <= {data_shift[6:0], in};
    	else if(next_state == parity)
            data_shift <= {data_shift[6:0], odd};
    
    always @(posedge clk)
        if(reset)
            odd <= 0;
    	else if(next_state == parity)
            odd <= in;

endmodule"
N/A,N/A,-1,69,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    // Use FSM from Fsm_serialdata
    // New: Add parity checking.
    // New: Add shift register to hold the received data.
    
    parameter idle = 0, start = 1, data = 2, stop = 3, parity = 4, stop_err = 5;
    reg [2:0] state, next_state;
    reg [7:0] data_shift;
    reg odd;
    
    assign out_byte = data_shift;
    assign done = (state == stop) || (state == stop_err);
    
    always @(posedge clk)
        if(reset) state <= idle;
    	else state <= next_state;
    
    always @(*)
        case (state)
            idle:
                if(in)
                    next_state = start;
            	else
                    next_state = idle;
            start:
                if(in)
                    next_state = data;
                else
                    next_state = start;
            data:
                if(in)
                    next_state = data;
                else
                    next_state = parity;
            parity:
                if(in)
                    next_state = stop;
                else
                    next_state = parity;
            stop:
                if(in)
                    next_state = stop_err;
                else
                    next_state = idle;
            stop_err:
                if(in)
                    next_state = idle;
                else
                    next_state = idle;
            default:
                next_state = idle;
        endcase
    
    always @(posedge clk)
        if(reset)
            data_shift <= 0;
    	else if(next_state == data)
            data_shift <= {data_shift[6:0], in};
    	else if(next_state == parity)
            data_shift <= {data_shift[6:0], odd};
    
    always @(posedge clk)
        if(reset)
            odd <= 0;
    	else if(next_state == parity)
            odd <= in;

endmodule"
N/A,N/A,-1,70,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    parameter START = 0, DATA = 1, STOP = 2, DELAY = 3;
    reg [1:0] state, next_state;
    reg [3:0] count;
    reg out;
    
    always @(*) begin
        case (state)
            START: begin
                if(in)
                    next_state <= DATA;
                else
                    next_state <= START;
            end
            DATA: begin
                if(count == 8)
                    next_state <= STOP;
                else if(in)
                    next_state <= DATA;
                else
                    next_state <= START;
            end
            STOP: begin
                if(in) begin
                    next_state <= START;
                    out_byte[count] <= in;
                end
                else
                    next_state <= DELAY;
            end
            DELAY: begin
                if(count == 8)
                    next_state <= STOP;
                else
                    next_state <= DELAY;
            end
        endcase
    end
    
    always @(posedge clk) begin
        if(reset)
            state <= START;
        else
            state <= next_state;
    end
    
    always @(posedge clk) begin
        if(reset)
            count <= 0;
        else if(next_state == DATA)
            count <= count + 1;
        else
            count <= 0;
    end
    
    always @(posedge clk) begin
        if(reset)
            out <= 0;
        else if(next_state == START)
            out <= 0;
        else if(next_state == DATA)
            out <= out_byte[count];
    end
    
    assign done = (state == DELAY)? (count == 8):(count == 0);
    
endmodule"
N/A,N/A,-1,71,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.
    
    parity p1(clk, reset, in, odd);
    
    // New: Add the byte counter.
    
    reg [7:0] out_byte_reg = 0;
    
    always @(posedge clk)
        if (reset) out_byte_reg <= 0;
        else if (odd) out_byte_reg <= {out_byte_reg[6:0], in};
    
    assign out_byte = out_byte_reg;
    assign done = done_reg;
    
    // New: Add the done signal.
    
    reg done_reg = 0;
    
    always @(posedge clk)
        if (reset) done_reg <= 0;
        else if (done_reg) done_reg <= 1;
        else if (done) done_reg <= 1;

endmodule"
N/A,N/A,-1,72,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.
    
    parity p1(clk, reset, in, odd);
    
    // New: Add the byte counter.
    
    reg [7:0] out_byte_reg = 0;
    
    always @(posedge clk)
        if (reset) out_byte_reg <= 0;
        else if (odd) out_byte_reg <= {out_byte_reg[6:0], in};
    
    assign out_byte = out_byte_reg;
    assign done = done_reg;
    
    // New: Add the done signal.
    
    reg done_reg = 0;
    
    always @(posedge clk)
        if (reset) done_reg <= 0;
        else if (done_reg) done_reg <= 1;
        else if (done) done_reg <= 1;

endmodule"
N/A,N/A,-1,73,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.
    
    parity p1(clk, reset, in, odd);
    
    // New: Add the byte counter.
    
    reg [7:0] out_byte_reg = 0;
    
    always @(posedge clk)
        if (reset) out_byte_reg <= 0;
        else if (odd) out_byte_reg <= {out_byte_reg[6:0], in};
    
    assign out_byte = out_byte_reg;
    assign done = done_reg;
    
    // New: Add the done signal.
    
    reg done_reg = 0;
    
    always @(posedge clk)
        if (reset) done_reg <= 0;
        else if (done_reg) done_reg <= 1;
        else if (done) done_reg <= 1;

endmodule"
N/A,N/A,-1,74,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.
    
    parity p1(clk, reset, in, odd);
    
    // New: Add the byte counter.
    
    reg [7:0] out_byte_reg = 0;
    
    always @(posedge clk)
        if (reset) out_byte_reg <= 0;
        else if (odd) out_byte_reg <= {out_byte_reg[6:0], in};
    
    assign out_byte = out_byte_reg;
    assign done = done_reg;
    
    // New: Add the done signal.
    
    reg done_reg = 0;
    
    always @(posedge clk)
        if (reset) done_reg <= 0;
        else if (done_reg) done_reg <= 1;
        else if (done) done_reg <= 1;

endmodule"
N/A,N/A,-1,75,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.
    
    parameter idle = 0, rec_data = 1, stop_bit = 2;
    reg [1:0] state, next_state;
    reg [3:0] counter;
    reg odd;
    reg [8:0] rec_data_reg;
    reg [7:0] out_byte_reg;
    
    assign done = (state == stop_bit);
    
    always @(*)
        case (state)
            idle:
                if (in)
                    next_state = rec_data;
                else
                    next_state = idle;
            rec_data:
                if (counter < 9)
                    next_state = rec_data;
                else
                    next_state = stop_bit;
            stop_bit:
                if (in)
                    next_state = idle;
                else
                    next_state = stop_bit;
            default:
                next_state = idle;
        endcase
    
    always @(posedge clk)
        if (reset)
            state <= idle;
        else
            state <= next_state;
    
    always @(posedge clk)
        if (reset)
            counter <= 0;
        else if (next_state == rec_data)
            counter <= counter + 1;
        else
            counter <= 0;
    
    always @(posedge clk)
        if (reset)
            rec_data_reg <= 0;
        else if (state == rec_data)
            rec_data_reg <= {rec_data_reg[6:0], in};
        else
            rec_data_reg <= rec_data_reg;
    
    always @(posedge clk)
        if (reset)
            out_byte_reg <= 0;
        else if (state == stop_bit)
            out_byte_reg <= rec_data_reg[7:1];
        else
            out_byte_reg <= out_byte_reg;
    
    assign out_byte = out_byte_reg;
    
    always @(posedge clk)
        if (reset)
            odd <= 0;
        else if (state == rec_data)
            odd <= rec_data_reg[8];
        else
            odd <= odd;
    
    // New: Add parity checking.
    
    parity pff(clk, reset, in, odd);
    
endmodule"
N/A,N/A,-1,76,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.
    
    parameter idle = 0, rec_data = 1, stop_bit = 2;
    reg [1:0] state, next_state;
    reg [3:0] counter;
    reg odd;
    reg [8:0] rec_data_reg;
    reg [7:0] out_byte_reg;
    
    assign done = (state == stop_bit);
    
    always @(*)
        case (state)
            idle:
                if (in)
                    next_state = rec_data;
                else
                    next_state = idle;
            rec_data:
                if (counter < 9)
                    next_state = rec_data;
                else
                    next_state = stop_bit;
            stop_bit:
                if (in)
                    next_state = idle;
                else
                    next_state = stop_bit;
            default:
                next_state = idle;
        endcase
    
    always @(posedge clk)
        if (reset)
            state <= idle;
        else
            state <= next_state;
    
    always @(posedge clk)
        if (reset)
            counter <= 0;
        else if (next_state == rec_data)
            counter <= counter + 1;
        else
            counter <= 0;
    
    always @(posedge clk)
        if (reset)
            rec_data_reg <= 0;
        else if (state == rec_data)
            rec_data_reg <= {rec_data_reg[6:0], in};
        else
            rec_data_reg <= rec_data_reg;
    
    always @(posedge clk)
        if (reset)
            out_byte_reg <= 0;
        else if (state == stop_bit)
            out_byte_reg <= rec_data_reg[7:1];
        else
            out_byte_reg <= out_byte_reg;
    
    assign out_byte = out_byte_reg;
    
    always @(posedge clk)
        if (reset)
            odd <= 0;
        else if (state == rec_data)
            odd <= rec_data_reg[8];
        else
            odd <= odd;
    
    // New: Add parity checking.
    
    parity pff(clk, reset, in, odd);
    
endmodule"
N/A,N/A,-1,77,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.
    
    wire clk_en;
    wire [9:0] data;
    
    serial_rx rx(.clk(clk),.in(in),.reset(reset),.clk_en(clk_en),.data(data));
    
    parity p(.clk(clk),.reset(reset),.in(data[7]),.odd(clk_en));
    
    Fsm_serialdata fsm(.clk(clk),.reset(reset),.clk_en(clk_en),.in(in),.out_byte(out_byte),.done(done));

endmodule"
N/A,N/A,-1,78,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    // Use FSM from Fsm_serialdata
    // New: Add parity checking.
    // New: Add state to FSM.
    
    parameter idle = 0, rec_data = 1, stop_bit = 2;
    reg [1:0] state, next_state;
    reg [3:0] counter;
    reg odd;
    
    always @(posedge clk)
        if (reset) state <= idle;
        else state <= next_state;
    
    always @(*)
        case (state)
            idle:
                begin
                    if (in)
                        next_state = rec_data;
                    else
                        next_state = idle;
                end
            rec_data:
                begin
                    if (counter == 7)
                        next_state = stop_bit;
                    else
                        next_state = rec_data;
                end
            stop_bit:
                begin
                    if (in)
                        next_state = idle;
                    else
                        next_state = rec_data;
                end
            default:
                next_state = idle;
        endcase
    
    always @(posedge clk)
        if (reset) counter <= 0;
        else if (next_state == rec_data)
            counter <= counter + 1;
        else if (next_state == stop_bit)
            counter <= 0;
    
    assign done = (state == stop_bit) && (counter == 7);
    
    // New: Add parity checking.
    parity pff(clk, reset, in, odd);
    
    always @(posedge clk)
        if (reset) out_byte <= 0;
        else if (state == rec_data)
            out_byte <= {in, odd};

endmodule"
N/A,N/A,-1,79,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    parameter START = 3'd0, DATA = 3'd1, PARITY = 3'd2, STOP = 3'd3, DELAY = 3'd4;
    reg [2:0] state, next_state;
    reg [8:0] counter;
    reg odd;
    reg [7:0] out;
    reg out_bit;
    
    always @(posedge clk)
        if(reset)
            state <= START;
        else
            state <= next_state;
    
    always @(*)
        case (state)
            START:
                if(in)
                    next_state = DATA;
                else
                    next_state = START;
            DATA:
                if(counter[8])
                    next_state = PARITY;
                else
                    next_state = DATA;
            PARITY:
                if(counter[8])
                    next_state = STOP;
                else
                    next_state = PARITY;
            STOP:
                if(counter[8])
                    next_state = DELAY;
                else
                    next_state = START;
            DELAY:
                if(counter[8])
                    next_state = DELAY;
                else
                    next_state = DATA;
            default:
                next_state = START;
        endcase
    
    always @(posedge clk)
        if(reset)
            counter <= 9'd0;
        else if(next_state == DATA)
            counter <= counter + 9'd1;
        else
            counter <= 9'd0;
    
    always @(posedge clk)
        if(reset)
            out_bit <= 1'b0;
        else if(state == DATA && next_state == PARITY)
            out_bit <= in;
        else
            out_bit <= 1'b0;
    
    always @(posedge clk)
        if(reset)
            out <= 8'd0;
        else if(state == PARITY && next_state == STOP)
            out <= {out[6:0], odd};
        else if(state == STOP && next_state == DELAY)
            out <= out_byte;
        else
            out <= 8'd0;
    
    assign done = (state == DELAY && next_state == START);
    
    assign out_byte = out;
    
endmodule"
N/A,N/A,-1,80,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    parameter START = 3'd0, DATA = 3'd1, PARITY = 3'd2, STOP = 3'd3, DELAY = 3'd4;
    reg [2:0] state, next_state;
    reg odd;
    reg [8:0] shift_reg;
    reg [7:0] out_byte_reg;
    reg done_reg;
    
    always @(posedge clk) begin
        if (reset) state <= START;
        else state <= next_state;
    end
    
    always @(*) begin
        case (state)
            START: begin
                if (in) next_state = DATA;
                else next_state = START;
            end
            DATA: begin
                if (shift_reg[8]) next_state = PARITY;
                else next_state = DATA;
            end
            PARITY: begin
                if (shift_reg[8] ^ odd) next_state = STOP;
                else next_state = PARITY;
            end
            STOP: begin
                if (in) begin
                    if (shift_reg[8]) done_reg = 1;
                    else begin
                        next_state = DELAY;
                        done_reg = 0;
                    end
                end
                else next_state = START;
            end
            DELAY: begin
                if (done_reg) next_state = START;
                else next_state = DELAY;
            end
            default: next_state = START;
        endcase
    end
    
    always @(posedge clk) begin
        if (reset) begin
            shift_reg <= 0;
            out_byte_reg <= 0;
            done_reg <= 0;
        end
        else begin
            shift_reg <= {shift_reg[7:0], in};
            out_byte_reg <= out_byte_reg + 1;
            if (state == DATA) odd <= ~odd;
            else odd <= 0;
            if (state == PARITY) done_reg <= 1;
            else done_reg <= 0;
        end
    end
    
    assign out_byte = out_byte_reg;
    assign done = done_reg;
    
endmodule"
N/A,N/A,-1,81,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.
    
    parameter idle = 0, rec_data = 1, stop_bit = 2, error = 3;
    reg [2:0] state, next_state;
    reg [9:0] counter;
    reg odd;
    reg [7:0] out_byte_reg;
    
    always @(posedge clk)
        if (reset)
            state <= idle;
        else
            state <= next_state;
    
    always @(*)
        case (state)
            idle:
                if (in)
                    next_state = rec_data;
                else
                    next_state = idle;
            rec_data:
                if (counter == 1023)
                    next_state = stop_bit;
                else
                    next_state = rec_data;
            stop_bit:
                if (in)
                    next_state = error;
                else
                    next_state = idle;
            error:
                next_state = idle;
            default:
                next_state = idle;
        endcase
    
    always @(posedge clk)
        if (reset)
            counter <= 0;
        else if (state == rec_data)
            counter <= counter + 1;
        else
            counter <= 0;
    
    always @(posedge clk)
        if (reset)
            out_byte_reg <= 0;
        else if (state == rec_data && odd == 0)
            out_byte_reg <= {out_byte_reg[6:0], in};
    
    assign done = (state == stop_bit);
    assign out_byte = out_byte_reg;
    
    // New: Add parity checking.
    parity pff(clk, reset, in, odd);

endmodule"
N/A,N/A,-1,82,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serialdata
    // New: Add parity checking.
    
    parameter idle = 0, rec_data = 1, stop_bit = 2, parity_bit = 3;
    reg [1:0] state, next_state;
    reg [3:0] counter;
    reg odd;
    
    always @(posedge clk)
        if (reset) state <= idle;
        else state <= next_state;
    
    always @(*)
        case (state)
            idle:
                if (in) next_state = rec_data;
                else next_state = idle;
            rec_data:
                if (counter == 8) next_state = stop_bit;
                else next_state = rec_data;
            stop_bit:
                if (in) next_state = idle;
                else next_state = parity_bit;
            parity_bit:
                if (counter == 8) next_state = idle;
                else next_state = rec_data;
            default:
                next_state = idle;
        endcase
    
    always @(posedge clk)
        if (reset) counter <= 0;
        else if (state == rec_data && in) counter <= counter + 1;
    
    assign done = (state == parity_bit && odd == in);
    
    assign out_byte = (state == stop_bit)? {in, odd} : 8'b0;
    
endmodule"
N/A,N/A,-1,83,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serialdata
    // New: Add parity checking.
    
    parameter idle = 0, rec_data = 1, stop_bit = 2, parity_bit = 3;
    reg [1:0] state, next_state;
    reg [3:0] counter;
    reg odd;
    
    always @(posedge clk)
        if (reset) state <= idle;
        else state <= next_state;
    
    always @(*)
        case (state)
            idle:
                if (in) next_state = rec_data;
                else next_state = idle;
            rec_data:
                if (counter == 8) next_state = stop_bit;
                else next_state = rec_data;
            stop_bit:
                if (in) next_state = idle;
                else next_state = parity_bit;
            parity_bit:
                if (counter == 8) next_state = idle;
                else next_state = rec_data;
            default:
                next_state = idle;
        endcase
    
    always @(posedge clk)
        if (reset) counter <= 0;
        else if (state == rec_data && in) counter <= counter + 1;
    
    assign done = (state == parity_bit && odd == in);
    
    assign out_byte = (state == stop_bit)? {in, odd} : 8'b0;
    
endmodule"
N/A,N/A,-1,84,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serialdata
    // New: Add parity checking.
    
    parameter idle = 0, rec_data = 1, stop_bit = 2, parity_bit = 3;
    reg [1:0] state, next_state;
    reg [3:0] counter;
    reg odd;
    
    always @(posedge clk)
        if (reset) state <= idle;
        else state <= next_state;
    
    always @(*)
        case (state)
            idle:
                if (in) next_state = rec_data;
                else next_state = idle;
            rec_data:
                if (counter == 8) next_state = stop_bit;
                else next_state = rec_data;
            stop_bit:
                if (in) next_state = idle;
                else next_state = parity_bit;
            parity_bit:
                if (counter == 8) next_state = idle;
                else next_state = rec_data;
            default:
                next_state = idle;
        endcase
    
    always @(posedge clk)
        if (reset) counter <= 0;
        else if (state == rec_data && in) counter <= counter + 1;
    
    assign done = (state == parity_bit && odd == in);
    
    assign out_byte = (state == stop_bit)? {in, odd} : 8'b0;
    
endmodule"
N/A,N/A,-1,85,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serialdata
    // New: Add parity checking.
    
    parity p1(clk, reset, in, odd);
    
    // New: Add serial output byte stream.
    
    serialdata s1(clk, in, odd, reset, out_byte, done);
    
endmodule"
N/A,N/A,-1,86,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serialdata
    // New: Add parity checking.
    
    parity p1(clk, reset, in, odd);
    
    // New: Add serial output byte stream.
    
    serialdata s1(clk, in, odd, reset, out_byte, done);
    
endmodule"
N/A,N/A,-1,87,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serialdata
    // New: Add parity checking.
    
    parity p1(clk, reset, in, odd);
    
    // New: Add serial output byte stream.
    
    serialdata s1(clk, in, odd, reset, out_byte, done);
    
endmodule"
N/A,N/A,-1,88,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serialdata
    // New: Add parity checking.
    
    parity p1(clk, reset, in, odd);
    
    // New: Add serial output byte stream.
    
    serialdata s1(clk, in, odd, reset, out_byte, done);
    
endmodule"
N/A,N/A,-1,89,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serialdata
    // New: Add parity checking.
    
    parameter idle = 0, rec_data = 1, stop_bit = 2;
    reg [1:0] state, next_state;
    
    always @(posedge clk)
        if (reset) state <= idle;
        else state <= next_state;
    
    always @(*)
        case (state)
            idle:
                begin
                    if (in) next_state = rec_data;
                    else next_state = idle;
                end
            rec_data:
                begin
                    if (in) next_state = rec_data;
                    else next_state = stop_bit;
                end
            stop_bit:
                begin
                    if (in) next_state = idle;
                    else next_state = idle;
                end
            default:
                next_state = idle;
        endcase
    
    assign done = (state == stop_bit)? 1 : 0;
    
    // New: Add parity checking.
    
    parity p1(clk, reset, in, odd);
    
    // New: Add parity checking.
    
    // Change the output assignments to read the input bits in the order of the serial data.
    // You may need to use a case statement to select the appropriate bits.
    
    assign out_byte[0] = in;
    assign out_byte[1] = out_byte[0];
    assign out_byte[2] = out_byte[1];
    assign out_byte[3] = out_byte[2];
    assign out_byte[4] = out_byte[3];
    assign out_byte[5] = out_byte[4];
    assign out_byte[6] = out_byte[5];
    assign out_byte[7] = out_byte[6];
    
endmodule"
N/A,N/A,-1,90,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serialdata
    // New: Add parity checking.
    
    parameter idle = 0, rec_data = 1, stop_bit = 2;
    reg [1:0] state, next_state;
    
    always @(posedge clk)
        if (reset) state <= idle;
        else state <= next_state;
    
    always @(*)
        case (state)
            idle:
                begin
                    if (in) next_state = rec_data;
                    else next_state = idle;
                end
            rec_data:
                begin
                    if (in) next_state = rec_data;
                    else next_state = stop_bit;
                end
            stop_bit:
                begin
                    if (in) next_state = idle;
                    else next_state = idle;
                end
            default:
                next_state = idle;
        endcase
    
    assign done = (state == stop_bit);
    
    // New: Add parity checking.
    
    parity p1(clk, reset, in, odd);
    
    always @(posedge clk)
        if (reset) out_byte <= 8'b0;
        else if (state == rec_data) out_byte <= {in, odd};

endmodule"
N/A,N/A,-1,91,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serialdata
    // New: Add parity checking.
    
    parameter idle = 0, rec_data = 1, stop_bit = 2;
    reg [1:0] state, next_state;
    
    always @(posedge clk) begin
        if (reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    always @(*) begin
        case (state)
            idle:
                if (in)
                    next_state = rec_data;
                else
                    next_state = idle;
            rec_data:
                if (in)
                    next_state = rec_data; // Wait for 9th bit
                else
                    next_state = stop_bit;
            stop_bit:
                if (in)
                    next_state = idle;
                else
                    next_state = idle; // Wait for start bit
            default:
                next_state = idle;
        endcase
    end
    
    // New: Add parity checking.
    parity pff(.clk(clk),.reset(reset),.in(in),.odd(odd));
    
    // New: Add parity checking.
    //assign done = (state == stop_bit) && (in == 1'b1);
    
    // Old: Add parity checking.
    assign done = (state == stop_bit) && (in == 1'b1);
    
    // New: Add parity checking.
    //assign out_byte = (state == rec_data)? {in, odd} : 8'b0;
    
    // Old: Add parity checking.
    assign out_byte = (state == rec_data)? {in, odd} : 8'b0;
    
endmodule"
N/A,N/A,-1,92,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    parameter START = 3'd0, DATA = 3'd1, PARITY = 3'd2, STOP = 3'd3, DELAY = 3'd4;
    reg [2:0] state, next_state;
    reg [8:0] counter;
    reg odd;
    reg [7:0] out;
    reg out_bit;
    assign done = (state == STOP);
    always @(*)
        case (state)
            START: begin
                if (in)
                    next_state = DATA;
                else
                    next_state = START;
            end
            DATA: begin
                if (counter < 9'd255)
                    next_state = DATA;
                else
                    next_state = PARITY;
            end
            PARITY: begin
                if (counter < 9'd255)
                    next_state = PARITY;
                else
                    next_state = STOP;
            end
            STOP: begin
                if (in)
                    next_state = START;
                else
                    next_state = DELAY;
            end
            DELAY: begin
                if (in)
                    next_state = DELAY;
                else
                    next_state = START;
            end
            default: next_state = START;
        endcase
    always @(posedge clk)
        if (reset)
            state <= START;
        else
            state <= next_state;
    always @(posedge clk)
        if (reset)
            counter <= 9'd0;
        else if (next_state == DATA)
            counter <= counter + 1'b1;
        else
            counter <= 9'd0;
    always @(posedge clk)
        if (reset)
            out_bit <= 1'b0;
        else if (state == DATA)
            out_bit <= in;
    always @(posedge clk)
        if (reset)
            out <= 8'd0;
        else if (state == PARITY)
            out <= {out, odd};
    always @(posedge clk)
        if (reset)
            odd <= 1'b0;
        else if (state == PARITY)
            odd <= out_bit;
    assign out_byte = out;
endmodule"
N/A,N/A,-1,93,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    parameter START = 3'd0, DATA = 3'd1, PARITY = 3'd2, STOP = 3'd3, DELAY = 3'd4;
    reg [2:0] state, next_state;
    reg [8:0] counter;
    reg odd;
    reg [7:0] out;
    reg out_bit;
    assign done = (state == STOP);
    always @(*)
        case (state)
            START: begin
                if (in)
                    next_state = DATA;
                else
                    next_state = START;
            end
            DATA: begin
                if (counter < 9'd255)
                    next_state = DATA;
                else
                    next_state = PARITY;
            end
            PARITY: begin
                if (counter < 9'd255)
                    next_state = PARITY;
                else
                    next_state = STOP;
            end
            STOP: begin
                if (in)
                    next_state = START;
                else
                    next_state = DELAY;
            end
            DELAY: begin
                if (in)
                    next_state = DELAY;
                else
                    next_state = START;
            end
            default: next_state = START;
        endcase
    always @(posedge clk)
        if (reset)
            state <= START;
        else
            state <= next_state;
    always @(posedge clk)
        if (reset)
            counter <= 9'd0;
        else if (next_state == DATA)
            counter <= counter + 1'b1;
        else
            counter <= 9'd0;
    always @(posedge clk)
        if (reset)
            out_bit <= 1'b0;
        else if (state == DATA)
            out_bit <= in;
    always @(posedge clk)
        if (reset)
            out <= 8'd0;
        else if (state == PARITY)
            out <= {out, odd};
    always @(posedge clk)
        if (reset)
            odd <= 1'b0;
        else if (state == PARITY)
            odd <= out_bit;
    assign out_byte = out;
endmodule"
N/A,N/A,-1,94,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    parameter START = 0, DATA = 1, STOP = 2, DELAY = 3;
    reg [1:0] state, next_state;
    reg [3:0] count;
    reg out;
    
    always @(*) begin
        case (state)
            START: begin
                if(in)
                    next_state <= DATA;
                else
                    next_state <= START;
                out_byte <= 0;
            end
            DATA: begin
                out_byte[count] <= in;
                if (count < 7)
                    next_state <= DATA;
                else
                    next_state <= STOP;
            end
            STOP: begin
                done <= 1;
                if (in) begin
                    next_state <= START;
                    out <= 1;
                end
                else begin
                    next_state <= START;
                    out <= 0;
                end
            end
            default: next_state <= START;
        endcase
    end
    
    always @(posedge clk) begin
        if (reset)
            state <= START;
        else
            state <= next_state;
            
        if (next_state == DATA)
            count <= count + 1;
        else if (next_state == STOP)
            count <= 0;
    end
    
    assign done = (state == STOP);
    
endmodule"
N/A,N/A,-1,95,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    // Use FSM from Fsm_serialdata
    // New: Add parity checking.
    
    parameter idle = 0, rec_data = 1, stop_bit = 2;
    reg [1:0] state, next_state;
    reg odd;
    reg [8:0] rec_data_bits;
    reg [8:0] rec_parity_bits;
    reg [8:0] stop_bits;
    
    always @(posedge clk)
        if (reset) state <= idle;
        else state <= next_state;
    
    always @(*)
        case (state)
            idle:
                if (in) next_state <= rec_data;
                else next_state <= idle;
            rec_data:
                if (rec_data_bits[8]) next_state <= stop_bit;
                else next_state <= rec_data;
            stop_bit:
                if (stop_bits[1]) next_state <= idle;
                else next_state <= rec_parity_bits[0];
            default:
                next_state <= idle;
        endcase
    
    // New: Add parity checking.
    always @(posedge clk)
        if (reset) begin
            rec_data_bits <= 0;
            rec_parity_bits <= 0;
            stop_bits <= 0;
        end
        else begin
            rec_data_bits <= {in, rec_data_bits[7:1]};
            rec_parity_bits <= {odd, rec_parity_bits[7:1]};
            stop_bits <= {rec_data_bits[8], stop_bits[0]};
        end
    
    assign done = (state == stop_bit) && (stop_bits[1] == 1);
    
    assign out_byte = rec_data_bits[7:0];
    
    always @(posedge clk)
        if (reset) odd <= 0;
        else odd <= rec_parity_bits[0];

endmodule"
N/A,N/A,-1,96,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    // Use FSM from Fsm_serialdata
    // New: Add parity checking.
    
    parameter idle = 0, rec_data = 1, stop_bit = 2;
    reg [1:0] state, next_state;
    reg odd;
    reg [8:0] rec_data_bits;
    reg [8:0] rec_parity_bits;
    reg [8:0] stop_bits;
    
    always @(posedge clk)
        if (reset) state <= idle;
        else state <= next_state;
    
    always @(*)
        case (state)
            idle:
                if (in) next_state <= rec_data;
                else next_state <= idle;
            rec_data:
                if (rec_data_bits[8]) next_state <= stop_bit;
                else next_state <= rec_data;
            stop_bit:
                if (stop_bits[1]) next_state <= idle;
                else next_state <= rec_parity_bits[0];
            default:
                next_state <= idle;
        endcase
    
    // New: Add parity checking.
    always @(posedge clk)
        if (reset) begin
            rec_data_bits <= 0;
            rec_parity_bits <= 0;
            stop_bits <= 0;
        end
        else begin
            rec_data_bits <= {in, rec_data_bits[7:1]};
            rec_parity_bits <= {odd, rec_parity_bits[7:1]};
            stop_bits <= {rec_data_bits[8], stop_bits[0]};
        end
    
    assign done = (state == stop_bit) && (stop_bits[1] == 1);
    
    assign out_byte = rec_data_bits[7:0];
    
    always @(posedge clk)
        if (reset) odd <= 0;
        else odd <= rec_parity_bits[0];

endmodule"
N/A,N/A,-1,97,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    // Use FSM from Fsm_serialdata
    // New: Add parity checking.
    
    parameter idle = 0, rec_data = 1, stop_bit = 2;
    reg [1:0] state, next_state;
    reg [7:0] rec_data_reg;
    reg odd_reg;
    
    always @(posedge clk)
        if (reset) state <= idle;
        else state <= next_state;
    
    always @(*)
        case (state)
            idle:
                if (in) next_state = rec_data;
                else next_state = idle;
            rec_data:
                if (rec_data_reg[7]) next_state = stop_bit;
                else next_state = rec_data;
            stop_bit:
                next_state = idle;
            default:
                next_state = idle;
        endcase
    
    always @(posedge clk)
        if (reset) begin
            rec_data_reg <= 0;
            odd_reg <= 0;
        end
        else begin
            rec_data_reg <= rec_data_reg << 1;
            rec_data_reg[0] <= in;
            odd_reg <= odd_reg ^ rec_data_reg[0];
        end
    
    assign done = (state == stop_bit) && (rec_data_reg[7] == 1);
    assign out_byte = {rec_data_reg[6:0], odd_reg};
    
endmodule"
N/A,N/A,-1,98,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    parameter START = 0, DATA = 1, STOP = 2, DELAY = 3;
    reg [1:0] state, next_state;
    reg [3:0] count;
    reg out;
    
    always @(*) begin
        case (state)
            START: begin
                if(in)
                    next_state = DATA;
                else
                    next_state = START;
            end
            DATA: begin
                if(count == 8)
                    next_state = STOP;
                else if(in)
                    next_state = DATA;
                else
                    next_state = START;
            end
            STOP: begin
                if(in) begin
                    next_state = START;
                    out_byte = count;
                    done = 1;
                end
                else
                    next_state = STOP;
            end
            DELAY: begin
                if(count == 4)
                    next_state = DELAY;
                else
                    next_state = START;
            end
            default: next_state = START;
        endcase
    end
    
    always @(posedge clk) begin
        if(reset) begin
            state <= START;
            count <= 0;
            out <= 0;
        end
        else begin
            state <= next_state;
            if(next_state == DATA)
                count <= count + 1;
            else if(next_state == STOP)
                out <= 1;
        end
    end
    
endmodule"
N/A,N/A,-1,99,0,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serialdata
    // New: Add parity checking.
    
    parameter idle = 0, rec_data = 1, stop_bit = 2;
    reg [1:0] state, next_state;
    
    always @(*) begin
        state <= next_state;
    end
    
    always @(posedge clk) begin
        if (reset)
            next_state <= idle;
        else
            case (state)
                idle:
                    if (in)
                        next_state <= rec_data;
                rec_data:
                    if (in)
                        next_state <= rec_data;
                    else
                        next_state <= stop_bit;
                stop_bit:
                    if (in)
                        next_state <= idle;
                    else
                        next_state <= idle;
                default:
                    next_state <= idle;
            endcase
    end
    
    assign done = (state == stop_bit);
    
    // New: Add parity checking.
    parity pff(clk, reset, in, odd);
    
    always @(posedge clk) begin
        if (reset)
            out_byte <= 8'b0;
        else if (state == rec_data)
            out_byte[7] <= in ^ odd;
    end
    
endmodule"
