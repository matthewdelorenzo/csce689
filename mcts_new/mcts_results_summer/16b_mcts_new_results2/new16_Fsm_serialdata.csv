Area,Delay,Score,Current Run,Episode,Verilog
N/A,N/A,-1,0,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Use FSM from Fsm_serial

endmodule"
N/A,N/A,-1,1,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Use FSM from Fsm_serial

endmodule"
N/A,N/A,-1,2,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serial
    
    parameter idle = 0, rec_data = 1, stop_bit = 2, overflow = 3;
    reg [2:0] state, next_state;
    reg [7:0] rec_data_reg;
    reg [3:0] rec_count;
    reg [2:0] stop_count;
    reg out_byte_reg;
    reg done_reg;
    
    always @(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    always @(*) begin
        case(state)
            idle: begin
                if(~in)
                    next_state = rec_data;
                else
                    next_state = idle;
            end
            
            rec_data: begin
                next_state = rec_data;
                rec_data_reg[7] <= in;
                rec_data_reg[6] <= rec_data_reg[7];
                rec_data_reg[5] <= rec_data_reg[6];
                rec_data_reg[4] <= rec_data_reg[5];
                rec_data_reg[3] <= rec_data_reg[4];
                rec_data_reg[2] <= rec_data_reg[3];
                rec_data_reg[1] <= rec_data_reg[2];
                rec_data_reg[0] <= rec_data_reg[1];
            end
            
            stop_bit: begin
                next_state = overflow;
                rec_count <= 0;
                stop_count <= 0;
            end
            
            overflow: begin
                next_state = idle;
                done_reg <= 1;
            end
        endcase
    end
    
    always @(posedge clk) begin
        if(state == rec_data) begin
            rec_count <= rec_count + 1;
            if(rec_count == 7)
                rec_data_reg <= {rec_data_reg[6:0], in};
        end else if(state == stop_bit) begin
            stop_count <= stop_count + 1;
            if(stop_count == 3)
                out_byte_reg <= rec_data_reg;
        end
    end
    
    assign done = done_reg;
    assign out_byte = out_byte_reg;
    
endmodule"
N/A,N/A,-1,3,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serial
    
    parameter idle = 0, rec_data = 1, stop_bit = 2, overflow = 3;
    reg [2:0] state, next_state;
    reg [7:0] rec_data_reg;
    reg [3:0] rec_count;
    reg [2:0] stop_count;
    reg out_byte_reg;
    reg done_reg;
    
    always @(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    always @(*) begin
        case(state)
            idle: begin
                if(~in)
                    next_state = rec_data;
                else
                    next_state = idle;
            end
            
            rec_data: begin
                next_state = rec_data;
                rec_data_reg[7] <= in;
                rec_data_reg[6] <= rec_data_reg[7];
                rec_data_reg[5] <= rec_data_reg[6];
                rec_data_reg[4] <= rec_data_reg[5];
                rec_data_reg[3] <= rec_data_reg[4];
                rec_data_reg[2] <= rec_data_reg[3];
                rec_data_reg[1] <= rec_data_reg[2];
                rec_data_reg[0] <= rec_data_reg[1];
            end
            
            stop_bit: begin
                next_state = overflow;
                rec_count <= 0;
                stop_count <= 0;
            end
            
            overflow: begin
                next_state = idle;
                done_reg <= 1;
            end
        endcase
    end
    
    always @(posedge clk) begin
        if(state == rec_data) begin
            rec_count <= rec_count + 1;
            if(rec_count == 7)
                rec_data_reg <= {rec_data_reg[6:0], in};
        end else if(state == stop_bit) begin
            stop_count <= stop_count + 1;
            if(stop_count == 3)
                out_byte_reg <= rec_data_reg;
        end
    end
    
    assign done = done_reg;
    assign out_byte = out_byte_reg;
    
endmodule"
N/A,N/A,-1,4,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Use FSM from Fsm_serial

// New: Datapath to latch input bits.

endmodule"
N/A,N/A,-1,5,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serial
    // New: Datapath to latch input bits.
    
    reg [2:0] state, next_state;
    reg [3:0] count;
    reg [7:0] out;
    reg out_bit;
    
    always @(*) begin
        case (state)
            3'b000: begin
                if (in)
                    next_state = 3'b001;
                else
                    next_state = 3'b000;
            end
            3'b001: begin
                if (count == 9)
                    next_state = 3'b010;
                else
                    next_state = 3'b001;
            end
            3'b010: begin
                if (in)
                    next_state = 3'b011;
                else
                    next_state = 3'b010;
            end
            3'b011: begin
                if (count == 8)
                    next_state = 3'b100;
                else
                    next_state = 3'b011;
            end
            3'b100: begin
                if (in)
                    next_state = 3'b101;
                else
                    next_state = 3'b100;
            end
            3'b101: begin
                if (count == 7)
                    next_state = 3'b110;
                else
                    next_state = 3'b101;
            end
            3'b110: begin
                if (in)
                    next_state = 3'b111;
                else
                    next_state = 3'b110;
            end
            3'b111: begin
                if (count == 6)
                    next_state = 3'b000;
                else
                    next_state = 3'b111;
            end
            default: next_state = 3'b000;
        endcase
    end
    
    always @(posedge clk) begin
        if (reset) begin
            state <= 3'b000;
            count <= 4'b0000;
            out <= 8'b00000000;
        end
        else begin
            state <= next_state;
            if (next_state == 3'b111)
                count <= count + 4'b0001;
            else if (next_state!= 3'b000) begin
                count <= 4'b0000;
                out_bit <= in;
            end
            else if (next_state == 3'b000) begin
                out_bit <= 1'b0;
                out <= out << 1;
            end
        end
    end
    
    assign done = (state == 3'b111);
    assign out_byte = out;
    
endmodule"
N/A,N/A,-1,6,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serial
    // New: Datapath to latch input bits.
    
    parameter idle = 0, rec_data = 1, stop_bit = 2, overflow = 3;
    reg [1:0] state, next_state;
    reg [3:0] counter;
    reg [7:0] rec_data_reg;
    reg [7:0] out_byte_reg;
    
    assign done = (state == stop_bit)? 1 : 0;
    
    always @(*) begin
        case (state)
            idle: begin
                if (in)
                    next_state = rec_data;
                else
                    next_state = idle;
            end
            
            rec_data: begin
                if (counter == 8)
                    next_state = stop_bit;
                else
                    next_state = rec_data;
            end
            
            stop_bit: begin
                if (in)
                    next_state = overflow;
                else
                    next_state = idle;
            end
            
            overflow: begin
                next_state = idle;
            end
            
            default: next_state = idle;
        endcase
    end
    
    always @(posedge clk) begin
        if (reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    always @(posedge clk) begin
        if (state == rec_data)
            rec_data_reg <= {rec_data_reg[6:0], in};
    end
    
    always @(posedge clk) begin
        if (state == stop_bit)
            counter <= counter + 1;
        else
            counter <= 0;
    end
    
    always @(posedge clk) begin
        if (state == rec_data && counter == 8)
            out_byte_reg <= {rec_data_reg[7], rec_data_reg[6:0]};
    end
    
    assign out_byte = (state == stop_bit)? out_byte_reg : 8'b0;
    
    // New: Datapath to latch input bits.
    
    always @(posedge clk) begin
        if (reset)
            rec_data_reg <= 0;
        else if (next_state == rec_data)
            rec_data_reg <= {rec_data_reg[6:0], in};
    end
    
    always @(posedge clk) begin
        if (reset)
            out_byte_reg <= 0;
        else if (next_state == rec_data && counter == 8)
            out_byte_reg <= {rec_data_reg[7], rec_data_reg[6:0]};
    end
    
endmodule"
N/A,N/A,-1,7,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serial
    // New: Latch input bits.
    
    // State transition logic
    always @(*) begin
        case (state)
            idle: begin
                if(~in)
                    next_state = idle;
                else
                    next_state = rec_data;
            end
            
            rec_data: begin
                if(~in)
                    next_state = rec_data;
                else
                    next_state = rec_stop;
            end
            
            rec_stop: begin
                if(~in)
                    next_state = rec_stop;
                else
                    next_state = idle;
            end
            
            default:
                next_state = idle;
        endcase
    end
    
    // State flip-flops with asynchronous reset
    always @(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    // New: Latch input bits.
    reg [7:0] rec_data_reg;
    always @(posedge clk) begin
        if(state == rec_data)
            rec_data_reg <= {rec_data_reg[6:0], in};
    end
    
    // New: Datapath to latch input bits.
    assign out_byte = rec_data_reg;
    
    // New: Output done flag
    assign done = (state == rec_stop);
    
endmodule"
N/A,N/A,-1,8,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Modify FSM and datapath from Fsm_serial

// New: Latch input bits.

endmodule"
N/A,N/A,-1,9,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Use FSM from Fsm_serial

// New: Datapath to latch input bits.

endmodule"
N/A,N/A,-1,10,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Use FSM from Fsm_serial

// New: Datapath to latch input bits.

endmodule"
N/A,N/A,-1,11,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serial
    
    parameter idle = 0, rec_data = 1, stop_bit = 2, error = 3;
    reg [2:0] state, next_state;
    reg [3:0] counter;
    reg out;
    reg [7:0] rec_data_byte;
    
    always @(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    always @(*) begin
        case(state)
            idle: begin
                if(~in)
                    next_state = rec_data;
                else
                    next_state = idle;
            end
            
            rec_data: begin
                if(counter == 8)
                    next_state = stop_bit;
                else
                    next_state = rec_data;
            end
            
            stop_bit: begin
                if(in)
                    next_state = idle;
                else
                    next_state = error;
            end
            
            error: begin
                if(counter == 8)
                    next_state = idle;
                else
                    next_state = error;
            end
            
            default: next_state = idle;
        endcase
    end
    
    always @(posedge clk) begin
        if(state == rec_data && counter < 8) begin
            rec_data_byte[7:0] <= {rec_data_byte[6:0], in};
            counter <= counter + 1;
        end
    end
    
    assign done = (state == stop_bit) && (counter == 8);
    
    assign out_byte = rec_data_byte;
    
endmodule"
N/A,N/A,-1,12,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serial
    
    parameter idle = 0, rec_data = 1, stop_bit = 2;
    reg [2:0] state, next_state;
    reg [3:0] counter;
    reg out;
    
    always @(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    always @(*) begin
        case(state)
            idle: begin
                if(~in)
                    next_state = rec_data;
                else
                    next_state = idle;
            end
            rec_data: begin
                if(counter == 8)
                    next_state = stop_bit;
                else
                    next_state = rec_data;
            end
            stop_bit: begin
                if(~in)
                    next_state = idle;
                else
                    next_state = rec_data;
            end
            default: next_state = idle;
        endcase
    end
    
    always @(posedge clk) begin
        if(state == rec_data && counter < 8)
            counter <= counter + 4'b1;
        else
            counter <= 0;
    end
    
    always @(posedge clk) begin
        if(state == stop_bit && in)
            out <= 1'b1;
        else
            out <= 1'b0;
    end
    
    assign done = (state == stop_bit)? out : 1'b0;
    
    assign out_byte = (state == rec_data)? {out, out, out, out, out, out, out, out} : 8'b0;
    
endmodule"
N/A,N/A,-1,13,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serial
    
    parameter idle = 0, rec_data = 1, stop_bit = 2, error = 3;
    reg [2:0] state, next_state;
    reg [7:0] rec_data_reg;
    reg [2:0] rec_counter;
    reg [2:0] num_bits;
    reg [1:0] rec_pos;
    reg out;
    
    always @(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    always @(*) begin
        case(state)
            idle: begin
                if(~in)
                    next_state = rec_data;
                else
                    next_state = idle;
            end
            rec_data: begin
                next_state = rec_counter < 3? rec_data : stop_bit;
            end
            stop_bit: begin
                next_state = error;
            end
            error: begin
                if(~in)
                    next_state = idle;
                else
                    next_state = error;
            end
        endcase
    end
    
    always @(posedge clk) begin
        if(state == rec_data)
            rec_data_reg <= {rec_data_reg[6:0], in};
        else
            rec_data_reg <= 7'b0;
    end
    
    always @(posedge clk) begin
        if(state == stop_bit) begin
            num_bits <= rec_counter;
            rec_pos <= 2'b00;
            out <= 0;
            rec_counter <= 3'b0;
        end
        else if(state == rec_data && rec_counter < 3) begin
            rec_counter <= rec_counter + 3'b1;
            rec_pos <= {rec_pos[0], rec_pos[1]};
            out <= rec_data_reg[rec_pos];
        end
    end
    
    assign done = (state == stop_bit) && (rec_pos == 2'b11);
    assign out_byte = (state == stop_bit)? {out, num_bits} : 8'b0;
    
endmodule"
N/A,N/A,-1,14,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    // Use FSM from Fsm_serial
    // New: Latch input bits.
    
    reg [2:0] state, next_state;
    parameter idle = 3'b000, start = 3'b001, trans0 = 3'b010, trans1 = 3'b011, trans2 = 3'b100, trans3 = 3'b101, trans4 = 3'b110, trans5 = 3'b111, stop = 3'b111;
    
    always @(*) begin
        state <= next_state;
    end
    
    always @(posedge clk) begin
        if(reset)
            next_state <= idle;
        else
            case(state)
                idle:
                    if(in)
                        next_state <= start;
                start:
                    if(in)
                        next_state <= trans0;
                trans0:
                    if(in)
                        next_state <= trans1;
                trans1:
                    if(in)
                        next_state <= trans2;
                trans2:
                    if(in)
                        next_state <= trans3;
                trans3:
                    if(in)
                        next_state <= trans4;
                trans4:
                    if(in)
                        next_state <= trans5;
                trans5:
                    if(in)
                        next_state <= stop;
                stop:
                    if(~in)
                        next_state <= idle;
                default:
                    next_state <= idle;
            endcase
    end
    
    assign done = (state == stop);
    
    // New: Datapath to latch input bits.
    
    reg [7:0] out_byte_reg;
    
    always @(posedge clk) begin
        if(reset)
            out_byte_reg <= 0;
        else begin
            if(next_state == trans0 || next_state == trans1 || next_state == trans2 || next_state == trans3 || next_state == trans4 || next_state == trans5)
                out_byte_reg[7:0] <= {out_byte_reg[6:0], in};
        end
    end
    
    assign out_byte = out_byte_reg;
    
endmodule"
N/A,N/A,-1,15,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    // Use FSM from Fsm_serial
    // New: Latch input bits.
    
    reg [2:0] state;
    reg [3:0] in_byte;
    reg [7:0] out_byte_reg;
    
    assign done = (state == 3);
    
    always @(posedge clk) begin
        if(reset) begin
            state <= 0;
            in_byte <= 0;
            out_byte_reg <= 0;
        end
        else begin
            // New: Latch input bits.
            in_byte <= {in, in_byte[3:1]};
            
            case(state)
                0: begin
                    if(in_byte[0])
                        state <= 1;
                end
                1: begin
                    if(in_byte[1])
                        state <= 2;
                end
                2: begin
                    if(in_byte[2])
                        state <= 3;
                end
                3: begin
                    if(in_byte[3])
                        state <= 0;
                end
            endcase
            
            // New: Latch input bits.
            out_byte_reg <= {out_byte_reg[6:0], in_byte[3:1]};
        end
    end
    
    assign out_byte = out_byte_reg;
    
endmodule"
N/A,N/A,-1,16,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

// Define states
localparam  IDLE = 0,
            GET_BYTE = 1;

// Define state transitions
localparam  S0 = IDLE,
            S1 = GET_BYTE,
            S2 = GET_BYTE,
            S3 = GET_BYTE,
            S4 = GET_BYTE,
            S5 = GET_BYTE,
            S6 = GET_BYTE,
            S7 = GET_BYTE,
            S8 = GET_BYTE,
            S9 = GET_BYTE,
            S10 = GET_BYTE;

// State register
reg [3:0] state;

// State Register
always @(posedge clk) begin
    if (reset)
        state <= S0;
    else
        state <= state_next;
end

// Output logic
reg [7:0] out_byte_reg;
assign out_byte = out_byte_reg;

// New: Datapath to latch input bits.
reg [3:0] in_byte;

always @(posedge clk) begin
    if (state == IDLE) begin
        out_byte_reg <= 0;
        in_byte <= 0;
    end
    else if (state == GET_BYTE) begin
        in_byte <= in;
        out_byte_reg <= in_byte;
    end
end

// State transition logic
always @* begin
    state_next = state;
    case (state)
        S0: if (in)
                state_next = S1;
        S1: if (in)
                state_next = S2;
        S2: if (in)
                state_next = S3;
        S3: if (in)
                state_next = S4;
        S4: if (in)
                state_next = S5;
        S5: if (in)
                state_next = S6;
        S6: if (in)
                state_next = S7;
        S7: if (in)
                state_next = S8;
        S8: if (in)
                state_next = S9;
        S9: if (in)
                state_next = S10;
        S10: if (in)
                state_next = S0;
        default: state_next = S0;
    endcase
end

// Output logic
assign done = (state == S10)? 1 : 0;

endmodule"
N/A,N/A,-1,17,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Use FSM from Fsm_serial

reg [2:0] state, next_state;
reg [7:0] out_byte_reg;
reg done_reg;

always @(*) begin
    state <= next_state;
end

always @(posedge clk) begin
    if(reset) begin
        out_byte_reg <= 0;
        done_reg <= 0;
    end
    else begin
        out_byte_reg <= out_byte;
        done_reg <= done;
    end
end

always @(*) begin
    next_state = state;
    case (state)
        3'b000: begin
            if(~in)
                next_state = 3'b001;
        end
        3'b001: begin
            if(in)
                next_state = 3'b010;
        end
        3'b010: begin
            if(~in)
                next_state = 3'b011;
        end
        3'b011: begin
            if(in)
                next_state = 3'b000;
        end
        default: begin
            next_state = 3'b000;
        end
    endcase
end

assign done = done_reg;
assign out_byte = out_byte_reg;

endmodule"
N/A,N/A,-1,18,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Use FSM from Fsm_serial

reg [2:0] state, next_state;
reg [3:0] count;
reg [7:0] out;
reg out_bit;
reg [1:0] next_out;

localparam
    idle = 3'b000,
    start = 3'b001,
    data = 3'b010,
    stop = 3'b011,
    finish = 3'b100;

always @(*) begin
    case (state)
        idle: begin
            if (in)
                next_state <= start;
            else
                next_state <= idle;
        end
        start: begin
            if (count == 8)
                next_state <= data;
            else
                next_state <= start;
        end
        data: begin
            if (count == 8) begin
                if (in)
                    next_state <= data;
                else
                    next_state <= stop;
            end
            else
                next_state <= data;
        end
        stop: begin
            if (count == 8)
                next_state <= finish;
            else
                next_state <= stop;
        end
        finish: begin
            if (count == 8)
                next_state <= idle;
            else
                next_state <= finish;
        end
        default: next_state <= idle;
    endcase
end

always @(posedge clk) begin
    if (reset)
        state <= idle;
    else
        state <= next_state;
end

always @(posedge clk) begin
    if (reset) begin
        count <= 0;
        out <= 0;
        out_bit <= 0;
        next_out <= 0;
    end
    else begin
        case (state)
            idle: begin
                out_bit <= 0;
                next_out <= 0;
                count <= 0;
            end
            start: begin
                out <= 0;
                count <= 1;
                next_out <= 2;
            end
            data: begin
                out <= {out, in};
                count <= count + 1;
                next_out <= next_out + 2;
            end
            stop: begin
                out_bit <= out[0];
                out <= {out[7:1], 1'b0};
                count <= count + 1;
                next_out <= next_out + 2;
            end
            finish: begin
                done <= 1;
                count <= count + 1;
            end
        endcase
    end
end

assign out_byte = out;
assign done = done;

endmodule"
N/A,N/A,-1,19,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Use FSM from Fsm_serial

reg [2:0] state, next_state;
reg [3:0] count;
reg [7:0] out;
reg out_bit;
reg [1:0] next_out;

localparam
    idle = 3'b000,
    start = 3'b001,
    data = 3'b010,
    stop = 3'b011,
    finish = 3'b100;

always @(*) begin
    case (state)
        idle: begin
            if (in)
                next_state <= start;
            else
                next_state <= idle;
        end
        start: begin
            if (count == 8)
                next_state <= data;
            else
                next_state <= start;
        end
        data: begin
            if (count == 8) begin
                if (in)
                    next_state <= data;
                else
                    next_state <= stop;
            end
            else
                next_state <= data;
        end
        stop: begin
            if (count == 8)
                next_state <= finish;
            else
                next_state <= stop;
        end
        finish: begin
            if (count == 8)
                next_state <= idle;
            else
                next_state <= finish;
        end
        default: next_state <= idle;
    endcase
end

always @(posedge clk) begin
    if (reset)
        state <= idle;
    else
        state <= next_state;
end

always @(posedge clk) begin
    if (reset) begin
        count <= 0;
        out <= 0;
        out_bit <= 0;
        next_out <= 0;
    end
    else begin
        case (state)
            idle: begin
                out_bit <= 0;
                next_out <= 0;
                count <= 0;
            end
            start: begin
                out <= 0;
                count <= 1;
                next_out <= 2;
            end
            data: begin
                out <= {out, in};
                count <= count + 1;
                next_out <= next_out + 2;
            end
            stop: begin
                out_bit <= out[0];
                out <= {out[7:1], 1'b0};
                count <= count + 1;
                next_out <= next_out + 2;
            end
            finish: begin
                done <= 1;
                count <= count + 1;
            end
        endcase
    end
end

assign out_byte = out;
assign done = done;

endmodule"
N/A,N/A,-1,20,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serial
    // New: Datapath to latch input bits.
    
    reg [2:0] state, next_state;
    reg [7:0] out;
    reg [3:0] count;
    reg out_bit;
    
    always @(*) begin
        case (state)
            3'b000: begin
                if (in)
                    next_state = 3'b001;
                else
                    next_state = 3'b000;
            end
            3'b001: begin
                if (count == 9)
                    next_state = 3'b010;
                else
                    next_state = 3'b001;
            end
            3'b010: begin
                if (in)
                    next_state = 3'b011;
                else
                    next_state = 3'b010;
            end
            3'b011: begin
                if (count == 9)
                    next_state = 3'b100;
                else
                    next_state = 3'b011;
            end
            3'b100: begin
                if (in)
                    next_state = 3'b101;
                else
                    next_state = 3'b100;
            end
            3'b101: begin
                if (count == 9)
                    next_state = 3'b110;
                else
                    next_state = 3'b101;
            end
            3'b110: begin
                if (in)
                    next_state = 3'b111;
                else
                    next_state = 3'b110;
            end
            3'b111: begin
                if (count == 9)
                    next_state = 3'b000;
                else
                    next_state = 3'b111;
            end
            default: next_state = 3'b000;
        endcase
    end
    
    always @(posedge clk) begin
        if (reset) begin
            state <= 3'b000;
            count <= 4'b0000;
            out_bit <= 1'b0;
            out <= 8'b00000000;
        end
        else begin
            state <= next_state;
            count <= count + 1'b1;
            out_bit <= in;
            out <= out << 1'b1;
        end
    end
    
    assign done = (count == 9)? (state == 3'b111) : 1'b0;
    assign out_byte = out;
    
endmodule"
N/A,N/A,-1,21,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serial
    // New: Datapath to latch input bits.
    
    reg [2:0] state, next_state;
    reg [7:0] out;
    reg [3:0] count;
    reg out_bit;
    
    always @(*) begin
        case (state)
            3'b000: begin
                if (in)
                    next_state = 3'b001;
                else
                    next_state = 3'b000;
            end
            3'b001: begin
                if (count == 9)
                    next_state = 3'b010;
                else
                    next_state = 3'b001;
            end
            3'b010: begin
                if (in)
                    next_state = 3'b011;
                else
                    next_state = 3'b010;
            end
            3'b011: begin
                if (count == 9)
                    next_state = 3'b100;
                else
                    next_state = 3'b011;
            end
            3'b100: begin
                if (in)
                    next_state = 3'b101;
                else
                    next_state = 3'b100;
            end
            3'b101: begin
                if (count == 9)
                    next_state = 3'b110;
                else
                    next_state = 3'b101;
            end
            3'b110: begin
                if (in)
                    next_state = 3'b111;
                else
                    next_state = 3'b110;
            end
            3'b111: begin
                if (count == 9)
                    next_state = 3'b000;
                else
                    next_state = 3'b111;
            end
            default: next_state = 3'b000;
        endcase
    end
    
    always @(posedge clk) begin
        if (reset) begin
            state <= 3'b000;
            count <= 4'b0000;
            out_bit <= 1'b0;
            out <= 8'b00000000;
        end
        else begin
            state <= next_state;
            count <= count + 1'b1;
            out_bit <= in;
            out <= out << 1'b1;
        end
    end
    
    assign done = (count == 9)? (state == 3'b111) : 1'b0;
    assign out_byte = out;
    
endmodule"
N/A,N/A,-1,22,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Use FSM from Fsm_serial

// New: Datapath to latch input bits.

endmodule"
N/A,N/A,-1,23,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Use FSM from Fsm_serial

endmodule"
N/A,N/A,-1,24,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

reg [7:0] out_byte;
reg done;

always @(posedge clk) begin
    if (reset) begin
        out_byte <= 0;
        done <= 0;
    end
    else begin
        if (in) begin
            out_byte <= {out_byte[6:0], 1'b0};
        end
        else begin
            if (&out_byte) begin
                done <= 1;
            end
        end
    end
end

endmodule"
N/A,N/A,-1,25,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

reg [7:0] out_byte;
reg done;

always @(posedge clk) begin
    if (reset) begin
        out_byte <= 0;
        done <= 0;
    end
    else begin
        if (in) begin
            out_byte <= {out_byte[6:0], 1'b0};
        end
        else begin
            if (&out_byte) begin
                done <= 1;
            end
        end
    end
end

endmodule"
N/A,N/A,-1,26,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Use FSM from Fsm_serial

// New: Datapath to latch input bits.

endmodule"
N/A,N/A,-1,27,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Use FSM from Fsm_serial

// New: Datapath to latch input bits.

endmodule"
N/A,N/A,-1,28,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Modify FSM and datapath from Fsm_serial
    
    parameter idle = 4'd0, start = 4'd1, trans0 = 4'd2, trans1 = 4'd3, trans2 = 4'd4, trans3 = 4'd5;
    parameter trans4 = 4'd6, trans5 = 4'd7, trans6 = 4'd8, trans7 = 4'd9, stop = 4'd10, error = 4'd11, pari = 4'd12;
    reg [3:0] state, next_state;
    
    always @(*) begin
        case (state)
            idle: begin
                if(~in)
                    next_state = start;
                else
                    next_state = idle;
            end
            start: 
                if(in)
                    next_state = trans0;
                else
                    next_state = idle;
            trans0:
                if(in)
                    next_state = trans1;
                else
                    next_state = trans0;
            trans1:
                if(in)
                    next_state = trans2;
                else
                    next_state = trans0;
            trans2:
                if(in)
                    next_state = trans3;
                else
                    next_state = trans0;
            trans3:
                if(in)
                    next_state = trans4;
                else
                    next_state = trans0;
            trans4:
                if(in)
                    next_state = trans5;
                else
                    next_state = trans0;
            trans5:
                if(in)
                    next_state = trans6;
                else
                    next_state = trans0;
            trans6:
                if(in)
                    next_state = trans7;
                else
                    next_state = trans0;
            trans7:
                if(in)
                    next_state = stop;
                else
                    next_state = trans0;
            stop:
                if(in)
                    next_state = idle;
                else
                    next_state = error;
            error:
                if(in)
                    next_state = idle;
                else
                    next_state = error;
            pari:
                if(in)
                    next_state = idle;
                else
                    next_state = pari;
        endcase
    end
    
    always @(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    assign done = (state == stop);
    
    // New: Datapath to latch input bits.
    reg [7:0] out;
    always @(posedge clk) begin
        if(state == trans0 || state == trans1 || state == trans2 || state == trans3 || state == trans4 || state == trans5 || state == trans6 || state == trans7)
            out <= {in, out[7:1]};
        else
            out <= out;
    end
    
    assign out_byte = out;
    
endmodule"
N/A,N/A,-1,29,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    // Use FSM from Fsm_serial
    // New: Datapath to latch input bits.
    
    reg [2:0] state;
    reg [7:0] data;
    reg [2:0] count;
    reg out;
    
    always @(posedge clk) begin
        if(reset) begin
            state <= 0;
            data <= 0;
            count <= 0;
            out <= 0;
        end
        else begin
            case(state)
                0: begin
                    if(in) begin
                        data <= data;
                        count <= count + 1;
                        state <= 1;
                    end
                end
                1: begin
                    if(count == 7) begin
                        state <= 2;
                        out <= data[0];
                        data <= {data[6:0], 1'b0};
                    end
                end
                2: begin
                    if(in) begin
                        data <= data << 1;
                        count <= count + 1;
                        state <= 1;
                    end
                end
                default: begin
                    state <= 0;
                end
            endcase
        end
    end
    
    assign done = (state == 2) && (count == 7);
    assign out_byte = out;
    
endmodule"
N/A,N/A,-1,30,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serial
    
    parameter idle = 0, rec_data = 1, stop_bit = 2, overflow = 3;
    reg [2:0] state, next_state;
    reg [3:0] count;
    reg [7:0] rec_data_byte;
    reg done_reg;
    
    always @(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    always @(*) begin
        case (state)
            idle: begin
                if(~in)
                    next_state = rec_data;
                else
                    next_state = idle;
            end
            
            rec_data: begin
                if(count == 8)
                    next_state = stop_bit;
                else
                    next_state = rec_data;
            end
            
            stop_bit: begin
                if(in)
                    next_state = overflow;
                else
                    next_state = idle;
            end
            
            overflow: begin
                if(count == 8)
                    next_state = idle;
                else
                    next_state = overflow;
            end
            
            default: next_state = idle;
        endcase
    end
    
    always @(posedge clk) begin
        if(state == rec_data && count < 8) begin
            rec_data_byte[7] <= in;
            count <= count + 1;
        end
    end
    
    always @(posedge clk) begin
        if(state == stop_bit) begin
            done_reg <= 1;
            out_byte <= rec_data_byte;
        end
        else
            done_reg <= 0;
    end
    
    assign done = done_reg;
    
endmodule"
N/A,N/A,-1,31,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serial
    
    // New: Datapath to latch input bits.
    
    reg [7:0] out_byte_reg;
    
    always @(posedge clk) begin
        if(reset) begin
            out_byte_reg <= 0;
        end
        else begin
            out_byte_reg <= {out_byte_reg[6:0], in};
        end
    end
    
    assign done = (out_byte_reg == ""done"");
    assign out_byte = done? out_byte_reg : out_byte_reg + 1;
    
endmodule"
N/A,N/A,-1,32,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Use FSM from Fsm_serial

// New: Datapath to latch input bits.

endmodule"
N/A,N/A,-1,33,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// You can use this counter to verify that the gap and latency are as expected.
reg [4:0] counter = 0;
always @(posedge clk) begin
    if(reset)
        counter <= 0;
    else
        counter <= counter + 1;
end

// Use this counter to verify that the input stream is being shifted out at the correct time.
reg [4:0] shift_count = 0;
always @(posedge clk) begin
    if(shift_en)
        shift_count <= shift_count + 1;
end

// Use this counter to verify that the output stream is being received at the correct time.
reg [4:0] out_count = 0;
always @(posedge clk) begin
    if(out_en)
        out_count <= out_count + 1;
end

// Define the states of the finite state machine.
parameter
    idle = 0,
    shift = 1,
    out = 2;

reg [1:0] state = idle, next_state = idle;

// Determine the next state of the machine.
always @(*) begin
    case(state)
        idle:
            if(shift_en)
                next_state = shift;
        shift:
            if(~shift_en)
                next_state = out;
        out:
            if(out_en)
                next_state = idle;
        default:
            next_state = idle;
    endcase
end

// Determine outputs.
assign done = (state == out)? 1 : 0;
assign shift_en = (state == shift)? 1 : 0;
assign out_en = (state == out)? 1 : 0;

// New: Datapath to latch input bits.
reg [7:0] in_byte = 0;
always @(posedge clk) begin
    if(shift_en)
        in_byte <= {in, in_byte[7:1]};
end

// New: Shift register to output the input bits in the correct order.
reg [7:0] out_byte_reg = 0;
always @(posedge clk) begin
    if(out_en)
        out_byte_reg <= in_byte;
end

assign out_byte = out_byte_reg;

// New: Counter to count the number of bits shifted out.
always @(posedge clk) begin
    if(state == shift)
        out_count <= shift_count;
end

endmodule"
N/A,N/A,-1,34,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// You can use this counter to verify that the gap and latency are as expected.
reg [4:0] counter = 0;
always @(posedge clk) begin
    if(reset)
        counter <= 0;
    else
        counter <= counter + 1;
end

// Use this counter to verify that the input stream is being shifted out at the correct time.
reg [4:0] shift_count = 0;
always @(posedge clk) begin
    if(shift_en)
        shift_count <= shift_count + 1;
end

// Use this counter to verify that the output stream is being received at the correct time.
reg [4:0] out_count = 0;
always @(posedge clk) begin
    if(out_en)
        out_count <= out_count + 1;
end

// Define the states of the finite state machine.
parameter
    idle = 0,
    shift = 1,
    out = 2;

reg [1:0] state = idle, next_state = idle;

// Determine the next state of the machine.
always @(*) begin
    case(state)
        idle:
            if(shift_en)
                next_state = shift;
        shift:
            if(~shift_en)
                next_state = out;
        out:
            if(out_en)
                next_state = idle;
        default:
            next_state = idle;
    endcase
end

// Determine outputs.
assign done = (state == out)? 1 : 0;
assign shift_en = (state == shift)? 1 : 0;
assign out_en = (state == out)? 1 : 0;

// New: Datapath to latch input bits.
reg [7:0] in_byte = 0;
always @(posedge clk) begin
    if(shift_en)
        in_byte <= {in, in_byte[7:1]};
end

// New: Shift register to output the input bits in the correct order.
reg [7:0] out_byte_reg = 0;
always @(posedge clk) begin
    if(out_en)
        out_byte_reg <= in_byte;
end

assign out_byte = out_byte_reg;

// New: Counter to count the number of bits shifted out.
always @(posedge clk) begin
    if(state == shift)
        out_count <= shift_count;
end

endmodule"
N/A,N/A,-1,35,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// You can use this counter to verify that the gap and latency are as expected.
reg [4:0] counter = 0;
always @(posedge clk) begin
    if(reset)
        counter <= 0;
    else
        counter <= counter + 1;
end

// Use this counter to verify that the input stream is being shifted out at the correct time.
reg [4:0] shift_count = 0;
always @(posedge clk) begin
    if(shift_en)
        shift_count <= shift_count + 1;
end

// Use this counter to verify that the output stream is being received at the correct time.
reg [4:0] out_count = 0;
always @(posedge clk) begin
    if(out_en)
        out_count <= out_count + 1;
end

// Define the states of the finite state machine.
parameter
    idle = 0,
    shift = 1,
    out = 2;

reg [1:0] state = idle, next_state = idle;

// Determine the next state of the machine.
always @(*) begin
    case(state)
        idle:
            if(shift_en)
                next_state = shift;
        shift:
            if(~shift_en)
                next_state = out;
        out:
            if(out_en)
                next_state = idle;
        default:
            next_state = idle;
    endcase
end

// Determine outputs.
assign done = (state == out)? 1 : 0;
assign shift_en = (state == shift)? 1 : 0;
assign out_en = (state == out)? 1 : 0;

// New: Datapath to latch input bits.
reg [7:0] in_byte = 0;
always @(posedge clk) begin
    if(shift_en)
        in_byte <= {in, in_byte[7:1]};
end

// New: Shift register to output the input bits in the correct order.
reg [7:0] out_byte_reg = 0;
always @(posedge clk) begin
    if(out_en)
        out_byte_reg <= in_byte;
end

assign out_byte = out_byte_reg;

// New: Counter to count the number of bits shifted out.
always @(posedge clk) begin
    if(state == shift)
        out_count <= shift_count;
end

endmodule"
N/A,N/A,-1,36,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Use FSM from Fsm_serial

// New: Datapath to latch input bits.

endmodule"
N/A,N/A,-1,37,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Use FSM from Fsm_serial

// New: Datapath to latch input bits.

endmodule"
N/A,N/A,-1,38,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Use FSM from Fsm_serial

// New: Datapath to latch input bits.

endmodule"
N/A,N/A,-1,39,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Use FSM from Fsm_serial

// New: Datapath to latch input bits.

endmodule"
N/A,N/A,-1,40,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Use FSM from Fsm_serial

// New: Datapath to latch input bits.

// New: Add parity checking.

endmodule"
N/A,N/A,-1,41,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Use FSM from Fsm_serial

// New: Datapath to latch input bits.

// New: Add parity checking.

endmodule"
N/A,N/A,-1,42,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Use FSM from Fsm_serial

// New: Datapath to latch input bits.

// New: Add parity checking.

endmodule"
N/A,N/A,-1,43,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Use FSM from Fsm_serial

// New: Datapath to latch input bits.

endmodule"
N/A,N/A,-1,44,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Use FSM from Fsm_serial

// New: Datapath to latch input bits.

endmodule"
N/A,N/A,-1,45,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Modify FSM and datapath from Fsm_serial

// New: Latch input bits.

endmodule"
N/A,N/A,-1,46,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Modify FSM and datapath from Fsm_serial

// New: Latch input bits.

endmodule"
N/A,N/A,-1,47,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Modify FSM and datapath from Fsm_serial

// New: Latch input bits.

endmodule"
N/A,N/A,-1,48,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Modify FSM and datapath from Fsm_serial
    
    parameter idle = 4'd0, start = 4'd1, trans0 = 4'd2, trans1 = 4'd3, trans2 = 4'd4, trans3 = 4'd5;
    parameter trans4 = 4'd6, trans5 = 4'd7, trans6 = 4'd8, trans7 = 4'd9, stop = 4'd10, error = 4'd11, pari = 4'd12;
    reg [3:0] state, next_state;
    
    always @(*) begin
        case (state)
            idle: begin
                if(~in)
                    next_state = start;
                else
                    next_state = idle;
            end
            start: 
                if(in)
                    next_state = trans0;
                else
                    next_state = idle;
            trans0:
                if(~in)
                    next_state = trans1;
                else
                    next_state = trans0;
            trans1:
                if(~in)
                    next_state = trans2;
                else
                    next_state = trans0;
            trans2:
                if(~in)
                    next_state = trans3;
                else
                    next_state = trans0;
            trans3:
                if(~in)
                    next_state = trans4;
                else
                    next_state = trans0;
            trans4:
                if(~in)
                    next_state = trans5;
                else
                    next_state = trans0;
            trans5:
                if(~in)
                    next_state = trans6;
                else
                    next_state = trans0;
            trans6:
                if(~in)
                    next_state = trans7;
                else
                    next_state = trans0;
            trans7:
                if(~in)
                    next_state = stop;
                else
                    next_state = trans0;
            stop: begin
                if(in)
                    next_state = idle;
                else
                    next_state = error;
            end
            error: begin
                if(in)
                    next_state = idle;
                else
                    next_state = error;
            end
            pari: begin
                if(in)
                    next_state = idle;
                else
                    next_state = pari;
            end
        endcase
    end
    
    always @(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    assign done = (state == stop);
    
    // New: Datapath to latch input bits.
    reg [7:0] out_byte_reg;
    always @(posedge clk) begin
        if(state == trans0 || state == trans1 || state == trans2 || state == trans3 || state == trans4 || state == trans5 || state == trans6 || state == trans7)
            out_byte_reg <= {in, out_byte_reg[7:1]};
    end
    assign out_byte = out_byte_reg;
    
endmodule"
N/A,N/A,-1,49,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Modify FSM and datapath from Fsm_serial
    
    parameter idle = 4'd0, start = 4'd1, trans0 = 4'd2, trans1 = 4'd3, trans2 = 4'd4, trans3 = 4'd5;
    parameter trans4 = 4'd6, trans5 = 4'd7, trans6 = 4'd8, trans7 = 4'd9, stop = 4'd10, error = 4'd11, pari = 4'd12;
    reg [3:0] state, next_state;
    
    always @(*) begin
        case (state)
            idle: begin
                if(~in)
                    next_state = start;
                else
                    next_state = idle;
            end
            start: 
                if(in)
                    next_state = trans0;
                else
                    next_state = idle;
            trans0:
                if(~in)
                    next_state = trans1;
                else
                    next_state = trans0;
            trans1:
                if(~in)
                    next_state = trans2;
                else
                    next_state = trans0;
            trans2:
                if(~in)
                    next_state = trans3;
                else
                    next_state = trans0;
            trans3:
                if(~in)
                    next_state = trans4;
                else
                    next_state = trans0;
            trans4:
                if(~in)
                    next_state = trans5;
                else
                    next_state = trans0;
            trans5:
                if(~in)
                    next_state = trans6;
                else
                    next_state = trans0;
            trans6:
                if(~in)
                    next_state = trans7;
                else
                    next_state = trans0;
            trans7:
                if(~in)
                    next_state = stop;
                else
                    next_state = trans0;
            stop: begin
                if(in)
                    next_state = idle;
                else
                    next_state = error;
            end
            error: begin
                if(in)
                    next_state = idle;
                else
                    next_state = error;
            end
            pari: begin
                if(in)
                    next_state = idle;
                else
                    next_state = pari;
            end
        endcase
    end
    
    always @(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    assign done = (state == stop);
    
    // New: Datapath to latch input bits.
    reg [7:0] out_byte_reg;
    always @(posedge clk) begin
        if(state == trans0 || state == trans1 || state == trans2 || state == trans3 || state == trans4 || state == trans5 || state == trans6 || state == trans7)
            out_byte_reg <= {in, out_byte_reg[7:1]};
    end
    assign out_byte = out_byte_reg;
    
endmodule"
N/A,N/A,-1,50,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Use FSM from Fsm_serial

// New: Datapath to latch input bits.

endmodule"
N/A,N/A,-1,51,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// You can use this counter to verify that the gap and width are as expected.
reg [8:0] gap_count;
reg [8:0] width_count;

always @(posedge clk) begin
    if (reset) begin
        gap_count <= 0;
        width_count <= 0;
    end
    else begin
        if (in) begin
            if (gap_count!= gap_width) begin
                $display(""Gap violation on %0t"", $time);
                $stop;
            end
            if (width_count!= width) begin
                $display(""Width violation on %0t"", $time);
                $stop;
            end
            
            gap_count <= 0;
            width_count <= 0;
        end
        else begin
            gap_count <= gap_count + 1;
            width_count <= width_count + 1;
        end
    end
end

// New: Datapath to latch input bits.
reg [7:0] in_byte;

always @(posedge clk) begin
    if (reset) begin
        in_byte <= 0;
    end
    else begin
        if (in) begin
            in_byte <= in_byte + 1;
        end
    end
end

assign out_byte = in_byte;
assign done = done_count == 8;

// New: Count the number of bits seen.
reg [8:0] done_count;

always @(posedge clk) begin
    if (reset) begin
        done_count <= 0;
    end
    else begin
        if (in) begin
            done_count <= done_count + 1;
        end
    end
end

endmodule"
N/A,N/A,-1,52,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Use FSM from Fsm_serial

endmodule"
N/A,N/A,-1,53,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serial
    // New: Latch input bits.
    
    reg [2:0] state, next_state;
    reg [7:0] out_byte_reg;
    
    localparam
        idle = 3'b000,
        start = 3'b001,
        data = 3'b010,
        stop = 3'b011,
        finish = 3'b100;
    
    always @(*) begin
        case (state)
            idle: begin
                if(~in)
                    next_state = start;
                else
                    next_state = idle;
            end
            start: begin
                if(in)
                    next_state = data;
                else
                    next_state = idle;
            end
            data: begin
                if(~in)
                    next_state = stop;
                else
                    next_state = data;
            end
            stop: begin
                if(in)
                    next_state = finish;
                else
                    next_state = idle;
            end
            finish: begin
                if(in)
                    next_state = finish;
                else
                    next_state = idle;
            end
            default: next_state = idle;
        endcase
    end
    
    always @(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    always @(posedge clk) begin
        if(state == finish)
            out_byte_reg <= out_byte;
    end
    
    assign done = (state == finish);
    assign out_byte = out_byte_reg;
    
endmodule"
N/A,N/A,-1,54,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serial
    // New: Datapath to latch input bits.
    
    reg [2:0] state, next_state;
    reg [7:0] out_byte_reg;
    reg done_reg;
    
    always @(*) begin
        state <= next_state;
    end
    
    always @(posedge clk) begin
        if(reset) begin
            out_byte_reg <= 0;
            done_reg <= 0;
        end
        else begin
            out_byte_reg <= out_byte;
            done_reg <= done;
        end
    end
    
    always @(*) begin
        case (state)
            3'b000: begin
                if(~in)
                    next_state = 3'b001;
                else
                    next_state = 3'b000;
            end
            3'b001: begin
                if(in)
                    next_state = 3'b010;
                else
                    next_state = 3'b001;
            end
            3'b010: begin
                if(in)
                    next_state = 3'b011;
                else
                    next_state = 3'b010;
            end
            3'b011: begin
                if(~in)
                    next_state = 3'b100;
                else
                    next_state = 3'b011;
            end
            3'b100: begin
                if(in)
                    next_state = 3'b101;
                else
                    next_state = 3'b100;
            end
            3'b101: begin
                if(~in)
                    next_state = 3'b110;
                else
                    next_state = 3'b101;
            end
            3'b110: begin
                if(~in)
                    next_state = 3'b000;
                else
                    next_state = 3'b110;
            end
            default: begin
                next_state = 3'b000;
            end
        endcase
    end
    
    assign done = done_reg;
    assign out_byte = out_byte_reg;
    
endmodule"
N/A,N/A,-1,55,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Modify FSM and datapath from Fsm_serial

reg [2:0] state, next_state;
reg [7:0] out;
reg out_bit;
reg [3:0] count;

assign done = (state == 3'd7) && (count == 4'd8);

always @(*) begin
    case (state)
        3'd0: begin
            next_state = in? 3'd1 : 3'd0;
            out_bit = 1'b0;
        end
        3'd1: begin
            next_state = in? 3'd2 : 3'd0;
            out_bit = 1'b0;
        end
        3'd2: begin
            next_state = in? 3'd2 : 3'd0;
            out_bit = 1'b0;
        end
        3'd3: begin
            next_state = in? 3'd4 : 3'd0;
            out_bit = 1'b0;
        end
        3'd4: begin
            next_state = in? 3'd5 : 3'd0;
            out_bit = 1'b0;
        end
        3'd5: begin
            next_state = in? 3'd6 : 3'd0;
            out_bit = 1'b0;
        end
        3'd6: begin
            next_state = in? 3'd7 : 3'd0;
            out_bit = 1'b0;
        end
        3'd7: begin
            next_state = in? 3'd7 : 3'd0;
            out_bit = 1'b0;
        end
        default: begin
            next_state = 3'd0;
            out_bit = 1'b0;
        end
    endcase
end

always @(posedge clk) begin
    if(reset) begin
        state <= 3'd0;
        count <= 4'd0;
        out <= 8'd0;
    end
    else begin
        state <= next_state;
        if(next_state == 3'd7) begin
            count <= count + 4'd1;
            if(count == 4'd8) begin
                count <= 4'd0;
                out <= {out[6:0], out_byte[7:1]};
            end
        end
        else begin
            count <= 4'd0;
            out <= 8'd0;
        end
    end
end

endmodule"
N/A,N/A,-1,56,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serial
    // New: Latch input bits.
    
    reg [2:0] state;
    reg [2:0] next_state;
    reg [7:0] out;
    reg out_bit;
    
    localparam IDLE = 3'b000;
    localparam START = 3'b001;
    localparam DATA = 3'b010;
    localparam STOP = 3'b011;
    localparam END = 3'b100;
    
    always @(*) begin
        case (state)
            IDLE: begin
                if(~in)
                    next_state = START;
                else
                    next_state = IDLE;
            end
            START: begin
                if(in)
                    next_state = DATA;
                else
                    next_state = IDLE;
            end
            DATA: begin
                if(~in)
                    next_state = STOP;
                else
                    next_state = DATA;
            end
            STOP: begin
                if(in)
                    next_state = END;
                else
                    next_state = IDLE;
            end
            END: begin
                if(in)
                    next_state = START;
                else
                    next_state = IDLE;
            end
            default: next_state = IDLE;
        endcase
    end
    
    always @(posedge clk) begin
        if(reset) begin
            state <= IDLE;
            out <= 8'b0;
            out_bit <= 1'b0;
        end
        else begin
            state <= next_state;
            out <= next_state == DATA? {out[6:0], in} : out;
            out_bit <= next_state == DATA? out[7] : out_bit;
        end
    end
    
    assign done = (state == END && out_bit == 1'b1);
    
    assign out_byte = out;
    
endmodule"
N/A,N/A,-1,57,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serial
    // New: Latch input bits.
    
    reg [2:0] state;
    reg [2:0] next_state;
    reg [7:0] out;
    reg out_bit;
    
    localparam IDLE = 3'b000;
    localparam START = 3'b001;
    localparam DATA = 3'b010;
    localparam STOP = 3'b011;
    localparam END = 3'b100;
    
    always @(*) begin
        case (state)
            IDLE: begin
                if(~in)
                    next_state = START;
                else
                    next_state = IDLE;
            end
            START: begin
                if(in)
                    next_state = DATA;
                else
                    next_state = IDLE;
            end
            DATA: begin
                if(~in)
                    next_state = STOP;
                else
                    next_state = DATA;
            end
            STOP: begin
                if(in)
                    next_state = END;
                else
                    next_state = IDLE;
            end
            END: begin
                if(in)
                    next_state = START;
                else
                    next_state = IDLE;
            end
            default: next_state = IDLE;
        endcase
    end
    
    always @(posedge clk) begin
        if(reset) begin
            state <= IDLE;
            out <= 8'b0;
            out_bit <= 1'b0;
        end
        else begin
            state <= next_state;
            out <= next_state == DATA? {out[6:0], in} : out;
            out_bit <= next_state == DATA? out[7] : out_bit;
        end
    end
    
    assign done = (state == END && out_bit == 1'b1);
    
    assign out_byte = out;
    
endmodule"
N/A,N/A,-1,58,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Use FSM from Fsm_serial

// New: Datapath to latch input bits.

endmodule"
N/A,N/A,-1,59,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serial
    
    parameter idle = 0, rec_data = 1, stop_bit = 2, error = 3;
    reg [2:0] state, next_state;
    reg [3:0] counter;
    reg out;
    
    always @(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    always @(*) begin
        case(state)
            idle:
                begin
                    if(~in)
                        next_state = rec_data;
                    else
                        next_state = idle;
                end
            rec_data:
                begin
                    if(counter == 8)
                        next_state = stop_bit;
                    else
                        next_state = rec_data;
                end
            stop_bit:
                begin
                    if(in)
                        next_state = idle;
                    else
                        next_state = error;
                end
            error:
                begin
                    if(counter == 8)
                        next_state = idle;
                    else
                        next_state = error;
                end
        endcase
    end
    
    always @(posedge clk) begin
        if(state == rec_data && counter < 8)
            counter <= counter + 1;
        else
            counter <= 0;
    end
    
    always @(*) begin
        case(state)
            idle:
                begin
                    out_byte = 8'b0;
                    done = 0;
                end
            rec_data:
                begin
                    out_byte[7:0] = out;
                    done = 0;
                end
            stop_bit:
                begin
                    done = 1;
                end
            error:
                begin
                    done = 0;
                end
        endcase
    end
    
    always @(posedge clk) begin
        if(state == rec_data)
            out <= in;
    end
    
endmodule"
N/A,N/A,-1,60,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serial
    // New: Datapath to latch input bits.
    
    reg [2:0] state, next_state;
    reg [7:0] out_byte_reg;
    reg done_reg;
    
    always @(*) begin
        state <= next_state;
    end
    
    always @(posedge clk) begin
        if(reset) begin
            out_byte_reg <= 0;
            done_reg <= 0;
        end
        else begin
            out_byte_reg <= out_byte;
            done_reg <= done;
        end
    end
    
    always @(*) begin
        case (state)
            3'b000: begin
                if(~in)
                    next_state = 3'b001;
                else
                    next_state = 3'b000;
            end
            3'b001: begin
                if(in)
                    next_state = 3'b010;
                else
                    next_state = 3'b001;
            end
            3'b010: begin
                if(~in)
                    next_state = 3'b011;
                else
                    next_state = 3'b010;
            end
            3'b011: begin
                if(in)
                    next_state = 3'b100;
                else
                    next_state = 3'b011;
            end
            3'b100: begin
                if(~in)
                    next_state = 3'b101;
                else
                    next_state = 3'b100;
            end
            3'b101: begin
                if(in)
                    next_state = 3'b110;
                else
                    next_state = 3'b101;
            end
            3'b110: begin
                if(~in)
                    next_state = 3'b111;
                else
                    next_state = 3'b110;
            end
            3'b111: begin
                if(in)
                    next_state = 3'b000;
                else
                    next_state = 3'b111;
            end
            default: begin
                next_state = 3'b000;
            end
        endcase
    end
    
    assign done = done_reg;
    assign out_byte = out_byte_reg;
    
endmodule"
N/A,N/A,-1,61,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serial
    // New: Datapath to latch input bits.
    
    reg [2:0] state, next_state;
    reg [7:0] out_byte_reg;
    reg done_reg;
    
    always @(*) begin
        state <= next_state;
    end
    
    always @(posedge clk) begin
        if(reset) begin
            out_byte_reg <= 0;
            done_reg <= 0;
        end
        else begin
            out_byte_reg <= out_byte;
            done_reg <= done;
        end
    end
    
    always @(*) begin
        case (state)
            3'b000: begin
                if(~in)
                    next_state = 3'b001;
                else
                    next_state = 3'b000;
            end
            3'b001: begin
                if(in)
                    next_state = 3'b010;
                else
                    next_state = 3'b001;
            end
            3'b010: begin
                if(~in)
                    next_state = 3'b011;
                else
                    next_state = 3'b010;
            end
            3'b011: begin
                if(in)
                    next_state = 3'b100;
                else
                    next_state = 3'b011;
            end
            3'b100: begin
                if(~in)
                    next_state = 3'b101;
                else
                    next_state = 3'b100;
            end
            3'b101: begin
                if(in)
                    next_state = 3'b110;
                else
                    next_state = 3'b101;
            end
            3'b110: begin
                if(~in)
                    next_state = 3'b111;
                else
                    next_state = 3'b110;
            end
            3'b111: begin
                if(in)
                    next_state = 3'b000;
                else
                    next_state = 3'b111;
            end
            default: begin
                next_state = 3'b000;
            end
        endcase
    end
    
    assign done = done_reg;
    assign out_byte = out_byte_reg;
    
endmodule"
N/A,N/A,-1,62,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Use FSM from Fsm_serial

reg [2:0] state, next_state;
reg [7:0] out_byte_reg;
reg done_reg;

parameter idle = 3'b000, start = 3'b001, trans0 = 3'b010, trans1 = 3'b011, trans2 = 3'b100, trans3 = 3'b101, trans4 = 3'b110, trans5 = 3'b111, stop = 3'b111;

always @(*) begin
    next_state = state;
    done_reg = 1'b0;
    out_byte_reg = 8'b0;
    case (state)
        idle: begin
            if (in)
                next_state = start;
        end
        start: begin
            if (in)
                next_state = trans0;
        end
        trans0: begin
            if (in)
                next_state = trans1;
        end
        trans1: begin
            if (in)
                next_state = trans2;
        end
        trans2: begin
            if (in)
                next_state = trans3;
        end
        trans3: begin
            if (in)
                next_state = trans4;
        end
        trans4: begin
            if (in)
                next_state = trans5;
        end
        trans5: begin
            if (~in)
                next_state = stop;
        end
        stop: begin
            if (~in)
                next_state = idle;
            else
                done_reg = 1'b1;
        end
        default: begin
            next_state = idle;
        end
    endcase
end

always @(posedge clk) begin
    if (reset) begin
        state <= idle;
    end
    else begin
        state <= next_state;
    end
end

always @(posedge clk) begin
    if (reset) begin
        out_byte_reg <= 8'b0;
    end
    else begin
        case (state)
            start: begin
                out_byte_reg <= 8'b0;
            end
            trans0: begin
                out_byte_reg[0] <= in;
            end
            trans1: begin
                out_byte_reg[1] <= in;
            end
            trans2: begin
                out_byte_reg[2] <= in;
            end
            trans3: begin
                out_byte_reg[3] <= in;
            end
            trans4: begin
                out_byte_reg[4] <= in;
            end
            trans5: begin
                out_byte_reg[5] <= in;
            end
            stop: begin
                out_byte_reg[6] <= in;
            end
        endcase
    end
end

assign done = done_reg;
assign out_byte = out_byte_reg;

endmodule"
N/A,N/A,-1,63,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serial
    
    parameter idle = 0, rec_data = 1, stop_bit = 2;
    reg [1:0] state, next_state;
    
    always @(*) begin
        state <= next_state;
    end
    
    always @(posedge clk) begin
        if(reset)
            next_state <= idle;
        else
            case(state)
                idle:
                    if(~in)
                        next_state <= rec_data;
                rec_data:
                    if(~in)
                        next_state <= stop_bit;
                stop_bit:
                    if(in)
                        next_state <= idle;
                default:
                    next_state <= idle;
            endcase
    end
    
    assign done = (state == stop_bit);
    
    // New: Datapath to latch input bits.
    reg [7:0] out_byte_reg;
    always @(posedge clk) begin
        if(reset)
            out_byte_reg <= 0;
        else begin
            if(state == rec_data)
                out_byte_reg <= {in, out_byte_reg[7:1]};
        end
    end
    assign out_byte = out_byte_reg;
    
endmodule"
N/A,N/A,-1,64,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serial
    
    // New: Datapath to latch input bits.
    
    reg [7:0] out_byte_reg;
    
    always @(posedge clk) begin
        if(reset) begin
            out_byte_reg <= 0;
        end
        else begin
            out_byte_reg <= {out_byte_reg[6:0], in};
        end
    end
    
    assign done = (out_byte_reg == 8'h0);
    assign out_byte = done? out_byte_reg : out_byte_reg + 8'h1;
    
endmodule"
N/A,N/A,-1,65,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// You can use this counter to verify that the gap and width are as expected.
reg [8:0] gap_count;
reg [8:0] width_count;

// Define states
parameter
    IDLE = 0,
    GAP = 1,
    WIDTH = 2,
    DATA = 3,
    STOP = 4;

reg [2:0] state;
reg [8:0] gap_width;
reg [7:0] data;
reg [3:0] bit_count;

always @(posedge clk) begin
    if (reset)
        state <= IDLE;
    else begin
        case (state)
            IDLE:
                if (in)
                    state <= GAP;
            GAP:
                if (bit_count == 4'd8)
                    state <= WIDTH;
            WIDTH:
                if (width_count == gap_width)
                    state <= DATA;
            DATA:
                if (bit_count == 8)
                    state <= STOP;
            STOP:
                if (in)
                    state <= IDLE;
            default:
                state <= IDLE;
        endcase
    end
end

always @(posedge clk) begin
    if (state == GAP || state == WIDTH) begin
        bit_count <= 4'd0;
    end else begin
        bit_count <= bit_count + 4'd1;
    end
end

always @(posedge clk) begin
    if (state == GAP || state == WIDTH) begin
        gap_count <= gap_width;
    end else begin
        gap_count <= gap_count + 4'd1;
    end
end

always @(posedge clk) begin
    if (state == DATA) begin
        width_count <= gap_width;
    end else begin
        width_count <= width_count + 4'd1;
    end
end

always @(posedge clk) begin
    if (state == STOP) begin
        data <= in;
    end
end

assign done = (state == STOP);

assign out_byte = data;

endmodule"
N/A,N/A,-1,66,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// You can use this counter to verify that the gap and width are as expected.
reg [8:0] gap_count;
reg [8:0] width_count;

// Define states
parameter
    IDLE = 0,
    GAP = 1,
    WIDTH = 2,
    DATA = 3,
    STOP = 4;

reg [2:0] state;
reg [8:0] gap_width;
reg [7:0] data;
reg [3:0] bit_count;

always @(posedge clk) begin
    if (reset)
        state <= IDLE;
    else begin
        case (state)
            IDLE:
                if (in)
                    state <= GAP;
            GAP:
                if (bit_count == 4'd8)
                    state <= WIDTH;
            WIDTH:
                if (width_count == gap_width)
                    state <= DATA;
            DATA:
                if (bit_count == 8)
                    state <= STOP;
            STOP:
                if (in)
                    state <= IDLE;
            default:
                state <= IDLE;
        endcase
    end
end

always @(posedge clk) begin
    if (state == GAP || state == WIDTH) begin
        bit_count <= 4'd0;
    end else begin
        bit_count <= bit_count + 4'd1;
    end
end

always @(posedge clk) begin
    if (state == GAP || state == WIDTH) begin
        gap_count <= gap_width;
    end else begin
        gap_count <= gap_count + 4'd1;
    end
end

always @(posedge clk) begin
    if (state == DATA) begin
        width_count <= gap_width;
    end else begin
        width_count <= width_count + 4'd1;
    end
end

always @(posedge clk) begin
    if (state == STOP) begin
        data <= in;
    end
end

assign done = (state == STOP);

assign out_byte = data;

endmodule"
N/A,N/A,-1,67,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serial
    // New: Datapath to latch input bits.
    
    parameter idle = 0, rec_data = 1, stop_bit = 2, error = 3;
    reg [2:0] state, next_state;
    reg [7:0] data;
    reg [3:0] count;
    
    always @(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    always @(*) begin
        case (state)
            idle:
                begin
                    if(~in)
                        next_state = idle;
                    else
                        next_state = rec_data;
                end
            rec_data:
                begin
                    if(count == 7)
                        next_state = stop_bit;
                    else
                        next_state = rec_data;
                end
            stop_bit:
                begin
                    if(in)
                        next_state = idle;
                    else
                        next_state = error;
                end
            error:
                begin
                    if(count == 4)
                        next_state = idle;
                    else
                        next_state = error;
                end
            default:
                next_state = idle;
        endcase
    end
    
    always @(posedge clk) begin
        if(state == rec_data && count < 7)
            data[count] <= in;
        else if(state == stop_bit)
            data[count] <= 0;
        
        if(state == rec_data)
            count <= count + 1;
        else
            count <= 0;
    end
    
    assign done = (state == stop_bit)? 1 : 0;
    
    assign out_byte = data;
    
endmodule"
N/A,N/A,-1,68,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Use FSM from Fsm_serial

reg [2:0] state, next_state;
reg [7:0] out;
reg done_reg;

always @(*) begin
    case(state)
        3'b000: begin
            if(~in)
                next_state = 3'b001;
            else
                next_state = 3'b000;
        end
        3'b001: begin
            if(in)
                next_state = 3'b010;
            else
                next_state = 3'b000;
        end
        3'b010: begin
            if(~in)
                next_state = 3'b011;
            else
                next_state = 3'b010;
        end
        3'b011: begin
            if(in)
                next_state = 3'b100;
            else
                next_state = 3'b010;
        end
        3'b100: begin
            if(~in)
                next_state = 3'b101;
            else
                next_state = 3'b100;
        end
        3'b101: begin
            if(in)
                next_state = 3'b110;
            else
                next_state = 3'b100;
        end
        3'b110: begin
            if(~in)
                next_state = 3'b111;
            else
                next_state = 3'b110;
        end
        3'b111: begin
            if(in)
                next_state = 3'b000;
            else
                next_state = 3'b110;
        end
        default: next_state = 3'b000;
    endcase
end

always @(posedge clk) begin
    if(reset) begin
        state <= 3'b000;
        done_reg <= 1'b0;
    end
    else begin
        state <= next_state;
        done_reg <= (next_state == 3'b111)? 1'b1 : 1'b0;
    end
end

always @(posedge clk) begin
    if(reset)
        out <= 8'b0;
    else begin
        case(state)
            3'b000: out <= 8'b0;
            3'b001: out <= 8'b0;
            3'b010: out <= 8'b0;
            3'b011: out <= 8'b0;
            3'b100: out <= 8'b0;
            3'b101: out <= 8'b0;
            3'b110: out <= 8'b0;
            3'b111: out <= in;
            default: out <= 8'b0;
        endcase
    end
end

assign out_byte = out;
assign done = done_reg;

endmodule"
N/A,N/A,-1,69,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Use FSM from Fsm_serial

// New: Datapath to latch input bits.

endmodule"
N/A,N/A,-1,70,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    // Use FSM from Fsm_serial
    // New: Datapath to latch input bits.
    
    reg [2:0] state, next_state;
    reg [7:0] out;
    reg done_reg;
    
    localparam
        idle = 3'b000,
        start = 3'b001,
        data = 3'b010,
        stop = 3'b011,
        finish = 3'b100;
    
    always @(*) begin
        case (state)
            idle: begin
                if(~in)
                    next_state = start;
                else
                    next_state = idle;
            end
            start: begin
                if(in)
                    next_state = data;
                else
                    next_state = idle;
            end
            data: begin
                if(~in)
                    next_state = stop;
                else
                    next_state = data;
            end
            stop: begin
                if(in)
                    next_state = finish;
                else
                    next_state = idle;
            end
            finish: begin
                if(in)
                    next_state = finish;
                else
                    next_state = idle;
            end
            default: next_state = idle;
        endcase
    end
    
    always @(posedge clk) begin
        if(reset) begin
            state <= idle;
            done_reg <= 1'b0;
        end
        else begin
            state <= next_state;
            done_reg <= (next_state == finish)? 1'b1 : 1'b0;
        end
    end
    
    always @(posedge clk) begin
        if(state == data)
            out <= {out, in};
    end
    
    assign done = done_reg;
    assign out_byte = out;
    
endmodule"
N/A,N/A,-1,71,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serial
    // New: Datapath to latch input bits.
    
    reg [2:0] state, next_state;
    reg [7:0] out_byte_reg;
    reg done_reg;
    
    parameter idle = 3'b000, start = 3'b001, trans0 = 3'b010, trans1 = 3'b011, trans2 = 3'b100, trans3 = 3'b101;
    
    always @(*) begin
        case (state)
            idle: begin
                if(~in)
                    next_state = start;
                else
                    next_state = idle;
            end
            start: begin
                if(in)
                    next_state = trans0;
                else
                    next_state = idle;
            end
            trans0: begin
                if(in)
                    next_state = trans1;
                else
                    next_state = idle;
            end
            trans1: begin
                if(in)
                    next_state = trans2;
                else
                    next_state = idle;
            end
            trans2: begin
                if(in)
                    next_state = trans3;
                else
                    next_state = idle;
            end
            trans3: begin
                if(in)
                    next_state = idle;
                else
                    next_state = idle;
            end
            default: next_state = idle;
        endcase
    end
    
    always @(posedge clk) begin
        if(reset) begin
            state <= idle;
            out_byte_reg <= 0;
            done_reg <= 0;
        end
        else begin
            state <= next_state;
            case (next_state)
                idle: begin
                    out_byte_reg <= 0;
                    done_reg <= 0;
                end
                start: begin
                    out_byte_reg <= 0;
                    done_reg <= 0;
                end
                trans0: begin
                    out_byte_reg[0] <= in;
                end
                trans1: begin
                    out_byte_reg[1] <= in;
                end
                trans2: begin
                    out_byte_reg[2] <= in;
                end
                trans3: begin
                    out_byte_reg[3] <= in;
                end
                default: begin
                    out_byte_reg <= 0;
                    done_reg <= 0;
                end
            endcase
        end
    end
    
    assign out_byte = out_byte_reg;
    assign done = done_reg;
    
endmodule"
N/A,N/A,-1,72,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Use FSM from Fsm_serial

// New: Datapath to latch input bits.

endmodule"
N/A,N/A,-1,73,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Use FSM from Fsm_serial

// New: Datapath to latch input bits.

endmodule"
N/A,N/A,-1,74,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Modify FSM and datapath from Fsm_serial
    
    parameter idle = 0, rec_data = 1, stop_bit = 2, error = 3;
    reg [2:0] state, next_state;
    reg [3:0] counter;
    reg [7:0] rec_data_byte;
    reg out;
    
    always @(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    always @(*) begin
        case(state)
            idle: begin
                if(~in)
                    next_state = rec_data;
                else
                    next_state = idle;
            end
            rec_data: begin
                if(counter == 7)
                    next_state = stop_bit;
                else
                    next_state = rec_data;
            end
            stop_bit: begin
                if(~in)
                    next_state = idle;
                else
                    next_state = error;
            end
            error: begin
                if(counter == 7)
                    next_state = idle;
                else
                    next_state = error;
            end
            default: next_state = idle;
        endcase
    end
    
    always @(posedge clk) begin
        if(state == rec_data && counter < 7) begin
            rec_data_byte[7-counter] <= in;
            counter <= counter + 1;
        end
    end
    
    assign done = (state == stop_bit) && (counter == 7);
    
    assign out_byte = rec_data_byte;
    
endmodule"
N/A,N/A,-1,75,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Modify FSM and datapath from Fsm_serial
    
    parameter idle = 0, rec_data = 1, stop_bit = 2, error = 3;
    reg [2:0] state, next_state;
    reg [3:0] counter;
    reg [7:0] rec_data_byte;
    reg out;
    
    always @(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    always @(*) begin
        case(state)
            idle: begin
                if(~in)
                    next_state = rec_data;
                else
                    next_state = idle;
            end
            rec_data: begin
                if(counter == 7)
                    next_state = stop_bit;
                else
                    next_state = rec_data;
            end
            stop_bit: begin
                if(~in)
                    next_state = idle;
                else
                    next_state = error;
            end
            error: begin
                if(counter == 7)
                    next_state = idle;
                else
                    next_state = error;
            end
            default: next_state = idle;
        endcase
    end
    
    always @(posedge clk) begin
        if(state == rec_data && counter < 7) begin
            rec_data_byte[7-counter] <= in;
            counter <= counter + 1;
        end
    end
    
    assign done = (state == stop_bit) && (counter == 7);
    
    assign out_byte = rec_data_byte;
    
endmodule"
N/A,N/A,-1,76,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Use FSM from Fsm_serial

// New: Datapath to latch input bits.

// Define states

// New: Datapath to latch input bits.

endmodule"
N/A,N/A,-1,77,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serial
    // New: Datapath to latch input bits.
    
    reg [2:0] state, next_state;
    reg [7:0] out_byte_reg;
    reg done_reg;
    
    always @(*) begin
        state <= next_state;
    end
    
    always @(posedge clk) begin
        if(reset) begin
            out_byte_reg <= 0;
            done_reg <= 0;
        end
        else begin
            if(next_state == 3)
                out_byte_reg <= out_byte;
            else
                out_byte_reg <= out_byte_reg;
            done_reg <= done;
        end
    end
    
    always @(*) begin
        case (state)
            3'b000: begin
                if(~in)
                    next_state = 3'b001;
                else
                    next_state = 3'b000;
            end
            
            3'b001: begin
                if(in)
                    next_state = 3'b010;
                else
                    next_state = 3'b001;
            end
            
            3'b010: begin
                if(~in)
                    next_state = 3'b011;
                else
                    next_state = 3'b010;
            end
            
            3'b011: begin
                if(in)
                    next_state = 3'b100;
                else
                    next_state = 3'b011;
            end
            
            3'b100: begin
                if(~in)
                    next_state = 3'b101;
                else
                    next_state = 3'b100;
            end
            
            3'b101: begin
                if(in)
                    next_state = 3'b110;
                else
                    next_state = 3'b101;
            end
            
            3'b110: begin
                if(~in)
                    next_state = 3'b111;
                else
                    next_state = 3'b110;
            end
            
            3'b111: begin
                if(in)
                    next_state = 3'b000;
                else
                    next_state = 3'b111;
            end
            
            default: begin
                next_state = 3'b000;
            end
        endcase
    end
    
    assign done = done_reg;
    assign out_byte = out_byte_reg;
    
endmodule"
N/A,N/A,-1,78,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serial
    // New: Datapath to latch input bits.
    
    reg [7:0] out;
    reg done_reg;
    
    always @(posedge clk) begin
        if(reset) begin
            out <= 0;
            done_reg <= 0;
        end
        else begin
            if(~done_reg) begin
                if(in) begin
                    out <= out + 1;
                end
            end
            else begin
                if(~in) begin
                    done_reg <= 1;
                end
            end
        end
    end
    
    assign done = done_reg;
    assign out_byte = out;
    
endmodule"
N/A,N/A,-1,79,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Modify FSM and datapath from Fsm_serial
    
    // New: Latch input bits.
    
    reg [2:0] state;
    reg [7:0] out_byte;
    reg done;
    
    always @(posedge clk) begin
        if(reset) begin
            state <= 0;
            out_byte <= 0;
            done <= 0;
        end
        else begin
            case(state)
                3'b000: begin
                    if(in) begin
                        state <= 3'b001;
                    end
                end
                3'b001: begin
                    if(in) begin
                        state <= 3'b010;
                    end
                end
                3'b010: begin
                    if(in) begin
                        state <= 3'b011;
                    end
                end
                3'b011: begin
                    if(in) begin
                        state <= 3'b100;
                    end
                end
                3'b100: begin
                    if(in) begin
                        state <= 3'b101;
                    end
                end
                3'b101: begin
                    if(in) begin
                        state <= 3'b110;
                    end
                end
                3'b110: begin
                    if(in) begin
                        state <= 3'b111;
                    end
                end
                3'b111: begin
                    if(in) begin
                        state <= 3'b000;
                    end
                    else begin
                        done <= 1;
                    end
                end
            endcase
            
            if(state == 3'b111) begin
                out_byte <= out_byte;
            end
            else begin
                out_byte <= 8'b0;
            end
        end
    end
    
endmodule"
N/A,N/A,-1,80,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Modify FSM and datapath from Fsm_serial
    
    // New: Latch input bits.
    
    reg [2:0] state;
    reg [7:0] out_byte;
    reg done;
    
    always @(posedge clk) begin
        if(reset) begin
            state <= 0;
            out_byte <= 0;
            done <= 0;
        end
        else begin
            case(state)
                3'b000: begin
                    if(in) begin
                        state <= 3'b001;
                    end
                end
                3'b001: begin
                    if(in) begin
                        state <= 3'b010;
                    end
                end
                3'b010: begin
                    if(in) begin
                        state <= 3'b011;
                    end
                end
                3'b011: begin
                    if(in) begin
                        state <= 3'b100;
                    end
                end
                3'b100: begin
                    if(in) begin
                        state <= 3'b101;
                    end
                end
                3'b101: begin
                    if(in) begin
                        state <= 3'b110;
                    end
                end
                3'b110: begin
                    if(in) begin
                        state <= 3'b111;
                    end
                end
                3'b111: begin
                    if(in) begin
                        state <= 3'b000;
                    end
                    else begin
                        done <= 1;
                    end
                end
            endcase
            
            if(state == 3'b111) begin
                out_byte <= out_byte;
            end
            else begin
                out_byte <= 8'b0;
            end
        end
    end
    
endmodule"
N/A,N/A,-1,81,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Use FSM from Fsm_serial

endmodule"
N/A,N/A,-1,82,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serial
    
    // New: Datapath to latch input bits.
    
    reg [7:0] out_byte_reg;
    
    always @(posedge clk) begin
        if(reset)
            out_byte_reg <= 0;
        else begin
            if(~in)
                out_byte_reg <= out_byte_reg;
            else
                out_byte_reg <= {out_byte_reg[6:0], out_byte};
        end
    end
    
    assign done = (in == 1'b0);
    
    assign out_byte = out_byte_reg;
    
endmodule"
N/A,N/A,-1,83,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serial
    
    // New: Datapath to latch input bits.
    
    reg [7:0] out_byte_reg;
    
    always @(posedge clk) begin
        if(reset)
            out_byte_reg <= 0;
        else begin
            if(~in)
                out_byte_reg <= out_byte_reg;
            else
                out_byte_reg <= {out_byte_reg[6:0], out_byte};
        end
    end
    
    assign done = (in == 1'b0);
    
    assign out_byte = out_byte_reg;
    
endmodule"
N/A,N/A,-1,84,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serial
    
    // New: Datapath to latch input bits.
    
    reg [7:0] out_byte_reg;
    
    always @(posedge clk) begin
        if(reset)
            out_byte_reg <= 0;
        else begin
            if(~in)
                out_byte_reg <= out_byte_reg;
            else
                out_byte_reg <= {out_byte_reg[6:0], out_byte};
        end
    end
    
    assign done = (in == 1'b0);
    
    assign out_byte = out_byte_reg;
    
endmodule"
N/A,N/A,-1,85,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Use FSM from Fsm_serial

endmodule"
N/A,N/A,-1,86,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Use FSM from Fsm_serial

endmodule"
N/A,N/A,-1,87,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Use FSM from Fsm_serial

endmodule"
N/A,N/A,-1,88,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Modify FSM and datapath from Fsm_serial
    
    parameter idle = 4'd0, start = 4'd1, trans0 = 4'd2, trans1 = 4'd3, trans2 = 4'd4, trans3 = 4'd5;
    parameter trans4 = 4'd6, trans5 = 4'd7, trans6 = 4'd8, trans7 = 4'd9, stop = 4'd10, error = 4'd11, pari = 4'd12;
    reg [3:0] state, next_state;
    
    always @(*) begin
        case (state)
            idle: begin
                if(~in)
                    next_state = start;
                else
                    next_state = idle;
            end
            start: 
                if(in)
                    next_state = trans0;
                else
                    next_state = idle;
            trans0:
                if(in)
                    next_state = trans1;
                else
                    next_state = trans0;
            trans1:
                if(in)
                    next_state = trans2;
                else
                    next_state = trans0;
            trans2:
                if(in)
                    next_state = trans3;
                else
                    next_state = trans0;
            trans3:
                if(in)
                    next_state = trans4;
                else
                    next_state = trans0;
            trans4:
                if(in)
                    next_state = trans5;
                else
                    next_state = trans0;
            trans5:
                if(in)
                    next_state = trans6;
                else
                    next_state = trans0;
            trans6:
                if(in)
                    next_state = trans7;
                else
                    next_state = trans0;
            trans7:
                if(in)
                    next_state = stop;
                else
                    next_state = trans0;
            stop:
                if(in)
                    next_state = idle;
                else
                    next_state = start;
            error:
                if(in)
                    next_state = idle;
                else
                    next_state = error;
            pari:
                if(in)
                    next_state = idle;
                else
                    next_state = pari;
        endcase
    end
    
    always @(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    assign done = (state == stop);
    
    // New: Datapath to latch input bits.
    reg [7:0] out;
    always @(posedge clk) begin
        if(state == trans0 || state == trans1 || state == trans2 || state == trans3 || state == trans4 || state == trans5 || state == trans6 || state == trans7)
            out <= {in, out[7:1]};
    end
    
    assign out_byte = out;
    
endmodule"
N/A,N/A,-1,89,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// You can use this counter to verify that the gap and width are as expected.
reg [4:0] counter = 0;

always @(posedge clk) begin
    if (reset)
        counter <= 0;
    else if (counter!= gap - 1)
        counter <= counter + 1;
    else
        counter <= 0;
end

// New: Datapath to latch input bits.
reg [7:0] in_byte = 0;

always @(posedge clk) begin
    if (reset)
        in_byte <= 0;
    else if (counter == gap - 1)
        in_byte <= {in, in_byte[7:1]};
end

assign done = (counter == gap - 1) && (in_byte == {in, in_byte[7:1]});

// New: Gap and width are now parameters.
parameter gap = 10;
parameter width = 8;

assign out_byte = in_byte >> 1;

endmodule"
N/A,N/A,-1,90,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serial
    // New: Datapath to latch input bits.
    
    reg [7:0] out_byte_reg;
    reg done_reg;
    
    always @(posedge clk) begin
        if(reset) begin
            out_byte_reg <= 0;
            done_reg <= 0;
        end
        else begin
            out_byte_reg <= out_byte;
            done_reg <= done;
        end
    end
    
    assign out_byte = out_byte_reg;
    assign done = done_reg;
    
endmodule"
N/A,N/A,-1,91,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serial
    // New: Datapath to latch input bits.
    
    reg [7:0] out_byte_reg;
    reg done_reg;
    
    always @(posedge clk) begin
        if(reset) begin
            out_byte_reg <= 0;
            done_reg <= 0;
        end
        else begin
            out_byte_reg <= out_byte;
            done_reg <= done;
        end
    end
    
    assign out_byte = out_byte_reg;
    assign done = done_reg;
    
endmodule"
N/A,N/A,-1,92,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Modify FSM and datapath from Fsm_serial
    
    parameter idle = 0, rec_data = 1, stop_bit = 2, error = 3;
    reg [2:0] state, next_state;
    reg [3:0] counter;
    reg out;
    
    always @(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    always @(*) begin
        case (state)
            idle: begin
                if(~in)
                    next_state = rec_data;
                else
                    next_state = idle;
            end
            
            rec_data: begin
                if(counter == 8)
                    next_state = stop_bit;
                else
                    next_state = rec_data;
            end
            
            stop_bit: begin
                if(in)
                    next_state = idle;
                else
                    next_state = error;
            end
            
            error: begin
                if(counter == 8)
                    next_state = idle;
                else
                    next_state = error;
            end
            
            default: next_state = idle;
        endcase
    end
    
    always @(posedge clk) begin
        if(state == rec_data && counter < 8)
            counter <= counter + 1;
        else
            counter <= 0;
    end
    
    always @(posedge clk) begin
        if(state == rec_data && counter == 8)
            out_byte[7:0] <= {out, out_byte[7:1]};
    end
    
    always @(*) begin
        case (state)
            idle: begin
                done = 0;
                out = 0;
            end
            
            rec_data: begin
                done = 0;
                out = in;
            end
            
            stop_bit: begin
                done = 1;
                out = 0;
            end
            
            error: begin
                done = 0;
                out = 0;
            end
            
            default: begin
                done = 0;
                out = 0;
            end
        endcase
    end
    
endmodule"
N/A,N/A,-1,93,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Modify FSM and datapath from Fsm_serial
    
    parameter idle = 0, rec_data = 1, stop_bit = 2, error = 3;
    reg [2:0] state, next_state;
    reg [3:0] counter;
    reg out;
    
    always @(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    always @(*) begin
        case (state)
            idle: begin
                if(~in)
                    next_state = rec_data;
                else
                    next_state = idle;
            end
            
            rec_data: begin
                if(counter == 8)
                    next_state = stop_bit;
                else
                    next_state = rec_data;
            end
            
            stop_bit: begin
                if(in)
                    next_state = idle;
                else
                    next_state = error;
            end
            
            error: begin
                if(counter == 8)
                    next_state = idle;
                else
                    next_state = error;
            end
            
            default: next_state = idle;
        endcase
    end
    
    always @(posedge clk) begin
        if(state == rec_data && counter < 8)
            counter <= counter + 1;
        else
            counter <= 0;
    end
    
    always @(posedge clk) begin
        if(state == rec_data && counter == 8)
            out_byte[7:0] <= {out, out_byte[7:1]};
    end
    
    always @(*) begin
        case (state)
            idle: begin
                done = 0;
                out = 0;
            end
            
            rec_data: begin
                done = 0;
                out = in;
            end
            
            stop_bit: begin
                done = 1;
                out = 0;
            end
            
            error: begin
                done = 0;
                out = 0;
            end
            
            default: begin
                done = 0;
                out = 0;
            end
        endcase
    end
    
endmodule"
N/A,N/A,-1,94,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Use FSM from Fsm_serial

// New: Datapath to latch input bits.

endmodule"
N/A,N/A,-1,95,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serial
    
    // New: Latch input bits.
    
    reg [7:0] out;
    reg done_reg;
    
    always @(posedge clk) begin
        if(reset) begin
            out <= 0;
            done_reg <= 0;
        end
        else begin
            out <= {out[6:0], in};
            done_reg <= done_reg;
        end
    end
    
    assign done = done_reg;
    assign out_byte = out;
    
endmodule"
N/A,N/A,-1,96,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serial
    
    // New: Latch input bits.
    
    reg [7:0] out;
    reg done_reg;
    
    always @(posedge clk) begin
        if(reset) begin
            out <= 0;
            done_reg <= 0;
        end
        else begin
            out <= {out[6:0], in};
            done_reg <= done_reg;
        end
    end
    
    assign done = done_reg;
    assign out_byte = out;
    
endmodule"
N/A,N/A,-1,97,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serial
    // New: Latch input bits
    
    reg [2:0] state, next_state;
    reg [7:0] out;
    reg done_reg;
    
    always @(*) begin
        done_reg <= 1'b0;
        case (state)
            3'b000: begin
                if(~in)
                    next_state = 3'b001;
                else
                    next_state = 3'b000;
            end
            3'b001: begin
                if(in)
                    next_state = 3'b010;
                else
                    next_state = 3'b000;
            end
            3'b010: begin
                if(in)
                    next_state = 3'b011;
                else
                    next_state = 3'b000;
            end
            3'b011: begin
                if(in)
                    next_state = 3'b100;
                else
                    next_state = 3'b000;
            end
            3'b100: begin
                if(in)
                    next_state = 3'b101;
                else
                    next_state = 3'b000;
            end
            3'b101: begin
                if(~in)
                    next_state = 3'b110;
                else
                    next_state = 3'b000;
            end
            3'b110: begin
                if(in)
                    next_state = 3'b000;
                else
                    next_state = 3'b000;
            end
            default: begin
                next_state = 3'b000;
            end
        endcase
    end
    
    always @(posedge clk) begin
        if(reset) begin
            state <= 3'b000;
            out <= 8'b0;
            done_reg <= 1'b0;
        end
        else begin
            state <= next_state;
            out <= out;
            done_reg <= done_reg;
        end
    end
    
    assign done = done_reg;
    assign out_byte = out;
    
endmodule"
N/A,N/A,-1,98,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Use FSM from Fsm_serial

endmodule"
N/A,N/A,-1,99,0,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Use FSM from Fsm_serial

endmodule"
