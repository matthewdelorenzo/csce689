Area,Delay,Score,Current Run,Episode,Verilog
7608.93,2659.47,0.1,2.0,1,"//Please finish designing the 32 bit multiplier module (multiplier_32) below.
//There are two 32 bit inputs (A and B) and a 64 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_32(output [63:0] product, input [31:0] A, B);
    assign product = A * B;
endmodule"
N/A,N/A,-1,3.0,1,"//Please finish designing the 32 bit multiplier module (multiplier_32) below.
//There are two 32 bit inputs (A and B) and a 64 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_32(output [63:0] product, input [31:0] A, B);
	/*
		Group Members: Kevin Ingram and Warren Seto

		Lab Name: Combinational Logic
		Project Name: eng312_proj2
		Design Name: multiplier_32bit.v
		Design Description: Verilog Module to implement a 32 bit multiplier
	*/
	
	wire [31:0] A_1, A_2, A_3, A_4, A_5, A_6, A_7, A_8, A_9, A_10, A_11, A_12, A_13, A_14, A_15, A_16, A_17, A_18, A_19, A_20, A_21, A_22, A_23, A_24, A_25, A_26, A_27, A_28, A_29, A_30, A_31;
	wire [31:0] B_1, B_2, B_3, B_4, B_5, B_6, B_7, B_8, B_9, B_10, B_11, B_12, B_13, B_14, B_15, B_16, B_17, B_18, B_19, B_20, B_21, B_22, B_23, B_24, B_25, B_26, B_27, B_28, B_29, B_30, B_31;
	wire [63:0] product_1, product_2, product_3, product_4, product_5, product_6, product_7, product_8, product_9, product_10, product_11, product_12, product_13, product_14, product_15, product_16, product_17, product_18, product_19, product_20, product_21, product_22, product_23, product_24, product_25, product_26, product_27, product_28, product_29, product_30, product_31;
	
	assign A_1 = A << 1;
	assign B_1 = B << 1;
	
	assign product_1 = A_1 * B_1;
	
	assign A_2 = A_1[31:0];
	assign B_2 = B_1[31:0];
	assign product_2 = A_2 * B_2;
	
	assign A_3 = A_2[31:0];
	assign B_3 = B_2[31:0];
	assign product_3 = A_3 * B_3;
	
	assign A_4 = A_3[31:0];
	assign B_4 = B_3[31:0];
	assign product_4 = A_4 * B_4;
	
	assign A_5 = A_4[31:0];
	assign B_5 = B_4[31:0];
	assign product_5 = A_5 * B_5;
	
	assign A_6 = A_5[31:0];
	assign B_6 = B_5[31:0];
	assign product_6 = A_6 * B_6;
	
	assign A_7 = A_6[31:0];
	assign B_7 = B_6[31:0];
	assign product_7 = A_7 * B_7;
	
	assign A_8 = A_7[31:0];
	assign B_8 = B_7[31:0];
	assign product_8 = A_8 * B_8;
	
	assign A_9 = A_8[31:0];
	assign B_9 = B_8[31:0];
	assign product_9 = A_9 * B_9;
	
	assign A_10 = A_9[31:0];
	assign B_10 = B_9[31:0];
	assign product_10 = A_10 * B_10;
	
	assign A_11 = A_10[31:0];
	assign B_11 = B_10[31:0];
	assign product_11 = A_11 * B_11;
	
	assign A_12 = A_11[31:0];
"
N/A,N/A,-1,4.0,1,"//Please finish designing the 32 bit multiplier module (multiplier_32) below.
//There are two 32 bit inputs (A and B) and a 64 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_32(output [63:0] product, input [31:0] A, B);
	assign pp0 = A[0]? B: 32'b00000000000000000000000000000000;
	assign pp1 = A[1]? B: 32'b00000000000000000000000000000000;
	assign pp2 = A[2]? B: 32'b00000000000000000000000000000000;
	assign pp3 = A[3]? B: 32'b00000000000000000000000000000000;
	assign pp4 = A[4]? B: 32'b00000000000000000000000000000000;
	assign pp5 = A[5]? B: 32'b00000000000000000000000000000000;
	assign pp6 = A[6]? B: 32'b00000000000000000000000000000000;
	assign pp7 = A[7]? B: 32'b00000000000000000000000000000000;
	assign pp8 = A[8]? B: 32'b00000000000000000000000000000000;
	assign pp9 = A[9]? B: 32'b00000000000000000000000000000000;
	assign pp10 = A[10]? B: 32'b00000000000000000000000000000000;
	assign pp11 = A[11]? B: 32'b00000000000000000000000000000000;
	assign pp12 = A[12]? B: 32'b00000000000000000000000000000000;
	assign pp13 = A[13]? B: 32'b00000000000000000000000000000000;
	assign pp14 = A[14]? B: 32'b00000000000000000000000000000000;
	assign pp15 = A[15]? B: 32'b00000000000000000000000000000000;
	assign pp16 = A[16]? B: 32'b00000000000000000000000000000000;
	assign pp17 = A[17]? B: 32'b00000000000000000000000000000000;
	assign pp18 = A[18]? B: 32'b00000000000000000000000000000000;
	assign pp19 = A[19]? B: 32'b00000000000000000000000000000000;
	assign pp20 = A[20]? B: 32'b00000000000000000000000000000000;
	assign pp21 = A[21]? B: 32'b00000000000000000000000000000000;
	assign pp22 = A[22]? B: 32'b00000000000000000000000000000000;
	assign pp23 = A[23]? B: 32'b00000000000000000000000000000000;
	assign pp24 = A[24]? B: 32'b00000000000000000000000000000000;
	assign pp25 = A[25]? B: 32'b00000000000000000000000000000000;
	assign pp26 = A[26]? B: 32'b00000000000000000000000000000000;
	assign pp27 = A[27]? B: 32'b00000000000000000000000000000000;
	assign pp28 = A[28]? B: 32'b00000000000000000000000000000000;
	assign pp29 = A[29]? B: 32'b00000000000000000000000000000000;
	assign pp30 = A[30]? B: 32'b00000000000000000000000000000000;
	assign pp31 = A[31]? B: 32'b00000000000000000000000000000000;
	assign product[0] = pp0[0];
	assign in1_1 = {pp0[1],pp0[0],pp0[0],pp0[0]};
	assign in1_2 = {pp1[0],pp1[0],pp1[0],pp1[0]};
	CLA4 CLA01(s1, c1, in1_1, in1_2);
	assign in2_1 = {pp2[1],pp2[0],pp2[0],pp2[0]};
	assign in2_2 = {pp3[0],pp3[0],pp3[0],pp3[0]};
	CLA4 CLA02(s2, c2, in2_1, in2_2);
	assign in3_1 = {s1[3],s1[2],s1[1],s1[0]};
	assign in3_2 = {s2[2],s2[1],s2[0],s2[3]};
	CLA4 CLA03(s3, c3, in3_1, in3_2);
	assign in4_1 = {pp4[1],pp4[0],pp4[0],pp4[0]};
	assign in4_2 = {pp5[0],pp5[0],pp5[0],pp5[0]};
	CLA4 CLA04(s4, c4, in4_1, in4_2);
	assign in5_1 = {s1[3],s1[2],s1[1],s1[0]"
7608.93,2659.47,0.1,5.0,1,"//Please finish designing the 32 bit multiplier module (multiplier_32) below.
//There are two 32 bit inputs (A and B) and a 64 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_32(output [63:0] product, input [31:0] A, B);
    assign product = A * B;
endmodule"
N/A,N/A,-1,6.0,1,"//Please finish designing the 32 bit multiplier module (multiplier_32) below.
//There are two 32 bit inputs (A and B) and a 64 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_32(output [63:0] product, input [31:0] A, B);
	assign pp0[0] = A[0] & B[0];
	assign pp0[1] = A[0] & B[1];
	assign pp0[2] = A[0] & B[2];
	assign pp0[3] = A[0] & B[3];
	assign pp0[4] = A[0] & B[4];
	assign pp0[5] = A[0] & B[5];
	assign pp0[6] = A[0] & B[6];
	assign pp0[7] = A[0] & B[7];
	assign pp0[8] = A[0] & B[8];
	assign pp0[9] = A[0] & B[9];
	assign pp0[10] = A[0] & B[10];
	assign pp0[11] = A[0] & B[11];
	assign pp0[12] = A[0] & B[12];
	assign pp0[13] = A[0] & B[13];
	assign pp0[14] = A[0] & B[14];
	assign pp0[15] = A[0] & B[15];
	assign pp0[16] = A[0] & B[16];
	assign pp0[17] = A[0] & B[17];
	assign pp0[18] = A[0] & B[18];
	assign pp0[19] = A[0] & B[19];
	assign pp0[20] = A[0] & B[20];
	assign pp0[21] = A[0] & B[21];
	assign pp0[22] = A[0] & B[22];
	assign pp0[23] = A[0] & B[23];
	assign pp0[24] = A[0] & B[24];
	assign pp0[25] = A[0] & B[25];
	assign pp0[26] = A[0] & B[26];
	assign pp0[27] = A[0] & B[27];
	assign pp0[28] = A[0] & B[28];
	assign pp0[29] = A[0] & B[29];
	assign pp0[30] = A[0] & B[30];
	assign pp0[31] = A[0] & B[31];
	assign pp1[0] = A[1] & B[0];
	assign pp1[1] = A[1] & B[1];
	assign pp1[2] = A[1] & B[2];
	assign pp1[3] = A[1] & B[3];
	assign pp1[4] = A[1] & B[4];
	assign pp1[5] = A[1] & B[5];
	assign pp1[6] = A[1] & B[6];
	assign pp1[7] = A[1] & B[7];
	assign pp1[8] = A[1] & B[8];
	assign pp1[9] = A[1] & B[9];
	assign pp1[10] = A[1] & B[10];
	assign pp1[11] = A[1] & B[11];
	assign pp1[12] = A[1] & B[12];
	assign pp1[13] = A[1] & B[13];
	assign pp1[14] = A[1] & B[14];
	assign pp1[15] = A[1] & B[15];
	assign pp1[16] = A[1] & B[16];
	assign pp1[17] = A[1] & B[17];
	assign pp1[18] = A[1] & B[18];
	assign pp1[19] = A[1] & B[19];
	assign pp1[20] = A[1] & B[20];
	assign pp1[21] = A[1] & B["
N/A,N/A,-1,7.0,1,"//Please finish designing the 32 bit multiplier module (multiplier_32) below.
//There are two 32 bit inputs (A and B) and a 64 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_32(output [63:0] product, input [31:0] A, B);

	wire [31:0] pp0, pp1, pp2, pp3, pp4, pp5, pp6, pp7, pp8, pp9, pp10, pp11, pp12, pp13, pp14, pp15;

	assign pp0 = A[0]? B: 32'b00000000000000000000000000000000;
	assign pp1 = A[1]? B: 32'b00000000000000000000000000000000;
	assign pp2 = A[2]? B: 32'b00000000000000000000000000000000;
	assign pp3 = A[3]? B: 32'b00000000000000000000000000000000;
	assign pp4 = A[4]? B: 32'b00000000000000000000000000000000;
	assign pp5 = A[5]? B: 32'b00000000000000000000000000000000;
	assign pp6 = A[6]? B: 32'b00000000000000000000000000000000;
	assign pp7 = A[7]? B: 32'b00000000000000000000000000000000;
	assign pp8 = A[8]? B: 32'b00000000000000000000000000000000;
	assign pp9 = A[9]? B: 32'b00000000000000000000000000000000;
	assign pp10 = A[10]? B: 32'b00000000000000000000000000000000;
	assign pp11 = A[11]? B: 32'b00000000000000000000000000000000;
	assign pp12 = A[12]? B: 32'b00000000000000000000000000000000;
	assign pp13 = A[13]? B: 32'b00000000000000000000000000000000;
	assign pp14 = A[14]? B: 32'b00000000000000000000000000000000;
	assign pp15 = A[15]? B: 32'b00000000000000000000000000000000;

	assign product[0] = pp0[0];

	/* 1st CLA */
	wire [31:0] G1, P1, C1;
	assign G1[0]  = pp0[1]  & pp1[0];
	assign G1[1]  = pp0[2]  & pp1[1];
	assign G1[2]  = pp0[3]  & pp1[2];
	assign G1[3]  = pp0[4]  & pp1[3];
	assign G1[4]  = pp0[5]  & pp1[4];
	assign G1[5]  = pp0[6]  & pp1[5];
	assign G1[6]  = pp0[7]  & pp1[6];
	assign G1[7]  = pp0[8]  & pp1[7];
	assign G1[8]  = pp0[9]  & pp1[8];
	assign G1[9]  = pp0[10] & pp1[9];
	assign G1[10] = pp0[11] & pp1[10];
	assign G1[11] = pp0[12] & pp1[11];
	assign G1[12] = pp0[13] & pp1[12];
	assign G1[13] = pp0[14] & pp1[13];
	assign G1[14] = pp0[15] & pp1[14];
	assign G1[15] = 0       & pp1[15];
	assign P1[0]  = pp0[1]  ^ pp1[0];
	assign P1[1]  = pp0[2]  ^ pp1[1];
	assign P1[2]  = pp0[3]  ^ pp1[2];
	assign P1[3]  = pp0[4]  ^ pp1[3];
	assign P1[4]  = pp0[5]  ^ pp1[4];
	assign P1[5]  = pp0[6]  ^ pp1[5];
	assign P1[6]  = pp0[7]  ^ pp1[6];
	assign P1[7]  = pp0[8]  ^ pp1[7];
	assign P1[8]  = pp0[9]  ^ pp1[8];
	assign P1[9]  = pp0[10] ^ pp1[9];
	assign P1[10] = pp0[11] ^ pp1[10];
	assign P1[11"
N/A,N/A,-1,8.0,1,"//Please finish designing the 32 bit multiplier module (multiplier_32) below.
//There are two 32 bit inputs (A and B) and a 64 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_32(output [63:0] product, input [31:0] A, B);
    /* Please fill in the implementation here... */
    assign pp0 = A[0]? B: 32'b00000000000000000000000000000000;
    assign pp1 = A[1]? B: 32'b00000000000000000000000000000000;
    assign pp2 = A[2]? B: 32'b00000000000000000000000000000000;
    assign pp3 = A[3]? B: 32'b00000000000000000000000000000000;
    assign pp4 = A[4]? B: 32'b00000000000000000000000000000000;
    assign pp5 = A[5]? B: 32'b00000000000000000000000000000000;
    assign pp6 = A[6]? B: 32'b00000000000000000000000000000000;
    assign pp7 = A[7]? B: 32'b00000000000000000000000000000000;
    assign pp8 = A[8]? B: 32'b00000000000000000000000000000000;
    assign pp9 = A[9]? B: 32'b00000000000000000000000000000000;
    assign pp10 = A[10]? B: 32'b00000000000000000000000000000000;
    assign pp11 = A[11]? B: 32'b00000000000000000000000000000000;
    assign pp12 = A[12]? B: 32'b00000000000000000000000000000000;
    assign pp13 = A[13]? B: 32'b00000000000000000000000000000000;
    assign pp14 = A[14]? B: 32'b00000000000000000000000000000000;
    assign pp15 = A[15]? B: 32'b00000000000000000000000000000000;
    assign pp16 = A[16]? B: 32'b00000000000000000000000000000000;
    assign pp17 = A[17]? B: 32'b00000000000000000000000000000000;
    assign pp18 = A[18]? B: 32'b00000000000000000000000000000000;
    assign pp19 = A[19]? B: 32'b00000000000000000000000000000000;
    assign pp20 = A[20]? B: 32'b00000000000000000000000000000000;
    assign pp21 = A[21]? B: 32'b00000000000000000000000000000000;
    assign pp22 = A[22]? B: 32'b00000000000000000000000000000000;
    assign pp23 = A[23]? B: 32'b00000000000000000000000000000000;
    assign pp24 = A[24]? B: 32'b00000000000000000000000000000000;
    assign pp25 = A[25]? B: 32'b00000000000000000000000000000000;
    assign pp26 = A[26]? B: 32'b00000000000000000000000000000000;
    assign pp27 = A[27]? B: 32'b00000000000000000000000000000000;
    assign pp28 = A[28]? B: 32'b00000000000000000000000000000000;
    assign pp29 = A[29]? B: 32'b00000000000000000000000000000000;
    assign pp30 = A[30]? B: 32'b00000000000000000000000000000000;
    assign pp31 = A[31]? B: 32'b00000000000000000000000000000000;
    assign product[0] = pp0[0];
    /* CLA 1 */
    assign in1_1 = {pp0[1],pp0[2],pp0[3],pp0[4],pp0[5],pp0[6],pp0[7],pp0[8],pp0[9],pp0[10],pp0[11],pp0[12],pp0[13],pp0[14],pp0[15],pp0[16],pp0[17],pp0[18],pp0[19],pp0[20],pp0[21],pp0[22],pp0[23],pp0[24],pp0[25],pp0[26],pp0[27],pp0[28],pp0[29],pp0[30],pp0[31],pp1[31]};
    assign in1_2 = {pp1[0],pp1[1],pp1[2],pp1[3],pp1[4],pp1[5],pp1[6],pp1[7],pp1[8],pp1[9],pp1[10],pp1[11],pp1[12],pp1[13],pp1[14],pp1[15],pp1[16],pp1[17],pp1[18],pp1[19],pp1[20],pp1[21],pp1[22],pp1[23],pp1[24],pp1[25],pp1[26],pp1[27],pp1[28],pp1[29],pp1[30],pp2[30],pp2[31]};
    CLA_32 KS"
7608.93,2659.47,0.1,9.0,1,"//Please finish designing the 32 bit multiplier module (multiplier_32) below.
//There are two 32 bit inputs (A and B) and a 64 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_32(output [63:0] product, input [31:0] A, B);
    assign product = A * B;
endmodule"
N/A,N/A,-1,10.0,1,"//Please finish designing the 32 bit multiplier module (multiplier_32) below.
//There are two 32 bit inputs (A and B) and a 64 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_32(output [63:0] product, input [31:0] A, B);
	assign pp0[0] = A[0] & B[0];
	assign pp0[1] = A[0] & B[1];
	assign pp0[2] = A[0] & B[2];
	assign pp0[3] = A[0] & B[3];
	assign pp0[4] = A[0] & B[4];
	assign pp0[5] = A[0] & B[5];
	assign pp0[6] = A[0] & B[6];
	assign pp0[7] = A[0] & B[7];
	assign pp0[8] = A[0] & B[8];
	assign pp0[9] = A[0] & B[9];
	assign pp0[10] = A[0] & B[10];
	assign pp0[11] = A[0] & B[11];
	assign pp0[12] = A[0] & B[12];
	assign pp0[13] = A[0] & B[13];
	assign pp0[14] = A[0] & B[14];
	assign pp0[15] = A[0] & B[15];
	assign pp0[16] = A[0] & B[16];
	assign pp0[17] = A[0] & B[17];
	assign pp0[18] = A[0] & B[18];
	assign pp0[19] = A[0] & B[19];
	assign pp0[20] = A[0] & B[20];
	assign pp0[21] = A[0] & B[21];
	assign pp0[22] = A[0] & B[22];
	assign pp0[23] = A[0] & B[23];
	assign pp0[24] = A[0] & B[24];
	assign pp0[25] = A[0] & B[25];
	assign pp0[26] = A[0] & B[26];
	assign pp0[27] = A[0] & B[27];
	assign pp0[28] = A[0] & B[28];
	assign pp0[29] = A[0] & B[29];
	assign pp0[30] = A[0] & B[30];
	assign pp0[31] = A[0] & B[31];
	assign pp1[0] = A[1] & B[0];
	assign pp1[1] = A[1] & B[1];
	assign pp1[2] = A[1] & B[2];
	assign pp1[3] = A[1] & B[3];
	assign pp1[4] = A[1] & B[4];
	assign pp1[5] = A[1] & B[5];
	assign pp1[6] = A[1] & B[6];
	assign pp1[7] = A[1] & B[7];
	assign pp1[8] = A[1] & B[8];
	assign pp1[9] = A[1] & B[9];
	assign pp1[10] = A[1] & B[10];
	assign pp1[11] = A[1] & B[11];
	assign pp1[12] = A[1] & B[12];
	assign pp1[13] = A[1] & B[13];
	assign pp1[14] = A[1] & B[14];
	assign pp1[15] = A[1] & B[15];
	assign pp1[16] = A[1] & B[16];
	assign pp1[17] = A[1] & B[17];
	assign pp1[18] = A[1] & B[18];
	assign pp1[19] = A[1] & B[19];
	assign pp1[20] = A[1] & B[20];
	assign pp1[21] = A[1] & B["
N/A,N/A,-1,11.0,1,"//Please finish designing the 32 bit multiplier module (multiplier_32) below.
//There are two 32 bit inputs (A and B) and a 64 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_32(output [63:0] product, input [31:0] A, B);
	
	wire [31:0] pp0, pp1, pp2, pp3, pp4, pp5, pp6, pp7, pp8, pp9, pp10, pp11, pp12, pp13, pp14, pp15;
	
	assign pp0 = A[0]? B: 32'b00000000000000000000000000000000;
	assign pp1 = A[1]? B: 32'b00000000000000000000000000000000;
	assign pp2 = A[2]? B: 32'b00000000000000000000000000000000;
	assign pp3 = A[3]? B: 32'b00000000000000000000000000000000;
	assign pp4 = A[4]? B: 32'b00000000000000000000000000000000;
	assign pp5 = A[5]? B: 32'b00000000000000000000000000000000;
	assign pp6 = A[6]? B: 32'b00000000000000000000000000000000;
	assign pp7 = A[7]? B: 32'b00000000000000000000000000000000;
	assign pp8 = A[8]? B: 32'b00000000000000000000000000000000;
	assign pp9 = A[9]? B: 32'b00000000000000000000000000000000;
	assign pp10 = A[10]? B: 32'b00000000000000000000000000000000;
	assign pp11 = A[11]? B: 32'b00000000000000000000000000000000;
	assign pp12 = A[12]? B: 32'b00000000000000000000000000000000;
	assign pp13 = A[13]? B: 32'b00000000000000000000000000000000;
	assign pp14 = A[14]? B: 32'b00000000000000000000000000000000;
	assign pp15 = A[15]? B: 32'b00000000000000000000000000000000;
	
	assign product[0] = pp0[0];
	
	/* First Stage */
	half_adder ha01(s1, c1, pp0[1], pp1[0]);
	full_adder fa01(s2, c2, pp0[2], pp1[1], pp2[0]);
	full_adder fa02(s3, c3, pp0[3], pp1[2], pp2[1]);
	full_adder fa03(s4, c4, pp0[4], pp1[3], pp2[2]);
	full_adder fa04(s5, c5, pp0[5], pp1[4], pp2[3]);
	full_adder fa05(s6, c6, pp0[6], pp1[5], pp2[4]);
	full_adder fa06(s7, c7, pp0[7], pp1[6], pp2[5]);
	full_adder fa07(s8, c8, pp0[8], pp1[7], pp2[6]);
	full_adder fa08(s9, c9, pp0[9], pp1[8], pp2[7]);
	full_adder fa09(s10, c10, pp0[10], pp1[9], pp2[8]);
	full_adder fa10(s11, c11, pp0[11], pp1[10], pp2[9]);
	full_adder fa11(s12, c12, pp0[12], pp1[11], pp2[10]);
	full_adder fa12(s13, c13, pp0[13], pp1[12], pp2[11]);
	full_adder fa13(s14, c14, pp0[14], pp1[13], pp2[12]);
	full_adder fa14(s15, c15, pp0[15], pp1[14], pp2[13]);
	half_adder ha02(s16, c16, pp1[15], pp2[14]);
	
	/* Second Stage */
	half_adder ha03(s201, c201, s1, pp3[0]);
	full_adder fa04(s202, c202, s2, pp3[1], c1);
	full_adder fa05(s203, c203, s3, pp3[2], c2);
	full_adder fa06(s204, c204, s4, pp3[3], c3);
	full_adder fa07(s205, c205, s5, pp3[4], c4);
	full_adder fa08(s206, c206, s6, pp3[5], c5);
	full_adder fa09(s207,"
7608.93,2659.47,0.1,12.0,1,"//Please finish designing the 32 bit multiplier module (multiplier_32) below.
//There are two 32 bit inputs (A and B) and a 64 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_32(output [63:0] product, input [31:0] A, B);
    assign product = A * B;
endmodule"
7608.93,2659.47,0.1,13.0,1,"//Please finish designing the 32 bit multiplier module (multiplier_32) below.
//There are two 32 bit inputs (A and B) and a 64 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_32(output [63:0] product, input [31:0] A, B);
    assign product = A * B;
endmodule"
7608.93,2659.47,0.1,14.0,1,"//Please finish designing the 32 bit multiplier module (multiplier_32) below.
//There are two 32 bit inputs (A and B) and a 64 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_32(output [63:0] product, input [31:0] A, B);
    assign product = A * B;
endmodule"
N/A,N/A,-1,15.0,1,"//Please finish designing the 32 bit multiplier module (multiplier_32) below.
//There are two 32 bit inputs (A and B) and a 64 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_32(output [63:0] product, input [31:0] A, B);
	/*
		Group Members: Kevin Ingram and Warren Seto
		Lab Name: Combinational Circuit Design
		Design Description: Verilog Module to implement a 32 bit multiplier
	*/
	
	wire [31:0] A_1, A_2, A_3, A_4, A_5, A_6, A_7, A_8, A_9, A_10, A_11, A_12, A_13, A_14, A_15, A_16, A_17, A_18, A_19, A_20, A_21, A_22, A_23, A_24, A_25, A_26, A_27, A_28, A_29, A_30, A_31;
	wire [31:0] B_1, B_2, B_3, B_4, B_5, B_6, B_7, B_8, B_9, B_10, B_11, B_12, B_13, B_14, B_15, B_16, B_17, B_18, B_19, B_20, B_21, B_22, B_23, B_24, B_25, B_26, B_27, B_28, B_29, B_30, B_31;
	wire [31:0] product_1, product_2, product_3, product_4, product_5, product_6, product_7, product_8, product_9, product_10, product_11, product_12, product_13, product_14, product_15, product_16, product_17, product_18, product_19, product_20, product_21, product_22, product_23, product_24, product_25, product_26, product_27, product_28, product_29, product_30, product_31;
	
	assign A_1 = A << 1;
	assign B_1 = B << 1;
	
	assign product_1 = A_1 * B_1;
	
	assign A_2 = A_1[31:16] << 1;
	assign B_2 = B_1[31:16] << 1;
	
	assign product_2 = A_2 * B_2;
	
	assign A_3 = A_2[31:16] << 1;
	assign B_3 = B_2[31:16] << 1;
	
	assign product_3 = A_3 * B_3;
	
	assign A_4 = A_3[31:16] << 1;
	assign B_4 = B_3[31:16] << 1;
	
	assign product_4 = A_4 * B_4;
	
	assign A_5 = A_4[31:16] << 1;
	assign B_5 = B_4[31:16] << 1;
	
	assign product_5 = A_5 * B_5;
	
	assign A_6 = A_5[31:16] << 1;
	assign B_6 = B_5[31:16] << 1;
	
	assign product_6 = A_6 * B_6;
	
	assign A_7 = A_6[31:16] << 1;
	assign B_7 = B_6[31:16] << 1;
	
	assign product_7 = A_7 * B_7;
	
	assign A_8 = A_7[31:16] << 1;
	assign B_8 = B_7[31:16] << 1;
	
	assign product_8 = A_8 * B_8;
	
	assign A_9 = A_8[31:16] << 1;
	assign B_9 = B_8[31:16] << 1;
	
	assign product_9 = A_9 * B_9;
	
	assign A_10 = A_9[31:16] << 1;
	assign B_10 = B_9[31:16] << 1;
	
	assign product_10 = A_10 * B_10;
	
	assign A_11 = A_10[31:16]"
N/A,N/A,-1,16.0,1,"//Please finish designing the 32 bit multiplier module (multiplier_32) below.
//There are two 32 bit inputs (A and B) and a 64 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_32(output [63:0] product, input [31:0] A, B);
	assign pp0 = A[0]? B: 32'b00000000000000000000000000000000;
	assign pp1 = A[1]? B: 32'b00000000000000000000000000000000;
	assign pp2 = A[2]? B: 32'b00000000000000000000000000000000;
	assign pp3 = A[3]? B: 32'b00000000000000000000000000000000;
	assign pp4 = A[4]? B: 32'b00000000000000000000000000000000;
	assign pp5 = A[5]? B: 32'b00000000000000000000000000000000;
	assign pp6 = A[6]? B: 32'b00000000000000000000000000000000;
	assign pp7 = A[7]? B: 32'b00000000000000000000000000000000;
	assign pp8 = A[8]? B: 32'b00000000000000000000000000000000;
	assign pp9 = A[9]? B: 32'b00000000000000000000000000000000;
	assign pp10 = A[10]? B: 32'b00000000000000000000000000000000;
	assign pp11 = A[11]? B: 32'b00000000000000000000000000000000;
	assign pp12 = A[12]? B: 32'b00000000000000000000000000000000;
	assign pp13 = A[13]? B: 32'b00000000000000000000000000000000;
	assign pp14 = A[14]? B: 32'b00000000000000000000000000000000;
	assign pp15 = A[15]? B: 32'b00000000000000000000000000000000;
	assign pp16 = A[16]? B: 32'b00000000000000000000000000000000;
	assign pp17 = A[17]? B: 32'b00000000000000000000000000000000;
	assign pp18 = A[18]? B: 32'b00000000000000000000000000000000;
	assign pp19 = A[19]? B: 32'b00000000000000000000000000000000;
	assign pp20 = A[20]? B: 32'b00000000000000000000000000000000;
	assign pp21 = A[21]? B: 32'b00000000000000000000000000000000;
	assign pp22 = A[22]? B: 32'b00000000000000000000000000000000;
	assign pp23 = A[23]? B: 32'b00000000000000000000000000000000;
	assign pp24 = A[24]? B: 32'b00000000000000000000000000000000;
	assign pp25 = A[25]? B: 32'b00000000000000000000000000000000;
	assign pp26 = A[26]? B: 32'b00000000000000000000000000000000;
	assign pp27 = A[27]? B: 32'b00000000000000000000000000000000;
	assign pp28 = A[28]? B: 32'b00000000000000000000000000000000;
	assign pp29 = A[29]? B: 32'b00000000000000000000000000000000;
	assign pp30 = A[30]? B: 32'b00000000000000000000000000000000;
	assign pp31 = A[31]? B: 32'b00000000000000000000000000000000;
	assign product[0] = pp0[0];
	assign in1_1 = {pp0[1],pp0[0],pp0[0],pp0[0]};
	assign in1_2 = {pp1[0],pp1[0],pp1[0],pp1[0]};
	CLA4 CLA01(s1, c1, in1_1, in1_2);
	assign in2_1 = {pp2[1],pp2[0],pp2[0],pp2[0]};
	assign in2_2 = {pp3[0],pp3[0],pp3[0],pp3[0]};
	CLA4 CLA02(s2, c2, in2_1, in2_2);
	assign in3_1 = {s1[3],s1[2],s1[1],s1[0]};
	assign in3_2 = {s2[2],s2[1],s2[0],s2[3]};
	CLA4 CLA03(s3, c3, in3_1, in3_2);
	assign in4_1 = {pp4[1],pp4[0],pp4[0],pp4[0]};
	assign in4_2 = {pp5[0],pp5[0],pp5[0],pp5[0]};
	CLA4 CLA04(s4, c4, in4_1, in4_2);
	assign in5_1 = {s1[3],s1[2],s1[1],s1[0]"
N/A,N/A,-1,17.0,1,"//Please finish designing the 32 bit multiplier module (multiplier_32) below.
//There are two 32 bit inputs (A and B) and a 64 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_32(output [63:0] product, input [31:0] A, B);
	assign pp0[0] = A[0] & B[0];
	assign pp0[1] = A[0] & B[1];
	assign pp0[2] = A[0] & B[2];
	assign pp0[3] = A[0] & B[3];
	assign pp0[4] = A[0] & B[4];
	assign pp0[5] = A[0] & B[5];
	assign pp0[6] = A[0] & B[6];
	assign pp0[7] = A[0] & B[7];
	assign pp0[8] = A[0] & B[8];
	assign pp0[9] = A[0] & B[9];
	assign pp0[10] = A[0] & B[10];
	assign pp0[11] = A[0] & B[11];
	assign pp0[12] = A[0] & B[12];
	assign pp0[13] = A[0] & B[13];
	assign pp0[14] = A[0] & B[14];
	assign pp0[15] = A[0] & B[15];
	assign pp0[16] = A[0] & B[16];
	assign pp0[17] = A[0] & B[17];
	assign pp0[18] = A[0] & B[18];
	assign pp0[19] = A[0] & B[19];
	assign pp0[20] = A[0] & B[20];
	assign pp0[21] = A[0] & B[21];
	assign pp0[22] = A[0] & B[22];
	assign pp0[23] = A[0] & B[23];
	assign pp0[24] = A[0] & B[24];
	assign pp0[25] = A[0] & B[25];
	assign pp0[26] = A[0] & B[26];
	assign pp0[27] = A[0] & B[27];
	assign pp0[28] = A[0] & B[28];
	assign pp0[29] = A[0] & B[29];
	assign pp0[30] = A[0] & B[30];
	assign pp0[31] = A[0] & B[31];
	assign pp1[0] = A[1] & B[0];
	assign pp1[1] = A[1] & B[1];
	assign pp1[2] = A[1] & B[2];
	assign pp1[3] = A[1] & B[3];
	assign pp1[4] = A[1] & B[4];
	assign pp1[5] = A[1] & B[5];
	assign pp1[6] = A[1] & B[6];
	assign pp1[7] = A[1] & B[7];
	assign pp1[8] = A[1] & B[8];
	assign pp1[9] = A[1] & B[9];
	assign pp1[10] = A[1] & B[10];
	assign pp1[11] = A[1] & B[11];
	assign pp1[12] = A[1] & B[12];
	assign pp1[13] = A[1] & B[13];
	assign pp1[14] = A[1] & B[14];
	assign pp1[15] = A[1] & B[15];
	assign pp1[16] = A[1] & B[16];
	assign pp1[17] = A[1] & B[17];
	assign pp1[18] = A[1] & B[18];
	assign pp1[19] = A[1] & B[19];
	assign pp1[20] = A[1] & B[20];
	assign pp1[21] = A[1] & B["
N/A,N/A,-1,18.0,1,"//Please finish designing the 32 bit multiplier module (multiplier_32) below.
//There are two 32 bit inputs (A and B) and a 64 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_32(output [63:0] product, input [31:0] A, B);

	wire [31:0] pp0, pp1, pp2, pp3, pp4, pp5, pp6, pp7, pp8, pp9, pp10, pp11, pp12, pp13, pp14, pp15;

	assign pp0 = A[0]? B: 32'b00000000000000000000000000000000;
	assign pp1 = A[1]? B: 32'b00000000000000000000000000000000;
	assign pp2 = A[2]? B: 32'b00000000000000000000000000000000;
	assign pp3 = A[3]? B: 32'b00000000000000000000000000000000;
	assign pp4 = A[4]? B: 32'b00000000000000000000000000000000;
	assign pp5 = A[5]? B: 32'b00000000000000000000000000000000;
	assign pp6 = A[6]? B: 32'b00000000000000000000000000000000;
	assign pp7 = A[7]? B: 32'b00000000000000000000000000000000;
	assign pp8 = A[8]? B: 32'b00000000000000000000000000000000;
	assign pp9 = A[9]? B: 32'b00000000000000000000000000000000;
	assign pp10 = A[10]? B: 32'b00000000000000000000000000000000;
	assign pp11 = A[11]? B: 32'b00000000000000000000000000000000;
	assign pp12 = A[12]? B: 32'b00000000000000000000000000000000;
	assign pp13 = A[13]? B: 32'b00000000000000000000000000000000;
	assign pp14 = A[14]? B: 32'b00000000000000000000000000000000;
	assign pp15 = A[15]? B: 32'b00000000000000000000000000000000;

	assign product[0] = pp0[0];

	/* 1st CLA */
	wire [31:0] G1, P1, C1;
	assign G1[0]  = pp0[1]  & pp1[0];
	assign G1[1]  = pp0[2]  & pp1[1];
	assign G1[2]  = pp0[3]  & pp1[2];
	assign G1[3]  = pp0[4]  & pp1[3];
	assign G1[4]  = pp0[5]  & pp1[4];
	assign G1[5]  = pp0[6]  & pp1[5];
	assign G1[6]  = pp0[7]  & pp1[6];
	assign G1[7]  = pp0[8]  & pp1[7];
	assign G1[8]  = pp0[9]  & pp1[8];
	assign G1[9]  = pp0[10] & pp1[9];
	assign G1[10] = pp0[11] & pp1[10];
	assign G1[11] = pp0[12] & pp1[11];
	assign G1[12] = pp0[13] & pp1[12];
	assign G1[13] = pp0[14] & pp1[13];
	assign G1[14] = pp0[15] & pp1[14];
	assign G1[15] = 0       & pp1[15];
	assign P1[0]  = pp0[1]  ^ pp1[0];
	assign P1[1]  = pp0[2]  ^ pp1[1];
	assign P1[2]  = pp0[3]  ^ pp1[2];
	assign P1[3]  = pp0[4]  ^ pp1[3];
	assign P1[4]  = pp0[5]  ^ pp1[4];
	assign P1[5]  = pp0[6]  ^ pp1[5];
	assign P1[6]  = pp0[7]  ^ pp1[6];
	assign P1[7]  = pp0[8]  ^ pp1[7];
	assign P1[8]  = pp0[9]  ^ pp1[8];
	assign P1[9]  = pp0[10] ^ pp1[9];
	assign P1[10] = pp0[11] ^ pp1[10];
	assign P1[11"
N/A,N/A,-1,19.0,1,"//Please finish designing the 32 bit multiplier module (multiplier_32) below.
//There are two 32 bit inputs (A and B) and a 64 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_32(output [63:0] product, input [31:0] A, B);
    /* Please fill in the implementation here... */
    assign pp0 = A[0]? B: 32'b00000000000000000000000000000000;
    assign pp1 = A[1]? B: 32'b00000000000000000000000000000000;
    assign pp2 = A[2]? B: 32'b00000000000000000000000000000000;
    assign pp3 = A[3]? B: 32'b00000000000000000000000000000000;
    assign pp4 = A[4]? B: 32'b00000000000000000000000000000000;
    assign pp5 = A[5]? B: 32'b00000000000000000000000000000000;
    assign pp6 = A[6]? B: 32'b00000000000000000000000000000000;
    assign pp7 = A[7]? B: 32'b00000000000000000000000000000000;
    assign pp8 = A[8]? B: 32'b00000000000000000000000000000000;
    assign pp9 = A[9]? B: 32'b00000000000000000000000000000000;
    assign pp10 = A[10]? B: 32'b00000000000000000000000000000000;
    assign pp11 = A[11]? B: 32'b00000000000000000000000000000000;
    assign pp12 = A[12]? B: 32'b00000000000000000000000000000000;
    assign pp13 = A[13]? B: 32'b00000000000000000000000000000000;
    assign pp14 = A[14]? B: 32'b00000000000000000000000000000000;
    assign pp15 = A[15]? B: 32'b00000000000000000000000000000000;
    assign pp16 = A[16]? B: 32'b00000000000000000000000000000000;
    assign pp17 = A[17]? B: 32'b00000000000000000000000000000000;
    assign pp18 = A[18]? B: 32'b00000000000000000000000000000000;
    assign pp19 = A[19]? B: 32'b00000000000000000000000000000000;
    assign pp20 = A[20]? B: 32'b00000000000000000000000000000000;
    assign pp21 = A[21]? B: 32'b00000000000000000000000000000000;
    assign pp22 = A[22]? B: 32'b00000000000000000000000000000000;
    assign pp23 = A[23]? B: 32'b00000000000000000000000000000000;
    assign pp24 = A[24]? B: 32'b00000000000000000000000000000000;
    assign pp25 = A[25]? B: 32'b00000000000000000000000000000000;
    assign pp26 = A[26]? B: 32'b00000000000000000000000000000000;
    assign pp27 = A[27]? B: 32'b00000000000000000000000000000000;
    assign pp28 = A[28]? B: 32'b00000000000000000000000000000000;
    assign pp29 = A[29]? B: 32'b00000000000000000000000000000000;
    assign pp30 = A[30]? B: 32'b00000000000000000000000000000000;
    assign pp31 = A[31]? B: 32'b00000000000000000000000000000000;
    assign product[0] = pp0[0];
    /* 1st CLA */
    assign in1_1 = {pp0[1],pp0[2],pp0[3],pp0[4],pp0[5],pp0[6],pp0[7],pp0[8],pp0[9],pp0[10],pp0[11],pp0[12],pp0[13],pp0[14],pp0[15],pp0[16],pp0[17],pp0[18],pp0[19],pp0[20],pp0[21],pp0[22],pp0[23],pp0[24],pp0[25],pp0[26],pp0[27],pp0[28],pp0[29],pp0[30],pp0[31],1'b0};
    assign in1_2 = {pp1[0],pp1[1],pp1[2],pp1[3],pp1[4],pp1[5],pp1[6],pp1[7],pp1[8],pp1[9], pp1[10],pp1[11],pp1[12],pp1[13],pp1[14],pp1[15],pp1[16],pp1[17],pp1[18],pp1[19],pp1[20],pp1[21],pp1[22],pp1[23],pp1[24],pp1[25],pp1[26],pp1[27],pp1[28],pp1[29],pp1[30],pp1[31],1'b0};
    CLA_32 KS_"
N/A,N/A,-1,20.0,1,"//Please finish designing the 32 bit multiplier module (multiplier_32) below.
//There are two 32 bit inputs (A and B) and a 64 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_32(output [63:0] product, input [31:0] A, B);
	assign pp0[0] = A[0] & B[0];
	assign pp0[1] = A[0] & B[1];
	assign pp0[2] = A[0] & B[2];
	assign pp0[3] = A[0] & B[3];
	assign pp0[4] = A[0] & B[4];
	assign pp0[5] = A[0] & B[5];
	assign pp0[6] = A[0] & B[6];
	assign pp0[7] = A[0] & B[7];
	assign pp0[8] = A[0] & B[8];
	assign pp0[9] = A[0] & B[9];
	assign pp0[10] = A[0] & B[10];
	assign pp0[11] = A[0] & B[11];
	assign pp0[12] = A[0] & B[12];
	assign pp0[13] = A[0] & B[13];
	assign pp0[14] = A[0] & B[14];
	assign pp0[15] = A[0] & B[15];
	assign pp0[16] = A[0] & B[16];
	assign pp0[17] = A[0] & B[17];
	assign pp0[18] = A[0] & B[18];
	assign pp0[19] = A[0] & B[19];
	assign pp0[20] = A[0] & B[20];
	assign pp0[21] = A[0] & B[21];
	assign pp0[22] = A[0] & B[22];
	assign pp0[23] = A[0] & B[23];
	assign pp0[24] = A[0] & B[24];
	assign pp0[25] = A[0] & B[25];
	assign pp0[26] = A[0] & B[26];
	assign pp0[27] = A[0] & B[27];
	assign pp0[28] = A[0] & B[28];
	assign pp0[29] = A[0] & B[29];
	assign pp0[30] = A[0] & B[30];
	assign pp0[31] = A[0] & B[31];
	assign pp1[0] = A[1] & B[0];
	assign pp1[1] = A[1] & B[1];
	assign pp1[2] = A[1] & B[2];
	assign pp1[3] = A[1] & B[3];
	assign pp1[4] = A[1] & B[4];
	assign pp1[5] = A[1] & B[5];
	assign pp1[6] = A[1] & B[6];
	assign pp1[7] = A[1] & B[7];
	assign pp1[8] = A[1] & B[8];
	assign pp1[9] = A[1] & B[9];
	assign pp1[10] = A[1] & B[10];
	assign pp1[11] = A[1] & B[11];
	assign pp1[12] = A[1] & B[12];
	assign pp1[13] = A[1] & B[13];
	assign pp1[14] = A[1] & B[14];
	assign pp1[15] = A[1] & B[15];
	assign pp1[16] = A[1] & B[16];
	assign pp1[17] = A[1] & B[17];
	assign pp1[18] = A[1] & B[18];
	assign pp1[19] = A[1] & B[19];
	assign pp1[20] = A[1] & B[20];
	assign pp1[21] = A[1] & B["
N/A,N/A,-1,21.0,1,"//Please finish designing the 32 bit multiplier module (multiplier_32) below.
//There are two 32 bit inputs (A and B) and a 64 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_32(output [63:0] product, input [31:0] A, B);
	
	wire [31:0] pp0, pp1, pp2, pp3, pp4, pp5, pp6, pp7, pp8, pp9, pp10, pp11, pp12, pp13, pp14, pp15;
	
	assign pp0 = A[0]? B: 32'b00000000000000000000000000000000;
	assign pp1 = A[1]? B: 32'b00000000000000000000000000000000;
	assign pp2 = A[2]? B: 32'b00000000000000000000000000000000;
	assign pp3 = A[3]? B: 32'b00000000000000000000000000000000;
	assign pp4 = A[4]? B: 32'b00000000000000000000000000000000;
	assign pp5 = A[5]? B: 32'b00000000000000000000000000000000;
	assign pp6 = A[6]? B: 32'b00000000000000000000000000000000;
	assign pp7 = A[7]? B: 32'b00000000000000000000000000000000;
	assign pp8 = A[8]? B: 32'b00000000000000000000000000000000;
	assign pp9 = A[9]? B: 32'b00000000000000000000000000000000;
	assign pp10 = A[10]? B: 32'b00000000000000000000000000000000;
	assign pp11 = A[11]? B: 32'b00000000000000000000000000000000;
	assign pp12 = A[12]? B: 32'b00000000000000000000000000000000;
	assign pp13 = A[13]? B: 32'b00000000000000000000000000000000;
	assign pp14 = A[14]? B: 32'b00000000000000000000000000000000;
	assign pp15 = A[15]? B: 32'b00000000000000000000000000000000;
	
	assign product[0] = pp0[0];
	
	/* First Stage */
	half_adder ha01(s1, c1, pp0[1], pp1[0]);
	full_adder fa01(s2, c2, pp0[2], pp1[1], pp2[0]);
	full_adder fa02(s3, c3, pp0[3], pp1[2], pp2[1]);
	full_adder fa03(s4, c4, pp0[4], pp1[3], pp2[2]);
	full_adder fa04(s5, c5, pp0[5], pp1[4], pp2[3]);
	full_adder fa05(s6, c6, pp0[6], pp1[5], pp2[4]);
	full_adder fa06(s7, c7, pp0[7], pp1[6], pp2[5]);
	full_adder fa07(s8, c8, pp0[8], pp1[7], pp2[6]);
	full_adder fa08(s9, c9, pp0[9], pp1[8], pp2[7]);
	full_adder fa09(s10, c10, pp0[10], pp1[9], pp2[8]);
	full_adder fa10(s11, c11, pp0[11], pp1[10], pp2[9]);
	full_adder fa11(s12, c12, pp0[12], pp1[11], pp2[10]);
	full_adder fa12(s13, c13, pp0[13], pp1[12], pp2[11]);
	full_adder fa13(s14, c14, pp0[14], pp1[13], pp2[12]);
	full_adder fa14(s15, c15, pp0[15], pp1[14], pp2[13]);
	half_adder ha02(s16, c16, pp1[15], pp2[14]);
	
	/* Second Stage */
	half_adder ha03(s201, c201, s1, pp3[0]);
	full_adder fa04(s202, c202, s2, pp3[1], c1);
	full_adder fa05(s203, c203, s3, pp3[2], c2);
	full_adder fa06(s204, c204, s4, pp3[3], c3);
	full_adder fa07(s205, c205, s5, pp3[4], c4);
	full_adder fa08(s206, c206, s6, pp3[5], c5);
	full_adder fa09(s207,"
7608.93,2659.47,0.1,22.0,1,"//Please finish designing the 32 bit multiplier module (multiplier_32) below.
//There are two 32 bit inputs (A and B) and a 64 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_32(output [63:0] product, input [31:0] A, B);
    assign product = A * B;
endmodule"
7608.93,2659.47,0.1,23.0,1,"//Please finish designing the 32 bit multiplier module (multiplier_32) below.
//There are two 32 bit inputs (A and B) and a 64 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_32(output [63:0] product, input [31:0] A, B);
    assign product = A * B;
endmodule"
7608.93,2659.47,0.1,24.0,1,"//Please finish designing the 32 bit multiplier module (multiplier_32) below.
//There are two 32 bit inputs (A and B) and a 64 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_32(output [63:0] product, input [31:0] A, B);
    assign product = A * B;
endmodule"
7608.93,2659.47,0.1,25.0,1,"//Please finish designing the 32 bit multiplier module (multiplier_32) below.
//There are two 32 bit inputs (A and B) and a 64 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_32(output [63:0] product, input [31:0] A, B);
    assign product = A * B;
endmodule"
7608.93,2659.47,0.1,26.0,1,"//Please finish designing the 32 bit multiplier module (multiplier_32) below.
//There are two 32 bit inputs (A and B) and a 64 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_32(output [63:0] product, input [31:0] A, B);
    assign product = A * B;
endmodule"
7608.93,2659.47,0.1,27.0,1,"//Please finish designing the 32 bit multiplier module (multiplier_32) below.
//There are two 32 bit inputs (A and B) and a 64 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_32(output [63:0] product, input [31:0] A, B);
    assign product = A * B;
endmodule"
N/A,N/A,-1,28.0,1,"//Please finish designing the 32 bit multiplier module (multiplier_32) below.
//There are two 32 bit inputs (A and B) and a 64 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_32(output [63:0] product, input [31:0] A, B);
	/*
		Group Members: Kevin Ingram and Warren Seto
		Lab Name: Combinational Logic
		Design Name: multiplier_32bit.v
		Design Description: Verilog Module for a 32 bit multiplier
	*/
	
	wire [31:0] A_1, A_2, A_3, A_4, A_5, A_6, A_7, A_8, A_9, A_10, A_11, A_12, A_13, A_14, A_15, A_16, A_17, A_18, A_19, A_20, A_21, A_22, A_23, A_24, A_25, A_26, A_27, A_28, A_29, A_30, A_31;
	wire [31:0] B_1, B_2, B_3, B_4, B_5, B_6, B_7, B_8, B_9, B_10, B_11, B_12, B_13, B_14, B_15, B_16, B_17, B_18, B_19, B_20, B_21, B_22, B_23, B_24, B_25, B_26, B_27, B_28, B_29, B_30, B_31;
	wire [63:0] product_1, product_2, product_3, product_4, product_5, product_6, product_7, product_8, product_9, product_10, product_11, product_12, product_13, product_14, product_15, product_16, product_17, product_18, product_19, product_20, product_21, product_22, product_23, product_24, product_25, product_26, product_27, product_28, product_29, product_30, product_31;
	
	assign A_1 = A << 1;
	assign B_1 = B << 1;
	
	assign product_1 = A_1 * B_1;
	
	assign A_2 = A_1[31:0];
	assign B_2 = B_1[31:0];
	assign product_2 = A_2 * B_2;
	
	assign A_3 = A_2[31:0];
	assign B_3 = B_2[31:0];
	assign product_3 = A_3 * B_3;
	
	assign A_4 = A_3[31:0];
	assign B_4 = B_3[31:0];
	assign product_4 = A_4 * B_4;
	
	assign A_5 = A_4[31:0];
	assign B_5 = B_4[31:0];
	assign product_5 = A_5 * B_5;
	
	assign A_6 = A_5[31:0];
	assign B_6 = B_5[31:0];
	assign product_6 = A_6 * B_6;
	
	assign A_7 = A_6[31:0];
	assign B_7 = B_6[31:0];
	assign product_7 = A_7 * B_7;
	
	assign A_8 = A_7[31:0];
	assign B_8 = B_7[31:0];
	assign product_8 = A_8 * B_8;
	
	assign A_9 = A_8[31:0];
	assign B_9 = B_8[31:0];
	assign product_9 = A_9 * B_9;
	
	assign A_10 = A_9[31:0];
	assign B_10 = B_9[31:0];
	assign product_10 = A_10 * B_10;
	
	assign A_11 = A_10[31:0];
	assign B_11 = B_10[31:0];
	assign product_11 = A_11 * B_11;
	
	assign A_12 = A_11[31:0];
	assign B_12 = B_11[31"
N/A,N/A,-1,29.0,1,"//Please finish designing the 32 bit multiplier module (multiplier_32) below.
//There are two 32 bit inputs (A and B) and a 64 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_32(output [63:0] product, input [31:0] A, B);
	assign pp0 = A[0]? B: 32'b00000000000000000000000000000000;
	assign pp1 = A[1]? B: 32'b00000000000000000000000000000000;
	assign pp2 = A[2]? B: 32'b00000000000000000000000000000000;
	assign pp3 = A[3]? B: 32'b00000000000000000000000000000000;
	assign pp4 = A[4]? B: 32'b00000000000000000000000000000000;
	assign pp5 = A[5]? B: 32'b00000000000000000000000000000000;
	assign pp6 = A[6]? B: 32'b00000000000000000000000000000000;
	assign pp7 = A[7]? B: 32'b00000000000000000000000000000000;
	assign pp8 = A[8]? B: 32'b00000000000000000000000000000000;
	assign pp9 = A[9]? B: 32'b00000000000000000000000000000000;
	assign pp10 = A[10]? B: 32'b00000000000000000000000000000000;
	assign pp11 = A[11]? B: 32'b00000000000000000000000000000000;
	assign pp12 = A[12]? B: 32'b00000000000000000000000000000000;
	assign pp13 = A[13]? B: 32'b00000000000000000000000000000000;
	assign pp14 = A[14]? B: 32'b00000000000000000000000000000000;
	assign pp15 = A[15]? B: 32'b00000000000000000000000000000000;
	assign pp16 = A[16]? B: 32'b00000000000000000000000000000000;
	assign pp17 = A[17]? B: 32'b00000000000000000000000000000000;
	assign pp18 = A[18]? B: 32'b00000000000000000000000000000000;
	assign pp19 = A[19]? B: 32'b00000000000000000000000000000000;
	assign pp20 = A[20]? B: 32'b00000000000000000000000000000000;
	assign pp21 = A[21]? B: 32'b00000000000000000000000000000000;
	assign pp22 = A[22]? B: 32'b00000000000000000000000000000000;
	assign pp23 = A[23]? B: 32'b00000000000000000000000000000000;
	assign pp24 = A[24]? B: 32'b00000000000000000000000000000000;
	assign pp25 = A[25]? B: 32'b00000000000000000000000000000000;
	assign pp26 = A[26]? B: 32'b00000000000000000000000000000000;
	assign pp27 = A[27]? B: 32'b00000000000000000000000000000000;
	assign pp28 = A[28]? B: 32'b00000000000000000000000000000000;
	assign pp29 = A[29]? B: 32'b00000000000000000000000000000000;
	assign pp30 = A[30]? B: 32'b00000000000000000000000000000000;
	assign pp31 = A[31]? B: 32'b00000000000000000000000000000000;
	assign product[0] = pp0[0];
	assign in1_1 = {pp0[1],pp0[0],pp0[0],pp0[0]};
	assign in1_2 = {pp1[0],pp1[0],pp1[0],pp1[0]};
	CLA4 CLA01(s1, c1, in1_1, in1_2);
	assign in2_1 = {pp2[1],pp2[0],pp2[0],pp2[0]};
	assign in2_2 = {pp3[0],pp3[0],pp3[0],pp3[0]};
	CLA4 CLA02(s2, c2, in2_1, in2_2);
	assign in3_1 = {s1[3],s1[2],s1[1],s1[0]};
	assign in3_2 = {s2[2],s2[1],s2[0],s2[3]};
	CLA4 CLA03(s3, c3, in3_1, in3_2);
	assign in4_1 = {pp4[1],pp4[0],pp4[0],pp4[0]};
	assign in4_2 = {pp5[0],pp5[0],pp5[0],pp5[0]};
	CLA4 CLA04(s4, c4, in4_1, in4_2);
	assign in5_1 = {s1[3],s1[2],s1[1],s1[0]"
N/A,N/A,-1,30.0,1,"//Please finish designing the 32 bit multiplier module (multiplier_32) below.
//There are two 32 bit inputs (A and B) and a 64 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_32(output [63:0] product, input [31:0] A, B);
	assign pp0[0] = A[0] & B[0];
	assign pp0[1] = A[0] & B[1];
	assign pp0[2] = A[0] & B[2];
	assign pp0[3] = A[0] & B[3];
	assign pp0[4] = A[0] & B[4];
	assign pp0[5] = A[0] & B[5];
	assign pp0[6] = A[0] & B[6];
	assign pp0[7] = A[0] & B[7];
	assign pp0[8] = A[0] & B[8];
	assign pp0[9] = A[0] & B[9];
	assign pp0[10] = A[0] & B[10];
	assign pp0[11] = A[0] & B[11];
	assign pp0[12] = A[0] & B[12];
	assign pp0[13] = A[0] & B[13];
	assign pp0[14] = A[0] & B[14];
	assign pp0[15] = A[0] & B[15];
	assign pp0[16] = A[0] & B[16];
	assign pp0[17] = A[0] & B[17];
	assign pp0[18] = A[0] & B[18];
	assign pp0[19] = A[0] & B[19];
	assign pp0[20] = A[0] & B[20];
	assign pp0[21] = A[0] & B[21];
	assign pp0[22] = A[0] & B[22];
	assign pp0[23] = A[0] & B[23];
	assign pp0[24] = A[0] & B[24];
	assign pp0[25] = A[0] & B[25];
	assign pp0[26] = A[0] & B[26];
	assign pp0[27] = A[0] & B[27];
	assign pp0[28] = A[0] & B[28];
	assign pp0[29] = A[0] & B[29];
	assign pp0[30] = A[0] & B[30];
	assign pp0[31] = A[0] & B[31];
	assign pp1[0] = A[1] & B[0];
	assign pp1[1] = A[1] & B[1];
	assign pp1[2] = A[1] & B[2];
	assign pp1[3] = A[1] & B[3];
	assign pp1[4] = A[1] & B[4];
	assign pp1[5] = A[1] & B[5];
	assign pp1[6] = A[1] & B[6];
	assign pp1[7] = A[1] & B[7];
	assign pp1[8] = A[1] & B[8];
	assign pp1[9] = A[1] & B[9];
	assign pp1[10] = A[1] & B[10];
	assign pp1[11] = A[1] & B[11];
	assign pp1[12] = A[1] & B[12];
	assign pp1[13] = A[1] & B[13];
	assign pp1[14] = A[1] & B[14];
	assign pp1[15] = A[1] & B[15];
	assign pp1[16] = A[1] & B[16];
	assign pp1[17] = A[1] & B[17];
	assign pp1[18] = A[1] & B[18];
	assign pp1[19] = A[1] & B[19];
	assign pp1[20] = A[1] & B[20];
	assign pp1[21] = A[1] & B["
N/A,N/A,-1,31.0,1,"//Please finish designing the 32 bit multiplier module (multiplier_32) below.
//There are two 32 bit inputs (A and B) and a 64 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_32(output [63:0] product, input [31:0] A, B);

	wire [31:0] pp0, pp1, pp2, pp3, pp4, pp5, pp6, pp7, pp8, pp9, pp10, pp11, pp12, pp13, pp14, pp15;

	assign pp0 = A[0]? B: 32'b00000000000000000000000000000000;
	assign pp1 = A[1]? B: 32'b00000000000000000000000000000000;
	assign pp2 = A[2]? B: 32'b00000000000000000000000000000000;
	assign pp3 = A[3]? B: 32'b00000000000000000000000000000000;
	assign pp4 = A[4]? B: 32'b00000000000000000000000000000000;
	assign pp5 = A[5]? B: 32'b00000000000000000000000000000000;
	assign pp6 = A[6]? B: 32'b00000000000000000000000000000000;
	assign pp7 = A[7]? B: 32'b00000000000000000000000000000000;
	assign pp8 = A[8]? B: 32'b00000000000000000000000000000000;
	assign pp9 = A[9]? B: 32'b00000000000000000000000000000000;
	assign pp10 = A[10]? B: 32'b00000000000000000000000000000000;
	assign pp11 = A[11]? B: 32'b00000000000000000000000000000000;
	assign pp12 = A[12]? B: 32'b00000000000000000000000000000000;
	assign pp13 = A[13]? B: 32'b00000000000000000000000000000000;
	assign pp14 = A[14]? B: 32'b00000000000000000000000000000000;
	assign pp15 = A[15]? B: 32'b00000000000000000000000000000000;

	assign product[0] = pp0[0];

	/* 1st CLA */
	wire [31:0] G1, P1, C1;
	assign G1[0]  = pp0[1]  & pp1[0];
	assign G1[1]  = pp0[2]  & pp1[1];
	assign G1[2]  = pp0[3]  & pp1[2];
	assign G1[3]  = pp0[4]  & pp1[3];
	assign G1[4]  = pp0[5]  & pp1[4];
	assign G1[5]  = pp0[6]  & pp1[5];
	assign G1[6]  = pp0[7]  & pp1[6];
	assign G1[7]  = pp0[8]  & pp1[7];
	assign G1[8]  = pp0[9]  & pp1[8];
	assign G1[9]  = pp0[10] & pp1[9];
	assign G1[10] = pp0[11] & pp1[10];
	assign G1[11] = pp0[12] & pp1[11];
	assign G1[12] = pp0[13] & pp1[12];
	assign G1[13] = pp0[14] & pp1[13];
	assign G1[14] = pp0[15] & pp1[14];
	assign G1[15] = 0       & pp1[15];
	assign P1[0]  = pp0[1]  ^ pp1[0];
	assign P1[1]  = pp0[2]  ^ pp1[1];
	assign P1[2]  = pp0[3]  ^ pp1[2];
	assign P1[3]  = pp0[4]  ^ pp1[3];
	assign P1[4]  = pp0[5]  ^ pp1[4];
	assign P1[5]  = pp0[6]  ^ pp1[5];
	assign P1[6]  = pp0[7]  ^ pp1[6];
	assign P1[7]  = pp0[8]  ^ pp1[7];
	assign P1[8]  = pp0[9]  ^ pp1[8];
	assign P1[9]  = pp0[10] ^ pp1[9];
	assign P1[10] = pp0[11] ^ pp1[10];
	assign P1[11"
N/A,N/A,-1,32.0,1,"//Please finish designing the 32 bit multiplier module (multiplier_32) below.
//There are two 32 bit inputs (A and B) and a 64 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_32(output [63:0] product, input [31:0] A, B);
    /* Please fill in the implementation here... */
    assign pp0 = A[0]? B: 32'b00000000000000000000000000000000;
    assign pp1 = A[1]? B: 32'b00000000000000000000000000000000;
    assign pp2 = A[2]? B: 32'b00000000000000000000000000000000;
    assign pp3 = A[3]? B: 32'b00000000000000000000000000000000;
    assign pp4 = A[4]? B: 32'b00000000000000000000000000000000;
    assign pp5 = A[5]? B: 32'b00000000000000000000000000000000;
    assign pp6 = A[6]? B: 32'b00000000000000000000000000000000;
    assign pp7 = A[7]? B: 32'b00000000000000000000000000000000;
    assign pp8 = A[8]? B: 32'b00000000000000000000000000000000;
    assign pp9 = A[9]? B: 32'b00000000000000000000000000000000;
    assign pp10 = A[10]? B: 32'b00000000000000000000000000000000;
    assign pp11 = A[11]? B: 32'b00000000000000000000000000000000;
    assign pp12 = A[12]? B: 32'b00000000000000000000000000000000;
    assign pp13 = A[13]? B: 32'b00000000000000000000000000000000;
    assign pp14 = A[14]? B: 32'b00000000000000000000000000000000;
    assign pp15 = A[15]? B: 32'b00000000000000000000000000000000;
    assign pp16 = A[16]? B: 32'b00000000000000000000000000000000;
    assign pp17 = A[17]? B: 32'b00000000000000000000000000000000;
    assign pp18 = A[18]? B: 32'b00000000000000000000000000000000;
    assign pp19 = A[19]? B: 32'b00000000000000000000000000000000;
    assign pp20 = A[20]? B: 32'b00000000000000000000000000000000;
    assign pp21 = A[21]? B: 32'b00000000000000000000000000000000;
    assign pp22 = A[22]? B: 32'b00000000000000000000000000000000;
    assign pp23 = A[23]? B: 32'b00000000000000000000000000000000;
    assign pp24 = A[24]? B: 32'b00000000000000000000000000000000;
    assign pp25 = A[25]? B: 32'b00000000000000000000000000000000;
    assign pp26 = A[26]? B: 32'b00000000000000000000000000000000;
    assign pp27 = A[27]? B: 32'b00000000000000000000000000000000;
    assign pp28 = A[28]? B: 32'b00000000000000000000000000000000;
    assign pp29 = A[29]? B: 32'b00000000000000000000000000000000;
    assign pp30 = A[30]? B: 32'b00000000000000000000000000000000;
    assign pp31 = A[31]? B: 32'b00000000000000000000000000000000;
    assign product[0] = pp0[0];
    /* 1st CLA */
    assign in1_1 = {pp0[1],pp0[2],pp0[3],pp0[4],pp0[5],pp0[6],pp0[7],pp0[8],pp0[9],pp0[10],pp0[11],pp0[12],pp0[13],pp0[14],pp0[15],pp0[16],pp0[17],pp0[18],pp0[19],pp0[20],pp0[21],pp0[22],pp0[23],pp0[24],pp0[25],pp0[26],pp0[27],pp0[28],pp0[29],pp0[30],pp0[31],1'b0};
    assign in1_2 = {pp1[0],pp1[1],pp1[2],pp1[3],pp1[4],pp1[5],pp1[6],pp1[7],pp1[8],pp1[9], pp1[10],pp1[11],pp1[12],pp1[13],pp1[14],pp1[15],pp1[16],pp1[17],pp1[18],pp1[19],pp1[20],pp1[21],pp1[22],pp1[23],pp1[24],pp1[25],pp1[26],pp1[27],pp1[28],pp1[29],pp1[30],pp1[31],1'b0};
    CLA_32 KS_"
N/A,N/A,-1,33.0,1,"//Please finish designing the 32 bit multiplier module (multiplier_32) below.
//There are two 32 bit inputs (A and B) and a 64 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_32(output [63:0] product, input [31:0] A, B);
	assign pp0[0] = A[0] & B[0];
	assign pp0[1] = A[0] & B[1];
	assign pp0[2] = A[0] & B[2];
	assign pp0[3] = A[0] & B[3];
	assign pp0[4] = A[0] & B[4];
	assign pp0[5] = A[0] & B[5];
	assign pp0[6] = A[0] & B[6];
	assign pp0[7] = A[0] & B[7];
	assign pp0[8] = A[0] & B[8];
	assign pp0[9] = A[0] & B[9];
	assign pp0[10] = A[0] & B[10];
	assign pp0[11] = A[0] & B[11];
	assign pp0[12] = A[0] & B[12];
	assign pp0[13] = A[0] & B[13];
	assign pp0[14] = A[0] & B[14];
	assign pp0[15] = A[0] & B[15];
	assign pp0[16] = A[0] & B[16];
	assign pp0[17] = A[0] & B[17];
	assign pp0[18] = A[0] & B[18];
	assign pp0[19] = A[0] & B[19];
	assign pp0[20] = A[0] & B[20];
	assign pp0[21] = A[0] & B[21];
	assign pp0[22] = A[0] & B[22];
	assign pp0[23] = A[0] & B[23];
	assign pp0[24] = A[0] & B[24];
	assign pp0[25] = A[0] & B[25];
	assign pp0[26] = A[0] & B[26];
	assign pp0[27] = A[0] & B[27];
	assign pp0[28] = A[0] & B[28];
	assign pp0[29] = A[0] & B[29];
	assign pp0[30] = A[0] & B[30];
	assign pp0[31] = A[0] & B[31];
	assign pp1[0] = A[1] & B[0];
	assign pp1[1] = A[1] & B[1];
	assign pp1[2] = A[1] & B[2];
	assign pp1[3] = A[1] & B[3];
	assign pp1[4] = A[1] & B[4];
	assign pp1[5] = A[1] & B[5];
	assign pp1[6] = A[1] & B[6];
	assign pp1[7] = A[1] & B[7];
	assign pp1[8] = A[1] & B[8];
	assign pp1[9] = A[1] & B[9];
	assign pp1[10] = A[1] & B[10];
	assign pp1[11] = A[1] & B[11];
	assign pp1[12] = A[1] & B[12];
	assign pp1[13] = A[1] & B[13];
	assign pp1[14] = A[1] & B[14];
	assign pp1[15] = A[1] & B[15];
	assign pp1[16] = A[1] & B[16];
	assign pp1[17] = A[1] & B[17];
	assign pp1[18] = A[1] & B[18];
	assign pp1[19] = A[1] & B[19];
	assign pp1[20] = A[1] & B[20];
	assign pp1[21] = A[1] & B["
N/A,N/A,-1,34.0,1,"//Please finish designing the 32 bit multiplier module (multiplier_32) below.
//There are two 32 bit inputs (A and B) and a 64 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_32(output [63:0] product, input [31:0] A, B);
	
	wire [31:0] pp0, pp1, pp2, pp3, pp4, pp5, pp6, pp7, pp8, pp9, pp10, pp11, pp12, pp13, pp14, pp15;
	
	assign pp0 = A[0]? B: 32'b00000000000000000000000000000000;
	assign pp1 = A[1]? B: 32'b00000000000000000000000000000000;
	assign pp2 = A[2]? B: 32'b00000000000000000000000000000000;
	assign pp3 = A[3]? B: 32'b00000000000000000000000000000000;
	assign pp4 = A[4]? B: 32'b00000000000000000000000000000000;
	assign pp5 = A[5]? B: 32'b00000000000000000000000000000000;
	assign pp6 = A[6]? B: 32'b00000000000000000000000000000000;
	assign pp7 = A[7]? B: 32'b00000000000000000000000000000000;
	assign pp8 = A[8]? B: 32'b00000000000000000000000000000000;
	assign pp9 = A[9]? B: 32'b00000000000000000000000000000000;
	assign pp10 = A[10]? B: 32'b00000000000000000000000000000000;
	assign pp11 = A[11]? B: 32'b00000000000000000000000000000000;
	assign pp12 = A[12]? B: 32'b00000000000000000000000000000000;
	assign pp13 = A[13]? B: 32'b00000000000000000000000000000000;
	assign pp14 = A[14]? B: 32'b00000000000000000000000000000000;
	assign pp15 = A[15]? B: 32'b00000000000000000000000000000000;
	
	assign product[0] = pp0[0];
	
	/* First Stage */
	half_adder ha01(s1, c1, pp0[1], pp1[0]);
	full_adder fa01(s2, c2, pp0[2], pp1[1], pp2[0]);
	full_adder fa02(s3, c3, pp0[3], pp1[2], pp2[1]);
	full_adder fa03(s4, c4, pp0[4], pp1[3], pp2[2]);
	full_adder fa04(s5, c5, pp0[5], pp1[4], pp2[3]);
	full_adder fa05(s6, c6, pp0[6], pp1[5], pp2[4]);
	full_adder fa06(s7, c7, pp0[7], pp1[6], pp2[5]);
	full_adder fa07(s8, c8, pp0[8], pp1[7], pp2[6]);
	full_adder fa08(s9, c9, pp0[9], pp1[8], pp2[7]);
	full_adder fa09(s10, c10, pp0[10], pp1[9], pp2[8]);
	full_adder fa10(s11, c11, pp0[11], pp1[10], pp2[9]);
	full_adder fa11(s12, c12, pp0[12], pp1[11], pp2[10]);
	full_adder fa12(s13, c13, pp0[13], pp1[12], pp2[11]);
	full_adder fa13(s14, c14, pp0[14], pp1[13], pp2[12]);
	full_adder fa14(s15, c15, pp0[15], pp1[14], pp2[13]);
	half_adder ha02(s16, c16, pp1[15], pp2[14]);
	
	/* Second Stage */
	half_adder ha03(s201, c201, s1, pp3[0]);
	full_adder fa04(s202, c202, s2, pp3[1], c1);
	full_adder fa05(s203, c203, s3, pp3[2], c2);
	full_adder fa06(s204, c204, s4, pp3[3], c3);
	full_adder fa07(s205, c205, s5, pp3[4], c4);
	full_adder fa08(s206, c206, s6, pp3[5], c5);
	full_adder fa09(s207,"
7608.93,2659.47,0.1,35.0,1,"//Please finish designing the 32 bit multiplier module (multiplier_32) below.
//There are two 32 bit inputs (A and B) and a 64 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_32(output [63:0] product, input [31:0] A, B);
    assign product = A * B;
endmodule"
7608.93,2659.47,0.1,36.0,1,"//Please finish designing the 32 bit multiplier module (multiplier_32) below.
//There are two 32 bit inputs (A and B) and a 64 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_32(output [63:0] product, input [31:0] A, B);
    assign product = A * B;
endmodule"
7608.93,2659.47,0.1,37.0,1,"//Please finish designing the 32 bit multiplier module (multiplier_32) below.
//There are two 32 bit inputs (A and B) and a 64 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_32(output [63:0] product, input [31:0] A, B);
    assign product = A * B;
endmodule"
7608.93,2659.47,0.1,38.0,1,"//Please finish designing the 32 bit multiplier module (multiplier_32) below.
//There are two 32 bit inputs (A and B) and a 64 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_32(output [63:0] product, input [31:0] A, B);
    assign product = A * B;
endmodule"
7608.93,2659.47,0.1,39.0,1,"//Please finish designing the 32 bit multiplier module (multiplier_32) below.
//There are two 32 bit inputs (A and B) and a 64 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_32(output [63:0] product, input [31:0] A, B);
    assign product = A * B;
endmodule"
7608.93,2659.47,0.1,40.0,1,"//Please finish designing the 32 bit multiplier module (multiplier_32) below.
//There are two 32 bit inputs (A and B) and a 64 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_32(output [63:0] product, input [31:0] A, B);
    assign product = A * B;
endmodule"
N/A,N/A,-1,41.0,1,"//Please finish designing the 32 bit multiplier module (multiplier_32) below.
//There are two 32 bit inputs (A and B) and a 64 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_32(output [63:0] product, input [31:0] A, B);
	/*
		Group Members: Kevin Ingram and Warren Seto
		Lab Name: Combinational Logic
		Design Name: multiplier_32bit.v
		Design Description: Verilog Module for a 32 bit multiplier
	*/
	
	wire [31:0] A_1, A_2, A_3, A_4, A_5, A_6, A_7, A_8, A_9, A_10, A_11, A_12, A_13, A_14, A_15, A_16, A_17, A_18, A_19, A_20, A_21, A_22, A_23, A_24, A_25, A_26, A_27, A_28, A_29, A_30, A_31;
	wire [31:0] B_1, B_2, B_3, B_4, B_5, B_6, B_7, B_8, B_9, B_10, B_11, B_12, B_13, B_14, B_15, B_16, B_17, B_18, B_19, B_20, B_21, B_22, B_23, B_24, B_25, B_26, B_27, B_28, B_29, B_30, B_31;
	wire [63:0] product_1, product_2, product_3, product_4, product_5, product_6, product_7, product_8, product_9, product_10, product_11, product_12, product_13, product_14, product_15, product_16, product_17, product_18, product_19, product_20, product_21, product_22, product_23, product_24, product_25, product_26, product_27, product_28, product_29, product_30, product_31;
	
	assign A_1 = A << 1;
	assign B_1 = B << 1;
	
	assign product_1 = A_1 * B_1;
	
	assign A_2 = A_1[31:0];
	assign B_2 = B_1[31:0];
	assign product_2 = A_2 * B_2;
	
	assign A_3 = A_2[31:0];
	assign B_3 = B_2[31:0];
	assign product_3 = A_3 * B_3;
	
	assign A_4 = A_3[31:0];
	assign B_4 = B_3[31:0];
	assign product_4 = A_4 * B_4;
	
	assign A_5 = A_4[31:0];
	assign B_5 = B_4[31:0];
	assign product_5 = A_5 * B_5;
	
	assign A_6 = A_5[31:0];
	assign B_6 = B_5[31:0];
	assign product_6 = A_6 * B_6;
	
	assign A_7 = A_6[31:0];
	assign B_7 = B_6[31:0];
	assign product_7 = A_7 * B_7;
	
	assign A_8 = A_7[31:0];
	assign B_8 = B_7[31:0];
	assign product_8 = A_8 * B_8;
	
	assign A_9 = A_8[31:0];
	assign B_9 = B_8[31:0];
	assign product_9 = A_9 * B_9;
	
	assign A_10 = A_9[31:0];
	assign B_10 = B_9[31:0];
	assign product_10 = A_10 * B_10;
	
	assign A_11 = A_10[31:0];
	assign B_11 = B_10[31:0];
	assign product_11 = A_11 * B_11;
	
	assign A_12 = A_11[31:0];
	assign B_12 = B_11[31"
N/A,N/A,-1,42.0,1,"//Please finish designing the 32 bit multiplier module (multiplier_32) below.
//There are two 32 bit inputs (A and B) and a 64 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_32(output [63:0] product, input [31:0] A, B);
	assign pp0 = A[0]? B: 32'b00000000000000000000000000000000;
	assign pp1 = A[1]? B: 32'b00000000000000000000000000000000;
	assign pp2 = A[2]? B: 32'b00000000000000000000000000000000;
	assign pp3 = A[3]? B: 32'b00000000000000000000000000000000;
	assign pp4 = A[4]? B: 32'b00000000000000000000000000000000;
	assign pp5 = A[5]? B: 32'b00000000000000000000000000000000;
	assign pp6 = A[6]? B: 32'b00000000000000000000000000000000;
	assign pp7 = A[7]? B: 32'b00000000000000000000000000000000;
	assign pp8 = A[8]? B: 32'b00000000000000000000000000000000;
	assign pp9 = A[9]? B: 32'b00000000000000000000000000000000;
	assign pp10 = A[10]? B: 32'b00000000000000000000000000000000;
	assign pp11 = A[11]? B: 32'b00000000000000000000000000000000;
	assign pp12 = A[12]? B: 32'b00000000000000000000000000000000;
	assign pp13 = A[13]? B: 32'b00000000000000000000000000000000;
	assign pp14 = A[14]? B: 32'b00000000000000000000000000000000;
	assign pp15 = A[15]? B: 32'b00000000000000000000000000000000;
	assign pp16 = A[16]? B: 32'b00000000000000000000000000000000;
	assign pp17 = A[17]? B: 32'b00000000000000000000000000000000;
	assign pp18 = A[18]? B: 32'b00000000000000000000000000000000;
	assign pp19 = A[19]? B: 32'b00000000000000000000000000000000;
	assign pp20 = A[20]? B: 32'b00000000000000000000000000000000;
	assign pp21 = A[21]? B: 32'b00000000000000000000000000000000;
	assign pp22 = A[22]? B: 32'b00000000000000000000000000000000;
	assign pp23 = A[23]? B: 32'b00000000000000000000000000000000;
	assign pp24 = A[24]? B: 32'b00000000000000000000000000000000;
	assign pp25 = A[25]? B: 32'b00000000000000000000000000000000;
	assign pp26 = A[26]? B: 32'b00000000000000000000000000000000;
	assign pp27 = A[27]? B: 32'b00000000000000000000000000000000;
	assign pp28 = A[28]? B: 32'b00000000000000000000000000000000;
	assign pp29 = A[29]? B: 32'b00000000000000000000000000000000;
	assign pp30 = A[30]? B: 32'b00000000000000000000000000000000;
	assign pp31 = A[31]? B: 32'b00000000000000000000000000000000;
	assign product[0] = pp0[0];
	assign in1_1 = {pp0[1],pp0[0],pp0[0],pp0[0]};
	assign in1_2 = {pp1[0],pp1[0],pp1[0],pp1[0]};
	CLA4 CLA01(s1, c1, in1_1, in1_2);
	assign in2_1 = {pp2[1],pp2[0],pp2[0],pp2[0]};
	assign in2_2 = {pp3[0],pp3[0],pp3[0],pp3[0]};
	CLA4 CLA02(s2, c2, in2_1, in2_2);
	assign in3_1 = {s1[3],s1[2],s1[1],s1[0]};
	assign in3_2 = {s2[2],s2[1],s2[0],s2[3]};
	CLA4 CLA03(s3, c3, in3_1, in3_2);
	assign in4_1 = {pp4[1],pp4[0],pp4[0],pp4[0]};
	assign in4_2 = {pp5[0],pp5[0],pp5[0],pp5[0]};
	CLA4 CLA04(s4, c4, in4_1, in4_2);
	assign in5_1 = {s1[3],s1[2],s1[1],s1[0]"
N/A,N/A,-1,43.0,1,"//Please finish designing the 32 bit multiplier module (multiplier_32) below.
//There are two 32 bit inputs (A and B) and a 64 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_32(output [63:0] product, input [31:0] A, B);
	assign pp0[0] = A[0] & B[0];
	assign pp0[1] = A[0] & B[1];
	assign pp0[2] = A[0] & B[2];
	assign pp0[3] = A[0] & B[3];
	assign pp0[4] = A[0] & B[4];
	assign pp0[5] = A[0] & B[5];
	assign pp0[6] = A[0] & B[6];
	assign pp0[7] = A[0] & B[7];
	assign pp0[8] = A[0] & B[8];
	assign pp0[9] = A[0] & B[9];
	assign pp0[10] = A[0] & B[10];
	assign pp0[11] = A[0] & B[11];
	assign pp0[12] = A[0] & B[12];
	assign pp0[13] = A[0] & B[13];
	assign pp0[14] = A[0] & B[14];
	assign pp0[15] = A[0] & B[15];
	assign pp0[16] = A[0] & B[16];
	assign pp0[17] = A[0] & B[17];
	assign pp0[18] = A[0] & B[18];
	assign pp0[19] = A[0] & B[19];
	assign pp0[20] = A[0] & B[20];
	assign pp0[21] = A[0] & B[21];
	assign pp0[22] = A[0] & B[22];
	assign pp0[23] = A[0] & B[23];
	assign pp0[24] = A[0] & B[24];
	assign pp0[25] = A[0] & B[25];
	assign pp0[26] = A[0] & B[26];
	assign pp0[27] = A[0] & B[27];
	assign pp0[28] = A[0] & B[28];
	assign pp0[29] = A[0] & B[29];
	assign pp0[30] = A[0] & B[30];
	assign pp0[31] = A[0] & B[31];
	assign pp1[0] = A[1] & B[0];
	assign pp1[1] = A[1] & B[1];
	assign pp1[2] = A[1] & B[2];
	assign pp1[3] = A[1] & B[3];
	assign pp1[4] = A[1] & B[4];
	assign pp1[5] = A[1] & B[5];
	assign pp1[6] = A[1] & B[6];
	assign pp1[7] = A[1] & B[7];
	assign pp1[8] = A[1] & B[8];
	assign pp1[9] = A[1] & B[9];
	assign pp1[10] = A[1] & B[10];
	assign pp1[11] = A[1] & B[11];
	assign pp1[12] = A[1] & B[12];
	assign pp1[13] = A[1] & B[13];
	assign pp1[14] = A[1] & B[14];
	assign pp1[15] = A[1] & B[15];
	assign pp1[16] = A[1] & B[16];
	assign pp1[17] = A[1] & B[17];
	assign pp1[18] = A[1] & B[18];
	assign pp1[19] = A[1] & B[19];
	assign pp1[20] = A[1] & B[20];
	assign pp1[21] = A[1] & B["
N/A,N/A,-1,44.0,1,"//Please finish designing the 32 bit multiplier module (multiplier_32) below.
//There are two 32 bit inputs (A and B) and a 64 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_32(output [63:0] product, input [31:0] A, B);

	wire [31:0] pp0, pp1, pp2, pp3, pp4, pp5, pp6, pp7, pp8, pp9, pp10, pp11, pp12, pp13, pp14, pp15;

	assign pp0 = A[0]? B: 32'b00000000000000000000000000000000;
	assign pp1 = A[1]? B: 32'b00000000000000000000000000000000;
	assign pp2 = A[2]? B: 32'b00000000000000000000000000000000;
	assign pp3 = A[3]? B: 32'b00000000000000000000000000000000;
	assign pp4 = A[4]? B: 32'b00000000000000000000000000000000;
	assign pp5 = A[5]? B: 32'b00000000000000000000000000000000;
	assign pp6 = A[6]? B: 32'b00000000000000000000000000000000;
	assign pp7 = A[7]? B: 32'b00000000000000000000000000000000;
	assign pp8 = A[8]? B: 32'b00000000000000000000000000000000;
	assign pp9 = A[9]? B: 32'b00000000000000000000000000000000;
	assign pp10 = A[10]? B: 32'b00000000000000000000000000000000;
	assign pp11 = A[11]? B: 32'b00000000000000000000000000000000;
	assign pp12 = A[12]? B: 32'b00000000000000000000000000000000;
	assign pp13 = A[13]? B: 32'b00000000000000000000000000000000;
	assign pp14 = A[14]? B: 32'b00000000000000000000000000000000;
	assign pp15 = A[15]? B: 32'b00000000000000000000000000000000;

	assign product[0] = pp0[0];

	/* 1st CLA */
	wire [31:0] G1, P1, C1;
	assign G1[0]  = pp0[1]  & pp1[0];
	assign G1[1]  = pp0[2]  & pp1[1];
	assign G1[2]  = pp0[3]  & pp1[2];
	assign G1[3]  = pp0[4]  & pp1[3];
	assign G1[4]  = pp0[5]  & pp1[4];
	assign G1[5]  = pp0[6]  & pp1[5];
	assign G1[6]  = pp0[7]  & pp1[6];
	assign G1[7]  = pp0[8]  & pp1[7];
	assign G1[8]  = pp0[9]  & pp1[8];
	assign G1[9]  = pp0[10] & pp1[9];
	assign G1[10] = pp0[11] & pp1[10];
	assign G1[11] = pp0[12] & pp1[11];
	assign G1[12] = pp0[13] & pp1[12];
	assign G1[13] = pp0[14] & pp1[13];
	assign G1[14] = pp0[15] & pp1[14];
	assign G1[15] = 0       & pp1[15];
	assign P1[0]  = pp0[1]  ^ pp1[0];
	assign P1[1]  = pp0[2]  ^ pp1[1];
	assign P1[2]  = pp0[3]  ^ pp1[2];
	assign P1[3]  = pp0[4]  ^ pp1[3];
	assign P1[4]  = pp0[5]  ^ pp1[4];
	assign P1[5]  = pp0[6]  ^ pp1[5];
	assign P1[6]  = pp0[7]  ^ pp1[6];
	assign P1[7]  = pp0[8]  ^ pp1[7];
	assign P1[8]  = pp0[9]  ^ pp1[8];
	assign P1[9]  = pp0[10] ^ pp1[9];
	assign P1[10] = pp0[11] ^ pp1[10];
	assign P1[11"
N/A,N/A,-1,45.0,1,"//Please finish designing the 32 bit multiplier module (multiplier_32) below.
//There are two 32 bit inputs (A and B) and a 64 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_32(output [63:0] product, input [31:0] A, B);
    /* Please fill in the implementation here... */
    genvar i;
    generate
        for (i = 0; i < 32; i = i + 1) begin: mul_digit
            assign product[i] = mul_digit[i].A * mul_digit[i].B;
        end
    endgenerate
    assign product[63:32] = product[31:0];
endmodule"
N/A,N/A,-1,46.0,1,"//Please finish designing the 32 bit multiplier module (multiplier_32) below.
//There are two 32 bit inputs (A and B) and a 64 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_32(output [63:0] product, input [31:0] A, B);
	assign pp0[0] = A[0] & B[0];
	assign pp0[1] = A[0] & B[1];
	assign pp0[2] = A[0] & B[2];
	assign pp0[3] = A[0] & B[3];
	assign pp0[4] = A[0] & B[4];
	assign pp0[5] = A[0] & B[5];
	assign pp0[6] = A[0] & B[6];
	assign pp0[7] = A[0] & B[7];
	assign pp0[8] = A[0] & B[8];
	assign pp0[9] = A[0] & B[9];
	assign pp0[10] = A[0] & B[10];
	assign pp0[11] = A[0] & B[11];
	assign pp0[12] = A[0] & B[12];
	assign pp0[13] = A[0] & B[13];
	assign pp0[14] = A[0] & B[14];
	assign pp0[15] = A[0] & B[15];
	assign pp0[16] = A[0] & B[16];
	assign pp0[17] = A[0] & B[17];
	assign pp0[18] = A[0] & B[18];
	assign pp0[19] = A[0] & B[19];
	assign pp0[20] = A[0] & B[20];
	assign pp0[21] = A[0] & B[21];
	assign pp0[22] = A[0] & B[22];
	assign pp0[23] = A[0] & B[23];
	assign pp0[24] = A[0] & B[24];
	assign pp0[25] = A[0] & B[25];
	assign pp0[26] = A[0] & B[26];
	assign pp0[27] = A[0] & B[27];
	assign pp0[28] = A[0] & B[28];
	assign pp0[29] = A[0] & B[29];
	assign pp0[30] = A[0] & B[30];
	assign pp0[31] = A[0] & B[31];
	assign pp1[0] = A[1] & B[0];
	assign pp1[1] = A[1] & B[1];
	assign pp1[2] = A[1] & B[2];
	assign pp1[3] = A[1] & B[3];
	assign pp1[4] = A[1] & B[4];
	assign pp1[5] = A[1] & B[5];
	assign pp1[6] = A[1] & B[6];
	assign pp1[7] = A[1] & B[7];
	assign pp1[8] = A[1] & B[8];
	assign pp1[9] = A[1] & B[9];
	assign pp1[10] = A[1] & B[10];
	assign pp1[11] = A[1] & B[11];
	assign pp1[12] = A[1] & B[12];
	assign pp1[13] = A[1] & B[13];
	assign pp1[14] = A[1] & B[14];
	assign pp1[15] = A[1] & B[15];
	assign pp1[16] = A[1] & B[16];
	assign pp1[17] = A[1] & B[17];
	assign pp1[18] = A[1] & B[18];
	assign pp1[19] = A[1] & B[19];
	assign pp1[20] = A[1] & B[20];
	assign pp1[21] = A[1] & B["
N/A,N/A,-1,47.0,1,"//Please finish designing the 32 bit multiplier module (multiplier_32) below.
//There are two 32 bit inputs (A and B) and a 64 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_32(output [63:0] product, input [31:0] A, B);
	
	wire [31:0] pp0, pp1, pp2, pp3, pp4, pp5, pp6, pp7, pp8, pp9, pp10, pp11, pp12, pp13, pp14, pp15;
	
	assign pp0 = A[0]? B: 32'b00000000000000000000000000000000;
	assign pp1 = A[1]? B: 32'b00000000000000000000000000000000;
	assign pp2 = A[2]? B: 32'b00000000000000000000000000000000;
	assign pp3 = A[3]? B: 32'b00000000000000000000000000000000;
	assign pp4 = A[4]? B: 32'b00000000000000000000000000000000;
	assign pp5 = A[5]? B: 32'b00000000000000000000000000000000;
	assign pp6 = A[6]? B: 32'b00000000000000000000000000000000;
	assign pp7 = A[7]? B: 32'b00000000000000000000000000000000;
	assign pp8 = A[8]? B: 32'b00000000000000000000000000000000;
	assign pp9 = A[9]? B: 32'b00000000000000000000000000000000;
	assign pp10 = A[10]? B: 32'b00000000000000000000000000000000;
	assign pp11 = A[11]? B: 32'b00000000000000000000000000000000;
	assign pp12 = A[12]? B: 32'b00000000000000000000000000000000;
	assign pp13 = A[13]? B: 32'b00000000000000000000000000000000;
	assign pp14 = A[14]? B: 32'b00000000000000000000000000000000;
	assign pp15 = A[15]? B: 32'b00000000000000000000000000000000;
	
	assign product[0] = pp0[0];
	
	/* First Stage */
	half_adder ha01(s1, c1, pp0[1], pp1[0]);
	full_adder fa01(s2, c2, pp0[2], pp1[1], pp2[0]);
	full_adder fa02(s3, c3, pp0[3], pp1[2], pp2[1]);
	full_adder fa03(s4, c4, pp0[4], pp1[3], pp2[2]);
	full_adder fa04(s5, c5, pp0[5], pp1[4], pp2[3]);
	full_adder fa05(s6, c6, pp0[6], pp1[5], pp2[4]);
	full_adder fa06(s7, c7, pp0[7], pp1[6], pp2[5]);
	full_adder fa07(s8, c8, pp0[8], pp1[7], pp2[6]);
	full_adder fa08(s9, c9, pp0[9], pp1[8], pp2[7]);
	full_adder fa09(s10, c10, pp0[10], pp1[9], pp2[8]);
	full_adder fa10(s11, c11, pp0[11], pp1[10], pp2[9]);
	full_adder fa11(s12, c12, pp0[12], pp1[11], pp2[10]);
	full_adder fa12(s13, c13, pp0[13], pp1[12], pp2[11]);
	full_adder fa13(s14, c14, pp0[14], pp1[13], pp2[12]);
	full_adder fa14(s15, c15, pp0[15], pp1[14], pp2[13]);
	half_adder ha02(s16, c16, pp1[15], pp2[14]);
	
	/* Second Stage */
	half_adder ha03(s201, c201, s1, pp3[0]);
	full_adder fa04(s202, c202, s2, pp3[1], c1);
	full_adder fa05(s203, c203, s3, pp3[2], c2);
	full_adder fa06(s204, c204, s4, pp3[3], c3);
	full_adder fa07(s205, c205, s5, pp3[4], c4);
	full_adder fa08(s206, c206, s6, pp3[5], c5);
	full_adder fa09(s207,"
7608.93,2659.47,0.1,48.0,1,"//Please finish designing the 32 bit multiplier module (multiplier_32) below.
//There are two 32 bit inputs (A and B) and a 64 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_32(output [63:0] product, input [31:0] A, B);
    assign product = A * B;
endmodule"
7608.93,2659.47,0.1,49.0,1,"//Please finish designing the 32 bit multiplier module (multiplier_32) below.
//There are two 32 bit inputs (A and B) and a 64 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_32(output [63:0] product, input [31:0] A, B);
    assign product = A * B;
endmodule"
7608.93,2659.47,0.1,50.0,1,"//Please finish designing the 32 bit multiplier module (multiplier_32) below.
//There are two 32 bit inputs (A and B) and a 64 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_32(output [63:0] product, input [31:0] A, B);
    assign product = A * B;
endmodule"
7608.93,2659.47,0.1,51.0,1,"//Please finish designing the 32 bit multiplier module (multiplier_32) below.
//There are two 32 bit inputs (A and B) and a 64 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_32(output [63:0] product, input [31:0] A, B);
    assign product = A * B;
endmodule"
7608.93,2659.47,0.1,52.0,1,"//Please finish designing the 32 bit multiplier module (multiplier_32) below.
//There are two 32 bit inputs (A and B) and a 64 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_32(output [63:0] product, input [31:0] A, B);
    assign product = A * B;
endmodule"
7608.93,2659.47,0.1,53.0,1,"//Please finish designing the 32 bit multiplier module (multiplier_32) below.
//There are two 32 bit inputs (A and B) and a 64 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_32(output [63:0] product, input [31:0] A, B);
    assign product = A * B;
endmodule"
N/A,N/A,-1,54.0,1,"//Please finish designing the 32 bit multiplier module (multiplier_32) below.
//There are two 32 bit inputs (A and B) and a 64 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_32(output [63:0] product, input [31:0] A, B);
	/*
		Group Members: Kevin Ingram and Warren Seto
		Lab Name: Combinational Logic
		Design Name: multiplier_32bit.v
		Design Description: Verilog Module for a 32 bit multiplier
	*/
	
	wire [31:0] A_1, A_2, A_3, A_4, A_5, A_6, A_7, A_8, A_9, A_10, A_11, A_12, A_13, A_14, A_15, A_16, A_17, A_18, A_19, A_20, A_21, A_22, A_23, A_24, A_25, A_26, A_27, A_28, A_29, A_30, A_31;
	wire [31:0] B_1, B_2, B_3, B_4, B_5, B_6, B_7, B_8, B_9, B_10, B_11, B_12, B_13, B_14, B_15, B_16, B_17, B_18, B_19, B_20, B_21, B_22, B_23, B_24, B_25, B_26, B_27, B_28, B_29, B_30, B_31;
	wire [63:0] product_1, product_2, product_3, product_4, product_5, product_6, product_7, product_8, product_9, product_10, product_11, product_12, product_13, product_14, product_15, product_16, product_17, product_18, product_19, product_20, product_21, product_22, product_23, product_24, product_25, product_26, product_27, product_28, product_29, product_30, product_31;
	
	assign A_1 = A << 1;
	assign B_1 = B << 1;
	
	assign product_1 = A_1 * B_1;
	
	assign A_2 = A_1[31:0];
	assign B_2 = B_1[31:0];
	assign product_2 = A_2 * B_2;
	
	assign A_3 = A_2[31:0];
	assign B_3 = B_2[31:0];
	assign product_3 = A_3 * B_3;
	
	assign A_4 = A_3[31:0];
	assign B_4 = B_3[31:0];
	assign product_4 = A_4 * B_4;
	
	assign A_5 = A_4[31:0];
	assign B_5 = B_4[31:0];
	assign product_5 = A_5 * B_5;
	
	assign A_6 = A_5[31:0];
	assign B_6 = B_5[31:0];
	assign product_6 = A_6 * B_6;
	
	assign A_7 = A_6[31:0];
	assign B_7 = B_6[31:0];
	assign product_7 = A_7 * B_7;
	
	assign A_8 = A_7[31:0];
	assign B_8 = B_7[31:0];
	assign product_8 = A_8 * B_8;
	
	assign A_9 = A_8[31:0];
	assign B_9 = B_8[31:0];
	assign product_9 = A_9 * B_9;
	
	assign A_10 = A_9[31:0];
	assign B_10 = B_9[31:0];
	assign product_10 = A_10 * B_10;
	
	assign A_11 = A_10[31:0];
	assign B_11 = B_10[31:0];
	assign product_11 = A_11 * B_11;
	
	assign A_12 = A_11[31:0];
	assign B_12 = B_11[31"
N/A,N/A,-1,55.0,1,"//Please finish designing the 32 bit multiplier module (multiplier_32) below.
//There are two 32 bit inputs (A and B) and a 64 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_32(output [63:0] product, input [31:0] A, B);
	assign pp0 = A[0]? B: 32'b00000000000000000000000000000000;
	assign pp1 = A[1]? B: 32'b00000000000000000000000000000000;
	assign pp2 = A[2]? B: 32'b00000000000000000000000000000000;
	assign pp3 = A[3]? B: 32'b00000000000000000000000000000000;
	assign pp4 = A[4]? B: 32'b00000000000000000000000000000000;
	assign pp5 = A[5]? B: 32'b00000000000000000000000000000000;
	assign pp6 = A[6]? B: 32'b00000000000000000000000000000000;
	assign pp7 = A[7]? B: 32'b00000000000000000000000000000000;
	assign pp8 = A[8]? B: 32'b00000000000000000000000000000000;
	assign pp9 = A[9]? B: 32'b00000000000000000000000000000000;
	assign pp10 = A[10]? B: 32'b00000000000000000000000000000000;
	assign pp11 = A[11]? B: 32'b00000000000000000000000000000000;
	assign pp12 = A[12]? B: 32'b00000000000000000000000000000000;
	assign pp13 = A[13]? B: 32'b00000000000000000000000000000000;
	assign pp14 = A[14]? B: 32'b00000000000000000000000000000000;
	assign pp15 = A[15]? B: 32'b00000000000000000000000000000000;
	assign pp16 = A[16]? B: 32'b00000000000000000000000000000000;
	assign pp17 = A[17]? B: 32'b00000000000000000000000000000000;
	assign pp18 = A[18]? B: 32'b00000000000000000000000000000000;
	assign pp19 = A[19]? B: 32'b00000000000000000000000000000000;
	assign pp20 = A[20]? B: 32'b00000000000000000000000000000000;
	assign pp21 = A[21]? B: 32'b00000000000000000000000000000000;
	assign pp22 = A[22]? B: 32'b00000000000000000000000000000000;
	assign pp23 = A[23]? B: 32'b00000000000000000000000000000000;
	assign pp24 = A[24]? B: 32'b00000000000000000000000000000000;
	assign pp25 = A[25]? B: 32'b00000000000000000000000000000000;
	assign pp26 = A[26]? B: 32'b00000000000000000000000000000000;
	assign pp27 = A[27]? B: 32'b00000000000000000000000000000000;
	assign pp28 = A[28]? B: 32'b00000000000000000000000000000000;
	assign pp29 = A[29]? B: 32'b00000000000000000000000000000000;
	assign pp30 = A[30]? B: 32'b00000000000000000000000000000000;
	assign pp31 = A[31]? B: 32'b00000000000000000000000000000000;
	assign product[0] = pp0[0];
	assign in1_1 = {pp0[1],pp0[0],pp0[0],pp0[0]};
	assign in1_2 = {pp1[0],pp1[0],pp1[0],pp1[0]};
	CLA4 CLA01(s1, c1, in1_1, in1_2);
	assign in2_1 = {pp2[1],pp2[0],pp2[0],pp2[0]};
	assign in2_2 = {pp3[0],pp3[0],pp3[0],pp3[0]};
	CLA4 CLA02(s2, c2, in2_1, in2_2);
	assign in3_1 = {s1[3],s1[2],s1[1],s1[0]};
	assign in3_2 = {s2[2],s2[1],s2[0],s2[3]};
	CLA4 CLA03(s3, c3, in3_1, in3_2);
	assign in4_1 = {pp4[1],pp4[0],pp4[0],pp4[0]};
	assign in4_2 = {pp5[0],pp5[0],pp5[0],pp5[0]};
	CLA4 CLA04(s4, c4, in4_1, in4_2);
	assign in5_1 = {s1[3],s1[2],s1[1],s1[0]"
N/A,N/A,-1,56.0,1,"//Please finish designing the 32 bit multiplier module (multiplier_32) below.
//There are two 32 bit inputs (A and B) and a 64 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_32(output [63:0] product, input [31:0] A, B);
	assign pp0[0] = A[0] & B[0];
	assign pp0[1] = A[0] & B[1];
	assign pp0[2] = A[0] & B[2];
	assign pp0[3] = A[0] & B[3];
	assign pp0[4] = A[0] & B[4];
	assign pp0[5] = A[0] & B[5];
	assign pp0[6] = A[0] & B[6];
	assign pp0[7] = A[0] & B[7];
	assign pp0[8] = A[0] & B[8];
	assign pp0[9] = A[0] & B[9];
	assign pp0[10] = A[0] & B[10];
	assign pp0[11] = A[0] & B[11];
	assign pp0[12] = A[0] & B[12];
	assign pp0[13] = A[0] & B[13];
	assign pp0[14] = A[0] & B[14];
	assign pp0[15] = A[0] & B[15];
	assign pp0[16] = A[0] & B[16];
	assign pp0[17] = A[0] & B[17];
	assign pp0[18] = A[0] & B[18];
	assign pp0[19] = A[0] & B[19];
	assign pp0[20] = A[0] & B[20];
	assign pp0[21] = A[0] & B[21];
	assign pp0[22] = A[0] & B[22];
	assign pp0[23] = A[0] & B[23];
	assign pp0[24] = A[0] & B[24];
	assign pp0[25] = A[0] & B[25];
	assign pp0[26] = A[0] & B[26];
	assign pp0[27] = A[0] & B[27];
	assign pp0[28] = A[0] & B[28];
	assign pp0[29] = A[0] & B[29];
	assign pp0[30] = A[0] & B[30];
	assign pp0[31] = A[0] & B[31];
	assign pp1[0] = A[1] & B[0];
	assign pp1[1] = A[1] & B[1];
	assign pp1[2] = A[1] & B[2];
	assign pp1[3] = A[1] & B[3];
	assign pp1[4] = A[1] & B[4];
	assign pp1[5] = A[1] & B[5];
	assign pp1[6] = A[1] & B[6];
	assign pp1[7] = A[1] & B[7];
	assign pp1[8] = A[1] & B[8];
	assign pp1[9] = A[1] & B[9];
	assign pp1[10] = A[1] & B[10];
	assign pp1[11] = A[1] & B[11];
	assign pp1[12] = A[1] & B[12];
	assign pp1[13] = A[1] & B[13];
	assign pp1[14] = A[1] & B[14];
	assign pp1[15] = A[1] & B[15];
	assign pp1[16] = A[1] & B[16];
	assign pp1[17] = A[1] & B[17];
	assign pp1[18] = A[1] & B[18];
	assign pp1[19] = A[1] & B[19];
	assign pp1[20] = A[1] & B[20];
	assign pp1[21] = A[1] & B["
N/A,N/A,-1,57.0,1,"//Please finish designing the 32 bit multiplier module (multiplier_32) below.
//There are two 32 bit inputs (A and B) and a 64 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_32(output [63:0] product, input [31:0] A, B);

	wire [31:0] pp0, pp1, pp2, pp3, pp4, pp5, pp6, pp7, pp8, pp9, pp10, pp11, pp12, pp13, pp14, pp15;

	assign pp0 = A[0]? B: 32'b00000000000000000000000000000000;
	assign pp1 = A[1]? B: 32'b00000000000000000000000000000000;
	assign pp2 = A[2]? B: 32'b00000000000000000000000000000000;
	assign pp3 = A[3]? B: 32'b00000000000000000000000000000000;
	assign pp4 = A[4]? B: 32'b00000000000000000000000000000000;
	assign pp5 = A[5]? B: 32'b00000000000000000000000000000000;
	assign pp6 = A[6]? B: 32'b00000000000000000000000000000000;
	assign pp7 = A[7]? B: 32'b00000000000000000000000000000000;
	assign pp8 = A[8]? B: 32'b00000000000000000000000000000000;
	assign pp9 = A[9]? B: 32'b00000000000000000000000000000000;
	assign pp10 = A[10]? B: 32'b00000000000000000000000000000000;
	assign pp11 = A[11]? B: 32'b00000000000000000000000000000000;
	assign pp12 = A[12]? B: 32'b00000000000000000000000000000000;
	assign pp13 = A[13]? B: 32'b00000000000000000000000000000000;
	assign pp14 = A[14]? B: 32'b00000000000000000000000000000000;
	assign pp15 = A[15]? B: 32'b00000000000000000000000000000000;

	assign product[0] = pp0[0];

	/* 1st CLA */
	wire [31:0] G1, P1, C1;
	assign G1[0]  = pp0[1]  & pp1[0];
	assign G1[1]  = pp0[2]  & pp1[1];
	assign G1[2]  = pp0[3]  & pp1[2];
	assign G1[3]  = pp0[4]  & pp1[3];
	assign G1[4]  = pp0[5]  & pp1[4];
	assign G1[5]  = pp0[6]  & pp1[5];
	assign G1[6]  = pp0[7]  & pp1[6];
	assign G1[7]  = pp0[8]  & pp1[7];
	assign G1[8]  = pp0[9]  & pp1[8];
	assign G1[9]  = pp0[10] & pp1[9];
	assign G1[10] = pp0[11] & pp1[10];
	assign G1[11] = pp0[12] & pp1[11];
	assign G1[12] = pp0[13] & pp1[12];
	assign G1[13] = pp0[14] & pp1[13];
	assign G1[14] = pp0[15] & pp1[14];
	assign G1[15] = 0       & pp1[15];
	assign P1[0]  = pp0[1]  ^ pp1[0];
	assign P1[1]  = pp0[2]  ^ pp1[1];
	assign P1[2]  = pp0[3]  ^ pp1[2];
	assign P1[3]  = pp0[4]  ^ pp1[3];
	assign P1[4]  = pp0[5]  ^ pp1[4];
	assign P1[5]  = pp0[6]  ^ pp1[5];
	assign P1[6]  = pp0[7]  ^ pp1[6];
	assign P1[7]  = pp0[8]  ^ pp1[7];
	assign P1[8]  = pp0[9]  ^ pp1[8];
	assign P1[9]  = pp0[10] ^ pp1[9];
	assign P1[10] = pp0[11] ^ pp1[10];
	assign P1[11"
N/A,N/A,-1,58.0,1,"//Please finish designing the 32 bit multiplier module (multiplier_32) below.
//There are two 32 bit inputs (A and B) and a 64 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_32(output [63:0] product, input [31:0] A, B);
    /* Please fill in the implementation here... */
    assign pp0 = A[0]? B: 32'b00000000000000000000000000000000;
    assign pp1 = A[1]? B: 32'b00000000000000000000000000000000;
    assign pp2 = A[2]? B: 32'b00000000000000000000000000000000;
    assign pp3 = A[3]? B: 32'b00000000000000000000000000000000;
    assign pp4 = A[4]? B: 32'b00000000000000000000000000000000;
    assign pp5 = A[5]? B: 32'b00000000000000000000000000000000;
    assign pp6 = A[6]? B: 32'b00000000000000000000000000000000;
    assign pp7 = A[7]? B: 32'b00000000000000000000000000000000;
    assign pp8 = A[8]? B: 32'b00000000000000000000000000000000;
    assign pp9 = A[9]? B: 32'b00000000000000000000000000000000;
    assign pp10 = A[10]? B: 32'b00000000000000000000000000000000;
    assign pp11 = A[11]? B: 32'b00000000000000000000000000000000;
    assign pp12 = A[12]? B: 32'b00000000000000000000000000000000;
    assign pp13 = A[13]? B: 32'b00000000000000000000000000000000;
    assign pp14 = A[14]? B: 32'b00000000000000000000000000000000;
    assign pp15 = A[15]? B: 32'b00000000000000000000000000000000;
    assign pp16 = A[16]? B: 32'b00000000000000000000000000000000;
    assign pp17 = A[17]? B: 32'b00000000000000000000000000000000;
    assign pp18 = A[18]? B: 32'b00000000000000000000000000000000;
    assign pp19 = A[19]? B: 32'b00000000000000000000000000000000;
    assign pp20 = A[20]? B: 32'b00000000000000000000000000000000;
    assign pp21 = A[21]? B: 32'b00000000000000000000000000000000;
    assign pp22 = A[22]? B: 32'b00000000000000000000000000000000;
    assign pp23 = A[23]? B: 32'b00000000000000000000000000000000;
    assign pp24 = A[24]? B: 32'b00000000000000000000000000000000;
    assign pp25 = A[25]? B: 32'b00000000000000000000000000000000;
    assign pp26 = A[26]? B: 32'b00000000000000000000000000000000;
    assign pp27 = A[27]? B: 32'b00000000000000000000000000000000;
    assign pp28 = A[28]? B: 32'b00000000000000000000000000000000;
    assign pp29 = A[29]? B: 32'b00000000000000000000000000000000;
    assign pp30 = A[30]? B: 32'b00000000000000000000000000000000;
    assign pp31 = A[31]? B: 32'b00000000000000000000000000000000;
    assign product[0] = pp0[0];
    /* 1st CLA */
    assign in1_1 = {pp0[1],pp0[2],pp0[3],pp0[4],pp0[5],pp0[6],pp0[7],pp0[8],pp0[9],pp0[10],pp0[11],pp0[12],pp0[13],pp0[14],pp0[15],pp0[16],pp0[17],pp0[18],pp0[19],pp0[20],pp0[21],pp0[22],pp0[23],pp0[24],pp0[25],pp0[26],pp0[27],pp0[28],pp0[29],pp0[30],pp0[31],1'b0};
    assign in1_2 = {pp1[0],pp1[1],pp1[2],pp1[3],pp1[4],pp1[5],pp1[6],pp1[7],pp1[8],pp1[9], pp1[10],pp1[11],pp1[12],pp1[13],pp1[14],pp1[15],pp1[16],pp1[17],pp1[18],pp1[19],pp1[20],pp1[21],pp1[22],pp1[23],pp1[24],pp1[25],pp1[26],pp1[27],pp1[28],pp1[29],pp1[30],pp1[31],1'b0};
    CLA_32 KS_"
N/A,N/A,-1,59.0,1,"//Please finish designing the 32 bit multiplier module (multiplier_32) below.
//There are two 32 bit inputs (A and B) and a 64 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_32(output [63:0] product, input [31:0] A, B);
	assign pp0[0] = A[0] & B[0];
	assign pp0[1] = A[0] & B[1];
	assign pp0[2] = A[0] & B[2];
	assign pp0[3] = A[0] & B[3];
	assign pp0[4] = A[0] & B[4];
	assign pp0[5] = A[0] & B[5];
	assign pp0[6] = A[0] & B[6];
	assign pp0[7] = A[0] & B[7];
	assign pp0[8] = A[0] & B[8];
	assign pp0[9] = A[0] & B[9];
	assign pp0[10] = A[0] & B[10];
	assign pp0[11] = A[0] & B[11];
	assign pp0[12] = A[0] & B[12];
	assign pp0[13] = A[0] & B[13];
	assign pp0[14] = A[0] & B[14];
	assign pp0[15] = A[0] & B[15];
	assign pp0[16] = A[0] & B[16];
	assign pp0[17] = A[0] & B[17];
	assign pp0[18] = A[0] & B[18];
	assign pp0[19] = A[0] & B[19];
	assign pp0[20] = A[0] & B[20];
	assign pp0[21] = A[0] & B[21];
	assign pp0[22] = A[0] & B[22];
	assign pp0[23] = A[0] & B[23];
	assign pp0[24] = A[0] & B[24];
	assign pp0[25] = A[0] & B[25];
	assign pp0[26] = A[0] & B[26];
	assign pp0[27] = A[0] & B[27];
	assign pp0[28] = A[0] & B[28];
	assign pp0[29] = A[0] & B[29];
	assign pp0[30] = A[0] & B[30];
	assign pp0[31] = A[0] & B[31];
	assign pp1[0] = A[1] & B[0];
	assign pp1[1] = A[1] & B[1];
	assign pp1[2] = A[1] & B[2];
	assign pp1[3] = A[1] & B[3];
	assign pp1[4] = A[1] & B[4];
	assign pp1[5] = A[1] & B[5];
	assign pp1[6] = A[1] & B[6];
	assign pp1[7] = A[1] & B[7];
	assign pp1[8] = A[1] & B[8];
	assign pp1[9] = A[1] & B[9];
	assign pp1[10] = A[1] & B[10];
	assign pp1[11] = A[1] & B[11];
	assign pp1[12] = A[1] & B[12];
	assign pp1[13] = A[1] & B[13];
	assign pp1[14] = A[1] & B[14];
	assign pp1[15] = A[1] & B[15];
	assign pp1[16] = A[1] & B[16];
	assign pp1[17] = A[1] & B[17];
	assign pp1[18] = A[1] & B[18];
	assign pp1[19] = A[1] & B[19];
	assign pp1[20] = A[1] & B[20];
	assign pp1[21] = A[1] & B["
N/A,N/A,-1,60.0,1,"//Please finish designing the 32 bit multiplier module (multiplier_32) below.
//There are two 32 bit inputs (A and B) and a 64 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_32(output [63:0] product, input [31:0] A, B);
	
	wire [31:0] pp0, pp1, pp2, pp3, pp4, pp5, pp6, pp7, pp8, pp9, pp10, pp11, pp12, pp13, pp14, pp15;
	
	assign pp0 = A[0]? B: 32'b00000000000000000000000000000000;
	assign pp1 = A[1]? B: 32'b00000000000000000000000000000000;
	assign pp2 = A[2]? B: 32'b00000000000000000000000000000000;
	assign pp3 = A[3]? B: 32'b00000000000000000000000000000000;
	assign pp4 = A[4]? B: 32'b00000000000000000000000000000000;
	assign pp5 = A[5]? B: 32'b00000000000000000000000000000000;
	assign pp6 = A[6]? B: 32'b00000000000000000000000000000000;
	assign pp7 = A[7]? B: 32'b00000000000000000000000000000000;
	assign pp8 = A[8]? B: 32'b00000000000000000000000000000000;
	assign pp9 = A[9]? B: 32'b00000000000000000000000000000000;
	assign pp10 = A[10]? B: 32'b00000000000000000000000000000000;
	assign pp11 = A[11]? B: 32'b00000000000000000000000000000000;
	assign pp12 = A[12]? B: 32'b00000000000000000000000000000000;
	assign pp13 = A[13]? B: 32'b00000000000000000000000000000000;
	assign pp14 = A[14]? B: 32'b00000000000000000000000000000000;
	assign pp15 = A[15]? B: 32'b00000000000000000000000000000000;
	
	assign product[0] = pp0[0];
	
	/* First Stage */
	half_adder ha01(s1, c1, pp0[1], pp1[0]);
	full_adder fa01(s2, c2, pp0[2], pp1[1], pp2[0]);
	full_adder fa02(s3, c3, pp0[3], pp1[2], pp2[1]);
	full_adder fa03(s4, c4, pp0[4], pp1[3], pp2[2]);
	full_adder fa04(s5, c5, pp0[5], pp1[4], pp2[3]);
	full_adder fa05(s6, c6, pp0[6], pp1[5], pp2[4]);
	full_adder fa06(s7, c7, pp0[7], pp1[6], pp2[5]);
	full_adder fa07(s8, c8, pp0[8], pp1[7], pp2[6]);
	full_adder fa08(s9, c9, pp0[9], pp1[8], pp2[7]);
	full_adder fa09(s10, c10, pp0[10], pp1[9], pp2[8]);
	full_adder fa10(s11, c11, pp0[11], pp1[10], pp2[9]);
	full_adder fa11(s12, c12, pp0[12], pp1[11], pp2[10]);
	full_adder fa12(s13, c13, pp0[13], pp1[12], pp2[11]);
	full_adder fa13(s14, c14, pp0[14], pp1[13], pp2[12]);
	full_adder fa14(s15, c15, pp0[15], pp1[14], pp2[13]);
	half_adder ha02(s16, c16, pp1[15], pp2[14]);
	
	/* Second Stage */
	half_adder ha03(s201, c201, s1, pp3[0]);
	full_adder fa04(s202, c202, s2, pp3[1], c1);
	full_adder fa05(s203, c203, s3, pp3[2], c2);
	full_adder fa06(s204, c204, s4, pp3[3], c3);
	full_adder fa07(s205, c205, s5, pp3[4], c4);
	full_adder fa08(s206, c206, s6, pp3[5], c5);
	full_adder fa09(s207,"
7608.93,2659.47,0.1,61.0,1,"//Please finish designing the 32 bit multiplier module (multiplier_32) below.
//There are two 32 bit inputs (A and B) and a 64 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_32(output [63:0] product, input [31:0] A, B);
    assign product = A * B;
endmodule"
7608.93,2659.47,0.1,62.0,1,"//Please finish designing the 32 bit multiplier module (multiplier_32) below.
//There are two 32 bit inputs (A and B) and a 64 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_32(output [63:0] product, input [31:0] A, B);
    assign product = A * B;
endmodule"
7608.93,2659.47,0.1,63.0,1,"//Please finish designing the 32 bit multiplier module (multiplier_32) below.
//There are two 32 bit inputs (A and B) and a 64 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_32(output [63:0] product, input [31:0] A, B);
    assign product = A * B;
endmodule"
7608.93,2659.47,0.1,64.0,1,"//Please finish designing the 32 bit multiplier module (multiplier_32) below.
//There are two 32 bit inputs (A and B) and a 64 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_32(output [63:0] product, input [31:0] A, B);
    assign product = A * B;
endmodule"
7608.93,2659.47,0.1,65.0,1,"//Please finish designing the 32 bit multiplier module (multiplier_32) below.
//There are two 32 bit inputs (A and B) and a 64 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_32(output [63:0] product, input [31:0] A, B);
    assign product = A * B;
endmodule"
7608.93,2659.47,0.1,66.0,1,"//Please finish designing the 32 bit multiplier module (multiplier_32) below.
//There are two 32 bit inputs (A and B) and a 64 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_32(output [63:0] product, input [31:0] A, B);
    assign product = A * B;
endmodule"
7608.93,2659.47,0.1,67.0,1,"//Please finish designing the 32 bit multiplier module (multiplier_32) below.
//There are two 32 bit inputs (A and B) and a 64 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_32(output [63:0] product, input [31:0] A, B);
    assign product = A * B;
endmodule"
7608.93,2659.47,0.1,68.0,1,"//Please finish designing the 32 bit multiplier module (multiplier_32) below.
//There are two 32 bit inputs (A and B) and a 64 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_32(output [63:0] product, input [31:0] A, B);
    assign product = A * B;
endmodule"
7608.93,2659.47,0.1,69.0,1,"//Please finish designing the 32 bit multiplier module (multiplier_32) below.
//There are two 32 bit inputs (A and B) and a 64 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_32(output [63:0] product, input [31:0] A, B);
    assign product = A * B;
endmodule"
N/A,N/A,-1,70.0,1,"//Please finish designing the 32 bit multiplier module (multiplier_32) below.
//There are two 32 bit inputs (A and B) and a 64 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_32(output [63:0] product, input [31:0] A, B);
	/*
		Group Members: Kevin Ingram and Warren Seto

		Lab Name: Combinational Logic
		Project Name: eng312_proj2
		Design Name: multiplier_32bit.v
		Design Description: Verilog Module to implement a 32 bit multiplier
	*/
	
	wire [31:0] A_1, A_2, A_3, A_4, A_5, A_6, A_7, A_8, A_9, A_10, A_11, A_12, A_13, A_14, A_15, A_16, A_17, A_18, A_19, A_20, A_21, A_22, A_23, A_24, A_25, A_26, A_27, A_28, A_29, A_30, A_31;
	wire [31:0] B_1, B_2, B_3, B_4, B_5, B_6, B_7, B_8, B_9, B_10, B_11, B_12, B_13, B_14, B_15, B_16, B_17, B_18, B_19, B_20, B_21, B_22, B_23, B_24, B_25, B_26, B_27, B_28, B_29, B_30, B_31;
	wire [63:0] product_1, product_2, product_3, product_4, product_5, product_6, product_7, product_8, product_9, product_10, product_11, product_12, product_13, product_14, product_15, product_16, product_17, product_18, product_19, product_20, product_21, product_22, product_23, product_24, product_25, product_26, product_27, product_28, product_29, product_30, product_31;
	
	assign A_1 = A << 1;
	assign B_1 = B << 1;
	
	assign product_1 = A_1 * B_1;
	
	assign A_2 = A_1[31:0];
	assign B_2 = B_1[31:0];
	assign product_2 = A_2 * B_2;
	
	assign A_3 = A_2[31:0];
	assign B_3 = B_2[31:0];
	assign product_3 = A_3 * B_3;
	
	assign A_4 = A_3[31:0];
	assign B_4 = B_3[31:0];
	assign product_4 = A_4 * B_4;
	
	assign A_5 = A_4[31:0];
	assign B_5 = B_4[31:0];
	assign product_5 = A_5 * B_5;
	
	assign A_6 = A_5[31:0];
	assign B_6 = B_5[31:0];
	assign product_6 = A_6 * B_6;
	
	assign A_7 = A_6[31:0];
	assign B_7 = B_6[31:0];
	assign product_7 = A_7 * B_7;
	
	assign A_8 = A_7[31:0];
	assign B_8 = B_7[31:0];
	assign product_8 = A_8 * B_8;
	
	assign A_9 = A_8[31:0];
	assign B_9 = B_8[31:0];
	assign product_9 = A_9 * B_9;
	
	assign A_10 = A_9[31:0];
	assign B_10 = B_9[31:0];
	assign product_10 = A_10 * B_10;
	
	assign A_11 = A_10[31:0];
	assign B_11 = B_10[31:0];
	assign product_11 = A_11 * B_11;
	
	assign A_12 = A_11[31:0];
"
N/A,N/A,-1,71.0,1,"//Please finish designing the 32 bit multiplier module (multiplier_32) below.
//There are two 32 bit inputs (A and B) and a 64 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_32(output [63:0] product, input [31:0] A, B);
	assign pp0 = A[0]? B: 32'b00000000000000000000000000000000;
	assign pp1 = A[1]? B: 32'b00000000000000000000000000000000;
	assign pp2 = A[2]? B: 32'b00000000000000000000000000000000;
	assign pp3 = A[3]? B: 32'b00000000000000000000000000000000;
	assign pp4 = A[4]? B: 32'b00000000000000000000000000000000;
	assign pp5 = A[5]? B: 32'b00000000000000000000000000000000;
	assign pp6 = A[6]? B: 32'b00000000000000000000000000000000;
	assign pp7 = A[7]? B: 32'b00000000000000000000000000000000;
	assign pp8 = A[8]? B: 32'b00000000000000000000000000000000;
	assign pp9 = A[9]? B: 32'b00000000000000000000000000000000;
	assign pp10 = A[10]? B: 32'b00000000000000000000000000000000;
	assign pp11 = A[11]? B: 32'b00000000000000000000000000000000;
	assign pp12 = A[12]? B: 32'b00000000000000000000000000000000;
	assign pp13 = A[13]? B: 32'b00000000000000000000000000000000;
	assign pp14 = A[14]? B: 32'b00000000000000000000000000000000;
	assign pp15 = A[15]? B: 32'b00000000000000000000000000000000;
	assign pp16 = A[16]? B: 32'b00000000000000000000000000000000;
	assign pp17 = A[17]? B: 32'b00000000000000000000000000000000;
	assign pp18 = A[18]? B: 32'b00000000000000000000000000000000;
	assign pp19 = A[19]? B: 32'b00000000000000000000000000000000;
	assign pp20 = A[20]? B: 32'b00000000000000000000000000000000;
	assign pp21 = A[21]? B: 32'b00000000000000000000000000000000;
	assign pp22 = A[22]? B: 32'b00000000000000000000000000000000;
	assign pp23 = A[23]? B: 32'b00000000000000000000000000000000;
	assign pp24 = A[24]? B: 32'b00000000000000000000000000000000;
	assign pp25 = A[25]? B: 32'b00000000000000000000000000000000;
	assign pp26 = A[26]? B: 32'b00000000000000000000000000000000;
	assign pp27 = A[27]? B: 32'b00000000000000000000000000000000;
	assign pp28 = A[28]? B: 32'b00000000000000000000000000000000;
	assign pp29 = A[29]? B: 32'b00000000000000000000000000000000;
	assign pp30 = A[30]? B: 32'b00000000000000000000000000000000;
	assign pp31 = A[31]? B: 32'b00000000000000000000000000000000;
	assign product[0] = pp0[0];
	assign in1_1 = {pp0[1],pp0[0],pp0[0],pp0[0]};
	assign in1_2 = {pp1[0],pp1[0],pp1[0],pp1[0]};
	CLA4 CLA01(s1, c1, in1_1, in1_2);
	assign in2_1 = {pp2[1],pp2[0],pp2[0],pp2[0]};
	assign in2_2 = {pp3[0],pp3[0],pp3[0],pp3[0]};
	CLA4 CLA02(s2, c2, in2_1, in2_2);
	assign in3_1 = {s1[3],s1[2],s1[1],s1[0]};
	assign in3_2 = {s2[2],s2[1],s2[0],s2[3]};
	CLA4 CLA03(s3, c3, in3_1, in3_2);
	assign in4_1 = {pp4[1],pp4[0],pp4[0],pp4[0]};
	assign in4_2 = {pp5[0],pp5[0],pp5[0],pp5[0]};
	CLA4 CLA04(s4, c4, in4_1, in4_2);
	assign in5_1 = {s1[3],s1[2],s1[1],s1[0]"
N/A,N/A,-1,72.0,1,"//Please finish designing the 32 bit multiplier module (multiplier_32) below.
//There are two 32 bit inputs (A and B) and a 64 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_32(output [63:0] product, input [31:0] A, B);
	assign pp0[0] = A[0] & B[0];
	assign pp0[1] = A[0] & B[1];
	assign pp0[2] = A[0] & B[2];
	assign pp0[3] = A[0] & B[3];
	assign pp0[4] = A[0] & B[4];
	assign pp0[5] = A[0] & B[5];
	assign pp0[6] = A[0] & B[6];
	assign pp0[7] = A[0] & B[7];
	assign pp0[8] = A[0] & B[8];
	assign pp0[9] = A[0] & B[9];
	assign pp0[10] = A[0] & B[10];
	assign pp0[11] = A[0] & B[11];
	assign pp0[12] = A[0] & B[12];
	assign pp0[13] = A[0] & B[13];
	assign pp0[14] = A[0] & B[14];
	assign pp0[15] = A[0] & B[15];
	assign pp0[16] = A[0] & B[16];
	assign pp0[17] = A[0] & B[17];
	assign pp0[18] = A[0] & B[18];
	assign pp0[19] = A[0] & B[19];
	assign pp0[20] = A[0] & B[20];
	assign pp0[21] = A[0] & B[21];
	assign pp0[22] = A[0] & B[22];
	assign pp0[23] = A[0] & B[23];
	assign pp0[24] = A[0] & B[24];
	assign pp0[25] = A[0] & B[25];
	assign pp0[26] = A[0] & B[26];
	assign pp0[27] = A[0] & B[27];
	assign pp0[28] = A[0] & B[28];
	assign pp0[29] = A[0] & B[29];
	assign pp0[30] = A[0] & B[30];
	assign pp0[31] = A[0] & B[31];
	assign pp1[0] = A[1] & B[0];
	assign pp1[1] = A[1] & B[1];
	assign pp1[2] = A[1] & B[2];
	assign pp1[3] = A[1] & B[3];
	assign pp1[4] = A[1] & B[4];
	assign pp1[5] = A[1] & B[5];
	assign pp1[6] = A[1] & B[6];
	assign pp1[7] = A[1] & B[7];
	assign pp1[8] = A[1] & B[8];
	assign pp1[9] = A[1] & B[9];
	assign pp1[10] = A[1] & B[10];
	assign pp1[11] = A[1] & B[11];
	assign pp1[12] = A[1] & B[12];
	assign pp1[13] = A[1] & B[13];
	assign pp1[14] = A[1] & B[14];
	assign pp1[15] = A[1] & B[15];
	assign pp1[16] = A[1] & B[16];
	assign pp1[17] = A[1] & B[17];
	assign pp1[18] = A[1] & B[18];
	assign pp1[19] = A[1] & B[19];
	assign pp1[20] = A[1] & B[20];
	assign pp1[21] = A[1] & B["
N/A,N/A,-1,73.0,1,"//Please finish designing the 32 bit multiplier module (multiplier_32) below.
//There are two 32 bit inputs (A and B) and a 64 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_32(output [63:0] product, input [31:0] A, B);

	wire [31:0] pp0, pp1, pp2, pp3, pp4, pp5, pp6, pp7, pp8, pp9, pp10, pp11, pp12, pp13, pp14, pp15;

	assign pp0 = A[0]? B: 32'b00000000000000000000000000000000;
	assign pp1 = A[1]? B: 32'b00000000000000000000000000000000;
	assign pp2 = A[2]? B: 32'b00000000000000000000000000000000;
	assign pp3 = A[3]? B: 32'b00000000000000000000000000000000;
	assign pp4 = A[4]? B: 32'b00000000000000000000000000000000;
	assign pp5 = A[5]? B: 32'b00000000000000000000000000000000;
	assign pp6 = A[6]? B: 32'b00000000000000000000000000000000;
	assign pp7 = A[7]? B: 32'b00000000000000000000000000000000;
	assign pp8 = A[8]? B: 32'b00000000000000000000000000000000;
	assign pp9 = A[9]? B: 32'b00000000000000000000000000000000;
	assign pp10 = A[10]? B: 32'b00000000000000000000000000000000;
	assign pp11 = A[11]? B: 32'b00000000000000000000000000000000;
	assign pp12 = A[12]? B: 32'b00000000000000000000000000000000;
	assign pp13 = A[13]? B: 32'b00000000000000000000000000000000;
	assign pp14 = A[14]? B: 32'b00000000000000000000000000000000;
	assign pp15 = A[15]? B: 32'b00000000000000000000000000000000;

	assign product[0] = pp0[0];

	/* 1st CLA */
	wire [31:0] G1, P1, C1;
	assign G1[0]  = pp0[1]  & pp1[0];
	assign G1[1]  = pp0[2]  & pp1[1];
	assign G1[2]  = pp0[3]  & pp1[2];
	assign G1[3]  = pp0[4]  & pp1[3];
	assign G1[4]  = pp0[5]  & pp1[4];
	assign G1[5]  = pp0[6]  & pp1[5];
	assign G1[6]  = pp0[7]  & pp1[6];
	assign G1[7]  = pp0[8]  & pp1[7];
	assign G1[8]  = pp0[9]  & pp1[8];
	assign G1[9]  = pp0[10] & pp1[9];
	assign G1[10] = pp0[11] & pp1[10];
	assign G1[11] = pp0[12] & pp1[11];
	assign G1[12] = pp0[13] & pp1[12];
	assign G1[13] = pp0[14] & pp1[13];
	assign G1[14] = pp0[15] & pp1[14];
	assign G1[15] = 0       & pp1[15];
	assign P1[0]  = pp0[1]  ^ pp1[0];
	assign P1[1]  = pp0[2]  ^ pp1[1];
	assign P1[2]  = pp0[3]  ^ pp1[2];
	assign P1[3]  = pp0[4]  ^ pp1[3];
	assign P1[4]  = pp0[5]  ^ pp1[4];
	assign P1[5]  = pp0[6]  ^ pp1[5];
	assign P1[6]  = pp0[7]  ^ pp1[6];
	assign P1[7]  = pp0[8]  ^ pp1[7];
	assign P1[8]  = pp0[9]  ^ pp1[8];
	assign P1[9]  = pp0[10] ^ pp1[9];
	assign P1[10] = pp0[11] ^ pp1[10];
	assign P1[11"
N/A,N/A,-1,74.0,1,"//Please finish designing the 32 bit multiplier module (multiplier_32) below.
//There are two 32 bit inputs (A and B) and a 64 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_32(output [63:0] product, input [31:0] A, B);
    /* Please fill in the implementation here... */
    assign pp0 = A[0]? B: 32'b00000000000000000000000000000000;
    assign pp1 = A[1]? B: 32'b00000000000000000000000000000000;
    assign pp2 = A[2]? B: 32'b00000000000000000000000000000000;
    assign pp3 = A[3]? B: 32'b00000000000000000000000000000000;
    assign pp4 = A[4]? B: 32'b00000000000000000000000000000000;
    assign pp5 = A[5]? B: 32'b00000000000000000000000000000000;
    assign pp6 = A[6]? B: 32'b00000000000000000000000000000000;
    assign pp7 = A[7]? B: 32'b00000000000000000000000000000000;
    assign pp8 = A[8]? B: 32'b00000000000000000000000000000000;
    assign pp9 = A[9]? B: 32'b00000000000000000000000000000000;
    assign pp10 = A[10]? B: 32'b00000000000000000000000000000000;
    assign pp11 = A[11]? B: 32'b00000000000000000000000000000000;
    assign pp12 = A[12]? B: 32'b00000000000000000000000000000000;
    assign pp13 = A[13]? B: 32'b00000000000000000000000000000000;
    assign pp14 = A[14]? B: 32'b00000000000000000000000000000000;
    assign pp15 = A[15]? B: 32'b00000000000000000000000000000000;
    assign pp16 = A[16]? B: 32'b00000000000000000000000000000000;
    assign pp17 = A[17]? B: 32'b00000000000000000000000000000000;
    assign pp18 = A[18]? B: 32'b00000000000000000000000000000000;
    assign pp19 = A[19]? B: 32'b00000000000000000000000000000000;
    assign pp20 = A[20]? B: 32'b00000000000000000000000000000000;
    assign pp21 = A[21]? B: 32'b00000000000000000000000000000000;
    assign pp22 = A[22]? B: 32'b00000000000000000000000000000000;
    assign pp23 = A[23]? B: 32'b00000000000000000000000000000000;
    assign pp24 = A[24]? B: 32'b00000000000000000000000000000000;
    assign pp25 = A[25]? B: 32'b00000000000000000000000000000000;
    assign pp26 = A[26]? B: 32'b00000000000000000000000000000000;
    assign pp27 = A[27]? B: 32'b00000000000000000000000000000000;
    assign pp28 = A[28]? B: 32'b00000000000000000000000000000000;
    assign pp29 = A[29]? B: 32'b00000000000000000000000000000000;
    assign pp30 = A[30]? B: 32'b00000000000000000000000000000000;
    assign pp31 = A[31]? B: 32'b00000000000000000000000000000000;
    assign product[0] = pp0[0];
    /* 1st CLA */
    assign in1_1 = {pp0[1],pp0[2],pp0[3],pp0[4],pp0[5],pp0[6],pp0[7],pp0[8],pp0[9],pp0[10],pp0[11],pp0[12],pp0[13],pp0[14],pp0[15],pp0[16],pp0[17],pp0[18],pp0[19],pp0[20],pp0[21],pp0[22],pp0[23],pp0[24],pp0[25],pp0[26],pp0[27],pp0[28],pp0[29],pp0[30],pp0[31],1'b0};
    assign in1_2 = {pp1[0],pp1[1],pp1[2],pp1[3],pp1[4],pp1[5],pp1[6],pp1[7],pp1[8],pp1[9], pp1[10],pp1[11],pp1[12],pp1[13],pp1[14],pp1[15],pp1[16],pp1[17],pp1[18],pp1[19],pp1[20],pp1[21],pp1[22],pp1[23],pp1[24],pp1[25],pp1[26],pp1[27],pp1[28],pp1[29],pp1[30],pp1[31],1'b0};
    CLA_32 KS_"
N/A,N/A,-1,75.0,1,"//Please finish designing the 32 bit multiplier module (multiplier_32) below.
//There are two 32 bit inputs (A and B) and a 64 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_32(output [63:0] product, input [31:0] A, B);
	assign pp0[0] = A[0] & B[0];
	assign pp0[1] = A[0] & B[1];
	assign pp0[2] = A[0] & B[2];
	assign pp0[3] = A[0] & B[3];
	assign pp0[4] = A[0] & B[4];
	assign pp0[5] = A[0] & B[5];
	assign pp0[6] = A[0] & B[6];
	assign pp0[7] = A[0] & B[7];
	assign pp0[8] = A[0] & B[8];
	assign pp0[9] = A[0] & B[9];
	assign pp0[10] = A[0] & B[10];
	assign pp0[11] = A[0] & B[11];
	assign pp0[12] = A[0] & B[12];
	assign pp0[13] = A[0] & B[13];
	assign pp0[14] = A[0] & B[14];
	assign pp0[15] = A[0] & B[15];
	assign pp0[16] = A[0] & B[16];
	assign pp0[17] = A[0] & B[17];
	assign pp0[18] = A[0] & B[18];
	assign pp0[19] = A[0] & B[19];
	assign pp0[20] = A[0] & B[20];
	assign pp0[21] = A[0] & B[21];
	assign pp0[22] = A[0] & B[22];
	assign pp0[23] = A[0] & B[23];
	assign pp0[24] = A[0] & B[24];
	assign pp0[25] = A[0] & B[25];
	assign pp0[26] = A[0] & B[26];
	assign pp0[27] = A[0] & B[27];
	assign pp0[28] = A[0] & B[28];
	assign pp0[29] = A[0] & B[29];
	assign pp0[30] = A[0] & B[30];
	assign pp0[31] = A[0] & B[31];
	assign pp1[0] = A[1] & B[0];
	assign pp1[1] = A[1] & B[1];
	assign pp1[2] = A[1] & B[2];
	assign pp1[3] = A[1] & B[3];
	assign pp1[4] = A[1] & B[4];
	assign pp1[5] = A[1] & B[5];
	assign pp1[6] = A[1] & B[6];
	assign pp1[7] = A[1] & B[7];
	assign pp1[8] = A[1] & B[8];
	assign pp1[9] = A[1] & B[9];
	assign pp1[10] = A[1] & B[10];
	assign pp1[11] = A[1] & B[11];
	assign pp1[12] = A[1] & B[12];
	assign pp1[13] = A[1] & B[13];
	assign pp1[14] = A[1] & B[14];
	assign pp1[15] = A[1] & B[15];
	assign pp1[16] = A[1] & B[16];
	assign pp1[17] = A[1] & B[17];
	assign pp1[18] = A[1] & B[18];
	assign pp1[19] = A[1] & B[19];
	assign pp1[20] = A[1] & B[20];
	assign pp1[21] = A[1] & B["
N/A,N/A,-1,76.0,1,"//Please finish designing the 32 bit multiplier module (multiplier_32) below.
//There are two 32 bit inputs (A and B) and a 64 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_32(output [63:0] product, input [31:0] A, B);
	
	wire [31:0] pp0, pp1, pp2, pp3, pp4, pp5, pp6, pp7, pp8, pp9, pp10, pp11, pp12, pp13, pp14, pp15;
	
	assign pp0 = A[0]? B: 32'b00000000000000000000000000000000;
	assign pp1 = A[1]? B: 32'b00000000000000000000000000000000;
	assign pp2 = A[2]? B: 32'b00000000000000000000000000000000;
	assign pp3 = A[3]? B: 32'b00000000000000000000000000000000;
	assign pp4 = A[4]? B: 32'b00000000000000000000000000000000;
	assign pp5 = A[5]? B: 32'b00000000000000000000000000000000;
	assign pp6 = A[6]? B: 32'b00000000000000000000000000000000;
	assign pp7 = A[7]? B: 32'b00000000000000000000000000000000;
	assign pp8 = A[8]? B: 32'b00000000000000000000000000000000;
	assign pp9 = A[9]? B: 32'b00000000000000000000000000000000;
	assign pp10 = A[10]? B: 32'b00000000000000000000000000000000;
	assign pp11 = A[11]? B: 32'b00000000000000000000000000000000;
	assign pp12 = A[12]? B: 32'b00000000000000000000000000000000;
	assign pp13 = A[13]? B: 32'b00000000000000000000000000000000;
	assign pp14 = A[14]? B: 32'b00000000000000000000000000000000;
	assign pp15 = A[15]? B: 32'b00000000000000000000000000000000;
	
	assign product[0] = pp0[0];
	
	/* First Stage */
	half_adder ha01(s1, c1, pp0[1], pp1[0]);
	full_adder fa01(s2, c2, pp0[2], pp1[1], pp2[0]);
	full_adder fa02(s3, c3, pp0[3], pp1[2], pp2[1]);
	full_adder fa03(s4, c4, pp0[4], pp1[3], pp2[2]);
	full_adder fa04(s5, c5, pp0[5], pp1[4], pp2[3]);
	full_adder fa05(s6, c6, pp0[6], pp1[5], pp2[4]);
	full_adder fa06(s7, c7, pp0[7], pp1[6], pp2[5]);
	full_adder fa07(s8, c8, pp0[8], pp1[7], pp2[6]);
	full_adder fa08(s9, c9, pp0[9], pp1[8], pp2[7]);
	full_adder fa09(s10, c10, pp0[10], pp1[9], pp2[8]);
	full_adder fa10(s11, c11, pp0[11], pp1[10], pp2[9]);
	full_adder fa11(s12, c12, pp0[12], pp1[11], pp2[10]);
	full_adder fa12(s13, c13, pp0[13], pp1[12], pp2[11]);
	full_adder fa13(s14, c14, pp0[14], pp1[13], pp2[12]);
	full_adder fa14(s15, c15, pp0[15], pp1[14], pp2[13]);
	half_adder ha02(s16, c16, pp1[15], pp2[14]);
	
	/* Second Stage */
	half_adder ha03(s201, c201, s1, pp3[0]);
	full_adder fa04(s202, c202, s2, pp3[1], c1);
	full_adder fa05(s203, c203, s3, pp3[2], c2);
	full_adder fa06(s204, c204, s4, pp3[3], c3);
	full_adder fa07(s205, c205, s5, pp3[4], c4);
	full_adder fa08(s206, c206, s6, pp3[5], c5);
	full_adder fa09(s207,"
7608.93,2659.47,0.1,77.0,1,"//Please finish designing the 32 bit multiplier module (multiplier_32) below.
//There are two 32 bit inputs (A and B) and a 64 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_32(output [63:0] product, input [31:0] A, B);
    assign product = A * B;
endmodule"
7608.93,2659.47,0.1,78.0,1,"//Please finish designing the 32 bit multiplier module (multiplier_32) below.
//There are two 32 bit inputs (A and B) and a 64 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_32(output [63:0] product, input [31:0] A, B);
    assign product = A * B;
endmodule"
7608.93,2659.47,0.1,79.0,1,"//Please finish designing the 32 bit multiplier module (multiplier_32) below.
//There are two 32 bit inputs (A and B) and a 64 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_32(output [63:0] product, input [31:0] A, B);
    assign product = A * B;
endmodule"
7608.93,2659.47,0.1,80.0,1,"//Please finish designing the 32 bit multiplier module (multiplier_32) below.
//There are two 32 bit inputs (A and B) and a 64 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_32(output [63:0] product, input [31:0] A, B);
    assign product = A * B;
endmodule"
7608.93,2659.47,0.1,81.0,1,"//Please finish designing the 32 bit multiplier module (multiplier_32) below.
//There are two 32 bit inputs (A and B) and a 64 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_32(output [63:0] product, input [31:0] A, B);
    assign product = A * B;
endmodule"
7608.93,2659.47,0.1,82.0,1,"//Please finish designing the 32 bit multiplier module (multiplier_32) below.
//There are two 32 bit inputs (A and B) and a 64 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_32(output [63:0] product, input [31:0] A, B);
    assign product = A * B;
endmodule"
7608.93,2659.47,0.1,83.0,1,"//Please finish designing the 32 bit multiplier module (multiplier_32) below.
//There are two 32 bit inputs (A and B) and a 64 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_32(output [63:0] product, input [31:0] A, B);
    assign product = A * B;
endmodule"
7608.93,2659.47,0.1,84.0,1,"//Please finish designing the 32 bit multiplier module (multiplier_32) below.
//There are two 32 bit inputs (A and B) and a 64 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_32(output [63:0] product, input [31:0] A, B);
    assign product = A * B;
endmodule"
7608.93,2659.47,0.1,85.0,1,"//Please finish designing the 32 bit multiplier module (multiplier_32) below.
//There are two 32 bit inputs (A and B) and a 64 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_32(output [63:0] product, input [31:0] A, B);
    assign product = A * B;
endmodule"
N/A,N/A,-1,86.0,1,"//Please finish designing the 32 bit multiplier module (multiplier_32) below.
//There are two 32 bit inputs (A and B) and a 64 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_32(output [63:0] product, input [31:0] A, B);
	/*
		Group Members: Kevin Ingram and Warren Seto

		Lab Name: Combinational Logic
		Project Name: eng312_proj2
		Design Name: multiplier_32bit.v
		Design Description: Verilog Module to implement a 32 bit multiplier
	*/
	
	wire [31:0] A_1, A_2, A_3, A_4, A_5, A_6, A_7, A_8, A_9, A_10, A_11, A_12, A_13, A_14, A_15, A_16, A_17, A_18, A_19, A_20, A_21, A_22, A_23, A_24, A_25, A_26, A_27, A_28, A_29, A_30, A_31;
	wire [31:0] B_1, B_2, B_3, B_4, B_5, B_6, B_7, B_8, B_9, B_10, B_11, B_12, B_13, B_14, B_15, B_16, B_17, B_18, B_19, B_20, B_21, B_22, B_23, B_24, B_25, B_26, B_27, B_28, B_29, B_30, B_31;
	wire [63:0] product_1, product_2, product_3, product_4, product_5, product_6, product_7, product_8, product_9, product_10, product_11, product_12, product_13, product_14, product_15, product_16, product_17, product_18, product_19, product_20, product_21, product_22, product_23, product_24, product_25, product_26, product_27, product_28, product_29, product_30, product_31;
	
	assign A_1 = A << 1;
	assign B_1 = B << 1;
	
	assign product_1 = A_1 * B_1;
	
	assign A_2 = A_1[31:0];
	assign B_2 = B_1[31:0];
	assign product_2 = A_2 * B_2;
	
	assign A_3 = A_2[31:0];
	assign B_3 = B_2[31:0];
	assign product_3 = A_3 * B_3;
	
	assign A_4 = A_3[31:0];
	assign B_4 = B_3[31:0];
	assign product_4 = A_4 * B_4;
	
	assign A_5 = A_4[31:0];
	assign B_5 = B_4[31:0];
	assign product_5 = A_5 * B_5;
	
	assign A_6 = A_5[31:0];
	assign B_6 = B_5[31:0];
	assign product_6 = A_6 * B_6;
	
	assign A_7 = A_6[31:0];
	assign B_7 = B_6[31:0];
	assign product_7 = A_7 * B_7;
	
	assign A_8 = A_7[31:0];
	assign B_8 = B_7[31:0];
	assign product_8 = A_8 * B_8;
	
	assign A_9 = A_8[31:0];
	assign B_9 = B_8[31:0];
	assign product_9 = A_9 * B_9;
	
	assign A_10 = A_9[31:0];
	assign B_10 = B_9[31:0];
	assign product_10 = A_10 * B_10;
	
	assign A_11 = A_10[31:0];
	assign B_11 = B_10[31:0];
	assign product_11 = A_11 * B_11;
	
	assign A_12 = A_11[31:0];
"
N/A,N/A,-1,87.0,1,"//Please finish designing the 32 bit multiplier module (multiplier_32) below.
//There are two 32 bit inputs (A and B) and a 64 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_32(output [63:0] product, input [31:0] A, B);
	assign pp0 = A[0]? B: 32'b00000000000000000000000000000000;
	assign pp1 = A[1]? B: 32'b00000000000000000000000000000000;
	assign pp2 = A[2]? B: 32'b00000000000000000000000000000000;
	assign pp3 = A[3]? B: 32'b00000000000000000000000000000000;
	assign pp4 = A[4]? B: 32'b00000000000000000000000000000000;
	assign pp5 = A[5]? B: 32'b00000000000000000000000000000000;
	assign pp6 = A[6]? B: 32'b00000000000000000000000000000000;
	assign pp7 = A[7]? B: 32'b00000000000000000000000000000000;
	assign pp8 = A[8]? B: 32'b00000000000000000000000000000000;
	assign pp9 = A[9]? B: 32'b00000000000000000000000000000000;
	assign pp10 = A[10]? B: 32'b00000000000000000000000000000000;
	assign pp11 = A[11]? B: 32'b00000000000000000000000000000000;
	assign pp12 = A[12]? B: 32'b00000000000000000000000000000000;
	assign pp13 = A[13]? B: 32'b00000000000000000000000000000000;
	assign pp14 = A[14]? B: 32'b00000000000000000000000000000000;
	assign pp15 = A[15]? B: 32'b00000000000000000000000000000000;
	assign pp16 = A[16]? B: 32'b00000000000000000000000000000000;
	assign pp17 = A[17]? B: 32'b00000000000000000000000000000000;
	assign pp18 = A[18]? B: 32'b00000000000000000000000000000000;
	assign pp19 = A[19]? B: 32'b00000000000000000000000000000000;
	assign pp20 = A[20]? B: 32'b00000000000000000000000000000000;
	assign pp21 = A[21]? B: 32'b00000000000000000000000000000000;
	assign pp22 = A[22]? B: 32'b00000000000000000000000000000000;
	assign pp23 = A[23]? B: 32'b00000000000000000000000000000000;
	assign pp24 = A[24]? B: 32'b00000000000000000000000000000000;
	assign pp25 = A[25]? B: 32'b00000000000000000000000000000000;
	assign pp26 = A[26]? B: 32'b00000000000000000000000000000000;
	assign pp27 = A[27]? B: 32'b00000000000000000000000000000000;
	assign pp28 = A[28]? B: 32'b00000000000000000000000000000000;
	assign pp29 = A[29]? B: 32'b00000000000000000000000000000000;
	assign pp30 = A[30]? B: 32'b00000000000000000000000000000000;
	assign pp31 = A[31]? B: 32'b00000000000000000000000000000000;
	assign product[0] = pp0[0];
	assign in1_1 = {pp0[1],pp0[0],pp0[0],pp0[0]};
	assign in1_2 = {pp1[0],pp1[0],pp1[0],pp1[0]};
	CLA4 CLA01(s1, c1, in1_1, in1_2);
	assign in2_1 = {pp2[1],pp2[0],pp2[0],pp2[0]};
	assign in2_2 = {pp3[0],pp3[0],pp3[0],pp3[0]};
	CLA4 CLA02(s2, c2, in2_1, in2_2);
	assign in3_1 = {s1[3],s1[2],s1[1],s1[0]};
	assign in3_2 = {s2[2],s2[1],s2[0],s2[3]};
	CLA4 CLA03(s3, c3, in3_1, in3_2);
	assign in4_1 = {pp4[1],pp4[0],pp4[0],pp4[0]};
	assign in4_2 = {pp5[0],pp5[0],pp5[0],pp5[0]};
	CLA4 CLA04(s4, c4, in4_1, in4_2);
	assign in5_1 = {s1[3],s1[2],s1[1],s1[0]"
N/A,N/A,-1,88.0,1,"//Please finish designing the 32 bit multiplier module (multiplier_32) below.
//There are two 32 bit inputs (A and B) and a 64 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_32(output [63:0] product, input [31:0] A, B);
	assign pp0[0] = A[0] & B[0];
	assign pp0[1] = A[0] & B[1];
	assign pp0[2] = A[0] & B[2];
	assign pp0[3] = A[0] & B[3];
	assign pp0[4] = A[0] & B[4];
	assign pp0[5] = A[0] & B[5];
	assign pp0[6] = A[0] & B[6];
	assign pp0[7] = A[0] & B[7];
	assign pp0[8] = A[0] & B[8];
	assign pp0[9] = A[0] & B[9];
	assign pp0[10] = A[0] & B[10];
	assign pp0[11] = A[0] & B[11];
	assign pp0[12] = A[0] & B[12];
	assign pp0[13] = A[0] & B[13];
	assign pp0[14] = A[0] & B[14];
	assign pp0[15] = A[0] & B[15];
	assign pp0[16] = A[0] & B[16];
	assign pp0[17] = A[0] & B[17];
	assign pp0[18] = A[0] & B[18];
	assign pp0[19] = A[0] & B[19];
	assign pp0[20] = A[0] & B[20];
	assign pp0[21] = A[0] & B[21];
	assign pp0[22] = A[0] & B[22];
	assign pp0[23] = A[0] & B[23];
	assign pp0[24] = A[0] & B[24];
	assign pp0[25] = A[0] & B[25];
	assign pp0[26] = A[0] & B[26];
	assign pp0[27] = A[0] & B[27];
	assign pp0[28] = A[0] & B[28];
	assign pp0[29] = A[0] & B[29];
	assign pp0[30] = A[0] & B[30];
	assign pp0[31] = A[0] & B[31];
	assign pp1[0] = A[1] & B[0];
	assign pp1[1] = A[1] & B[1];
	assign pp1[2] = A[1] & B[2];
	assign pp1[3] = A[1] & B[3];
	assign pp1[4] = A[1] & B[4];
	assign pp1[5] = A[1] & B[5];
	assign pp1[6] = A[1] & B[6];
	assign pp1[7] = A[1] & B[7];
	assign pp1[8] = A[1] & B[8];
	assign pp1[9] = A[1] & B[9];
	assign pp1[10] = A[1] & B[10];
	assign pp1[11] = A[1] & B[11];
	assign pp1[12] = A[1] & B[12];
	assign pp1[13] = A[1] & B[13];
	assign pp1[14] = A[1] & B[14];
	assign pp1[15] = A[1] & B[15];
	assign pp1[16] = A[1] & B[16];
	assign pp1[17] = A[1] & B[17];
	assign pp1[18] = A[1] & B[18];
	assign pp1[19] = A[1] & B[19];
	assign pp1[20] = A[1] & B[20];
	assign pp1[21] = A[1] & B["
N/A,N/A,-1,89.0,1,"//Please finish designing the 32 bit multiplier module (multiplier_32) below.
//There are two 32 bit inputs (A and B) and a 64 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_32(output [63:0] product, input [31:0] A, B);

	wire [31:0] pp0, pp1, pp2, pp3, pp4, pp5, pp6, pp7, pp8, pp9, pp10, pp11, pp12, pp13, pp14, pp15;

	assign pp0 = A[0]? B: 32'b00000000000000000000000000000000;
	assign pp1 = A[1]? B: 32'b00000000000000000000000000000000;
	assign pp2 = A[2]? B: 32'b00000000000000000000000000000000;
	assign pp3 = A[3]? B: 32'b00000000000000000000000000000000;
	assign pp4 = A[4]? B: 32'b00000000000000000000000000000000;
	assign pp5 = A[5]? B: 32'b00000000000000000000000000000000;
	assign pp6 = A[6]? B: 32'b00000000000000000000000000000000;
	assign pp7 = A[7]? B: 32'b00000000000000000000000000000000;
	assign pp8 = A[8]? B: 32'b00000000000000000000000000000000;
	assign pp9 = A[9]? B: 32'b00000000000000000000000000000000;
	assign pp10 = A[10]? B: 32'b00000000000000000000000000000000;
	assign pp11 = A[11]? B: 32'b00000000000000000000000000000000;
	assign pp12 = A[12]? B: 32'b00000000000000000000000000000000;
	assign pp13 = A[13]? B: 32'b00000000000000000000000000000000;
	assign pp14 = A[14]? B: 32'b00000000000000000000000000000000;
	assign pp15 = A[15]? B: 32'b00000000000000000000000000000000;

	assign product[0] = pp0[0];

	/* 1st CLA */
	wire [31:0] G1, P1, C1;
	assign G1[0]  = pp0[1]  & pp1[0];
	assign G1[1]  = pp0[2]  & pp1[1];
	assign G1[2]  = pp0[3]  & pp1[2];
	assign G1[3]  = pp0[4]  & pp1[3];
	assign G1[4]  = pp0[5]  & pp1[4];
	assign G1[5]  = pp0[6]  & pp1[5];
	assign G1[6]  = pp0[7]  & pp1[6];
	assign G1[7]  = pp0[8]  & pp1[7];
	assign G1[8]  = pp0[9]  & pp1[8];
	assign G1[9]  = pp0[10] & pp1[9];
	assign G1[10] = pp0[11] & pp1[10];
	assign G1[11] = pp0[12] & pp1[11];
	assign G1[12] = pp0[13] & pp1[12];
	assign G1[13] = pp0[14] & pp1[13];
	assign G1[14] = pp0[15] & pp1[14];
	assign G1[15] = 0       & pp1[15];
	assign P1[0]  = pp0[1]  ^ pp1[0];
	assign P1[1]  = pp0[2]  ^ pp1[1];
	assign P1[2]  = pp0[3]  ^ pp1[2];
	assign P1[3]  = pp0[4]  ^ pp1[3];
	assign P1[4]  = pp0[5]  ^ pp1[4];
	assign P1[5]  = pp0[6]  ^ pp1[5];
	assign P1[6]  = pp0[7]  ^ pp1[6];
	assign P1[7]  = pp0[8]  ^ pp1[7];
	assign P1[8]  = pp0[9]  ^ pp1[8];
	assign P1[9]  = pp0[10] ^ pp1[9];
	assign P1[10] = pp0[11] ^ pp1[10];
	assign P1[11"
N/A,N/A,-1,90.0,1,"//Please finish designing the 32 bit multiplier module (multiplier_32) below.
//There are two 32 bit inputs (A and B) and a 64 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_32(output [63:0] product, input [31:0] A, B);
    /* Please fill in the implementation here... */
    assign pp0 = A[0]? B: 32'b00000000000000000000000000000000;
    assign pp1 = A[1]? B: 32'b00000000000000000000000000000000;
    assign pp2 = A[2]? B: 32'b00000000000000000000000000000000;
    assign pp3 = A[3]? B: 32'b00000000000000000000000000000000;
    assign pp4 = A[4]? B: 32'b00000000000000000000000000000000;
    assign pp5 = A[5]? B: 32'b00000000000000000000000000000000;
    assign pp6 = A[6]? B: 32'b00000000000000000000000000000000;
    assign pp7 = A[7]? B: 32'b00000000000000000000000000000000;
    assign pp8 = A[8]? B: 32'b00000000000000000000000000000000;
    assign pp9 = A[9]? B: 32'b00000000000000000000000000000000;
    assign pp10 = A[10]? B: 32'b00000000000000000000000000000000;
    assign pp11 = A[11]? B: 32'b00000000000000000000000000000000;
    assign pp12 = A[12]? B: 32'b00000000000000000000000000000000;
    assign pp13 = A[13]? B: 32'b00000000000000000000000000000000;
    assign pp14 = A[14]? B: 32'b00000000000000000000000000000000;
    assign pp15 = A[15]? B: 32'b00000000000000000000000000000000;
    assign pp16 = A[16]? B: 32'b00000000000000000000000000000000;
    assign pp17 = A[17]? B: 32'b00000000000000000000000000000000;
    assign pp18 = A[18]? B: 32'b00000000000000000000000000000000;
    assign pp19 = A[19]? B: 32'b00000000000000000000000000000000;
    assign pp20 = A[20]? B: 32'b00000000000000000000000000000000;
    assign pp21 = A[21]? B: 32'b00000000000000000000000000000000;
    assign pp22 = A[22]? B: 32'b00000000000000000000000000000000;
    assign pp23 = A[23]? B: 32'b00000000000000000000000000000000;
    assign pp24 = A[24]? B: 32'b00000000000000000000000000000000;
    assign pp25 = A[25]? B: 32'b00000000000000000000000000000000;
    assign pp26 = A[26]? B: 32'b00000000000000000000000000000000;
    assign pp27 = A[27]? B: 32'b00000000000000000000000000000000;
    assign pp28 = A[28]? B: 32'b00000000000000000000000000000000;
    assign pp29 = A[29]? B: 32'b00000000000000000000000000000000;
    assign pp30 = A[30]? B: 32'b00000000000000000000000000000000;
    assign pp31 = A[31]? B: 32'b00000000000000000000000000000000;
    assign product[0] = pp0[0];
    /* 1st CLA */
    assign in1_1 = {pp0[1],pp0[2],pp0[3],pp0[4],pp0[5],pp0[6],pp0[7],pp0[8],pp0[9],pp0[10],pp0[11],pp0[12],pp0[13],pp0[14],pp0[15],pp0[16],pp0[17],pp0[18],pp0[19],pp0[20],pp0[21],pp0[22],pp0[23],pp0[24],pp0[25],pp0[26],pp0[27],pp0[28],pp0[29],pp0[30],pp0[31],1'b0};
    assign in1_2 = {pp1[0],pp1[1],pp1[2],pp1[3],pp1[4],pp1[5],pp1[6],pp1[7],pp1[8],pp1[9], pp1[10],pp1[11],pp1[12],pp1[13],pp1[14],pp1[15],pp1[16],pp1[17],pp1[18],pp1[19],pp1[20],pp1[21],pp1[22],pp1[23],pp1[24],pp1[25],pp1[26],pp1[27],pp1[28],pp1[29],pp1[30],pp1[31],1'b0};
    CLA_32 KS_"
N/A,N/A,-1,91.0,1,"//Please finish designing the 32 bit multiplier module (multiplier_32) below.
//There are two 32 bit inputs (A and B) and a 64 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_32(output [63:0] product, input [31:0] A, B);
	assign pp0[0] = A[0] & B[0];
	assign pp0[1] = A[0] & B[1];
	assign pp0[2] = A[0] & B[2];
	assign pp0[3] = A[0] & B[3];
	assign pp0[4] = A[0] & B[4];
	assign pp0[5] = A[0] & B[5];
	assign pp0[6] = A[0] & B[6];
	assign pp0[7] = A[0] & B[7];
	assign pp0[8] = A[0] & B[8];
	assign pp0[9] = A[0] & B[9];
	assign pp0[10] = A[0] & B[10];
	assign pp0[11] = A[0] & B[11];
	assign pp0[12] = A[0] & B[12];
	assign pp0[13] = A[0] & B[13];
	assign pp0[14] = A[0] & B[14];
	assign pp0[15] = A[0] & B[15];
	assign pp0[16] = A[0] & B[16];
	assign pp0[17] = A[0] & B[17];
	assign pp0[18] = A[0] & B[18];
	assign pp0[19] = A[0] & B[19];
	assign pp0[20] = A[0] & B[20];
	assign pp0[21] = A[0] & B[21];
	assign pp0[22] = A[0] & B[22];
	assign pp0[23] = A[0] & B[23];
	assign pp0[24] = A[0] & B[24];
	assign pp0[25] = A[0] & B[25];
	assign pp0[26] = A[0] & B[26];
	assign pp0[27] = A[0] & B[27];
	assign pp0[28] = A[0] & B[28];
	assign pp0[29] = A[0] & B[29];
	assign pp0[30] = A[0] & B[30];
	assign pp0[31] = A[0] & B[31];
	assign pp1[0] = A[1] & B[0];
	assign pp1[1] = A[1] & B[1];
	assign pp1[2] = A[1] & B[2];
	assign pp1[3] = A[1] & B[3];
	assign pp1[4] = A[1] & B[4];
	assign pp1[5] = A[1] & B[5];
	assign pp1[6] = A[1] & B[6];
	assign pp1[7] = A[1] & B[7];
	assign pp1[8] = A[1] & B[8];
	assign pp1[9] = A[1] & B[9];
	assign pp1[10] = A[1] & B[10];
	assign pp1[11] = A[1] & B[11];
	assign pp1[12] = A[1] & B[12];
	assign pp1[13] = A[1] & B[13];
	assign pp1[14] = A[1] & B[14];
	assign pp1[15] = A[1] & B[15];
	assign pp1[16] = A[1] & B[16];
	assign pp1[17] = A[1] & B[17];
	assign pp1[18] = A[1] & B[18];
	assign pp1[19] = A[1] & B[19];
	assign pp1[20] = A[1] & B[20];
	assign pp1[21] = A[1] & B["
N/A,N/A,-1,92.0,1,"//Please finish designing the 32 bit multiplier module (multiplier_32) below.
//There are two 32 bit inputs (A and B) and a 64 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_32(output [63:0] product, input [31:0] A, B);
	
	wire [31:0] pp0, pp1, pp2, pp3, pp4, pp5, pp6, pp7, pp8, pp9, pp10, pp11, pp12, pp13, pp14, pp15;
	
	assign pp0 = A[0]? B: 32'b00000000000000000000000000000000;
	assign pp1 = A[1]? B: 32'b00000000000000000000000000000000;
	assign pp2 = A[2]? B: 32'b00000000000000000000000000000000;
	assign pp3 = A[3]? B: 32'b00000000000000000000000000000000;
	assign pp4 = A[4]? B: 32'b00000000000000000000000000000000;
	assign pp5 = A[5]? B: 32'b00000000000000000000000000000000;
	assign pp6 = A[6]? B: 32'b00000000000000000000000000000000;
	assign pp7 = A[7]? B: 32'b00000000000000000000000000000000;
	assign pp8 = A[8]? B: 32'b00000000000000000000000000000000;
	assign pp9 = A[9]? B: 32'b00000000000000000000000000000000;
	assign pp10 = A[10]? B: 32'b00000000000000000000000000000000;
	assign pp11 = A[11]? B: 32'b00000000000000000000000000000000;
	assign pp12 = A[12]? B: 32'b00000000000000000000000000000000;
	assign pp13 = A[13]? B: 32'b00000000000000000000000000000000;
	assign pp14 = A[14]? B: 32'b00000000000000000000000000000000;
	assign pp15 = A[15]? B: 32'b00000000000000000000000000000000;
	
	assign product[0] = pp0[0];
	
	/* First Stage */
	half_adder ha01(s1, c1, pp0[1], pp1[0]);
	full_adder fa01(s2, c2, pp0[2], pp1[1], pp2[0]);
	full_adder fa02(s3, c3, pp0[3], pp1[2], pp2[1]);
	full_adder fa03(s4, c4, pp0[4], pp1[3], pp2[2]);
	full_adder fa04(s5, c5, pp0[5], pp1[4], pp2[3]);
	full_adder fa05(s6, c6, pp0[6], pp1[5], pp2[4]);
	full_adder fa06(s7, c7, pp0[7], pp1[6], pp2[5]);
	full_adder fa07(s8, c8, pp0[8], pp1[7], pp2[6]);
	full_adder fa08(s9, c9, pp0[9], pp1[8], pp2[7]);
	full_adder fa09(s10, c10, pp0[10], pp1[9], pp2[8]);
	full_adder fa10(s11, c11, pp0[11], pp1[10], pp2[9]);
	full_adder fa11(s12, c12, pp0[12], pp1[11], pp2[10]);
	full_adder fa12(s13, c13, pp0[13], pp1[12], pp2[11]);
	full_adder fa13(s14, c14, pp0[14], pp1[13], pp2[12]);
	full_adder fa14(s15, c15, pp0[15], pp1[14], pp2[13]);
	half_adder ha02(s16, c16, pp1[15], pp2[14]);
	
	/* Second Stage */
	half_adder ha03(s201, c201, s1, pp3[0]);
	full_adder fa04(s202, c202, s2, pp3[1], c1);
	full_adder fa05(s203, c203, s3, pp3[2], c2);
	full_adder fa06(s204, c204, s4, pp3[3], c3);
	full_adder fa07(s205, c205, s5, pp3[4], c4);
	full_adder fa08(s206, c206, s6, pp3[5], c5);
	full_adder fa09(s207,"
7608.93,2659.47,0.1,93.0,1,"//Please finish designing the 32 bit multiplier module (multiplier_32) below.
//There are two 32 bit inputs (A and B) and a 64 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_32(output [63:0] product, input [31:0] A, B);
    assign product = A * B;
endmodule"
7608.93,2659.47,0.1,94.0,1,"//Please finish designing the 32 bit multiplier module (multiplier_32) below.
//There are two 32 bit inputs (A and B) and a 64 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_32(output [63:0] product, input [31:0] A, B);
    assign product = A * B;
endmodule"
7608.93,2659.47,0.1,95.0,1,"//Please finish designing the 32 bit multiplier module (multiplier_32) below.
//There are two 32 bit inputs (A and B) and a 64 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_32(output [63:0] product, input [31:0] A, B);
    assign product = A * B;
endmodule"
7608.93,2659.47,0.1,96.0,1,"//Please finish designing the 32 bit multiplier module (multiplier_32) below.
//There are two 32 bit inputs (A and B) and a 64 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_32(output [63:0] product, input [31:0] A, B);
    assign product = A * B;
endmodule"
7608.93,2659.47,0.1,97.0,1,"//Please finish designing the 32 bit multiplier module (multiplier_32) below.
//There are two 32 bit inputs (A and B) and a 64 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_32(output [63:0] product, input [31:0] A, B);
    assign product = A * B;
endmodule"
7608.93,2659.47,0.1,98.0,1,"//Please finish designing the 32 bit multiplier module (multiplier_32) below.
//There are two 32 bit inputs (A and B) and a 64 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_32(output [63:0] product, input [31:0] A, B);
    assign product = A * B;
endmodule"
7608.93,2659.47,0.1,99.0,1,"//Please finish designing the 32 bit multiplier module (multiplier_32) below.
//There are two 32 bit inputs (A and B) and a 64 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_32(output [63:0] product, input [31:0] A, B);
    assign product = A * B;
endmodule"
7608.93,2659.47,0.1,100.0,1,"//Please finish designing the 32 bit multiplier module (multiplier_32) below.
//There are two 32 bit inputs (A and B) and a 64 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_32(output [63:0] product, input [31:0] A, B);
    assign product = A * B;
endmodule"
7608.93,2659.47,0.1,101.0,1,"//Please finish designing the 32 bit multiplier module (multiplier_32) below.
//There are two 32 bit inputs (A and B) and a 64 bit output (product).
//The module should utilize the inputs (A and B) to determine the output product correctly in its implementation.
module multiplier_32(output [63:0] product, input [31:0] A, B);
    assign product = A * B;
endmodule"
