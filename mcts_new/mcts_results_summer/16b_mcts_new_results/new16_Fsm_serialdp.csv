Area,Delay,Score,Current Run,Episode,Verilog
N/A,N/A,-1,2.0,1,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serialdata
    // New: Add parity checking.
    
    parity p1(clk, reset, in, odd);
    
    // New: Add serial output byte stream.
    
    serial_out s1(clk, reset, odd, out_byte, done);
    
endmodule"
N/A,N/A,-1,3.0,1,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serialdata
    // New: Add parity checking.
    
    parity p1(clk, reset, in, odd);
    
    // New: Add serial output byte stream.
    
    serial_out s1(clk, reset, odd, out_byte, done);
    
endmodule"
N/A,N/A,-1,4.0,1,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    parameter START = 0, DATA = 1, STOP = 2, DELAY = 3;
    reg [1:0] state, next_state;
    reg [9:0] count;
    reg out;
    
    always @(*) begin
        case (state)
            START: begin
                if(in)
                    next_state = DATA;
                else
                    next_state = START;
                out_byte = 0;
                count = 0;
            end
            DATA: begin
                out_byte[7] = out;
                if(count == 10)
                    next_state = STOP;
                else if(in)
                    next_state = DATA;
                else
                    next_state = START;
                count = count + 1;
            end
            STOP: begin
                done = 1;
                if(in)
                    next_state = START;
                else
                    next_state = STOP;
            end
            DELAY: begin
                done = 0;
                if(in)
                    next_state = DELAY;
                else
                    next_state = START;
            end
            default: begin
                next_state = START;
                out_byte = 0;
                count = 0;
                done = 0;
            end
        endcase
    end
    
    always @(posedge clk) begin
        if(reset)
            state <= START;
        else
            state <= next_state;
    end
    
    assign out = (state == DATA)? out_byte[7] : 0;
    
endmodule"
N/A,N/A,-1,5.0,1,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.
    
    parity p1(clk, reset, in, odd);
    
    // New: Add the byte counter.
    
    reg [3:0] counter;
    
    always @(posedge clk)
        if (reset) counter <= 0;
        else if (counter < 8) counter <= counter + 1;
        else done <= 1;
    
    // New: Add the output byte.
    
    assign out_byte = {in, odd};
    
endmodule"
N/A,N/A,-1,6.0,1,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.
    
    parity p1(clk, reset, in, odd);
    
    // New: Add the byte counter.
    
    reg [3:0] counter;
    
    always @(posedge clk)
        if (reset) counter <= 0;
        else if (counter < 8) counter <= counter + 1;
        else done <= 1;
    
    // New: Add the output byte.
    
    assign out_byte = {in, odd};
    
endmodule"
N/A,N/A,-1,7.0,1,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.
    
    parity p1(clk, reset, in, odd);
    
    // New: Add the byte counter.
    
    reg [3:0] counter;
    
    always @(posedge clk)
        if (reset) counter <= 0;
        else if (counter < 8) counter <= counter + 1;
        else done <= 1;
    
    // New: Add the output byte.
    
    assign out_byte = {in, odd};
    
endmodule"
N/A,N/A,-1,8.0,1,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.
    
    parity p1(clk, reset, in, odd);
    
    // New: Add the byte counter.
    
    reg [3:0] counter;
    
    always @(posedge clk)
        if (reset) counter <= 0;
        else if (counter < 8) counter <= counter + 1;
        else done <= 1;
    
    // New: Add the output byte.
    
    assign out_byte = {in, odd};
    
endmodule"
N/A,N/A,-1,9.0,1,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    parameter BYTE_SIZE = 8;
    
    // Define states
    localparam IDLE = 0, RWAIT = 1;
    
    // Define state transitions
    always @(*)
        case (state)
            IDLE: next_state = in? RWAIT : IDLE;
            RWAIT: next_state = done? IDLE : RWAIT;
            default: next_state = IDLE;
        endcase
    
    // Define state register
    reg state = IDLE;
    
    // Define output signals
    assign done = (state == IDLE);
    
    // New: Datapath to accumulate input bits.
    reg [BYTE_SIZE-1:0] byte_in = 0;
    
    // New: Output byte
    reg [7:0] byte_out = 0;
    
    // New: Parity bit
    reg odd = 0;
    
    // Define state machine
    always @(posedge clk)
        if (reset)
            state <= IDLE;
        else
            state <= next_state;
    
    // New: Parity bit
    always @(posedge clk)
        if (reset)
            byte_in <= 0;
        else if (next_state == RWAIT)
            byte_in <= {in, odd};
    
    // New: Accumulate input bits
    always @(posedge clk)
        if (reset)
            byte_out <= 0;
        else if (next_state == RWAIT)
            byte_out <= byte_in;
    
    // New: Output byte
    always @(posedge clk)
        if (reset)
            out_byte <= 0;
        else if (next_state == IDLE)
            out_byte <= byte_out;
    
    // New: Parity bit
    always @(posedge clk)
        if (reset)
            odd <= 0;
        else if (next_state == RWAIT)
            odd <= byte_out[0];
    
endmodule"
N/A,N/A,-1,10.0,1,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    parameter START = 0, DATA = 1, STOP = 2, DELAY = 3;
    reg [1:0] state, next_state;
    reg [3:0] count;
    reg out;
    
    always @(*) begin
        case (state)
            START: begin
                if(in)
                    next_state = DATA;
                else
                    next_state = START;
            end
            DATA: begin
                if(count == 8)
                    next_state = STOP;
                else if(in)
                    next_state = DATA;
                else
                    next_state = START;
            end
            STOP: begin
                if(in) begin
                    next_state = START;
                    out_byte[count] <= in;
                end
                else
                    next_state = DELAY;
            end
            DELAY: next_state = (count < 4)? DATA : START;
            default: next_state = START;
        endcase
    end
    
    always @(posedge clk) begin
        if(reset)
            state <= START;
        else
            state <= next_state;
    end
    
    always @(posedge clk) begin
        if(state == DATA)
            count <= count + 1;
        else
            count <= 0;
    end
    
    assign done = (state == STOP);
    assign out_byte = out? 8'b11111111 : 8'b00000000;
    
    always @(*) begin
        if(state == DATA)
            out = in;
        else
            out = 1'b0;
    end

endmodule"
N/A,N/A,-1,11.0,1,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    parameter START = 3'd0, DATA = 3'd1, PARITY = 3'd2, STOP = 3'd3, DELAY = 3'd4;
    reg [2:0] state, next_state;
    reg [7:0] data;
    reg odd;
    reg out;
    reg [2:0] count;
    
    always @(posedge clk)
        if (reset)
            state <= START;
        else
            state <= next_state;
    
    always @(*)
        case (state)
            START:
                begin
                    if (in)
                        next_state = DATA;
                    else
                        next_state = START;
                end
            DATA:
                begin
                    if (count == 7)
                        next_state = PARITY;
                    else
                        next_state = DATA;
                end
            PARITY:
                begin
                    if (count == 7)
                        next_state = STOP;
                    else
                        next_state = PARITY;
                end
            STOP:
                begin
                    if (count == 7)
                        next_state = DELAY;
                    else
                        next_state = START;
                end
            DELAY:
                begin
                    if (count == 3)
                        next_state = START;
                    else
                        next_state = DELAY;
                end
            default:
                next_state = START;
        endcase
    
    always @(posedge clk)
        if (reset)
            count <= 0;
        else if (state == DATA)
            count <= count + 1;
    
    always @(posedge clk)
        if (reset)
            data <= 0;
        else if (state == DATA)
            data <= data << 1;
        else if (state == PARITY)
            data <= {data[6:0], odd};
    
    always @(posedge clk)
        if (reset)
            out <= 0;
        else if (state == STOP)
            out <= 1;
    
    assign done = (state == DELAY);
    assign out_byte = out? data : 8'bzzzz_zzzz;
    
endmodule"
N/A,N/A,-1,12.0,1,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serialdata
    // New: Add parity checking.
    
    parameter idle = 0, rec_data = 1, stop_bit = 2;
    reg [1:0] state, next_state;
    reg odd;
    reg [8:0] rec_data_bits;
    reg [7:0] out_byte_reg;
    
    always @(posedge clk)
        if (reset) state <= idle;
        else state <= next_state;
    
    always @(*)
        case (state)
            idle:
                if (in) next_state = rec_data;
                else next_state = idle;
            rec_data:
                if (rec_data_bits[8])
                    next_state = stop_bit;
                else
                    next_state = rec_data;
            stop_bit:
                if (in)
                    next_state = idle;
                else
                    next_state = rec_data;
            default:
                next_state = idle;
        endcase
    
    // New: Add parity checking.
    
    always @(posedge clk)
        if (reset) odd <= 0;
        else if (state == rec_data)
            if (rec_data_bits[8])
                odd <= rec_data_bits[0] ^ rec_data_bits[1];
    
    always @(posedge clk)
        if (reset) out_byte_reg <= 0;
        else if (state == rec_data)
            if (rec_data_bits[8])
                out_byte_reg <= {rec_data_bits[7:0], in};
    
    assign out_byte = out_byte_reg;
    assign done = (state == stop_bit);
    
    always @(posedge clk)
        if (reset) rec_data_bits <= 0;
        else if (state == rec_data)
            if (in)
                rec_data_bits <= rec_data_bits + 9'b1;
            else
                rec_data_bits <= rec_data_bits - 9'b1;
    
endmodule"
N/A,N/A,-1,13.0,1,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    // Use FSM from Fsm_serialdata
    // New: Add parity checking.
    
    parameter idle = 0, rec_data = 1, stop_bit = 2, parity_bit = 3;
    reg [2:0] state, next_state;
    reg odd;
    reg [8:0] rec_data_bits;
    reg [7:0] out_byte_reg;
    
    always @(posedge clk)
        if (reset) state <= idle;
        else state <= next_state;
    
    always @(*)
        case (state)
            idle:
                if (in) next_state = rec_data;
                else next_state = idle;
            rec_data:
                if (rec_data_bits[8]) next_state = stop_bit;
                else next_state = rec_data;
            stop_bit:
                if (in) next_state = idle;
                else next_state = parity_bit;
            parity_bit:
                if (in) next_state = idle;
                else next_state = rec_data;
            default:
                next_state = idle;
        endcase
    
    always @(posedge clk)
        if (reset) begin
            rec_data_bits <= 0;
            out_byte_reg <= 0;
        end
        else begin
            // New: Add parity checking.
            case (state)
                idle:
                    if (in) begin
                        rec_data_bits <= 9'b100000000;
                        out_byte_reg <= 8'b0;
                    end
                rec_data:
                    if (rec_data_bits[8]) begin
                        rec_data_bits <= 9'b0;
                        out_byte_reg <= {out_byte_reg[6:0], in};
                    end
                    else begin
                        rec_data_bits <= rec_data_bits << 1;
                        rec_data_bits[0] <= in;
                    end
                stop_bit:
                    if (in) begin
                        out_byte <= out_byte_reg;
                        done <= 1'b1;
                    end
                parity_bit:
                    if (in) odd <= ~odd;
            endcase
        end
    
endmodule"
N/A,N/A,-1,14.0,1,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    parameter START = 0, DATA = 1, STOP = 2, DELAY = 3;
    reg [1:0] state, next_state;
    reg [3:0] count;
    reg out;
    
    always @(posedge clk)
        if (reset)
            state <= START;
        else
            state <= next_state;
    
    always @(*)
        case (state)
            START:
                begin
                    if (in)
                        next_state = DATA;
                    else
                        next_state = START;
                end
            DATA:
                begin
                    if (count == 8)
                        next_state = STOP;
                    else
                        next_state = DATA;
                end
            STOP:
                begin
                    if (in)
                        next_state = DELAY;
                    else
                        next_state = START;
                end
            DELAY:
                begin
                    if (count == 4)
                        next_state = START;
                    else
                        next_state = DELAY;
                end
        endcase
    
    always @(posedge clk)
        if (reset)
            count <= 0;
        else if (state == DATA)
            count <= count + 1;
    
    always @(*)
        case (state)
            START:
                begin
                    out_byte <= 8'b0;
                    out <= 0;
                end
            DATA:
                begin
                    out_byte[count] <= in;
                    out <= out_byte[0];
                end
            STOP:
                out <= 1;
            DELAY:
                out <= 0;
        endcase
    
    assign done = (state == DELAY);
    
endmodule"
N/A,N/A,-1,15.0,1,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    parameter START = 0, DATA = 1, STOP = 2, DELAY = 3;
    reg [1:0] state, next_state;
    reg [3:0] count;
    reg out;
    
    always @(posedge clk)
        if (reset)
            state <= START;
        else
            state <= next_state;
    
    always @(*)
        case (state)
            START:
                begin
                    if (in)
                        next_state = DATA;
                    else
                        next_state = START;
                end
            DATA:
                begin
                    if (count == 8)
                        next_state = STOP;
                    else
                        next_state = DATA;
                end
            STOP:
                begin
                    if (in)
                        next_state = DELAY;
                    else
                        next_state = START;
                end
            DELAY:
                begin
                    if (count == 4)
                        next_state = START;
                    else
                        next_state = DELAY;
                end
        endcase
    
    always @(posedge clk)
        if (reset)
            count <= 0;
        else if (state == DATA)
            count <= count + 1;
    
    always @(*)
        case (state)
            START:
                begin
                    out_byte <= 8'b0;
                    out <= 0;
                end
            DATA:
                begin
                    out_byte[count] <= in;
                    out <= out_byte[0];
                end
            STOP:
                out <= 1;
            DELAY:
                out <= 0;
        endcase
    
    assign done = (state == DELAY);
    
endmodule"
N/A,N/A,-1,16.0,1,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    parameter START = 0, DATA = 1, STOP = 2, DELAY = 3;
    reg [1:0] state, next_state;
    reg [3:0] count;
    reg out;
    
    always @(posedge clk)
        if (reset)
            state <= START;
        else
            state <= next_state;
    
    always @(*)
        case (state)
            START:
                begin
                    if (in)
                        next_state = DATA;
                    else
                        next_state = START;
                end
            DATA:
                begin
                    if (count == 8)
                        next_state = STOP;
                    else
                        next_state = DATA;
                end
            STOP:
                begin
                    if (in)
                        next_state = DELAY;
                    else
                        next_state = START;
                end
            DELAY:
                begin
                    if (count == 4)
                        next_state = START;
                    else
                        next_state = DELAY;
                end
        endcase
    
    always @(posedge clk)
        if (reset)
            count <= 0;
        else if (state == DATA)
            count <= count + 1;
    
    always @(*)
        case (state)
            START:
                begin
                    out_byte <= 8'b0;
                    out <= 0;
                end
            DATA:
                begin
                    out_byte[count] <= in;
                    out <= out_byte[0];
                end
            STOP:
                out <= 1;
            DELAY:
                out <= 0;
        endcase
    
    assign done = (state == DELAY);
    
endmodule"
N/A,N/A,-1,17.0,1,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    parameter START = 0, DATA = 1, STOP = 2, DELAY = 3;
    reg [1:0] state, next_state;
    reg [3:0] count;
    reg out;
    
    always @(posedge clk)
        if (reset)
            state <= START;
        else
            state <= next_state;
    
    always @(*)
        case (state)
            START:
                begin
                    if (in)
                        next_state = DATA;
                    else
                        next_state = START;
                end
            DATA:
                begin
                    if (count == 8)
                        next_state = STOP;
                    else
                        next_state = DATA;
                end
            STOP:
                begin
                    if (in)
                        next_state = DELAY;
                    else
                        next_state = START;
                end
            DELAY:
                begin
                    if (count == 4)
                        next_state = START;
                    else
                        next_state = DELAY;
                end
        endcase
    
    always @(posedge clk)
        if (reset)
            count <= 0;
        else if (state == DATA)
            count <= count + 1;
    
    always @(*)
        case (state)
            START:
                begin
                    out_byte <= 8'b0;
                    out <= 0;
                end
            DATA:
                begin
                    out_byte[count] <= in;
                    out <= out_byte[0];
                end
            STOP:
                out <= 1;
            DELAY:
                out <= 0;
        endcase
    
    assign done = (state == DELAY);
    
endmodule"
N/A,N/A,-1,18.0,1,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    parameter START = 3'd0, DATA = 3'd1, PARITY = 3'd2, STOP = 3'd3, DELAY = 3'd4;
    reg [2:0] state, next_state;
    reg [7:0] data;
    reg odd;
    
    always @(posedge clk)
        if (reset)
            state <= START;
        else
            state <= next_state;
    
    always @(*)
        case (state)
            START:
                begin
                    if (in)
                        next_state = DATA;
                    else
                        next_state = START;
                end
            DATA:
                begin
                    if (in)
                        next_state = DATA;
                    else
                        next_state = PARITY;
                end
            PARITY:
                begin
                    if (in)
                        next_state = STOP;
                    else
                        next_state = PARITY;
                end
            STOP:
                begin
                    if (in)
                        next_state = DELAY;
                    else
                        next_state = START;
                end
            DELAY:
                begin
                    if (in)
                        next_state = DELAY;
                    else
                        next_state = START;
                end
            default:
                next_state = START;
        endcase
    
    always @(posedge clk)
        if (reset)
            data <= 8'd0;
        else if (state == DATA)
            data <= {in, data[7:1]};
    
    assign out_byte = data;
    assign done = (state == DELAY);
    
    always @(posedge clk)
        if (reset)
            odd <= 1'b0;
        else if (state == PARITY)
            odd <= ~in;
    
endmodule"
N/A,N/A,-1,19.0,1,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    parameter START = 3'd0, DATA = 3'd1, PARITY = 3'd2, STOP = 3'd3, DELAY = 3'd4;
    reg [2:0] state, next_state;
    reg [7:0] data;
    reg odd;
    
    always @(posedge clk)
        if (reset)
            state <= START;
        else
            state <= next_state;
    
    always @(*)
        case (state)
            START:
                begin
                    if (in)
                        next_state = DATA;
                    else
                        next_state = START;
                end
            DATA:
                begin
                    if (in)
                        next_state = DATA;
                    else
                        next_state = PARITY;
                end
            PARITY:
                begin
                    if (in)
                        next_state = STOP;
                    else
                        next_state = PARITY;
                end
            STOP:
                begin
                    if (in)
                        next_state = DELAY;
                    else
                        next_state = START;
                end
            DELAY:
                begin
                    if (in)
                        next_state = DELAY;
                    else
                        next_state = START;
                end
            default:
                next_state = START;
        endcase
    
    always @(posedge clk)
        if (reset)
            data <= 8'd0;
        else if (state == DATA)
            data <= {in, data[7:1]};
    
    assign out_byte = data;
    assign done = (state == DELAY);
    
    always @(posedge clk)
        if (reset)
            odd <= 1'b0;
        else if (state == PARITY)
            odd <= ~in;
    
endmodule"
N/A,N/A,-1,20.0,1,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    parameter START = 0, DATA = 1, STOP = 2, DELAY = 3;
    reg [1:0] state, next_state;
    reg [9:0] count;
    reg out;
    
    always @(*) begin
        case (state)
            START: begin
                if(in)
                    next_state = DATA;
                else
                    next_state = START;
            end
            DATA: begin
                if(count == 1023)
                    next_state = STOP;
                else if(in)
                    next_state = DATA;
                else
                    next_state = START;
            end
            STOP: begin
                if(in)
                    next_state = DELAY;
                else
                    next_state = START;
            end
            DELAY: begin
                if(count == 1023)
                    next_state = START;
                else
                    next_state = DELAY;
            end
            default: next_state = START;
        endcase
    end
    
    always @(posedge clk) begin
        if(reset)
            state <= START;
        else
            state <= next_state;
    end
    
    always @(posedge clk) begin
        if(state == DATA)
            count <= count + 1;
        else
            count <= 0;
    end
    
    always @(posedge clk) begin
        if(state == STOP) begin
            out_byte[7] <= in;
            out_byte[6] <= in;
            out_byte[5] <= in;
            out_byte[4] <= in;
            out_byte[3] <= in;
            out_byte[2] <= in;
            out_byte[1] <= in;
            out_byte[0] <= in;
            out <= 0;
        end
        else
            out <= out;
    end
    
    assign done = (state == DELAY);
    
endmodule"
N/A,N/A,-1,21.0,1,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    parameter START = 3'd0, DATA = 3'd1, PARITY = 3'd2, STOP = 3'd3, DELAY = 3'd4;
    reg [2:0] state, next_state;
    reg [8:0] counter;
    reg odd;
    reg [7:0] out;
    
    always @(posedge clk)
        if (reset)
            state <= START;
        else
            state <= next_state;
            
    always @(*)
        case (state)
            START: begin
                if (in)
                    next_state = DATA;
                else
                    next_state = START;
            end
            DATA: begin
                if (counter < 9'd255)
                    next_state = DATA;
                else
                    next_state = PARITY;
            end
            PARITY: begin
                if (counter < 9'd255)
                    next_state = PARITY;
                else
                    next_state = STOP;
            end
            STOP: begin
                if (counter < 9'd255)
                    next_state = DELAY;
                else
                    next_state = START;
            end
            DELAY: begin
                if (counter < 9'd255)
                    next_state = DELAY;
                else
                    next_state = DATA;
            end
            default: next_state = START;
        endcase
    
    always @(posedge clk)
        if (reset)
            counter <= 9'd0;
        else if (state == DATA || state == PARITY)
            counter <= counter + 9'd1;
        else
            counter <= 9'd0;
    
    always @(posedge clk)
        if (reset)
            odd <= 1'b0;
        else if (state == PARITY)
            odd <= ~odd;
    
    always @(posedge clk)
        if (reset)
            out <= 8'd0;
        else if (state == DATA)
            out <= {out, in};
    
    assign done = (state == STOP);
    assign out_byte = odd? ~out : out;
    
endmodule"
N/A,N/A,-1,22.0,1,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serialdata
    // New: Add parity checking.
    
    parity p1(clk, reset, in, odd);
    
    // New: Add serial output byte stream.
    
    serialdata s1(clk, reset, odd, in, out_byte, done);
    
endmodule"
N/A,N/A,-1,23.0,1,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serialdata
    // New: Add parity checking.
    
    parity p1(clk, reset, in, odd);
    
    // New: Add serial output byte stream.
    
    serialdata s1(clk, reset, odd, in, out_byte, done);
    
endmodule"
N/A,N/A,-1,24.0,1,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    parameter START = 0, DATA = 1, STOP = 2, DELAY = 3;
    reg [1:0] state, next_state;
    reg [9:0] count;
    reg out;
    
    always @(posedge clk) begin
        if (reset)
            state <= START;
        else
            state <= next_state;
    end
    
    always @(*) begin
        case (state)
            START: begin
                if(in)
                    next_state = DATA;
                else
                    next_state = START;
            end
            DATA: begin
                if(count == 1023)
                    next_state = STOP;
                else
                    next_state = DATA;
            end
            STOP: begin
                if(in)
                    next_state = DELAY;
                else
                    next_state = START;
            end
            DELAY: begin
                if(count == 1023)
                    next_state = DELAY;
                else
                    next_state = DATA;
            end
            default: next_state = START;
        endcase
    end
    
    always @(posedge clk) begin
        if (reset) begin
            count <= 0;
            out <= 0;
        end
        else begin
            case (state)
                START: begin
                    out <= 0;
                    count <= 0;
                end
                DATA: begin
                    count <= count + 1;
                    out <= in;
                end
                STOP: begin
                    out <= 0;
                    count <= count + 1;
                end
                DELAY: begin
                    count <= count + 1;
                end
            endcase
        end
    end
    
    assign done = (state == DELAY);
    assign out_byte = out;
    
endmodule"
N/A,N/A,-1,25.0,1,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    parameter START = 0, DATA = 1, STOP = 2, DELAY = 3;
    reg [1:0] state, next_state;
    reg [9:0] count;
    reg out;
    
    always @(posedge clk) begin
        if (reset)
            state <= START;
        else
            state <= next_state;
    end
    
    always @(*) begin
        case (state)
            START: begin
                if(in)
                    next_state = DATA;
                else
                    next_state = START;
            end
            DATA: begin
                if(count == 1023)
                    next_state = STOP;
                else
                    next_state = DATA;
            end
            STOP: begin
                if(in)
                    next_state = DELAY;
                else
                    next_state = START;
            end
            DELAY: begin
                if(count == 1023)
                    next_state = DELAY;
                else
                    next_state = DATA;
            end
            default: next_state = START;
        endcase
    end
    
    always @(posedge clk) begin
        if (reset) begin
            count <= 0;
            out <= 0;
        end
        else begin
            case (state)
                START: begin
                    out <= 0;
                    count <= 0;
                end
                DATA: begin
                    count <= count + 1;
                    out <= in;
                end
                STOP: begin
                    out <= 0;
                    count <= count + 1;
                end
                DELAY: begin
                    count <= count + 1;
                end
            endcase
        end
    end
    
    assign done = (state == DELAY);
    assign out_byte = out;
    
endmodule"
N/A,N/A,-1,26.0,1,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.
    
    parameter idle = 3'b000, start = 3'b001, data = 3'b010, stop = 3'b011, end = 3'b100;
    reg [2:0] state, next_state;
    reg odd;
    reg [8:0] counter;
    reg [7:0] data_byte;
    
    always @(posedge clk)
        if (reset) state <= idle;
        else state <= next_state;
    
    always @(*)
        case (state)
            idle:
                if (in)
                    next_state = start;
                else
                    next_state = idle;
            start:
                if (counter == 9'd255)
                    next_state = data;
                else
                    next_state = start;
            data:
                if (counter == 9'd255)
                    next_state = stop;
                else
                    next_state = data;
            stop:
                if (counter == 9'd255)
                    next_state = end;
                else
                    next_state = stop;
            endcase
    
    always @(posedge clk)
        if (reset)
            counter <= 9'd0;
        else if (next_state == data)
            counter <= counter + 1'b1;
        else
            counter <= 9'd0;
    
    always @(posedge clk)
        if (reset)
            data_byte <= 8'd0;
        else if (next_state == start)
            data_byte <= in;
        else if (next_state == data)
            data_byte <= data_byte + 1'b1;
        else
            data_byte <= 8'd0;
    
    always @(posedge clk)
        if (reset)
            odd <= 0;
        else if (next_state == start)
            odd <= 1'b0;
        else if (next_state == data)
            odd <= ~odd;
        else
            odd <= 1'b0;
    
    assign done = (state == end);
    assign out_byte = data_byte;
    
endmodule"
N/A,N/A,-1,27.0,1,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    // Use FSM from Fsm_serialdata
    // New: Add parity checking.
    // New: Add state to control when the stop bit is detected.
    
    parameter idle = 0, rec_data = 1, stop_bit = 2;
    reg [1:0] state, next_state;
    reg [3:0] counter;
    reg odd;
    
    always @(posedge clk)
        if (reset) state <= idle;
        else state <= next_state;
    
    always @(*)
        case (state)
            idle:
                begin
                    if (in)
                        next_state <= rec_data;
                    else
                        next_state <= idle;
                end
            rec_data:
                begin
                    if (counter == 7)
                        next_state <= stop_bit;
                    else
                        next_state <= rec_data;
                end
            stop_bit:
                begin
                    if (in)
                        next_state <= idle;
                    else
                        next_state <= idle;
                end
            default:
                next_state <= idle;
        endcase
    
    always @(posedge clk)
        if (reset) counter <= 0;
        else if (state == rec_data && in)
            counter <= counter + 1;
        else if (state == stop_bit && in)
            counter <= 0;
    
    assign done = (state == stop_bit) && (counter == 7);
    
    assign out_byte = {in, odd};
    
    // New: Add parity checking.
    parity p1(clk, reset, in, odd);

endmodule"
N/A,N/A,-1,28.0,1,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    parameter START = 3'd0, DATA = 3'd1, PARITY = 3'd2, STOP = 3'd3, DELAY = 3'd4;
    reg [2:0] state, next_state;
    reg [8:0] counter;
    reg odd;
    
    always @(posedge clk) begin
        if (reset)
            state <= START;
        else
            state <= next_state;
    end
    
    always @(*) begin
        case (state)
            START: begin
                if (in)
                    next_state = DATA;
                else
                    next_state = START;
            end
            DATA: begin
                if (counter < 9'd255)
                    next_state = DATA;
                else
                    next_state = PARITY;
            end
            PARITY: begin
                if (counter < 9'd255)
                    next_state = PARITY;
                else
                    next_state = STOP;
            end
            STOP: begin
                if (in)
                    next_state = DELAY;
                else
                    next_state = START;
            end
            DELAY: begin
                if (counter < 9'd255)
                    next_state = DELAY;
                else
                    next_state = START;
            end
            default: next_state = START;
        endcase
    end
    
    always @(posedge clk) begin
        if (reset) begin
            state <= START;
            counter <= 0;
        end
        else begin
            case (state)
                START: begin
                    counter <= 0;
                    odd <= 0;
                end
                DATA: begin
                    counter <= counter + 1;
                end
                PARITY: begin
                    counter <= counter + 1;
                    odd <= odd ^ in;
                end
                STOP: begin
                    counter <= counter + 1;
                end
                DELAY: begin
                    counter <= counter + 1;
                end
            endcase
        end
    end
    
    assign done = (state == DELAY);
    assign out_byte = (state == DATA)? {in, odd} : 8'b0;
    
endmodule"
N/A,N/A,-1,29.0,1,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    parameter BYTE_SIZE = 8;
    
    // Define states
    parameter IDLE = 0, RWAIT = 1, RWAIT2 = 2, WWAIT = 3, DATA = 4;
    reg [1:0] state, next_state;
    
    // Define state transitions
    always @(*)
        case (state)
            IDLE: next_state <= in? RWAIT : IDLE;
            RWAIT: next_state <= in? RWAIT2 : WWAIT;
            RWAIT2: next_state <= in? RWAIT : DATA;
            WWAIT: next_state <= in? RWAIT : IDLE;
            DATA: next_state <= in? RWAIT : DATA;
            default: next_state <= IDLE;
        endcase
    
    // Define outputs
    assign done = (state == DATA) && (next_state == IDLE);
    assign out_byte = (state == DATA)? {in, out_byte[7:1]} : 8'b0;
    
    // Instansiate datapath
    // New: Add parity checking.
    parity p1(clk, reset, in, odd);
    
    // State registers
    always @(posedge clk)
        if (reset)
            state <= IDLE;
        else
            state <= next_state;

endmodule"
N/A,N/A,-1,30.0,1,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    parameter START = 0, DATA = 1, STOP = 2, DELAY = 3;
    reg [1:0] state, next_state;
    reg [3:0] count;
    reg out;
    
    always @(*) begin
        case (state)
            START: begin
                if(in)
                    next_state = DATA;
                else
                    next_state = START;
                out_byte = 4'b0000;
            end
            DATA: begin
                out_byte = {in, out_byte[7:1]};
                if(count == 7)
                    next_state = STOP;
                else
                    next_state = DATA;
            end
            STOP: begin
                done = 1;
                if(in) begin
                    next_state = START;
                    out_byte = 4'b0000;
                end
                else
                    next_state = DELAY;
            end
            DELAY: begin
                done = 0;
                if(count == 4)
                    next_state = START;
                else
                    next_state = DELAY;
            end
            default: begin
                next_state = START;
                out_byte = 4'b0000;
            end
        endcase
    end
    
    always @(posedge clk) begin
        if(reset) begin
            state <= START;
            count <= 0;
            out <= 0;
        end
        else begin
            state <= next_state;
            if(next_state == DATA)
                count <= count + 1;
            else
                count <= 0;
            if(next_state == STOP)
                out <= ~in;
            else
                out <= in;
        end
    end
endmodule"
N/A,N/A,-1,31.0,1,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    parameter START = 3'd0, DATA = 3'd1, PARITY = 3'd2, STOP = 3'd3, DELAY = 3'd4;
    reg [2:0] state, next_state;
    reg [7:0] data;
    reg odd;
    
    always @(posedge clk)
        if (reset)
            state <= START;
    	else
            state <= next_state;
    
    always @(*)
        case (state)
            START: begin
                if (in)
                    next_state = DATA;
                else
                    next_state = START;
            end
            DATA: next_state = parity(clk, in)? DATA : DELAY;
            DELAY: next_state = parity(clk, in)? DATA : PARITY;
            PARITY: next_state = parity(clk, in)? STOP : DELAY;
            STOP: next_state = START;
            default: next_state = START;
        endcase
    
    assign odd = data[0] ^ data[1] ^ data[2] ^ data[3] ^ data[4] ^ data[5] ^ data[6] ^ data[7];
    
    always @(posedge clk)
        if (reset)
            data <= 8'b0;
    	else if (state == DATA)
            data <= {in, data[7:1]};
    
    assign out_byte = odd? {data[0], data[7:1]} : {data[1], data[7:2]};
    
    assign done = (state == STOP);
    
endmodule"
N/A,N/A,-1,32.0,1,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    parameter START = 3'd0, DATA = 3'd1, PARITY = 3'd2, STOP = 3'd3, DELAY = 3'd4;
    reg [2:0] state, next_state;
    reg [7:0] data;
    reg odd;
    
    always @(posedge clk)
        if (reset)
            state <= START;
    	else
            state <= next_state;
    
    always @(*)
        case (state)
            START: begin
                if (in)
                    next_state = DATA;
                else
                    next_state = START;
            end
            DATA: next_state = parity(clk, in)? DATA : DELAY;
            DELAY: next_state = parity(clk, in)? DATA : PARITY;
            PARITY: next_state = parity(clk, in)? STOP : DELAY;
            STOP: next_state = START;
            default: next_state = START;
        endcase
    
    assign odd = data[0] ^ data[1] ^ data[2] ^ data[3] ^ data[4] ^ data[5] ^ data[6] ^ data[7];
    
    always @(posedge clk)
        if (reset)
            data <= 8'b0;
    	else if (state == DATA)
            data <= {in, data[7:1]};
    
    assign out_byte = odd? {data[0], data[7:1]} : {data[1], data[7:2]};
    
    assign done = (state == STOP);
    
endmodule"
N/A,N/A,-1,33.0,1,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    parameter START = 3'd0, DATA = 3'd1, PARITY = 3'd2, STOP = 3'd3, DELAY = 3'd4;
    reg [2:0] state, next_state;
    reg [7:0] data;
    reg odd;
    
    always @(posedge clk)
        if (reset)
            state <= START;
    	else
            state <= next_state;
    
    always @(*)
        case (state)
            START: begin
                if (in)
                    next_state = DATA;
                else
                    next_state = START;
            end
            DATA: next_state = parity(clk, in)? DATA : DELAY;
            DELAY: next_state = parity(clk, in)? DATA : PARITY;
            PARITY: next_state = parity(clk, in)? STOP : DELAY;
            STOP: next_state = START;
            default: next_state = START;
        endcase
    
    assign odd = data[0] ^ data[1] ^ data[2] ^ data[3] ^ data[4] ^ data[5] ^ data[6] ^ data[7];
    
    always @(posedge clk)
        if (reset)
            data <= 8'b0;
    	else if (state == DATA)
            data <= {in, data[7:1]};
    
    assign out_byte = odd? {data[0], data[7:1]} : {data[1], data[7:2]};
    
    assign done = (state == STOP);
    
endmodule"
N/A,N/A,-1,34.0,1,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    parameter START = 0, DATA = 1, STOP = 2, DELAY = 3;
    reg [1:0] state, next_state;
    reg [3:0] count;
    reg out;
    
    always @(*) begin
        case (state)
            START: begin
                if(in)
                    next_state = DATA;
                else
                    next_state = START;
            end
            DATA: begin
                if(count < 9)
                    next_state = DATA;
                else
                    next_state = STOP;
            end
            STOP: begin
                if(in)
                    next_state = START;
                else
                    next_state = DELAY;
            end
            DELAY: begin
                if(count < 19)
                    next_state = DELAY;
                else
                    next_state = START;
            end
        endcase
    end
    
    always @(posedge clk) begin
        if(reset)
            state <= START;
        else
            state <= next_state;
    end
    
    always @(posedge clk) begin
        if(state == DATA)
            count <= count + 1;
        else
            count <= 0;
    end
    
    always @(*) begin
        case (state)
            START: begin
                out_byte = 8'b0;
                done = 0;
            end
            DATA: begin
                if(count < 9)
                    out_byte = {out, in};
                else
                    done = 1;
            end
            STOP: begin
                out = 1;
            end
            DELAY: begin
                done = 0;
            end
        endcase
    end
    
endmodule"
N/A,N/A,-1,35.0,1,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    parameter START = 0, DATA = 1, STOP = 2, DELAY = 3;
    reg [1:0] state, next_state;
    reg [3:0] count;
    reg out;
    
    always @(*) begin
        case (state)
            START: begin
                if(in)
                    next_state = DATA;
                else
                    next_state = START;
            end
            DATA: begin
                if(count < 9)
                    next_state = DATA;
                else
                    next_state = STOP;
            end
            STOP: begin
                if(in)
                    next_state = START;
                else
                    next_state = DELAY;
            end
            DELAY: begin
                if(count < 19)
                    next_state = DELAY;
                else
                    next_state = START;
            end
        endcase
    end
    
    always @(posedge clk) begin
        if(reset)
            state <= START;
        else
            state <= next_state;
    end
    
    always @(posedge clk) begin
        if(state == DATA)
            count <= count + 1;
        else
            count <= 0;
    end
    
    always @(*) begin
        case (state)
            START: begin
                out_byte = 8'b0;
                done = 0;
            end
            DATA: begin
                if(count < 9)
                    out_byte = {out, in};
                else
                    done = 1;
            end
            STOP: begin
                out = 1;
            end
            DELAY: begin
                done = 0;
            end
        endcase
    end
    
endmodule"
N/A,N/A,-1,36.0,1,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    parameter START = 0, DATA = 1, STOP = 2, DELAY = 3;
    reg [1:0] state, next_state;
    reg [3:0] count;
    reg out;
    
    always @(*) begin
        case (state)
            START: begin
                if(in)
                    next_state = DATA;
                else
                    next_state = START;
            end
            DATA: begin
                if(count < 9)
                    next_state = DATA;
                else
                    next_state = STOP;
            end
            STOP: begin
                if(in)
                    next_state = START;
                else
                    next_state = DELAY;
            end
            DELAY: begin
                if(count < 19)
                    next_state = DELAY;
                else
                    next_state = START;
            end
        endcase
    end
    
    always @(posedge clk) begin
        if(reset)
            state <= START;
        else
            state <= next_state;
    end
    
    always @(posedge clk) begin
        if(state == DATA)
            count <= count + 1;
        else
            count <= 0;
    end
    
    always @(*) begin
        case (state)
            START: begin
                out_byte = 8'b0;
                done = 0;
            end
            DATA: begin
                if(count < 9)
                    out_byte = {out, in};
                else
                    done = 1;
            end
            STOP: begin
                out = 1;
            end
            DELAY: begin
                done = 0;
            end
        endcase
    end
    
endmodule"
N/A,N/A,-1,37.0,1,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    parameter START = 0, DATA = 1, STOP = 2, DELAY = 3;
    reg [1:0] state, next_state;
    reg [3:0] count;
    reg out;
    
    always @(*) begin
        case (state)
            START: begin
                if(in)
                    next_state = DATA;
                else
                    next_state = START;
            end
            DATA: begin
                if(count < 9)
                    next_state = DATA;
                else
                    next_state = STOP;
            end
            STOP: begin
                if(in)
                    next_state = START;
                else
                    next_state = DELAY;
            end
            DELAY: begin
                if(count < 19)
                    next_state = DELAY;
                else
                    next_state = START;
            end
        endcase
    end
    
    always @(posedge clk) begin
        if(reset)
            state <= START;
        else
            state <= next_state;
    end
    
    always @(posedge clk) begin
        if(state == DATA)
            count <= count + 1;
        else
            count <= 0;
    end
    
    always @(*) begin
        case (state)
            START: begin
                out_byte = 8'b0;
                done = 0;
            end
            DATA: begin
                if(count < 9)
                    out_byte = {out, in};
                else
                    done = 1;
            end
            STOP: begin
                out = 1;
            end
            DELAY: begin
                done = 0;
            end
        endcase
    end
    
endmodule"
N/A,N/A,-1,38.0,1,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    parameter START = 3'd0, DATA = 3'd1, PARITY = 3'd2, STOP = 3'd3, DELAY = 3'd4;
    reg [2:0] state, next_state;
    reg [7:0] data;
    reg odd;
    reg out;
    
    always @(posedge clk)
        if (reset)
            state <= START;
        else
            state <= next_state;
            
    always @(*)
        case (state)
            START:
                begin
                    if (in)
                        next_state = DATA;
                    else
                        next_state = START;
                end
            DATA:
                begin
                    if (in)
                        next_state = DATA;
                    else
                        next_state = PARITY;
                end
            PARITY:
                begin
                    if (in)
                        next_state = STOP;
                    else
                        next_state = DELAY;
                end
            DELAY:
                begin
                    if (in)
                        next_state = DELAY;
                    else
                        next_state = START;
                end
            STOP:
                begin
                    if (in)
                        next_state = START;
                    else
                        next_state = DELAY;
                end
            default:
                next_state = START;
        endcase
    
    always @(posedge clk)
        if (reset)
            data <= 8'b0;
        else if (state == DATA)
            data <= {in, data[7:1]};
    
    always @(posedge clk)
        if (reset)
            out_byte <= 8'b0;
        else if (state == PARITY)
            out_byte <= {odd, data[7:1]};
    
    always @(posedge clk)
        if (reset)
            done <= 0;
        else if (state == STOP)
            done <= 1;
    
    always @(posedge clk)
        if (reset)
            out <= 0;
        else if (state == DELAY)
            out <= in;
    
    assign odd = ^data;
    
endmodule"
N/A,N/A,-1,39.0,1,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    parameter BYTE_SIZE = 8;
    
    reg [BYTE_SIZE-1:0] byte_counter = 0;
    reg [3:0] bit_counter = 0;
    reg [7:0] out = 0;
    reg done_reg = 0;
    
    always @(posedge clk)
        if (reset) begin
            bit_counter <= 0;
            done_reg <= 0;
        end
        else if (in) begin
            if (bit_counter == 0) begin
                byte_counter <= byte_counter + 1;
                bit_counter <= BYTE_SIZE;
            end
            else begin
                bit_counter <= bit_counter - 1;
                out[bit_counter] <= in;
            end
        end
        else begin
            done_reg <= 1;
        end
    
    assign done = done_reg;
    assign out_byte = out;
    
endmodule"
N/A,N/A,-1,40.0,1,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    parameter START = 0, DATA = 1, STOP = 2, DELAY = 3;
    reg [1:0] state, next_state;
    reg [9:0] count;
    reg out;
    
    always @(*) begin
        case (state)
            START: begin
                if(in)
                    next_state <= DATA;
                else
                    next_state <= START;
            end
            DATA: begin
                if(count == 1023)
                    next_state <= STOP;
                else if(in)
                    next_state <= DATA;
                else
                    next_state <= START;
            end
            STOP: begin
                if(in) begin
                    next_state <= START;
                    out_byte[count] <= in;
                end
                else
                    next_state <= DELAY;
            end
            DELAY: next_state <= START;
            default: next_state <= START;
        endcase
    end
    
    always @(posedge clk) begin
        if(reset)
            state <= START;
        else
            state <= next_state;
    end
    
    always @(posedge clk) begin
        if(state == DATA)
            count <= count + 1;
        else
            count <= 0;
    end
    
    assign done = (state == STOP);
    assign out = out_byte[0];
    
endmodule"
N/A,N/A,-1,41.0,1,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    parameter START = 3'd0, DATA = 3'd1, PARITY = 3'd2, STOP = 3'd3, DELAY = 3'd4;
    reg [2:0] state, next_state;
    reg [8:0] counter;
    reg odd;
    reg [7:0] out;
    
    always @(posedge clk) begin
        if (reset)
            state <= START;
        else
            state <= next_state;
    end
    
    always @(*) begin
        case (state)
            START: begin
                if (in)
                    next_state = DATA;
                else
                    next_state = START;
            end
            DATA: begin
                if (counter < 9'd249)
                    next_state = DATA;
                else
                    next_state = PARITY;
            end
            PARITY: begin
                if (counter < 9'd491)
                    next_state = PARITY;
                else
                    next_state = STOP;
            end
            STOP: begin
                if (in)
                    next_state = DELAY;
                else
                    next_state = START;
            end
            DELAY: begin
                if (counter < 9'd249)
                    next_state = DELAY;
                else
                    next_state = START;
            end
            default: next_state = START;
        endcase
    end
    
    always @(posedge clk) begin
        if (reset) begin
            counter <= 0;
            state <= START;
        end
        else begin
            case (state)
                START: begin
                    counter <= 0;
                    state <= next_state;
                end
                DATA: begin
                    counter <= counter + 1;
                    state <= next_state;
                end
                PARITY: begin
                    odd <= in ^ odd;
                    counter <= counter + 1;
                    state <= next_state;
                end
                STOP: begin
                    counter <= counter + 1;
                    state <= next_state;
                end
                DELAY: begin
                    state <= next_state;
                end
            endcase
        end
    end
    
    always @(posedge clk) begin
        if (state == DATA)
            out <= {in, out[7:1]};
    end
    
    assign out_byte = out;
    assign done = (state == STOP);
    
endmodule"
N/A,N/A,-1,42.0,1,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serialdata
    // New: Add parity checking.
    
    parameter idle = 0, rec_data = 1, stop_bit = 2;
    reg [1:0] state, next_state;
    
    always @(posedge clk)
        if (reset) state <= idle;
        else state <= next_state;
    
    always @(*)
        case (state)
            idle:
                if (in) next_state = rec_data;
                else next_state = idle;
            rec_data:
                if (in) next_state = rec_data;
                else next_state = stop_bit;
            stop_bit:
                if (in) next_state = idle;
                else next_state = idle;
            default:
                next_state = idle;
        endcase
    
    assign done = (state == stop_bit);
    
    // New: Add parity checking.
    
    parity p1(clk, reset, in, odd);
    
    // New: Add parity checking.
    
    // Use this to display a hex display
    
    //assign out_byte = {state, odd};
    
    // Use this to display a binary display
    
    //assign out_byte = state;
    
    // Use this to display a 7-segment display
    
    //assign out_byte = (state == rec_data)? {odd, in} : {6'b0, state};
    
endmodule"
N/A,N/A,-1,43.0,1,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    // Use FSM from Fsm_serialdata
    // New: Add parity checking.
    // New: Add state to FSM.
    
    parameter idle = 0, rec_data = 1, stop_bit = 2;
    reg [2:0] state, next_state;
    
    always @(*) begin
        case (state)
            idle: begin
                if (in) next_state = rec_data;
                else next_state = idle;
            end
            rec_data: begin
                if (in) next_state = rec_data;
                else next_state = stop_bit;
            end
            stop_bit: begin
                if (in) next_state = idle;
                else next_state = idle;
            end
            default: next_state = idle;
        endcase
    end
    
    always @(posedge clk) begin
        if (reset) state <= idle;
        else state <= next_state;
    end
    
    assign done = (state == stop_bit)? 1 : 0;
    
    // New: Add parity checking.
    parity pff(clk, reset, in, odd);
    
    // New: Add state to FSM.
    // New: Add output byte to FSM.
    
    always @(*) begin
        case (state)
            idle: begin
                out_byte = 8'b0;
            end
            rec_data: begin
                out_byte = {in, odd};
            end
            stop_bit: begin
                out_byte = {in, odd};
            end
            default: out_byte = 8'b0;
        endcase
    end
    
endmodule"
N/A,N/A,-1,44.0,1,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    parameter START = 0, DATA = 1, STOP = 2, DELAY = 3;
    reg [1:0] state, next_state;
    reg [3:0] count;
    reg out;
    
    always @(*) begin
        case (state)
            START: begin
                if(in)
                    next_state <= DATA;
                else
                    next_state <= START;
                out <= 0;
            end
            DATA: begin
                out <= in;
                if (count == 7)
                    next_state <= STOP;
                else
                    next_state <= DATA;
            end
            STOP: begin
                done <= 1;
                if (in) begin
                    next_state <= START;
                    out <= 0;
                end
                else
                    next_state <= DELAY;
            end
            DELAY: next_state <= START;
            default: next_state <= START;
        endcase
    end
    
    always @(posedge clk) begin
        if (reset)
            state <= START;
        else
            state <= next_state;
            
        if (next_state == DATA)
            count <= count + 1;
        else
            count <= 0;
    end
    
    assign out_byte = out? 8'b11111111 : 8'b00000000;
    
endmodule"
N/A,N/A,-1,45.0,1,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    parameter START = 0, DATA = 1, STOP = 2, DELAY = 3;
    reg [1:0] state, next_state;
    reg [3:0] count;
    reg out;
    
    always @(*) begin
        case (state)
            START: begin
                if(in)
                    next_state <= DATA;
                else
                    next_state <= START;
                out <= 0;
            end
            DATA: begin
                out <= in;
                if (count == 7)
                    next_state <= STOP;
                else
                    next_state <= DATA;
            end
            STOP: begin
                done <= 1;
                if (in) begin
                    next_state <= START;
                    out <= 0;
                end
                else
                    next_state <= DELAY;
            end
            DELAY: next_state <= START;
            default: next_state <= START;
        endcase
    end
    
    always @(posedge clk) begin
        if (reset)
            state <= START;
        else
            state <= next_state;
            
        if (next_state == DATA)
            count <= count + 1;
        else
            count <= 0;
    end
    
    assign out_byte = out? 8'b11111111 : 8'b00000000;
    
endmodule"
N/A,N/A,-1,46.0,1,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.
    
    wire parity_error;
    wire [8:0] data;
    
    parity p (clk, reset, in, parity_error);
    serial_receiver sr (clk, reset, in, data, parity_error, done);
    
    assign out_byte = data[7:0];
    
endmodule"
N/A,N/A,-1,47.0,1,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.
    
    wire parity_error;
    wire [8:0] data;
    
    parity p (clk, reset, in, parity_error);
    serial_receiver sr (clk, reset, in, data, parity_error, done);
    
    assign out_byte = data[7:0];
    
endmodule"
N/A,N/A,-1,48.0,1,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    parameter START = 3'd0, DATA = 3'd1, STOP = 3'd2, DELAY = 3'd3;
    reg [2:0] state, next_state;
    reg [7:0] data;
    reg odd;
    reg [1:0] count;
    reg out;
    
    always @(posedge clk)
        if (reset)
            state <= START;
        else
            state <= next_state;
    
    always @(*)
        case (state)
            START: begin
                if (in)
                    next_state = DATA;
                else
                    next_state = START;
            end
            DATA: begin
                if (count == 9)
                    next_state = STOP;
                else if (in)
                    next_state = DATA;
                else
                    next_state = DELAY;
            end
            STOP: begin
                if (count == 9)
                    next_state = START;
                else if (in)
                    next_state = DELAY;
                else
                    next_state = STOP;
            end
            DELAY: begin
                if (count == 9)
                    next_state = START;
                else
                    next_state = DELAY;
            end
            default: next_state = START;
        endcase
    
    always @(posedge clk)
        if (reset) begin
            count <= 0;
            data <= 0;
            out <= 0;
            odd <= 0;
        end
        else begin
            case (state)
                START: begin
                    out <= 0;
                    count <= 0;
                    data <= 0;
                    odd <= 0;
                end
                DATA: begin
                    data[count] <= in;
                    count <= count + 1;
                    if (count == 9) begin
                        odd <= data[0] ^ data[1] ^ data[7] ^ data[8];
                        out <= 0;
                        count <= 0;
                        data <= 0;
                    end
                    else begin
                        out <= 0;
                    end
                end
                STOP: begin
                    done <= 1;
                    out <= 0;
                    count <= 0;
                    data <= 0;
                end
                DELAY: begin
                    done <= 0;
                    out <= 0;
                    count <= 0;
                    data <= 0;
                end
            endcase
        end
    
    assign out_byte = out;
    
endmodule"
N/A,N/A,-1,49.0,1,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    parameter START = 3'd0, DATA = 3'd1, STOP = 3'd2, DELAY = 3'd3;
    reg [2:0] state, next_state;
    reg [7:0] data;
    reg odd;
    reg [1:0] count;
    reg out;
    
    always @(posedge clk)
        if (reset)
            state <= START;
        else
            state <= next_state;
    
    always @(*)
        case (state)
            START: begin
                if (in)
                    next_state = DATA;
                else
                    next_state = START;
            end
            DATA: begin
                if (count == 9)
                    next_state = STOP;
                else if (in)
                    next_state = DATA;
                else
                    next_state = DELAY;
            end
            STOP: begin
                if (count == 9)
                    next_state = START;
                else if (in)
                    next_state = DELAY;
                else
                    next_state = STOP;
            end
            DELAY: begin
                if (count == 9)
                    next_state = START;
                else
                    next_state = DELAY;
            end
            default: next_state = START;
        endcase
    
    always @(posedge clk)
        if (reset) begin
            count <= 0;
            data <= 0;
            out <= 0;
            odd <= 0;
        end
        else begin
            case (state)
                START: begin
                    out <= 0;
                    count <= 0;
                    data <= 0;
                    odd <= 0;
                end
                DATA: begin
                    data[count] <= in;
                    count <= count + 1;
                    if (count == 9) begin
                        odd <= data[0] ^ data[1] ^ data[7] ^ data[8];
                        out <= 0;
                        count <= 0;
                        data <= 0;
                    end
                    else begin
                        out <= 0;
                    end
                end
                STOP: begin
                    done <= 1;
                    out <= 0;
                    count <= 0;
                    data <= 0;
                end
                DELAY: begin
                    done <= 0;
                    out <= 0;
                    count <= 0;
                    data <= 0;
                end
            endcase
        end
    
    assign out_byte = out;
    
endmodule"
N/A,N/A,-1,50.0,1,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    parameter START = 0, DATA = 1, STOP = 2, DELAY = 3;
    reg [1:0] state, next_state;
    reg [3:0] count;
    reg out;
    reg [8:0] shift_reg;
    assign out_byte = shift_reg[7:0];
    always @(*)
        case (state)
            START: begin
                shift_reg <= 9'b0;
                count <= 4'd0;
                out <= 0;
                if (in)
                    next_state <= DATA;
                else
                    next_state <= START;
            end
            DATA: begin
                shift_reg[0] <= in;
                if (count < 9)
                    count <= count + 4'd1;
                else
                    count <= 4'd0;
                if (count == 9)
                    next_state <= STOP;
                else
                    next_state <= DATA;
            end
            STOP: begin
                done <= 1'b1;
                if (in) begin
                    next_state <= START;
                    out <= 1'b1;
                end
                else
                    next_state <= START;
            end
            DELAY: next_state <= DELAY;
            default: next_state <= START;
        endcase
    always @(posedge clk)
        if (reset)
            state <= START;
        else
            state <= next_state;
endmodule"
N/A,N/A,-1,51.0,1,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    parameter START = 3'd0, DATA = 3'd1, PARITY = 3'd2, STOP = 3'd3, DELAY = 3'd4;
    reg [2:0] state, next_state;
    reg [8:0] counter;
    reg odd;
    reg out;
    
    always @(posedge clk) begin
        if (reset)
            state <= START;
        else
            state <= next_state;
    end
    
    always @(*) begin
        case (state)
            START: begin
                if (in)
                    next_state = DATA;
                else
                    next_state = START;
            end
            DATA: begin
                if (counter < 9'd255)
                    next_state = DATA;
                else
                    next_state = PARITY;
            end
            PARITY: begin
                if (counter < 9'd255)
                    next_state = PARITY;
                else
                    next_state = STOP;
            end
            STOP: begin
                if (in)
                    next_state = DELAY;
                else
                    next_state = START;
            end
            DELAY: begin
                if (counter < 9'd255)
                    next_state = DELAY;
                else
                    next_state = START;
            end
            default: next_state = START;
        endcase
    end
    
    always @(posedge clk) begin
        if (reset) begin
            counter <= 0;
            odd <= 0;
            out <= 0;
        end
        else begin
            case (state)
                START: begin
                    out_byte <= 8'b0;
                    counter <= 0;
                    odd <= 0;
                end
                DATA: begin
                    out_byte[counter] <= in;
                    counter <= counter + 1;
                end
                PARITY: begin
                    out_byte[counter] <= odd;
                    counter <= counter + 1;
                end
                STOP: begin
                    done <= 1;
                end
                DELAY: begin
                    done <= 0;
                end
            endcase
        end
    end

endmodule"
N/A,N/A,-1,52.0,1,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    parameter START = 3'd0, DATA = 3'd1, PARITY = 3'd2, STOP = 3'd3, DELAY = 3'd4;
    reg [2:0] state, next_state;
    reg [8:0] counter;
    reg odd;
    reg out;
    
    always @(posedge clk) begin
        if (reset)
            state <= START;
        else
            state <= next_state;
    end
    
    always @(*) begin
        case (state)
            START: begin
                if (in)
                    next_state = DATA;
                else
                    next_state = START;
            end
            DATA: begin
                if (counter < 9'd255)
                    next_state = DATA;
                else
                    next_state = PARITY;
            end
            PARITY: begin
                if (counter < 9'd255)
                    next_state = PARITY;
                else
                    next_state = STOP;
            end
            STOP: begin
                if (in)
                    next_state = DELAY;
                else
                    next_state = START;
            end
            DELAY: begin
                if (counter < 9'd255)
                    next_state = DELAY;
                else
                    next_state = START;
            end
            default: next_state = START;
        endcase
    end
    
    always @(posedge clk) begin
        if (reset) begin
            counter <= 0;
            odd <= 0;
            out <= 0;
        end
        else begin
            case (state)
                START: begin
                    out_byte <= 8'b0;
                    counter <= 0;
                    odd <= 0;
                end
                DATA: begin
                    out_byte[counter] <= in;
                    counter <= counter + 1;
                end
                PARITY: begin
                    out_byte[counter] <= odd;
                    counter <= counter + 1;
                end
                STOP: begin
                    done <= 1;
                end
                DELAY: begin
                    done <= 0;
                end
            endcase
        end
    end

endmodule"
N/A,N/A,-1,53.0,1,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    // Use FSM from Fsm_serialdata
    // New: Add parity checking.
    
    parameter idle = 0, rec_data = 1, stop_bit = 2;
    reg [1:0] state, next_state;
    reg [3:0] counter;
    reg odd;
    
    always @(posedge clk)
        if (reset)
            state <= idle;
        else
            state <= next_state;
    
    always @(*)
        case (state)
            idle:
                if (in)
                    next_state = rec_data;
                else
                    next_state = idle;
            rec_data:
                if (counter == 7)
                    next_state = stop_bit;
                else
                    next_state = rec_data;
            stop_bit:
                if (in)
                    next_state = idle;
                else
                    next_state = idle;
            default:
                next_state = idle;
        endcase
    
    always @(posedge clk)
        if (reset)
            counter <= 0;
        else if (state == rec_data)
            counter <= counter + 1;
    
    always @(posedge clk)
        if (reset)
            done <= 0;
        else if (state == stop_bit)
            done <= 1;
    
    // New: Add parity checking.
    parity pff(clk, reset, in, odd);
    
    assign out_byte = {in, odd};

endmodule"
N/A,N/A,-1,54.0,1,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    parameter START = 0, DATA = 1, STOP = 2, DELAY = 3;
    reg [1:0] state, next_state;
    reg [9:0] count;
    reg out;
    
    always @(*) begin
        case (state)
            START: begin
                if(in)
                    next_state <= DATA;
                else
                    next_state <= START;
                out_byte <= 0;
            end
            DATA: begin
                out_byte[7] <= in;
                out_byte[6] <= in;
                out_byte[5] <= in;
                out_byte[4] <= in;
                out_byte[3] <= in;
                out_byte[2] <= in;
                out_byte[1] <= in;
                out_byte[0] <= in;
                if (count == 10)
                    next_state <= STOP;
                else
                    next_state <= DATA;
            end
            STOP: begin
                done <= 1;
                if (in) begin
                    next_state <= START;
                    out <= 1;
                end
                else
                    next_state <= START;
            end
            DELAY: begin
                done <= 0;
                next_state <= START;
            end
            default: begin
                next_state <= START;
                out_byte <= 0;
                done <= 0;
            end
        endcase
    end
    
    always @(posedge clk) begin
        if (reset)
            state <= START;
        else
            state <= next_state;
        
        if (next_state == DATA)
            count <= count + 1;
        else
            count <= 0;
    end
    
    assign out = (state == DATA)? out_byte[7] : 0;
    
endmodule"
N/A,N/A,-1,55.0,1,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.
    
    parameter idle = 4'd0, start = 4'd1, data = 4'd2, stop = 4'd3, paridad = 4'd4, stop_err = 4'd5;
    reg [3:0] state, next_state;
    reg [8:0] counter;
    reg odd;
    
    always @(posedge clk)
        if(reset) state <= idle;
    	else state <= next_state;
    
    always @(*)
        case (state)
            idle: begin
                if(~in)
                    next_state = start;
                else
                    next_state = idle;
            end
            start: 
                if(counter == 9'd239)
                    next_state = data;
                else
                    next_state = start;
            data:
                if(counter == 9'd479) begin
                    if(in)
                        next_state = paridad;
                    else
                        next_state = stop_err;
                end
                else
                    next_state = data;
            paridad:
                if(counter == 9'd479)
                    next_state = stop;
                else
                    next_state = paridad;
            stop_err:
                if(counter == 9'd480)
                    next_state = idle;
                else
                    next_state = stop_err;
            stop:
                if(counter == 9'd480)
                    next_state = idle;
                else
                    next_state = stop;
            default:
                next_state = idle;
        endcase
    
    always @(posedge clk)
        if(reset) counter <= 0;
    	else if(next_state == data || next_state == paridad)
            counter <= 9'd239;
    	else if(next_state == stop_err)
            counter <= 9'd480;
    	else
            counter <= counter + 1'b1;
    
    always @(posedge clk)
        if(reset) odd <= 0;
    	else if(next_state == paridad)
            odd <= in;
    	else if(next_state == stop_err)
            odd <= ~in;
    
    assign done = (state == stop) && (counter == 9'd480);
    
    assign out_byte = (state == data)? {in, odd} : 8'd0;
    
endmodule"
N/A,N/A,-1,56.0,1,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.
    
    parameter idle = 4'd0, start = 4'd1, data = 4'd2, stop = 4'd3, paridad = 4'd4, stop_err = 4'd5;
    reg [3:0] state, next_state;
    reg [8:0] counter;
    reg odd;
    
    always @(posedge clk)
        if(reset) state <= idle;
    	else state <= next_state;
    
    always @(*)
        case (state)
            idle: begin
                if(~in)
                    next_state = start;
                else
                    next_state = idle;
            end
            start: 
                if(counter == 9'd239)
                    next_state = data;
                else
                    next_state = start;
            data:
                if(counter == 9'd479) begin
                    if(in)
                        next_state = paridad;
                    else
                        next_state = stop_err;
                end
                else
                    next_state = data;
            paridad:
                if(counter == 9'd479)
                    next_state = stop;
                else
                    next_state = paridad;
            stop_err:
                if(counter == 9'd480)
                    next_state = idle;
                else
                    next_state = stop_err;
            stop:
                if(counter == 9'd480)
                    next_state = idle;
                else
                    next_state = stop;
            default:
                next_state = idle;
        endcase
    
    always @(posedge clk)
        if(reset) counter <= 0;
    	else if(next_state == data || next_state == paridad)
            counter <= 9'd239;
    	else if(next_state == stop_err)
            counter <= 9'd480;
    	else
            counter <= counter + 1'b1;
    
    always @(posedge clk)
        if(reset) odd <= 0;
    	else if(next_state == paridad)
            odd <= in;
    	else if(next_state == stop_err)
            odd <= ~in;
    
    assign done = (state == stop) && (counter == 9'd480);
    
    assign out_byte = (state == data)? {in, odd} : 8'd0;
    
endmodule"
N/A,N/A,-1,57.0,1,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.
    
    parameter idle = 4'd0, start = 4'd1, data = 4'd2, stop = 4'd3, paridad = 4'd4, stop_err = 4'd5;
    reg [3:0] state, next_state;
    reg [8:0] counter;
    reg odd;
    
    always @(posedge clk)
        if(reset) state <= idle;
    	else state <= next_state;
    
    always @(*)
        case (state)
            idle: begin
                if(~in)
                    next_state = start;
                else
                    next_state = idle;
            end
            start: 
                if(counter == 9'd239)
                    next_state = data;
                else
                    next_state = start;
            data:
                if(counter == 9'd479) begin
                    if(in)
                        next_state = paridad;
                    else
                        next_state = stop_err;
                end
                else
                    next_state = data;
            paridad:
                if(counter == 9'd479)
                    next_state = stop;
                else
                    next_state = paridad;
            stop_err:
                if(counter == 9'd480)
                    next_state = idle;
                else
                    next_state = stop_err;
            stop:
                if(counter == 9'd480)
                    next_state = idle;
                else
                    next_state = stop;
            default:
                next_state = idle;
        endcase
    
    always @(posedge clk)
        if(reset) counter <= 0;
    	else if(next_state == data || next_state == paridad)
            counter <= 9'd239;
    	else if(next_state == stop_err)
            counter <= 9'd480;
    	else
            counter <= counter + 1'b1;
    
    always @(posedge clk)
        if(reset) odd <= 0;
    	else if(next_state == paridad)
            odd <= in;
    	else if(next_state == stop_err)
            odd <= ~in;
    
    assign done = (state == stop) && (counter == 9'd480);
    
    assign out_byte = (state == data)? {in, odd} : 8'd0;
    
endmodule"
N/A,N/A,-1,58.0,1,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    parameter START = 3'd0, DATA = 3'd1, PARITY = 3'd2, STOP = 3'd3, DELAY = 3'd4;
    reg [2:0] state, next_state;
    reg [8:0] counter;
    reg odd;
    reg [7:0] out;
    
    always @(posedge clk)
        if (reset)
            state <= START;
        else
            state <= next_state;
    
    always @(*)
        case (state)
            START:
                begin
                    if(in)
                        next_state = DATA;
                    else
                        next_state = START;
                end
            DATA:
                begin
                    if(counter == 9'd255)
                        next_state = PARITY;
                    else
                        next_state = DATA;
                end
            PARITY:
                begin
                    if(counter == 9'd255)
                        next_state = STOP;
                    else
                        next_state = PARITY;
                end
            STOP:
                begin
                    if(counter == 9'd255)
                        next_state = DELAY;
                    else
                        next_state = STOP;
                end
            DELAY:
                begin
                    if(counter == 9'd255)
                        next_state = START;
                    else
                        next_state = DELAY;
                end
            default:
                begin
                    next_state = START;
                end
        endcase
    
    always @(posedge clk)
        if(reset)
            counter <= 9'd0;
        else if(next_state == DATA)
            counter <= counter + 9'd1;
        else
            counter <= 9'd0;
    
    always @(posedge clk)
        if(reset)
            out <= 8'd0;
        else if(next_state == PARITY)
            out <= {out, odd};
        else if(next_state == STOP)
            out <= out_byte;
    
    assign done = (state == DELAY)? (counter == 9'd255):(state == START);
    assign out_byte = out;
    
    always @(posedge clk)
        if(reset)
            odd <= 1'b0;
        else if(next_state == PARITY)
            odd <= ~(out[0] ^ out[1] ^ out[2] ^ out[3] ^ out[4] ^ out[5] ^ out[6] ^ out[7]);

endmodule"
N/A,N/A,-1,59.0,1,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    parameter BYTE_SIZE = 8;
    parameter NUM_BYTES = 3;
    
    // Define states
    parameter IDLE = 0, RDATA = 1, WDATA = 2, WSTRB = 3, WLAST = 4;
    reg [NUM_BYTES-1:0] state, next_state;
    
    // State transition logic (combinational)
    always @(*)
        case (state)
            IDLE: next_state = in? RDATA : IDLE;
            RDATA: next_state = in? RDATA : WLAST;
            WDATA: next_state = in? WDATA : IDLE;
            WSTRB: next_state = in? WSTRB : WLAST;
            WLAST: next_state = in? WDATA : IDLE;
            default: next_state = IDLE;
        endcase
    
    // State flip-flops (sequential)
    always @(posedge clk)
        if(reset)
            state <= IDLE;
    	else
            state <= next_state;
    
    // Output logic
    assign done = (state == WLAST);
    
    // New: Datapath to store incoming bytes.
    reg [BYTE_SIZE-1:0] in_byte;
    
    // New: Parity checking.
    wire [BYTE_SIZE-1:0] out_byte_parity;
    parity p1(clk, in, out_byte_parity);
    
    // New: Output byte valid signal.
    reg out_byte_valid = 0;
    
    always @(posedge clk)
        if(reset)
            out_byte <= 0;
        else if(state == WLAST)
            out_byte <= in_byte;
    	else
            out_byte <= out_byte;
    
    always @(posedge clk)
        if(reset)
            out_byte_valid <= 0;
        else if(state == WLAST)
            out_byte_valid <= 1;
    	else
            out_byte_valid <= 0;
    
    // New: Datapath to store incoming bytes.
    always @(posedge clk)
        if(reset)
            in_byte <= 0;
        else if(state == WSTRB)
            in_byte <= in;
    
endmodule"
N/A,N/A,-1,60.0,1,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    parameter START = 0, DATA = 1, STOP = 2, DELAY = 3;
    reg [1:0] state, next_state;
    reg [3:0] count;
    reg out;
    
    always @(posedge clk) begin
        if (reset)
            state <= START;
        else
            state <= next_state;
    end
    
    always @(*) begin
        case (state)
            START: begin
                next_state <= DATA;
                count <= 4'd7;
                out <= 0;
            end
            DATA: begin
                if(count == 4'd8)
                    next_state <= DELAY;
                else
                    next_state <= DATA;
                
                count <= count - 4'd1;
                out <= in;
            end
            DELAY: begin
                if(count == 4'd7)
                    next_state <= STOP;
                else
                    next_state <= DELAY;
                
                count <= count - 4'd1;
            end
            STOP: begin
                done <= 1;
                next_state <= START;
            end
            default: begin
                done <= 0;
                next_state <= START;
            end
        endcase
    end
    
    assign out_byte = out;
endmodule"
N/A,N/A,-1,61.0,1,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    parameter START = 3'd0, DATA = 3'd1, PARITY = 3'd2, STOP = 3'd3, DELAY = 3'd4;
    reg [2:0] state, next_state;
    reg [7:0] data;
    reg odd;
    reg [1:0] count;
    
    always @(posedge clk)
        if (reset)
            state <= START;
        else
            state <= next_state;
    
    always @(*)
        case (state)
            START:
                begin
                    if (in)
                        next_state = DATA;
                    else
                        next_state = START;
                end
            DATA:
                begin
                    if (count == 9)
                        next_state = PARITY;
                    else
                        next_state = DATA;
                end
            PARITY:
                begin
                    if (count == 9)
                        next_state = STOP;
                    else
                        next_state = PARITY;
                end
            STOP:
                begin
                    if (count == 2)
                        next_state = DELAY;
                    else
                        next_state = STOP;
                end
            DELAY:
                begin
                    if (count == 2)
                        next_state = START;
                    else
                        next_state = DELAY;
                end
            default:
                next_state = START;
        endcase
    
    always @(posedge clk)
        if (reset)
            count <= 2'd0;
        else if (next_state == DATA)
            count <= count + 2'd1;
        else if (next_state == PARITY)
            count <= count + 2'd1;
        else if (next_state == STOP)
            count <= count + 2'd1;
        else if (next_state == DELAY)
            count <= count + 2'd1;
    
    always @(posedge clk)
        if (reset)
            data <= 8'd0;
        else if (next_state == DATA)
            data <= in;
    
    always @(posedge clk)
        if (reset)
            odd <= 0;
        else if (next_state == PARITY)
            odd <= odd ^ in;
    
    assign out_byte = data;
    assign done = (state == DELAY);
    
endmodule"
N/A,N/A,-1,62.0,1,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serialdata
    // New: Add parity checking.
    
    parameter idle = 4'd0, start = 4'd1, trans0 = 4'd2, trans1 = 4'd3, trans2 = 4'd4, trans3 = 4'd5;
    parameter trans4 = 4'd6, trans5 = 4'd7, trans6 = 4'd8, trans7 = 4'd9, stop = 4'd10, error = 4'd11, pari = 4'd12;
    reg [3:0] state, next_state;
    
    // New: Add parity checking.
    parity p0(clk, reset, in, odd);
    
    always @(posedge clk) begin
        if (reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    always @(state) begin
        case (state)
            idle:
                begin
                    done = 0;
                    next_state = start;
                end
            start:
                begin
                    done = 0;
                    next_state = trans0;
                end
            trans0:
                begin
                    done = 0;
                    next_state = trans1;
                end
            trans1:
                begin
                    done = 0;
                    next_state = trans2;
                end
            trans2:
                begin
                    done = 0;
                    next_state = trans3;
                end
            trans3:
                begin
                    done = 0;
                    next_state = trans4;
                end
            trans4:
                begin
                    done = 0;
                    next_state = trans5;
                end
            trans5:
                begin
                    done = 0;
                    next_state = trans6;
                end
            trans6:
                begin
                    done = 0;
                    next_state = trans7;
                end
            trans7:
                begin
                    done = 0;
                    next_state = stop;
                end
            stop:
                begin
                    done = 1;
                    next_state = idle;
                end
            error:
                begin
                    done = 1;
                    next_state = idle;
                end
            pari:
                begin
                    done = 1;
                    next_state = idle;
                end
        endcase
    end
    
    assign out_byte = {in, odd};
    
endmodule"
N/A,N/A,-1,63.0,1,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    // Use FSM from Fsm_serialdata
    // New: Add parity checking.
    
    parameter idle = 0, rec_data = 1, stop_bit = 2;
    reg [1:0] state, next_state;
    
    always @(posedge clk)
        if (reset) state <= idle;
        else state <= next_state;
    
    always @(*)
        case (state)
            idle:
                if (in) next_state = rec_data;
                else next_state = idle;
            rec_data:
                if (in) next_state = rec_data;
                else next_state = stop_bit;
            stop_bit:
                if (in) next_state = idle;
                else next_state = idle;
            default:
                next_state = idle;
        endcase
    
    assign done = (state == stop_bit);
    
    // New: Add parity checking.
    parity pff(.clk(clk),.reset(reset),.in(in),.odd(out_byte[7]));
    
    always @(posedge clk)
        out_byte[0] <= in;

endmodule"
N/A,N/A,-1,64.0,1,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    parameter START = 0, DATA = 1, STOP = 2, DELAY = 3;
    reg [1:0] state, next_state;
    reg [3:0] count;
    reg out;
    
    always @(*) begin
        case (state)
            START: begin
                if(in)
                    next_state = DATA;
                else
                    next_state = START;
            end
            DATA: begin
                if(count < 9)
                    next_state = DATA;
                else
                    next_state = STOP;
            end
            STOP: begin
                if(in)
                    next_state = START;
                else
                    next_state = DELAY;
            end
            DELAY: begin
                if(count < 9)
                    next_state = DELAY;
                else
                    next_state = STOP;
            end
        endcase
    end
    
    always @(posedge clk) begin
        if(reset)
            state <= START;
        else
            state <= next_state;
    end
    
    always @(posedge clk) begin
        if(state == DATA)
            count <= count + 1;
        else
            count <= 0;
    end
    
    always @(*) begin
        case (state)
            START: begin
                out_byte = 8'b0;
                done = 0;
            end
            DATA: begin
                if(count < 9) begin
                    out_byte[count-1] = in;
                end
                else begin
                    out_byte[7] = in;
                    done = 1;
                end
            end
            STOP: begin
                out_byte[7] = in;
                done = 1;
            end
            DELAY: begin
                done = 0;
            end
        endcase
    end
    
    assign out = (state == START) || (state == DATA);
    
endmodule"
N/A,N/A,-1,65.0,1,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.
    
    wire parity_error;
    wire stop_bit_error;
    
    parity p1(clk, reset, in, parity_error);
    stop_bit s1(clk, reset, in, stop_bit_error);
    
    always @(posedge clk)
        if (parity_error | stop_bit_error)
            done <= 1;
        else
            done <= 0;
    
    assign out_byte = in;
    
endmodule"
N/A,N/A,-1,66.0,1,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.
    
    wire parity_error;
    wire stop_bit_error;
    
    parity p1(clk, reset, in, parity_error);
    stop_bit s1(clk, reset, in, stop_bit_error);
    
    always @(posedge clk)
        if (parity_error | stop_bit_error)
            done <= 1;
        else
            done <= 0;
    
    assign out_byte = in;
    
endmodule"
N/A,N/A,-1,67.0,1,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.
    
    wire parity_error;
    wire stop_bit_error;
    
    parity p1(clk, reset, in, parity_error);
    stop_bit s1(clk, reset, in, stop_bit_error);
    
    always @(posedge clk)
        if (parity_error | stop_bit_error)
            done <= 1;
        else
            done <= 0;
    
    assign out_byte = in;
    
endmodule"
N/A,N/A,-1,68.0,1,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    parameter START = 3'd0, DATA = 3'd1, PARITY = 3'd2, STOP = 3'd3, DELAY = 3'd4;
    reg [2:0] state, next_state;
    reg [8:0] counter;
    reg odd;
    reg out;
    
    always @(posedge clk)
        if (reset)
            state <= START;
        else
            state <= next_state;
            
    always @(*)
        case (state)
            START: begin
                if (in)
                    next_state = DATA;
                else
                    next_state = START;
            end
            DATA: begin
                if (counter == 9'd255)
                    next_state = PARITY;
                else
                    next_state = DATA;
            end
            PARITY: begin
                if (counter == 9'd255)
                    next_state = STOP;
                else
                    next_state = PARITY;
            end
            STOP: begin
                if (counter == 9'd255)
                    next_state = DELAY;
                else
                    next_state = STOP;
            end
            DELAY: begin
                if (counter == 9'd255)
                    next_state = START;
                else
                    next_state = DELAY;
            end
            default: next_state = START;
        endcase
    
    always @(posedge clk)
        if (reset)
            counter <= 0;
        else if (state == DATA)
            counter <= counter + 1;
        else
            counter <= 0;
    
    always @(posedge clk)
        if (reset)
            out_byte <= 0;
        else if (state == PARITY)
            out_byte <= {out, odd};
        else
            out_byte <= out_byte;
            
    always @(posedge clk)
        if (reset)
            done <= 0;
        else if (state == DELAY)
            done <= 1;
        else
            done <= 0;
    
    always @(posedge clk)
        if (reset)
            odd <= 0;
        else if (state == PARITY)
            odd <= odd ^ in;
    
    always @(posedge clk)
        if (reset)
            out <= 0;
        else if (state == STOP)
            out <= in;

endmodule"
N/A,N/A,-1,69.0,1,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    parameter START = 3'd0, DATA = 3'd1, PARITY = 3'd2, STOP = 3'd3, DELAY = 3'd4;
    reg [2:0] state, next_state;
    reg [8:0] counter;
    reg odd;
    reg out;
    
    always @(posedge clk)
        if (reset)
            state <= START;
        else
            state <= next_state;
            
    always @(*)
        case (state)
            START: begin
                if (in)
                    next_state = DATA;
                else
                    next_state = START;
            end
            DATA: begin
                if (counter == 9'd255)
                    next_state = PARITY;
                else
                    next_state = DATA;
            end
            PARITY: begin
                if (counter == 9'd255)
                    next_state = STOP;
                else
                    next_state = PARITY;
            end
            STOP: begin
                if (counter == 9'd255)
                    next_state = DELAY;
                else
                    next_state = STOP;
            end
            DELAY: begin
                if (counter == 9'd255)
                    next_state = START;
                else
                    next_state = DELAY;
            end
            default: next_state = START;
        endcase
    
    always @(posedge clk)
        if (reset)
            counter <= 0;
        else if (state == DATA)
            counter <= counter + 1;
        else
            counter <= 0;
    
    always @(posedge clk)
        if (reset)
            out_byte <= 0;
        else if (state == PARITY)
            out_byte <= {out, odd};
        else
            out_byte <= out_byte;
            
    always @(posedge clk)
        if (reset)
            done <= 0;
        else if (state == DELAY)
            done <= 1;
        else
            done <= 0;
    
    always @(posedge clk)
        if (reset)
            odd <= 0;
        else if (state == PARITY)
            odd <= odd ^ in;
    
    always @(posedge clk)
        if (reset)
            out <= 0;
        else if (state == STOP)
            out <= in;

endmodule"
N/A,N/A,-1,70.0,1,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    parameter START = 0, DATA = 1, STOP = 2, DELAY = 3;
    reg [1:0] state, next_state;
    reg [3:0] count;
    reg out;
    
    always @(*) begin
        case (state)
            START: begin
                if(in)
                    next_state = DATA;
                else
                    next_state = START;
            end
            DATA: begin
                if(count == 8)
                    next_state = STOP;
                else if(in)
                    next_state = DATA;
                else
                    next_state = START;
            end
            STOP: begin
                if(in) begin
                    next_state = DELAY;
                    out = 1;
                end
                else
                    next_state = START;
            end
            DELAY: begin
                if(count >= 4)
                    next_state = START;
                else
                    next_state = DELAY;
            end
            default: next_state = START;
        endcase
    end
    
    always @(posedge clk) begin
        if(reset)
            state <= START;
        else
            state <= next_state;
    end
    
    always @(posedge clk) begin
        if(state == DATA)
            count <= count + 1;
        else
            count <= 0;
    end
    
    always @(posedge clk) begin
        if(state == STOP)
            out_byte <= {out, out_byte[7:1]};
    end
    
    assign done = (state == DELAY);
    
endmodule"
N/A,N/A,-1,71.0,1,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    parameter START = 3'd0, DATA = 3'd1, PARITY = 3'd2, STOP = 3'd3, DELAY = 3'd4;
    reg [2:0] state, next_state;
    reg [8:0] counter;
    reg odd;
    reg [7:0] out;
    
    always @(posedge clk) begin
        if (reset)
            state <= START;
        else
            state <= next_state;
    end
    
    always @(*) begin
        case (state)
            START: begin
                if (in)
                    next_state = DATA;
                else
                    next_state = START;
            end
            DATA: begin
                if (counter < 9'd255)
                    next_state = DATA;
                else
                    next_state = PARITY;
            end
            PARITY: begin
                if (counter < 9'd255)
                    next_state = PARITY;
                else
                    next_state = STOP;
            end
            STOP: begin
                if (in)
                    next_state = DELAY;
                else
                    next_state = START;
            end
            DELAY: begin
                if (counter < 9'd255)
                    next_state = DELAY;
                else
                    next_state = START;
            end
            default: next_state = START;
        endcase
    end
    
    always @(posedge clk) begin
        if (state == DATA || state == PARITY)
            counter <= counter + 1;
        else
            counter <= 0;
    end
    
    always @(posedge clk) begin
        if (state == DATA)
            out_byte[7:0] <= out[7:0];
        if (state == PARITY)
            out_byte[7] <= ^odd;
    end
    
    always @(posedge clk) begin
        if (state == STOP) begin
            done <= 1;
            out <= 0;
        end
        else begin
            done <= 0;
            if (in) begin
                odd <= ~odd;
                out <= {out, in};
            end
        end
    end
    
endmodule"
N/A,N/A,-1,72.0,1,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serialdata
    // New: Add parity checking.
    
    parity p1(clk, reset, in, odd);
    
    // New: Add serial output byte stream.
    
    serialdata s1(clk, in, reset, odd, out_byte, done);
    
endmodule"
N/A,N/A,-1,73.0,1,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serialdata
    // New: Add parity checking.
    
    parity p1(clk, reset, in, odd);
    
    // New: Add serial output byte stream.
    
    serialdata s1(clk, in, reset, odd, out_byte, done);
    
endmodule"
N/A,N/A,-1,74.0,1,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    parameter START = 0, DATA = 1, STOP = 2, DELAY = 3;
    reg [1:0] state, next_state;
    reg [3:0] count;
    reg out;
    
    always @(posedge clk)
        if(reset)
            state <= START;
        else
            state <= next_state;
            
    always @(*)
        case (state)
            START: begin
                next_state <= DATA;
                count <= 4'b0;
                out <= 0;
            end
            DATA: begin
                // Wait for 4 clk cycles to receive data
                if(count < 4'b1010)
                    next_state <= DATA;
                else
                    next_state <= STOP;
            end
            STOP: begin
                next_state <= DELAY;
                out_byte <= out;
            end
            DELAY: next_state <= (in)? START: STOP;
            default: next_state <= START;
        endcase
    
    assign done = (state == DELAY)? (in):(state == START);
    
endmodule"
N/A,N/A,-1,75.0,1,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    parameter START = 0, DATA = 1, STOP = 2, DELAY = 3;
    reg [1:0] state, next_state;
    reg [3:0] count;
    reg out;
    
    always @(posedge clk)
        if(reset)
            state <= START;
        else
            state <= next_state;
            
    always @(*)
        case (state)
            START: begin
                next_state <= DATA;
                count <= 4'b0;
                out <= 0;
            end
            DATA: begin
                // Wait for 4 clk cycles to receive data
                if(count < 4'b1010)
                    next_state <= DATA;
                else
                    next_state <= STOP;
            end
            STOP: begin
                next_state <= DELAY;
                out_byte <= out;
            end
            DELAY: next_state <= (in)? START: STOP;
            default: next_state <= START;
        endcase
    
    assign done = (state == DELAY)? (in):(state == START);
    
endmodule"
N/A,N/A,-1,76.0,1,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    parameter START = 0, DATA = 1, STOP = 2, DELAY = 3;
    reg [1:0] state, next_state;
    reg [3:0] count;
    reg out;
    
    always @(posedge clk)
        if(reset)
            state <= START;
        else
            state <= next_state;
            
    always @(*)
        case (state)
            START: begin
                next_state <= DATA;
                count <= 4'b0;
                out <= 0;
            end
            DATA: begin
                // Wait for 4 clk cycles to receive data
                if(count < 4'b1010)
                    next_state <= DATA;
                else
                    next_state <= STOP;
            end
            STOP: begin
                next_state <= DELAY;
                out_byte <= out;
            end
            DELAY: next_state <= (in)? START: STOP;
            default: next_state <= START;
        endcase
    
    assign done = (state == DELAY)? (in):(state == START);
    
endmodule"
N/A,N/A,-1,77.0,1,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    parameter START = 0, DATA = 1, STOP = 2, DELAY = 3;
    reg [1:0] state, next_state;
    reg [3:0] count;
    reg out;
    
    always @(posedge clk)
        if(reset)
            state <= START;
        else
            state <= next_state;
            
    always @(*)
        case (state)
            START: begin
                next_state <= DATA;
                count <= 4'b0;
                out <= 0;
            end
            DATA: begin
                // Wait for 4 clk cycles to receive data
                if(count < 4'b1010)
                    next_state <= DATA;
                else
                    next_state <= STOP;
            end
            STOP: begin
                next_state <= DELAY;
                out_byte <= out;
            end
            DELAY: next_state <= (in)? START: STOP;
            default: next_state <= START;
        endcase
    
    assign done = (state == DELAY)? (in):(state == START);
    
endmodule"
N/A,N/A,-1,78.0,1,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    parameter START = 3'd0, DATA = 3'd1, PARITY = 3'd2, STOP = 3'd3, DELAY = 3'd4;
    reg [2:0] state, next_state;
    reg [7:0] data;
    reg odd;
    reg out;
    
    always @(posedge clk)
        if (reset)
            state <= START;
        else
            state <= next_state;
            
    always @(*)
        case (state)
            START: begin
                if (in)
                    next_state <= DATA;
                else
                    next_state <= START;
            end
            DATA: begin
                if (in)
                    next_state <= DATA;
                else
                    next_state <= PARITY;
            end
            PARITY: begin
                if (in)
                    next_state <= STOP;
                else
                    next_state <= PARITY;
            end
            STOP: begin
                if (in)
                    next_state <= DELAY;
                else
                    next_state <= START;
            end
            DELAY: begin
                if (in)
                    next_state <= DELAY;
                else
                    next_state <= START;
            end
            default: next_state <= START;
        endcase
    
    always @(posedge clk)
        if (reset) begin
            data <= 8'd0;
            out <= 0;
        end
        else begin
            if (state == DATA)
                data <= {in, data[7:1]};
            if (state == PARITY)
                out <= odd;
        end
    
    assign done = (state == DELAY);
    assign out_byte = out? data : 8'd0;
    
endmodule"
N/A,N/A,-1,79.0,1,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    parameter START = 3'd0, DATA = 3'd1, PARITY = 3'd2, STOP = 3'd3, DELAY = 3'd4;
    reg [2:0] state, next_state;
    reg [7:0] data;
    reg odd;
    reg out;
    
    always @(posedge clk)
        if (reset)
            state <= START;
        else
            state <= next_state;
            
    always @(*)
        case (state)
            START: begin
                if (in)
                    next_state <= DATA;
                else
                    next_state <= START;
            end
            DATA: begin
                if (in)
                    next_state <= DATA;
                else
                    next_state <= PARITY;
            end
            PARITY: begin
                if (in)
                    next_state <= STOP;
                else
                    next_state <= PARITY;
            end
            STOP: begin
                if (in)
                    next_state <= DELAY;
                else
                    next_state <= START;
            end
            DELAY: begin
                if (in)
                    next_state <= DELAY;
                else
                    next_state <= START;
            end
            default: next_state <= START;
        endcase
    
    always @(posedge clk)
        if (reset) begin
            data <= 8'd0;
            out <= 0;
        end
        else begin
            if (state == DATA)
                data <= {in, data[7:1]};
            if (state == PARITY)
                out <= odd;
        end
    
    assign done = (state == DELAY);
    assign out_byte = out? data : 8'd0;
    
endmodule"
N/A,N/A,-1,80.0,1,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    parameter START = 0, DATA = 1, STOP = 2, DELAY = 3;
    reg [1:0] state, next_state;
    reg [8:0] counter;
    reg odd;
    reg out;
    assign done = out;
    assign out_byte = counter[7:0];
    always @(posedge clk)
        if(state == DATA)
            counter <= counter + 9'd1;
    always @(*)
        case(state)
            START: begin
                next_state <= (in)? START: DATA;
                out <= 0;
            end
            DATA: next_state <= (counter == 9'd159)? STOP: DATA;
            STOP: next_state <= (in)? START: DELAY;
            DELAY: next_state <= (in)? START: DATA;
            default: next_state <= state;
        endcase
    always @(posedge clk)
        if(state == START)
            state <= next_state;
    always @(posedge clk)
        if(state == DATA)
            odd <= (counter[8:1] == 8'd0);
    always @(posedge clk)
        if(state == STOP)
            out <= odd;
endmodule"
N/A,N/A,-1,81.0,1,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    parameter START = 3'd0, DATA = 3'd1, PARITY = 3'd2, STOP = 3'd3, DELAY = 3'd4;
    reg [2:0] state, next_state;
    reg [8:0] counter;
    reg odd;
    reg [7:0] out;
    
    always @(posedge clk)
        if (reset)
            state <= START;
        else
            state <= next_state;
    
    always @(*)
        case (state)
            START: begin
                if (in)
                    next_state = DATA;
                else
                    next_state = START;
            end
            DATA: begin
                if (counter < 9'd249)
                    next_state = DATA;
                else
                    next_state = PARITY;
            end
            PARITY: begin
                if (counter < 9'd491)
                    next_state = PARITY;
                else
                    next_state = STOP;
            end
            STOP: begin
                if (in)
                    next_state = DELAY;
                else
                    next_state = START;
            end
            DELAY: next_state = START;
            default: next_state = START;
        endcase
    
    always @(posedge clk)
        if (reset)
            counter <= 9'd0;
        else if (state == DATA || state == PARITY)
            counter <= counter + 9'd1;
        else
            counter <= 9'd0;
    
    always @(posedge clk)
        if (reset)
            odd <= 0;
        else if (state == PARITY)
            odd <= in;
    
    always @(posedge clk)
        if (reset)
            out_byte <= 8'd0;
        else if (state == DELAY)
            out_byte <= out;
    
    always @(posedge clk)
        if (reset)
            done <= 0;
        else if (state == STOP)
            done <= 1;
    
    always @(posedge clk)
        if (reset)
            out <= 8'd0;
        else if (state == DATA)
            out <= {in, odd};

endmodule"
N/A,N/A,-1,82.0,1,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serialdata
    // New: Add parity checking.
    
    parameter idle = 0, rec_data = 1, stop_bit = 2;
    reg [1:0] state, next_state;
    
    always @(posedge clk)
        if (reset) state <= idle;
        else state <= next_state;
    
    always @(*)
        case (state)
            idle:
                begin
                    if (in) next_state = rec_data;
                    else next_state = idle;
                end
            rec_data:
                begin
                    if (in) next_state = rec_data;
                    else next_state = stop_bit;
                end
            stop_bit:
                begin
                    if (in) next_state = idle;
                    else next_state = idle;
                end
            default:
                next_state = idle;
        endcase
    
    assign done = (state == stop_bit);
    
    // New: Add parity checking.
    
    parity pff(.clk(clk),.reset(reset),.in(in),.odd(out_byte[7]));
    
    assign out_byte[0] = (state == rec_data);
    
endmodule"
N/A,N/A,-1,83.0,1,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    // Use FSM from Fsm_serialdata
    // New: Add parity checking.
    
    // Create the instances
    parity p1 (clk, reset, in, odd);
    serialdata s1 (clk, reset, in, out_byte, done);
    
    // New: Add parity checking.
    assign odd = out_byte[7] ^ out_byte[3] ^ out_byte[0];
    
    
endmodule"
N/A,N/A,-1,84.0,1,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    parameter START = 0, DATA = 1, STOP = 2, DELAY = 3;
    reg [1:0] state, next_state;
    reg [7:0] data;
    reg odd;
    reg out;
    
    always @(*) begin
        case (state)
            START: begin
                if(~in)
                    next_state = DATA;
                else
                    next_state = START;
                out = 0;
            end
            DATA: begin
                if(~in)
                    next_state = STOP;
                else
                    next_state = DATA;
                out = 0;
            end
            STOP: begin
                if(in)
                    next_state = DELAY;
                else
                    next_state = START;
                out = 0;
            end
            DELAY: begin
                if(in)
                    next_state = DATA;
                else
                    next_state = START;
                out = 0;
            end
        endcase
    end
    
    always @(posedge clk) begin
        if(reset)
            state <= START;
        else
            state <= next_state;
    end
    
    always @(posedge clk) begin
        if(state == DATA)
            data <= {data[6:0], in};
        else if(state == STOP) begin
            data <= {data[6:0], 1'b0};
            odd <= ~odd;
        end
    end
    
    assign done = (state == DELAY);
    
    assign out_byte = (state == START)? 8'hff : (odd? data[7:0] : data[6:0]);
    
endmodule"
N/A,N/A,-1,85.0,1,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    parameter START = 0, DATA = 1, STOP = 2, DELAY = 3;
    reg [1:0] state, next_state;
    reg [7:0] data;
    reg odd;
    reg out;
    
    always @(*) begin
        case (state)
            START: begin
                if(~in)
                    next_state = DATA;
                else
                    next_state = START;
                out = 0;
            end
            DATA: begin
                if(~in)
                    next_state = STOP;
                else
                    next_state = DATA;
                out = 0;
            end
            STOP: begin
                if(in)
                    next_state = DELAY;
                else
                    next_state = START;
                out = 0;
            end
            DELAY: begin
                if(in)
                    next_state = DATA;
                else
                    next_state = START;
                out = 0;
            end
        endcase
    end
    
    always @(posedge clk) begin
        if(reset)
            state <= START;
        else
            state <= next_state;
    end
    
    always @(posedge clk) begin
        if(state == DATA)
            data <= {data[6:0], in};
        else if(state == STOP) begin
            data <= {data[6:0], 1'b0};
            odd <= ~odd;
        end
    end
    
    assign done = (state == DELAY);
    
    assign out_byte = (state == START)? 8'hff : (odd? data[7:0] : data[6:0]);
    
endmodule"
N/A,N/A,-1,86.0,1,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.
    
    wire parity_error;
    wire stop_bit_error;
    wire [7:0] byte;
    
    parity p1(clk, reset, in, parity_error);
    serial_rx s1(clk, reset, in, byte, stop_bit_error);
    serial_tx s2(clk, reset, byte, out_byte, parity_error, stop_bit_error);
    
    assign done = stop_bit_error;

endmodule"
N/A,N/A,-1,87.0,1,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.
    
    wire parity_error;
    wire stop_bit_error;
    wire [7:0] byte;
    
    parity p1(clk, reset, in, parity_error);
    serial_rx s1(clk, reset, in, byte, stop_bit_error);
    serial_tx s2(clk, reset, byte, out_byte, parity_error, stop_bit_error);
    
    assign done = stop_bit_error;

endmodule"
N/A,N/A,-1,88.0,1,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.
    
    wire parity_error;
    wire stop_bit_error;
    wire [7:0] byte;
    
    parity p1(clk, reset, in, parity_error);
    serial_rx s1(clk, reset, in, byte, stop_bit_error);
    serial_tx s2(clk, reset, byte, out_byte, parity_error, stop_bit_error);
    
    assign done = stop_bit_error;

endmodule"
N/A,N/A,-1,89.0,1,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    parameter BYTE_SIZE = 8;
    parameter NUM_STATES = 8;
    parameter IDLE = 0, RST = 1, START = 2, DATA = 3, STOP = 4, DELAY = 5;
    reg [NUM_STATES-1:0] state, next_state;
    reg [BYTE_SIZE-1:0] byte_out;
    reg odd;
    
    always @(*) begin
        case (state)
            IDLE: begin
                if (in)
                    next_state = START;
                else
                    next_state = IDLE;
            end
            
            RST: begin
                next_state = IDLE;
            end
            
            START: begin
                if (in)
                    next_state = DATA;
                else
                    next_state = IDLE;
            end
            
            DATA: begin
                if (in)
                    next_state = DATA;
                else
                    next_state = STOP;
            end
            
            STOP: begin
                if (in)
                    next_state = DELAY;
                else
                    next_state = IDLE;
            end
            
            DELAY: begin
                if (in)
                    next_state = DELAY;
                else
                    next_state = RST;
            end
            
            default: next_state = IDLE;
        endcase
    end
    
    always @(posedge clk) begin
        if (reset)
            state <= RST;
        else
            state <= next_state;
    end
    
    always @(posedge clk) begin
        if (reset) begin
            byte_out <= 0;
            odd <= 0;
        end
        else begin
            if (next_state == DATA)
                byte_out <= {byte_out[6:0], in};
            else if (next_state == START)
                byte_out <= 0;
            if ((next_state == DATA) && (state == START))
                odd <= ^byte_out;
        end
    end
    
    assign done = (state == DELAY);
    assign out_byte = byte_out;
    
endmodule"
N/A,N/A,-1,90.0,1,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    parameter START = 0, DATA = 1, STOP = 2, DELAY = 3;
    reg [1:0] state, next_state;
    reg [9:0] count;
    reg out;
    
    always @(*) begin
        case (state)
            START: begin
                if(in)
                    next_state = DATA;
                else
                    next_state = START;
            end
            DATA: begin
                if(count == 10'd255)
                    next_state = STOP;
                else if(in)
                    next_state = DATA;
                else
                    next_state = START;
            end
            STOP: begin
                if(in)
                    next_state = DELAY;
                else
                    next_state = START;
            end
            DELAY: begin
                if(count == 10'd255)
                    next_state = DELAY;
                else
                    next_state = START;
            end
            default: next_state = START;
        endcase
    end
    
    always @(posedge clk) begin
        if(reset)
            state <= START;
        else
            state <= next_state;
    end
    
    always @(posedge clk) begin
        if(state == DATA)
            count <= count + 1;
        else
            count <= 0;
    end
    
    always @(posedge clk) begin
        if(state == STOP) begin
            out_byte[7] <= in;
            out_byte[6] <= in;
            out_byte[5] <= in;
            out_byte[4] <= in;
            out_byte[3] <= in;
            out_byte[2] <= in;
            out_byte[1] <= in;
            out_byte[0] <= in;
            out <= 1'b0;
        end
        else
            out <= 1'b1;
    end
    
    assign done = (state == DELAY);
    
endmodule"
N/A,N/A,-1,91.0,1,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    parameter START = 3'd0, DATA = 3'd1, PARITY = 3'd2, STOP = 3'd3, DELAY = 3'd4;
    reg [2:0] state, next_state;
    reg [7:0] data;
    reg odd;
    reg out;
    
    always @(posedge clk)
        if (reset) state <= START;
        else state <= next_state;
    
    always @(*)
        case (state)
            START: begin
                if (in)
                    next_state = DATA;
                else
                    next_state = START;
            end
            DATA: begin
                next_state = PARITY;
            end
            PARITY: begin
                if (in)
                    next_state = STOP;
                else
                    next_state = DELAY;
            end
            DELAY: begin
                if (in)
                    next_state = DELAY;
                else
                    next_state = START;
            end
            STOP: begin
                if (in)
                    next_state = START;
                else
                    next_state = DELAY;
            end
            default: next_state = START;
        endcase
    
    always @(posedge clk)
        if (reset) begin
            data <= 8'd0;
            out <= 0;
        end
        else begin
            if (state == DATA)
                data <= {in, data[7:1]};
            if (state == PARITY)
                out <= odd;
        end
    
    assign done = (state == STOP);
    assign out_byte = done? data : 8'd0;
    
    always @(posedge clk)
        if (reset)
            odd <= 0;
        else if (state == PARITY)
            odd <= in ^ odd;

endmodule"
N/A,N/A,-1,92.0,1,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    parameter START = 3'd0, DATA = 3'd1, PARITY = 3'd2, STOP = 3'd3, DELAY = 3'd4;
    reg [2:0] state, next_state;
    reg [7:0] data;
    reg odd;
    reg out;
    
    always @(posedge clk)
        if (reset) state <= START;
        else state <= next_state;
    
    always @(*)
        case (state)
            START: begin
                if (in)
                    next_state = DATA;
                else
                    next_state = START;
            end
            DATA: begin
                next_state = PARITY;
            end
            PARITY: begin
                if (in)
                    next_state = STOP;
                else
                    next_state = DELAY;
            end
            DELAY: begin
                if (in)
                    next_state = DELAY;
                else
                    next_state = START;
            end
            STOP: begin
                if (in)
                    next_state = START;
                else
                    next_state = DELAY;
            end
            default: next_state = START;
        endcase
    
    always @(posedge clk)
        if (reset) begin
            data <= 8'd0;
            out <= 0;
        end
        else begin
            if (state == DATA)
                data <= {in, data[7:1]};
            if (state == PARITY)
                out <= odd;
        end
    
    assign done = (state == STOP);
    assign out_byte = done? data : 8'd0;
    
    always @(posedge clk)
        if (reset)
            odd <= 0;
        else if (state == PARITY)
            odd <= in ^ odd;

endmodule"
N/A,N/A,-1,93.0,1,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    // Use FSM from Fsm_serialdata
    // New: Add parity checking.
    
    parity p1(clk, reset, in, odd);
    
    // New: Add serial output byte stream.
    
    serialdata s1(clk, reset, odd, in, out_byte, done);
    
endmodule"
N/A,N/A,-1,94.0,1,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    parameter START = 0, DATA = 1, STOP = 2, DELAY = 3;
    reg [1:0] state, next_state;
    reg [3:0] count;
    reg out;
    
    always @(*) begin
        case (state)
            START: begin
                if(in)
                    next_state = DATA;
                else
                    next_state = START;
            end
            DATA: begin
                if(count == 8)
                    next_state = STOP;
                else if(in)
                    next_state = DATA;
                else
                    next_state = START;
            end
            STOP: begin
                if(in) begin
                    next_state = DELAY;
                    out = 1;
                end
                else
                    next_state = START;
            end
            DELAY: begin
                if(count == 4)
                    next_state = START;
                else
                    next_state = DELAY;
            end
        endcase
    end
    
    always @(posedge clk) begin
        if(reset)
            state <= START;
        else
            state <= next_state;
    end
    
    always @(posedge clk) begin
        if(state == DATA)
            count <= count + 1;
        else
            count <= 0;
    end
    
    always @(posedge clk) begin
        if(state == STOP) begin
            done <= out;
            out_byte <= count;
        end
    end
    
endmodule"
N/A,N/A,-1,95.0,1,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    parameter START = 0, DATA = 1, STOP = 2, DELAY = 3;
    reg [1:0] state, next_state;
    reg [3:0] count;
    reg out;
    
    always @(*) begin
        case (state)
            START: begin
                if(in)
                    next_state = DATA;
                else
                    next_state = START;
            end
            DATA: begin
                if(count == 8)
                    next_state = STOP;
                else if(in)
                    next_state = DATA;
                else
                    next_state = START;
            end
            STOP: begin
                if(in) begin
                    next_state = DELAY;
                    out = 1;
                end
                else
                    next_state = START;
            end
            DELAY: begin
                if(count == 4)
                    next_state = START;
                else
                    next_state = DELAY;
            end
        endcase
    end
    
    always @(posedge clk) begin
        if(reset)
            state <= START;
        else
            state <= next_state;
    end
    
    always @(posedge clk) begin
        if(state == DATA)
            count <= count + 1;
        else
            count <= 0;
    end
    
    always @(posedge clk) begin
        if(state == STOP) begin
            done <= out;
            out_byte <= count;
        end
    end
    
endmodule"
N/A,N/A,-1,96.0,1,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    parameter START = 0, DATA = 1, STOP = 2, DELAY = 3;
    reg [1:0] state, next_state;
    reg [3:0] count;
    reg out;
    
    always @(*) begin
        case (state)
            START: begin
                if(in)
                    next_state = DATA;
                else
                    next_state = START;
            end
            DATA: begin
                if(count == 8)
                    next_state = STOP;
                else if(in)
                    next_state = DATA;
                else
                    next_state = START;
            end
            STOP: begin
                if(in) begin
                    next_state = DELAY;
                    out = 1;
                end
                else
                    next_state = START;
            end
            DELAY: begin
                if(count == 4)
                    next_state = START;
                else
                    next_state = DELAY;
            end
        endcase
    end
    
    always @(posedge clk) begin
        if(reset)
            state <= START;
        else
            state <= next_state;
    end
    
    always @(posedge clk) begin
        if(state == DATA)
            count <= count + 1;
        else
            count <= 0;
    end
    
    always @(posedge clk) begin
        if(state == STOP) begin
            done <= out;
            out_byte <= count;
        end
    end
    
endmodule"
N/A,N/A,-1,97.0,1,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    parameter START = 0, DATA = 1, STOP = 2, DELAY = 3;
    reg [1:0] state, next_state;
    reg [3:0] count;
    reg out;
    
    always @(*) begin
        case (state)
            START: begin
                if(in)
                    next_state = DATA;
                else
                    next_state = START;
            end
            DATA: begin
                if(count == 8)
                    next_state = STOP;
                else if(in)
                    next_state = DATA;
                else
                    next_state = START;
            end
            STOP: begin
                if(in) begin
                    next_state = DELAY;
                    out = 1;
                end
                else
                    next_state = START;
            end
            DELAY: begin
                if(count == 4)
                    next_state = START;
                else
                    next_state = DELAY;
            end
        endcase
    end
    
    always @(posedge clk) begin
        if(reset)
            state <= START;
        else
            state <= next_state;
    end
    
    always @(posedge clk) begin
        if(state == DATA)
            count <= count + 1;
        else
            count <= 0;
    end
    
    always @(posedge clk) begin
        if(state == STOP) begin
            done <= out;
            out_byte <= count;
        end
    end
    
endmodule"
N/A,N/A,-1,98.0,1,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    parameter START = 3'd0, DATA = 3'd1, STOP = 3'd2, DELAY = 3'd3;
    reg [2:0] state, next_state;
    reg [7:0] data;
    reg odd;
    
    always @(posedge clk)
        if (reset) state <= START;
        else state <= next_state;
    
    always @(*)
        case (state)
            START: begin
                next_state <= (in)? START:DATA;
                data <= 8'd0;
            end
            DATA: begin
                next_state <= (in)? DATA:STOP;
                data <= {data, in};
            end
            STOP: begin
                next_state <= (in)? START:DELAY;
                data <= 8'd0;
            end
            DELAY: next_state <= (in)? START:DELAY;
            default: next_state <= state;
        endcase
    
    assign done = (state == DELAY)? 1:0;
    
    assign out_byte = data;
    
    always @(posedge clk)
        if (reset) odd <= 0;
        else if (state == DATA) odd <= (data[7] ^ data[6]);
    
    assign parity = odd;
    
endmodule"
N/A,N/A,-1,99.0,1,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    parameter START = 3'd0, DATA = 3'd1, STOP = 3'd2, DELAY = 3'd3;
    reg [2:0] state, next_state;
    reg [7:0] data;
    reg odd;
    
    always @(posedge clk)
        if (reset) state <= START;
        else state <= next_state;
    
    always @(*)
        case (state)
            START: begin
                next_state <= (in)? START:DATA;
                data <= 8'd0;
            end
            DATA: begin
                next_state <= (in)? DATA:STOP;
                data <= {data, in};
            end
            STOP: begin
                next_state <= (in)? START:DELAY;
                data <= 8'd0;
            end
            DELAY: next_state <= (in)? START:DELAY;
            default: next_state <= state;
        endcase
    
    assign done = (state == DELAY)? 1:0;
    
    assign out_byte = data;
    
    always @(posedge clk)
        if (reset) odd <= 0;
        else if (state == DATA) odd <= (data[7] ^ data[6]);
    
    assign parity = odd;
    
endmodule"
N/A,N/A,-1,100.0,1,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    parameter START = 0, DATA = 1, STOP = 2, DELAY = 3;
    reg [1:0] state, next_state;
    reg [3:0] count;
    reg out;
    
    always @(*) begin
        case (state)
            START: begin
                if(in)
                    next_state <= DATA;
                else
                    next_state <= START;
            end
            DATA: begin
                if(count == 8)
                    next_state <= STOP;
                else if(in)
                    next_state <= DATA;
                else
                    next_state <= START;
            end
            STOP: begin
                if(in) begin
                    next_state <= START;
                    out_byte[count] <= in;
                end
                else
                    next_state <= DELAY;
            end
            DELAY: begin
                if(count == 7)
                    next_state <= START;
                else
                    next_state <= DELAY;
            end
        endcase
    end
    
    always @(posedge clk) begin
        if(reset)
            state <= START;
        else
            state <= next_state;
    end
    
    always @(posedge clk) begin
        if(state == DATA)
            count <= count + 1;
        else
            count <= 0;
    end
    
    assign done = (state == STOP);
    
    always @(posedge clk) begin
        if(state == DATA)
            out <= in;
        else
            out <= 1'bz;
    end
    
endmodule"
N/A,N/A,-1,101.0,1,"// We want to add parity checking to the serial receiver. Parity checking adds one extra bit after each data byte. We will use odd parity, where the number of 1s in the 9 bits received must be odd. For example, 101001011 satisfies odd parity (there are 5 1s), but 001001011 does not.

// Change your FSM and datapath to perform odd parity checking. Assert the done signal only if a byte is correctly received and its parity check passes. Like the serial receiver FSM, this FSM needs to identify the start bit, wait for all 9 (data and parity) bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

// You are provided with the following module that can be used to calculate the parity of the input stream (It's a TFF with reset). The intended use is that it should be given the input bit stream, and reset at appropriate times so it counts the number of 1 bits in each byte.
    // Modify FSM and datapath from Fsm_serialdata
    // New: Add parity checking.

module parity (
    input clk,
    input reset,
    input in,
    output reg odd);

    always @(posedge clk)
        if (reset) odd <= 0;
        else if (in) odd <= ~odd;

endmodule

// Note that the serial protocol sends the least significant bit first, and the parity bit after the 8 data bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    parameter START = 3'd0, DATA = 3'd1, PARITY = 3'd2, STOP = 3'd3, DELAY = 3'd4;
    reg [2:0] state, next_state;
    reg [7:0] data;
    reg odd;
    reg [1:0] count;
    
    always @(posedge clk)
        if (reset)
            state <= START;
        else
            state <= next_state;
    
    always @(*)
        case (state)
            START:
                begin
                    if(in)
                        next_state = DATA;
                    else
                        next_state = START;
                end
            DATA:
                begin
                    if(count == 9)
                        next_state = PARITY;
                    else
                        next_state = DATA;
                end
            PARITY:
                begin
                    if(count == 9)
                        next_state = STOP;
                    else
                        next_state = PARITY;
                end
            STOP:
                begin
                    if(count == 2)
                        next_state = DELAY;
                    else
                        next_state = STOP;
                end
            DELAY:
                begin
                    if(count == 2)
                        next_state = DELAY;
                    else
                        next_state = START;
                end
            default:
                next_state = START;
        endcase
    
    always @(posedge clk)
        if (reset)
            count <= 2'd0;
        else if (state == DATA || state == PARITY)
            count <= count + 2'd1;
        else
            count <= 2'd0;
    
    always @(posedge clk)
        if (reset)
            data <= 8'd0;
        else if (state == DATA)
            data <= data << 1;
        else if (state == PARITY)
            data <= {data[6:0], odd};
    
    assign done = (state == DELAY);
    
    assign out_byte = data;
    
endmodule"
